
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INTERRUP._67</title>
    <style>
        body {
            font-variant-ligatures: none;
        }
        pre {
            font-family: 'Courier New', Courier, monospace;
        }
        a {
            color: black;
        }
        .bottom-nav {
            position: sticky;
            bottom: 0px;
            background-color: white;
            text-align: right;
        }
        h3, h4 {
            margin: 0;
        }
</style>
</head>
<body>

<b>Interrupt List Release 61 Last change 16jul00</b><br />
<b>Copyright (c) 1989-1999,2000 Ralf Brown</b><br />
<pre>
Index for interrupt INT 67
</pre>

<p>
<a name="__toc"><b>Table of Contents by Order</b></a><br />

<a href="#67"><b>67</b> - INT 67 - Adaptec controllers - DRIVE 1 DATA</a><br />
<a href="#67_0"><b>67</b> - INT 67 - TI Professional PC - SYSTEM DATA (NOT A VECTOR!)</a><br />
<a href="#67_1"><b>67</b> - INT 67 - Pdisk by Scott Garfinkle - Overwritten for Hard Drive information</a><br />
<a href="#67_2"><b>67</b> - INT 67 - Sangoma CCPOP 3270 resident module</a><br />
<a href="#67_3"><b>67</b> - INT 67 - CUCKOO.COM - INSTALLATION CHECK</a><br />
<a href="#67_4"><b>67</b> - INT 67 - PC-DRAFT - KEYBOARD DRIVER</a><br />
<a href="#6700"><b>6700</b> - INT 67 - PC-NET, Alloy NTNX - LOCK SEMAPHORE AND WAIT</a><br />
<a href="#6701"><b>6701</b> - INT 67 - PC-NET, Alloy NTNX - LOCK SEMAPHORE</a><br />
<a href="#6702"><b>6702</b> - INT 67 - PC-NET, Alloy NTNX - UNLOCK SEMAPHORE</a><br />
<a href="#671E"><b>671E</b> - INT 67 U - Qualitas 386MAX v7.00 - MEMLIMIT - INSTALLATION CHECK</a><br />
<a href="#671F"><b>671F</b> - INT 67 U - Qualitas 386MAX v7.00 - MEMLIMIT - API</a><br />
<a href="#672763CL01"><b>672763CL01</b> - INT 67 - VIDEMS.SYS v1.31+ - INSTALLATION CHECK</a><br />
<a href="#672763CL02"><b>672763CL02</b> - INT 67 - VIDEMS.SYS v1.31+ - FLUSH EMS TO VIDEO RAM</a><br />
<a href="#672763CL03"><b>672763CL03</b> - INT 67 - VIDEMS.SYS v1.31+ - RELOAD EMS FROM VIDEO RAM</a><br />
<a href="#672763CL04"><b>672763CL04</b> - INT 67 - VIDEMS.SYS v1.31+ - RETURN HIDDEN BLOCK SIZE</a><br />
<a href="#672763CL05"><b>672763CL05</b> - INT 67 - VIDEMS.SYS v1.31+ - RETURN PHYSICAL PAGE SIZE</a><br />
<a href="#672763CL06"><b>672763CL06</b> - INT 67 - VIDEMS.SYS v1.50+ - RETURN VIDEO RAM SIZE</a><br />
<a href="#672833"><b>672833</b> - INT 67 - Q87 v4+ - PREPARE TO UNLOAD AND GET XMS HANDLE FOR Q87 MEMORY</a><br />
<a href="#673F--CX5145"><b>673F--CX5145</b> - INT 67 U - QEMM-386 v4.23+ - INSTALLATION CHECK</a><br />
<a href="#6740"><b>6740</b> - INT 67 - LIM EMS - GET MANAGER STATUS</a><br />
<a href="#6741"><b>6741</b> - INT 67 - LIM EMS - GET PAGE FRAME SEGMENT</a><br />
<a href="#6742"><b>6742</b> - INT 67 - LIM EMS - GET NUMBER OF PAGES</a><br />
<a href="#6743"><b>6743</b> - INT 67 - LIM EMS - GET HANDLE AND ALLOCATE MEMORY</a><br />
<a href="#674321"><b>674321</b> - INT 67 - Q87 v4+ - INSTALLATION CHECK</a><br />
<a href="#6744"><b>6744</b> - INT 67 - LIM EMS - MAP MEMORY</a><br />
<a href="#6745"><b>6745</b> - INT 67 - LIM EMS - RELEASE HANDLE AND MEMORY</a><br />
<a href="#6746"><b>6746</b> - INT 67 - LIM EMS - GET EMM VERSION</a><br />
<a href="#6747"><b>6747</b> - INT 67 - LIM EMS - SAVE MAPPING CONTEXT</a><br />
<a href="#6748"><b>6748</b> - INT 67 - LIM EMS - RESTORE MAPPING CONTEXT</a><br />
<a href="#6749"><b>6749</b> - INT 67 - LIM EMS - reserved - GET I/O PORT ADDRESSES</a><br />
<a href="#674A"><b>674A</b> - INT 67 - LIM EMS - reserved - GET TRANSLATION ARRAY</a><br />
<a href="#674B"><b>674B</b> - INT 67 - LIM EMS - GET NUMBER OF EMM HANDLES</a><br />
<a href="#674C"><b>674C</b> - INT 67 - LIM EMS - GET PAGES OWNED BY HANDLE</a><br />
<a href="#674D"><b>674D</b> - INT 67 - LIM EMS - GET PAGES FOR ALL HANDLES</a><br />
<a href="#674E"><b>674E</b> - INT 67 - LIM EMS - GET OR SET PAGE MAP</a><br />
<a href="#674F"><b>674F</b> - INT 67 - LIM EMS 4.0 - GET/SET PARTIAL PAGE MAP</a><br />
<a href="#6750"><b>6750</b> - INT 67 - LIM EMS 4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES</a><br />
<a href="#6751"><b>6751</b> - INT 67 - LIM EMS 4.0 - REALLOCATE PAGES</a><br />
<a href="#6752"><b>6752</b> - INT 67 - LIM EMS 4.0 - GET/SET HANDLE ATTRIBUTES</a><br />
<a href="#6753"><b>6753</b> - INT 67 - LIM EMS 4.0 - GET/SET HANDLE NAME</a><br />
<a href="#6754"><b>6754</b> - INT 67 - LIM EMS 4.0 - GET HANDLE DIRECTORY</a><br />
<a href="#6755"><b>6755</b> - INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND JUMP</a><br />
<a href="#6756"><b>6756</b> - INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND CALL</a><br />
<a href="#6756FF"><b>6756FF</b> - INT 67 - RM386 v6.00 - ???</a><br />
<a href="#6757"><b>6757</b> - INT 67 - LIM EMS 4.0 - MOVE/EXCHANGE MEMORY REGION</a><br />
<a href="#6758"><b>6758</b> - INT 67 - LIM EMS 4.0 - GET MAPPABLE PHYSICAL ADDRESS ARRAY</a><br />
<a href="#675857"><b>675857</b> - INT 67 U - NETROOM??? - ???</a><br />
<a href="#6759"><b>6759</b> - INT 67 - LIM EMS 4.0 - GET EXPANDED MEMORY HARDWARE INFORMATION</a><br />
<a href="#675A"><b>675A</b> - INT 67 - LIM EMS 4.0 - ALLOCATE STANDARD/RAW PAGES</a><br />
<a href="#675B"><b>675B</b> - INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET</a><br />
<a href="#675B_0"><b>675B</b> - INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET - DMA REGISTERS</a><br />
<a href="#675BE0"><b>675BE0</b> - INT 67 - MICEMM v4D, RM386 - GET LINEAR ADDRESS OF MEMORY</a><br />
<a href="#675BE1"><b>675BE1</b> - INT 67 - RM386 v6.00+ - GET MEMORY MANAGER SIZE</a><br />
<a href="#675BE2"><b>675BE2</b> - INT 67 - RM386 v6.00+ - GET INTERRUPT VECTORS</a><br />
<a href="#675BF0"><b>675BF0</b> - INT 67 - MICEMM v4D, RM386 - INSTALLATION CHECK</a><br />
<a href="#675BF1"><b>675BF1</b> - INT 67 - MICEMM v4D, RM386 - GET ADDRESS MAP</a><br />
<a href="#675BF2"><b>675BF2</b> - INT 67 - RM386 - GET RM386 INTERNAL DATA</a><br />
<a href="#675BF3"><b>675BF3</b> - INT 67 - RM386 - RETURN TO REAL MODE</a><br />
<a href="#675BF4"><b>675BF4</b> - INT 67 - RM386 v6.00 - GET RM386 GLOBAL FLAGS</a><br />
<a href="#675BF5"><b>675BF5</b> - INT 67 - RM386 v6.00 - GET RM386 EMS HANDLE COUNT</a><br />
<a href="#675C"><b>675C</b> - INT 67 - LIM EMS 4.0 - PREPARE EXPANDED MEMORY HARDWARE FOR WARM BOOT</a><br />
<a href="#675D"><b>675D</b> - INT 67 - LIM EMS 4.0 - ENABLE/DISABLE OS FUNCTION SET FUNCTIONS</a><br />
<a href="#675D03"><b>675D03</b> - INT 67 u - Nanosoft MD386 - INTERNAL INITIALIZATION</a><br />
<a href="#675D04"><b>675D04</b> - INT 67 - Nanosoft MD386 - GET ALTERNATE MAP STRUCTURE</a><br />
<a href="#675D05"><b>675D05</b> - INT 67 - Nanosoft MD386 - GET INTERNAL HANDLE TABLE</a><br />
<a href="#675DE0"><b>675DE0</b> - INT 67 - RM386 - DISABLE RM386</a><br />
<a href="#675DE1"><b>675DE1</b> - INT 67 - RM386 - ENABLE RM386</a><br />
<a href="#675DE2"><b>675DE2</b> - INT 67 - RM386 - GET PAGE TABLE</a><br />
<a href="#675DE3"><b>675DE3</b> - INT 67 - RM386 - SET PAGE TABLE</a><br />
<a href="#675DE4"><b>675DE4</b> - INT 67 - RM386 - SET WRITE-PROTECTION FOR PAGE IN FIRST MEGABYTE</a><br />
<a href="#675DE5"><b>675DE5</b> - INT 67 - RM386 - MAP PHYSICAL PAGE TO PHYSICAL SEGMENT</a><br />
<a href="#675DE6"><b>675DE6</b> - INT 67 - RM386 - MAP LOGICAL 4K PAGE TO PHYSICAL SEGMENT</a><br />
<a href="#675DE7"><b>675DE7</b> - INT 67 - RM386 - SET PAGE TABLE BITS FOR RANGE OF PAGES</a><br />
<a href="#675DE8"><b>675DE8</b> - INT 67 - RM386 - GET PARTIAL PAGE TABLE</a><br />
<a href="#675DE9"><b>675DE9</b> - INT 67 - RM386 - SET PARTIAL PAGE TABLE</a><br />
<a href="#675DEA"><b>675DEA</b> - INT 67 - RM386 - V86-MODE I/O PORT TRAPPING CONTROL</a><br />
<a href="#675DEB"><b>675DEB</b> - INT 67 - RM386 - V86-MODE I/O TRAPPING PORT CONTROL</a><br />
<a href="#675DFD"><b>675DFD</b> - INT 67 U - RM386 v6.00 - ???</a><br />
<a href="#675DFE"><b>675DFE</b> - INT 67 U - RM386 v6.00 - ???</a><br />
<a href="#675DFF"><b>675DFF</b> - INT 67 U - RM386 v6.00 - ???</a><br />
<a href="#675E00"><b>675E00</b> - INT 67 - Nanosoft MD386 - SET HARDWARE BREAKPOINT</a><br />
<a href="#675E01"><b>675E01</b> - INT 67 - Nanosoft MD386 - GET HARDWARE DEBUG REGISTER</a><br />
<a href="#675E02"><b>675E02</b> - INT 67 - Nanosoft MD386 - SET DEBUG EXCEPTION HANDLER</a><br />
<a href="#675E03"><b>675E03</b> - INT 67 - Nanosoft MD386 - ENABLE/DISABLE MEMORY WRITE PROTECTION</a><br />
<a href="#675E04"><b>675E04</b> - INT 67 - Nanosoft MD386 - GET DEBUG EXCEPTION</a><br />
<a href="#675E05"><b>675E05</b> - INT 67 - Nanosoft MD386 - IGNORE NEXT DEBUG EXCEPTION</a><br />
<a href="#6760"><b>6760</b> - INT 67 - EEMS - GET PHYSICAL WINDOW ARRAY</a><br />
<a href="#6761"><b>6761</b> - INT 67 - EEMS - GENERIC ACCELERATOR CARD SUPPORT</a><br />
<a href="#676100"><b>676100</b> - INT 67 - EEMS - STB GENERIC ACCELERATOR CARD SUPPORT - INSTALLATION CHECK???</a><br />
<a href="#676101"><b>676101</b> - INT 67 - EEMS - STB GENERIC ACCELERATOR CARD SUPPORT - GET ??? ENTRY POINT</a><br />
<a href="#6768"><b>6768</b> - INT 67 - EEMS - GET ADDRESSES OF ALL PAGE FRAMES IN SYSTEM</a><br />
<a href="#6769"><b>6769</b> - INT 67 - EEMS - MAP PAGE INTO FRAME</a><br />
<a href="#676A"><b>676A</b> - INT 67 - EEMS - PAGE MAPPING</a><br />
<a href="#676B"><b>676B</b> - INT 67 - DESQview 2.42-2.53 - BUG</a><br />
<a href="#67DD"><b>67DD</b> - INT 67 - Quadtel QMAPS - API</a><br />
<a href="#67DE00"><b>67DE00</b> - INT 67 - Virtual Control Program Interface - INSTALLATION CHECK</a><br />
<a href="#67DE01"><b>67DE01</b> - INT 67 - Virtual Control Program Interface - GET PROTECTED MODE INTERFACE</a><br />
<a href="#67DE02"><b>67DE02</b> - INT 67 - Virtual Control Program Interface - GET MAX PHYSICAL MEMORY ADDRESS</a><br />
<a href="#67DE03"><b>67DE03</b> - INT 67 - Virtual Control Program Interface - GET NUMBER OF FREE 4K PAGES</a><br />
<a href="#67DE04"><b>67DE04</b> - INT 67 - Virtual Control Program Interface - ALLOCATE A 4K PAGE</a><br />
<a href="#67DE05"><b>67DE05</b> - INT 67 - Virtual Control Program Interface - FREE 4K PAGE</a><br />
<a href="#67DE06"><b>67DE06</b> - INT 67 - Virtual Control Program Interface - GET PHYS ADDR OF PAGE IN FIRST MB</a><br />
<a href="#67DE07"><b>67DE07</b> - INT 67 - Virtual Control Program Interface - READ CR0</a><br />
<a href="#67DE08"><b>67DE08</b> - INT 67 - Virtual Control Program Interface - READ DEBUG REGISTERS</a><br />
<a href="#67DE09"><b>67DE09</b> - INT 67 - Virtual Control Program Interface - SET DEBUG REGISTERS</a><br />
<a href="#67DE0A"><b>67DE0A</b> - INT 67 - Virtual Control Program Interface - GET 8259 INTERRUPT VECTOR MAPPINGS</a><br />
<a href="#67DE0B"><b>67DE0B</b> - INT 67 - Virtual Control Program Interface - SET 8259 INTERRUPT VECTOR MAPPINGS</a><br />
<a href="#67DE0C"><b>67DE0C</b> - INT 67 - Virtual Control Program Interface - SWITCH TO PROTECTED MODE</a><br />
<a href="#67DE0F"><b>67DE0F</b> - INT 67 - Netroom3 - ???</a><br />
<a href="#67DEE1BX0C55"><b>67DEE1BX0C55</b> - INT 67 - "SB Live!" Sound Blaster 16 Emulation Driver - INSTALLATION CHECK</a><br />
<a href="#67EF"><b>67EF</b> - INT 67 - RM386 v6.00+ - EXECUTE XMS FUNCTION</a><br />
<a href="#67FFA5"><b>67FFA5</b> - INT 67 - Microsoft EMM386.EXE v4.20+ - INSTALLATION CHECK</a><br />
<a href="#67FFA5BX4345"><b>67FFA5BX4345</b> - INT 67 U - Compaq CEMM v5.10+ - PRIVATE API</a><br />

<hr />

<a href="#67" name="67"><b>67</b></a> - INT 67 - Adaptec controllers - DRIVE 1 DATA<br />
<pre>
INT 67 - Adaptec controllers - DRIVE 1 DATA
Desc:	this vector stores the last four bytes of the parameter table for
	  hard disk 1
SeeAlso: INT 64"Adaptec",INT 65"Adaptec",INT 66"Adaptec"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67_0" name="67_0"><b>67</b></a> - INT 67 - TI Professional PC - SYSTEM DATA (NOT A VECTOR!)<br />
<pre>
INT 67 - TI Professional PC - SYSTEM DATA (NOT A VECTOR!)
Desc:	this vector contains the TI Pro's system configuration words
	  (see #03521)
SeeAlso: INT 66"TI Professional PC"

Bitfields for TI Professional PC System Configuration doubleword:
Bit(s)	Description	(Table 03521)
 0	8087 present
 31-1	reserved (0)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67_1" name="67_1"><b>67</b></a> - INT 67 - Pdisk by Scott Garfinkle - Overwritten for Hard Drive information<br />
<pre>
INT 67 - Pdisk by Scott Garfinkle - Overwritten for Hard Drive information
SeeAlso: INT 64"Pdisk",INT 66"Pdisk"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67_2" name="67_2"><b>67</b></a> - INT 67 - Sangoma CCPOP 3270 resident module<br />
<pre>
INT 67 - Sangoma CCPOP 3270 resident module
SeeAlso: INT 61"Sangoma",INT 68"Sangoma"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67_3" name="67_3"><b>67</b></a> - INT 67 - CUCKOO.COM - INSTALLATION CHECK<br />
<pre>
INT 67 - CUCKOO.COM - INSTALLATION CHECK
Program: CUCKOO is a resident on-screen clock with optional hourly chime or
	  cuckoo by an unknown author with revisions by Thomas A. Lundin
Note:	this is not a vector; when loaded for the first time, CUCKOO.COM uses
	  the last unused (0000h:0000h) vector in the range 60h-67h to store
	  the signature value 434Ch:4F4Bh ('CLOK')

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67_4" name="67_4"><b>67</b></a> - INT 67 - PC-DRAFT - KEYBOARD DRIVER<br />
<pre>
INT 67 - PC-DRAFT - KEYBOARD DRIVER
	???
Return: ???
Program: PC-DRAFT is a powerful CAD environment by rhv.
SeeAlso: INT 62"PC-DRAFT",INT 64"PC-DRAFT",INT 65"PC-DRAFT",INT 66"PC-DRAFT"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6700" name="6700"><b>6700</b></a> - INT 67 - PC-NET, Alloy NTNX - LOCK SEMAPHORE AND WAIT<br />
<pre>
INT 67 - PC-NET, Alloy NTNX - LOCK SEMAPHORE AND WAIT
	AH = 00h
	DS:DX -&gt; ASCIZ semaphore name (max 64 bytes)
Return: AL = status (see #03522)
	AH = semaphore owner if status=02h
SeeAlso: AH=01h,AH=02h"PC-NET",INT 7F/AH=00h

(Table 03522)
Values for PC-NET semaphore function status:
 00h	successful
 01h	invalid function
 02h	semaphore already locked
 03h	unable to lock semaphore
 04h	semaphore space exhausted

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6701" name="6701"><b>6701</b></a> - INT 67 - PC-NET, Alloy NTNX - LOCK SEMAPHORE<br />
<pre>
INT 67 - PC-NET, Alloy NTNX - LOCK SEMAPHORE
	AH = 01h
	DS:DX -&gt; ASCIZ semaphore name (max 64 bytes)
Return: AL = status (see #03522)
	AH = semaphore owner if status=02h
SeeAlso: AH=00h,AH=02h"PC-NET",INT 7F/AH=01h"Alloy"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6702" name="6702"><b>6702</b></a> - INT 67 - PC-NET, Alloy NTNX - UNLOCK SEMAPHORE<br />
<pre>
INT 67 - PC-NET, Alloy NTNX - UNLOCK SEMAPHORE
	AH = 02h
	DS:DX -&gt; ASCIZ semaphore name (max 64 bytes)
Return: AL = status (see #03522)
	AH = semaphore owner if status=02h
SeeAlso: AH=00h,AH=01h"PC-NET",INT 7F/AH=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#671E" name="671E"><b>671E</b></a> - INT 67 U - Qualitas 386MAX v7.00 - MEMLIMIT - INSTALLATION CHECK<br />
<pre>
INT 67 U - Qualitas 386MAX v7.00 - MEMLIMIT - INSTALLATION CHECK
	AH = 1Eh
Return: AH = 00h if installed
	    AL destroyed
	    ES:DI -&gt; ASCII signature "MemLimit"
SeeAlso: AH=1Fh,INT 21/AX=4402h"386MAX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#671F" name="671F"><b>671F</b></a> - INT 67 U - Qualitas 386MAX v7.00 - MEMLIMIT - API<br />
<pre>
INT 67 U - Qualitas 386MAX v7.00 - MEMLIMIT - API
	AH = 1Fh
	DS:SI -&gt; request packet (see #03523)
Return: AH = status (00h successful, 84h invalid function code, etc.)
SeeAlso: AH=1Eh

Format of 386MAX MEMLIMIT request packet:
Offset	Size	Description	(Table 03523)
 00h	WORD	function code (00h-0Fh)
 02h	WORD	return code (see #03524)
 04h  4 BYTEs	???
 08h	WORD	???
	???

(Table 03524)
Values for 386MAX MEMLIMIT return code:
 00h	unknown request
 01h	invalid parameter for VCPI limit
 02h	VCPI limit set
 03h	invalid parameter for EMS limit
 04h	EMS limit set
 05h	DPMI disabled
 06h	XMS disabled
 07h	XMS limit set
 08h	unable to uninstall
 09h	unloaded

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#672763CL01" name="672763CL01"><b>672763CL01</b></a> - INT 67 - VIDEMS.SYS v1.31+ - INSTALLATION CHECK<br />
<pre>
INT 67 - VIDEMS.SYS v1.31+ - INSTALLATION CHECK
	AX = 2763h
	CL = 01h
	BX = signature AAFFh
Return: AH = 00h if VIDEMS is installed
	    CH = 00h if optimization for 80286 is used, 01h otherwise
	    CL = internal revision number (typically 00h to 03h)
	    DX = driver version (DH=major, DL=minor; not a BCD!)
	AH = 84h if not installed but EMS manager is present
Program: VIDEMS is an expanded memory manager from Conea Software Corp. It
	 converts video adapter RAM to LIM 3.2 EMS.
SeeAlso: AX=2763h/CL=02h,AX=2763h/CL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#672763CL02" name="672763CL02"><b>672763CL02</b></a> - INT 67 - VIDEMS.SYS v1.31+ - FLUSH EMS TO VIDEO RAM<br />
<pre>
INT 67 - VIDEMS.SYS v1.31+ - FLUSH EMS TO VIDEO RAM
	AX = 2763h
	CL = 02h
	BX = signature AAFFh
Return: AH = 00h if successful
Notes:	This call is normally used by Conea products only.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#672763CL03" name="672763CL03"><b>672763CL03</b></a> - INT 67 - VIDEMS.SYS v1.31+ - RELOAD EMS FROM VIDEO RAM<br />
<pre>
INT 67 - VIDEMS.SYS v1.31+ - RELOAD EMS FROM VIDEO RAM
	AX = 2763h
	CL = 03h
	BX = signature AAFFh
Return: AH = 00h if successful
Notes:	This call is normally used by Conea products only.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#672763CL04" name="672763CL04"><b>672763CL04</b></a> - INT 67 - VIDEMS.SYS v1.31+ - RETURN HIDDEN BLOCK SIZE<br />
<pre>
INT 67 - VIDEMS.SYS v1.31+ - RETURN HIDDEN BLOCK SIZE
	AX = 2763h
	CL = 04h
	BX = signature AAFFh
Return: AH = 00h if successful
	    DX = block size in kilobytes
Desc:	Returns the amount of EMS which can be safely used at any time, and
	  can't be destroyed by writing anything to the B800:0000 buffer.
Note:	this function normally returns 184K, while the driver provides up to
	  240K of EMS.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#672763CL05" name="672763CL05"><b>672763CL05</b></a> - INT 67 - VIDEMS.SYS v1.31+ - RETURN PHYSICAL PAGE SIZE<br />
<pre>
INT 67 - VIDEMS.SYS v1.31+ - RETURN PHYSICAL PAGE SIZE
	AX = 2763h
	CL = 05h
	BX = signature AAFFh
Return: AH = 00h
	DX = size in bytes
Desc:	Used by Conea products to determine if addressing mode has changed.
	  Normally, all VIDEMS versions beginning from 1.15 use 4K "physical"
	  pages.
Notes:	this function will probably become raw page size in future releases of
	  VIDEMS, which	will support the LIM 4.0 standard.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#672763CL06" name="672763CL06"><b>672763CL06</b></a> - INT 67 - VIDEMS.SYS v1.50+ - RETURN VIDEO RAM SIZE<br />
<pre>
INT 67 - VIDEMS.SYS v1.50+ - RETURN VIDEO RAM SIZE
	AX = 2763h
	CL = 06h
	BX = signature AAFFh
Return: AH = 00h
	DX = total amount of video RAM
Desc:	beginning with version 1.50, VIDEMS can use more adapter memory on
	  some chipsets, and is no longer limited to the first 240K.
Notes:	this call is not officially documented, and Conea programmers use it
	  mainly for debugging purposes.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#672833" name="672833"><b>672833</b></a> - INT 67 - Q87 v4+ - PREPARE TO UNLOAD AND GET XMS HANDLE FOR Q87 MEMORY<br />
<pre>
INT 67 - Q87 v4+ - PREPARE TO UNLOAD AND GET XMS HANDLE FOR Q87 MEMORY
	AX = 2833h
	EAX = 29482833h (entire EAX value required)
Return: EAX = XMS handle for memory allocated when Q87 was installed
	EBX = status
	    00000000h Q87 is in demo mode (countdown running);
			  Q87 remains active
	    00000001h Q87 is in registered mode; memory manager's IDT, GDT,
			  and optionally CR0 (if BL &lt;&gt; 5Fh on entry) have
			  been restored
	    00000002h Q87 is in demo mode (demo time has expired);
			  Q87 remains active
Note:	this call is used by UNLOAD87 to release the memory used by Q87
BUG:	v4.00-v4.03 will hang on most machines when run under bare DOS with
	  no memory manager, because neither Q87 nor UNLOAD87 checks whether
	  there is a valid INT 67 handler before performing an installation
	  check via INT 67
SeeAlso: AX=4321h,INT 21/AX=4321h/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#673F--CX5145" name="673F--CX5145"><b>673F--CX5145</b></a> - INT 67 U - QEMM-386 v4.23+ - INSTALLATION CHECK<br />
<pre>
INT 67 U - QEMM-386 v4.23+ - INSTALLATION CHECK
	AH = 3Fh
	CX = 5145h ("QE")
	DX = 4D4Dh ("MM")
Return: AH = 00h if installed
	    ES:DI -&gt; QEMM API entry point (see #03525,#03528,#03640)
Notes:	if no other program has hooked INT 67, an alternate installation
	  check is to test for the string
	  "QUARTERDECK EXPANDED MEMORY MANAGER 386" at offset 14h in the INT 67
	  handler's segment; the word at offset 12h contains the offset in
	  the handler's segment of the API entry point
	although this function is still undocumented, Quarterdeck has recently
	  documented two alternate methods for determining the QEMM API entry
	  point, as well as several of the API functions
	MICEMM (Micronics Expanded Memory Manager) versions 2.0C and 4D support
	  the alternate QEMM installation check and entry point functions 00h,
	  02h, and 03h; version 4D only provides the signature string if the
	  commandline argument "DV" is provided
	386MAX v6.01 responds to this call, but DESQview 2.42 does not
	  recognize the returned entry point as providing QEMM's capabilities
	  because a) only functions 0Ch (different from QEMM 0Ch) and
			1000h-1009h are supported,
		  b) status is returned as for EMS functions, not QEMM funcs
		  c) the protected-mode entry point returned by function 1000h
			only supports functions 0Ch, 1004h, 1005h, and 100Ah
	the string check mentioned above is not supported by 386MAX
SeeAlso: AX=5BF0h,AH=DDh,AX=FFA5h,INT 15/AX=11DEh,INT 21/AX=4402h/SF=01h
SeeAlso: INT 21/AX=4402h"QEMM",INT 21/AX=4402h"386MAX",INT 2F/AX=D201h/BX=5145h

(Table 03525)
Values for calling QEMM "QPI_GetStatus" function:
	AH = 00h get QEMM state
Return: CF clear
	AL = QEMM state
	    bit 0 set if QEMM turned OFF
	    bit 1 set if in "Auto" mode
Note:	this function is officially documented
SeeAlso: #03526,#03527,#03528,#03640

(Table 03526)
Values for calling QEMM "QPI_SetStatus" function:
	AH = 01h set QEMM state
	AL = new state
	    bit 0 set: place QEMM in OFF state
Return: CF clear if successful
	CF set on error
Note:	this function is officially documented
SeeAlso: #03525

(Table 03527)
Values for calling QEMM QPI function 02h:
	AH = 02h get ???
Return: CF clear
	AX = segment of ??? data structure
	Data Structure
	Offset	Size	Description
	 00h	DWORD	page table entry for ???
		???
SeeAlso: #03528

(Table 03528)
Values for calling QEMM "QPI_GetVersion" function:
	AH = 03h get QEMM version
Return: CF clear
	AX = BX = version in BCD
Notes:	this function is officially documented.	 The most recent official docs
	  state that the version is returned in both AX and BX; older
	  documentation only mentions BX
	MICEMM returns AX=0001h, BX unchanged
SeeAlso: #03525,#03529

(Table 03529)
Values for calling QEMM QPI function 04h:
	AH = 04h allocate 4K page and set AUTO/ON mode
Return: CF clear if successful
	    DX = page number of a 4K page
	CF set if unable to allocate page
Note:	QEMM mode unchanged if not AUTO/OFF
SeeAlso: #03530

(Table 03530)
Values for calling QEMM QPI function 05h:
	AH = 05h free 4K page and turn QEMM off
	DX = page number returned by function 04h
Return: CF clear
Note:	QEMM mode unchanged if not AUTO/ON
SeeAlso: #03529,#03531

(Table 03531)
Values for calling QEMM QPI function 06h:
	AH = 06h make new mapping context???
	DX = page number of 4K page to hold page table
Return: CF clear
Note:	copies page table into given page and then sets ??? page table entry
	  to point at copy
SeeAlso: #03532,#03533

(Table 03532)
Values for calling QEMM QPI function 07h:
	AH = 07h get mapping context
Return: CF clear
	DX = page number of page table for current mapping context
SeeAlso: #03528,#03531,#03533

(Table 03533)
Values for calling QEMM QPI function 08h:
	AH = 08h set mapping context???
	DX = linear page number of page table
Return: CF clear
SeeAlso: #03528,#03531,#03532,#03534,#03536

(Table 03534)
Values for calling QEMM QPI function 09h:
	AH = 09h get linear page number for page table entry
	CX = page table index
Return: CF clear
	DX = linear page number
SeeAlso: #03535

(Table 03535)
Values for calling QEMM QPI function 0Ah:
	AH = 0Ah set linear page number for page table entry
	CX = page table index
	DX = linear page number
Return: CF clear
SeeAlso: #03534

(Table 03536)
Values for calling QEMM QPI function 0Bh:
	AH = 0Bh map 4K pages
	BX = number of pages
	CX = first page number (must be 0100h to allocate HMA)
	DX = EMS handle (memory belonging to EMS handle will be mapped
	      into the address space beginning with the first page
	      allocated to the handle)
Return: AH = 00h
SeeAlso: #03533,#03537

(Table 03537)
Values for calling QEMM QPI function 0Ch:
	AH = 0Ch get available memory
Return: CF clear
	BX = 0001h
	CX = total 4K pages???
	DX = number of 4K pages free
SeeAlso: #03536,#03538

(Table 03538)
Values for calling QEMM QPI function 0Dh:
	AH = 0Dh CRT controller I/O port trapping
	AL = mode
	    00h only trap on I/O ports 03C0h-03C5h, 03C7h, 03CAh-03CFh
	    01h trap on ports 03B4h, 03B5h, 03B8h, 03C6h, 03C8h, 03C9h,
		  03D4h, and 03D5h
	    02h only trap on I/O ports 03C6h, 03C8h, and 03C9h
Return: CF clear

(Table 03539)
Values for calling QEMM QPI function 0Eh:
	AH = 0Eh set cursor virtualization callbacks
	DS:BX -&gt; FAR routine for getting hardware cursor address
	ES:DX -&gt; FAR routine for setting hardware cursor address
Return: CF clear
Note:	both callbacks are invoked with CL indicating which
	  CRT controller register to access (0Eh for high
	  byte of cursor address, 0Fh for low byte)
	the DS:BX callback should return BX=cursor address;
	  ES:DX is called with BL or BH (depending on CL)
	  set to the appropriate half of the cursor's address

(Table 03540)
Values for calling QEMM QPI function 0Fh:
	AH = 0Fh unmap 4K pages
	CX = first page number
	DX = number of pages
Return: CF clear
	AL = 00h/01h if ???
Note:	if CX=0100h and DX=0010h, the HMA is remapped to
	  simulate a disabled A20

(Table 03541)
Values for calling QEMM QPI function 1000h:
	AX = 1000h get protected-mode interface
	DS:SI -&gt; 16-byte buffer for two GDT entries
	ES:DI -&gt; buffer for 4K page table
Return: CF clear
	EAX = offset of protected-mode API entry point
	DS:SI buffer filled with two GDT descriptors
		first is QEMM code segment, second is data???
	ES:DI buffer filled with 4K page table
	DI points to first unused page table entry
SeeAlso: INT 67/AX=DE01h

(Table 03542)
Values for calling QEMM QPI function 1001h:
	AX = 1001h get CPU debug registers
	ES:DI -&gt; buffer for debug registers (8 DWORDs)
Return: CF clear
	BL = INT01 handling (see #03543)
	ES:DI buffer filled

(Table 03543)
Values for calling QEMM QPI function 1002h:
	AX = 1002h set CPU debug registers
	BL = INT01 handling
	    00h	 reflect all debugging exceptions as V86-mode INT 01's
	    else convert debugging exceptions other than single-step
		  into V86-mode INT 03's, single-step to INT 01's
	ES:DI -&gt; buffer containing debug registers (8 DWORDs)
Return: CF clear
Notes:	identical to INT 67/AX=DE09h if BL=01h
	the INT01 handling flag is set to 01h by the general-protection
	  violation handler for certain privileged instructions
SeeAlso: #03542

(Table 03544)
Values for calling QEMM QPI function 1003h:
	AX = 1003h get machine status word CR0
Return: CF clear
	EAX = contents of CR0
SeeAlso: INT 67/AX=DE07h

(Table 03545)
Values for calling QEMM QPI function 1004h:
	AX = 1004h allocate a 4K page
Return: CF clear if successful
	    EDX = linear address of allocated page
	CF set on error
SeeAlso: INT 67/AX=DE04h

(Table 03546)
Values for calling QEMM QPI function 1005h:
	AX = 1005h free 4K page
	EDX = linear address of page to free
Return: CF clear
SeeAlso: INT 67/AX=DE05h

(Table 03547)
Values for calling QEMM QPI function 1006h:
	AX = 1006h NOP
Return: CF set

(Table 03548)
Values for calling QEMM QPI function 1007h:
	AX = 1007h get maximum physical memory address
Return: CF clear
	EDX = physical address of highest 4K memory page
SeeAlso: INT 67/AX=DE02h

(Table 03549)
Values for calling QEMM QPI function 1008h:
	AX = 1008h get physical address of page in first megabyte
	CX = page number (linear address shifted right 12 bits)
Return: CF clear
	EDX = linear address of page
SeeAlso: #03548,#03624,#03625

(Table 03550)
Values for calling QEMM QPI function 1009h:
	AX = 1009h switch to protected mode
	ESI = linear address in first megabyte of system reg values
	      (see INT 67/AX=DE0Ch)
	interrupts disabled
Return: interrupts disabled
	GDTR, IDTR, LDTR, TR loaded
	SS:ESP must have at least 16 bytes space, and the
	      entry point is required to set up a new stack
	      before enabling interrupts
	EAX, ESI, DS, ES, FS, GS destroyed

(Table 03551)
Values for calling QEMM QPI function 100Ah:
	AX = 100Ah switch back to virtual-86 mode
	DS = selector for data segment from function 1000h
	SS:ESP in first megabyte of linear memory
	interrupts disabled
	STACK:	QWORD  return address from FAR call to 32-bit segment
		DWORD  EIP
		DWORD  CS
		DWORD  reserved for EFLAGS
		DWORD  ESP
		DWORD  SS
		DWORD  ES
		DWORD  DS
		DWORD  FS
		DWORD  GS
	will switch to virtual86 mode with interrupts disabled, all
	  segment registers loaded, and EAX destroyed.

(Table 03552)
Values for calling QEMM QPI function 11h:
	AH = 11h get memory type map
	AL = zero/nonzero ??? (set by QEMM.COM but apparently ignored
	      by QEMM 6.00)
	ES:DI -&gt; 256-byte buffer for memory types
Return: CF clear
	BL = ???
	ES:DI buffer filled
Note:	each byte of the buffer corresponds to a 4K page, and
	  contains the type of that page: 00h = mappable,
	  02h = mapped ROM, 03h = high RAM, 04h = excluded,
	  05h = video, 06h = ROM, 07h = adapter ROM,
	  08h = split ROM, 09h = page frame, 0Ah = RAMmable,
	  0Bh = conventional, 83h = high RAM under MS Windows

(Table 03553)
Values for calling QEMM QPI function 12h:
	AH = 12h get HIRAM chain
Return: CF clear
	BX = segment of first MCB in high memory
	    0000h if no high memory

(Table 03554)
Values for calling QEMM QPI function 1300h:
	AX = 1300h VIDRAMEGA???
	BL = 00h copy ???
	     nonzero copy ??? (reverse)
Return: CF clear
	AL = status
	    00h if all pages clean
	    01h if any page dirty

(Table 03555)
Values for calling QEMM QPI function 1301h:
	AX = 1301h check if pages modified
	DX:DI = start address of range to check
	CX = length of range in paragraphs
Return: CF clear
	CX = status
	    0000h none of the indicated pages is dirty
		DI destroyed
	    1000h one or more pages is dirty
		DI = low word of first dirty page's linear addr

(Table 03556)
Values for calling QEMM QPI function 1302h:
	AX = 1302h ???
	BL = ???
	BH = ???
	CX = ???
	SI = offset of ???
	DI = offset of ???
	???
Return: CF clear
	???
Note:	disables certain interrupts at the two 8259 PICs during
	  execution; also modifies CRT controller during
	  execution under certain circumstances

(Table 03557)
Values for calling QEMM QPI function 1303h:
	AX = 1303h initialize EGA graphics virtualization
	BX = number of pages (less 1) of EMS to allocate
Return: CF clear if successful
	    DX = EMS handle
	CF set on error

(Table 03558)
Values for calling QEMM QPI function 1304h:
	AX = 1304h shutdown EGA graphics virtualization
	DX = EMS handle being used for virtualization
Return: CF clear

(Table 03559)
Values for calling QEMM QPI function 1305h:
	AX = 1305h select portion of EGA graphics to virtualize???
	(related to graphics virtualization, changes memory mappings)
	CX = start offset within A000h segment of virtualized mem???
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during
	  execution (see #03566) and runs inside a QEMM
	  critical section

(Table 03560)
Values for calling QEMM QPI function 1306h:
	AX = 1306h set DESQview critical section counter address
	ES:BX -&gt; WORD DESQview critical section counter or 0000h:0000h
Return: CF clear
Note:	also sets a pointer in the low-memory part of QEMM to
	  the current value of INT 15 if ES:BX not 0000h:0000h

(Table 03561)
Values for calling QEMM QPI function 1307h:
	AX = 1307h ??? (changes memory mappings for entire A000h segment)
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during
	  execution (see #03566) and runs inside a QEMM
	  critical section

(Table 03562)
Values for calling QEMM QPI function 1308h:
	AX = 1308h start/reset CRT controller I/O trapping
	BL = subfunction
	    00h restore CRTC I/O port trapping to previous state
	    else start trapping all accesses to I/O ports 03B0-03DF
Return: CF clear
Note:	if called more than once in a row with BL nonzero, the
	  original state of the I/O port trapping will be lost

(Table 03563)
Values for calling QEMM QPI function 1309h:
	AX = 1309h Hercules mode-change support
	ES:BX -&gt; new address for Hercules mode-change callback
Return: CF clear
Note:	the callback function is called whenever the CRTC mode
	  register is written, with AL set to the value written

(Table 03564)
Values for calling QEMM QPI function 130Ah:
	AX = 130Ah virtualize EGA/VGA DAC registers (I/O ports 03C8h/03C9h)
	CX:DX -&gt; DAC register virtualization buffer (see #03647)
		or 0000h:0000h to disable
Return: CF clear

(Table 03565)
Values for calling QEMM QPI function 130Bh:
	AX = 130Bh ???
	BL = ??? (??? or 00h)
Return: CF clear
	???
Note:	calls AX=130Eh in some cases

(Table 03566)
Values for calling QEMM QPI function 130Ch:
	AX = 130Ch set interrupts to mask
	BX = interrupts to mask out during AX=1302h,AX=1307h,AX=1308h,
	      AX=130Dh,AX=1310h (BL = master PIC, BH = slave PIC)
Return: CF clear

(Table 03567)
Values for calling QEMM QPI function 130Dh:
	AX = 130Dh map EGA memory at A0000h
	???
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during execution
	  (see #03566) and runs inside a QEMM critical section
	calls AX=1307h (see #03561)

(Table 03568)
Values for calling QEMM QPI function 130Eh:
	AX = 130Eh ??? (modifies CRT controller setup)
	???
Return: CF clear

(Table 03569)
Values for calling QEMM QPI function 130Fh:
	AX = 130Fh reset ???
Return: CF clear

(Table 03570)
Values for calling QEMM QPI function 1310h:
	AX = 1310h copy modified pages to physical video RAM???
	???
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during execution
	  (see #03566) and runs inside a QEMM critical section
	also calls AX=130Dh (see #03567)

(Table 03571)
Values for calling QEMM QPI function 1311h:
	AX = 1311h set ???
	BL = zero/nonzero???
Return: CF clear
Note:	certain operations will be performed with interrupts
	  (as set by AX=130Ch) enabled rather than disabled if
	  called with BL nonzero

(Table 03572)
Values for calling QEMM QPI function 1312h:
	AX = 1312h (v6.02) NOP???
Note:	called by DV 2.42, but appears to be a NOP in QEMM 6.02

(Table 03573)
Values for calling QEMM QPI function 1400h:
	AX = 1400h initialize DESQview "protection level" support
	ES:DI -&gt; protection level configuration (at least 24 bytes)
		(see #03641)
	BL = highest ??? to return (one less than number of words)
Return: CF clear
	AX = ??? (4204h for v6.00)
Note:	QEMM also sets the protected mode INT 02 and INT 06
	  vectors to alternate handlers in certain cases

(Table 03574)
Values for calling QEMM QPI function 1401h:
	AX = 1401h turn off DESQview protection level support
		Return: CF clear
			???
		Notes:	clears the DV critical-section flag address set with
			  function 1306h
			QEMM also sets the protected mode INT 02 and INT 06
			  vectors to the default handlers if they had been
			  revectored by function 1400h

(Table 03575)
Values for calling QEMM QPI function 1402h:
	AX = 1402h set protection level???
		BL = protection level???
		    00h NOP
		    01h ???
		    02h ???
		    other (03h) ???
		ES:DI -&gt; ???
		Return: CF clear
			???
		Format of Data structure:
		Offset	Size	Description
		 00h	WORD	segment of ??? (X, word at X:0136h set to X)
		 02h	WORD	segment of ??? (word at X:0124h set to this)
		 04h	WORD	number of paragraphs of ???
		 06h  3 WORDs	??? (copied to X:0000h)
		 0Ch	WORD	???

(Table 03576)
Values for calling QEMM QPI function 1403h:
	AX = 1403h add ??? to end of list and ??? (execute func 1406h)
		ES:DI -&gt; ??? structure added to end of ??? list
			(at least 31 bytes, DWORD at offset 06h used for
			 storing pointer to next struc, WORD at offset 00h
			 seems to be a key or index)
		Return: CF clear

(Table 03577)
Values for calling QEMM QPI function 1404h:
	AX = 1404h NOP
		Return: CF clear

(Table 03578)
Values for calling QEMM QPI function 1405h:
	AX = 1405h remove ??? from ??? list
		BX = key???
		Return: CF clear

(Table 03579)
Values for calling QEMM QPI function 1406h:
	AX = 1406h ???
		???
		Return: CF clear
			???
		Notes:	this function is a NOP unless protection level 2 or 3
			  is active
			when not a NOP, one of the actions is to write-protect
			  certain memory pages

(Table 03580)
Values for calling QEMM QPI function 1407h:
	AX = 1407h ???
		???
		Return: CF clear
			???
		Note:	same as function 1406h, but only does anything if
			  protection level 2 is active

(Table 03581)
Values for calling QEMM QPI function 1408h:
	AX = 1408h unprotect???
		???
		Return: CF clear
			???

(Table 03582)
Values for calling QEMM QPI function 1409h:
	AX = 1409h abort program causing protection violation???
		???
		Return: CF clear
			???

(Table 03583)
Values for calling QEMM QPI function 140Ah:
	AX = 140Ah set ???
		BX = index of ???
		Return: CF clear
			???
		Notes:	no range checking is performed on BX
			this function is a NOP unless protection level 3 active

(Table 03584)
Values for calling QEMM QPI function 140Bh:
	AX = 140Bh get ???
		BX = index of ???
		SI = 0000h
		Return: CF clear
			SI = segment of 256-byte buffer??? or 0000h
		Notes:	no range checking is performed on BX
			this function is a NOP unless protection level 3 active

(Table 03585)
Values for calling QEMM QPI function 15h:
	AH = 15h set timer channel 0 virtualization buffer
		ES:BX -&gt; WORD buffer for timer channel 0 divisor
			0000h:0000h to disable virtualization
		Return: CF clear

(Table 03586)
Values for calling QEMM v5.00+ QPI function 1600h:
	AX = 1600h get memory access status
		ES:DI -&gt; 256-byte buffer
		Return: ES:DI buffer filled
		Note:	each byte of the buffer indicates the status of a 4K
			  page (bit 0 set if read, bit 1 set if written)

(Table 03587)
Values for calling QEMM v5.00+ QPI function 1601h:
	AX = 1601h set memory access status
		ES:DI -&gt; 256-byte buffer containing access statuses (see #03586)

(Table 03588)
Values for calling QEMM v5.00+ QPI function 17h:
	AH = 17h get memory usage statistics
		ES:DI -&gt; 81-byte buffer for memory statistics (see #03645)
		Return: CF clear

(Table 03589)
Values for calling QEMM v5.11+ QPI function 18h:
	AH = 18h check whether conventional memory mapped into address range
		ES:BX = starting address
		CX = number of 4K pages
		Return: CF clear
			AL = 00h one or more pages is remapped
			     01h all pages in range are conventional memory
				(physical address == virtual address)

(Table 03590)
Values for calling QEMM v5.11+ QPI function 19h:
	AH = 19h NOP
		Return: CF set

(Table 03591)
Values for calling QEMM v5.11+ "QPI_UntrappedIORead" function:
	AX = 1A00h get byte from I/O port
	DX = port number
Return: CF clear
	BL = port value
Note:	this function was officially documented with the release of QEMM 7.50

(Table 03592)
Values for calling QEMM v5.11+ "QPI_UntrappedIOWrite" function:
	AX = 1A01h send byte to I/O port
	BL = value to send
	DX = port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 03593)
Values for calling QEMM v5.11+ "QPI_UntrappedIOReadIndexed" function:
	AX = 1A02h
	BH = index value to send
	DX = base port number
Return: CF clear
	BL = value read from I/O port (DX+1)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 03594)
Values for calling QEMM v5.11+ "QPI_UntrappedIOWriteIndexed" function:
	AX = 1A03h send bytes to two consecutive I/O ports
	BH = value for first I/O port (DX)
	BL = value for second I/O port (DX+1)
	DX = base port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 03595)
Values for calling QEMM v7.03+ "QPI_UntrappedIO" function:
	AX = 1A04h
	BX = value to write to port
	CX = direction and size
	    bit 2: output instead of input
	    bit 3: word instead of byte
	DX = I/O port to be accessed
Return: CF clear
	BX = value read (if CX indicates read)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 03596)
Values for calling QEMM v7.03+ function 1A05h
	AX = 1A05h
	???
Return: ???

(Table 03597)
Values for calling QEMM v7.03+ "QPI_GetIOCallback" function:
	AX = 1A06h
Return: CF clear
	ES:DI -&gt; current I/O callback function (see #03599)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 03598)
Values for calling QEMM v7.03+ "QPI_SetIOCallback" function:
	AX = 1A07h
	ES:DI -&gt; new I/O callback function (see #03599)
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 03599)
Values QEMM v7.03+ I/O callback function is called with:
	AL/AX = data to/from trapped port
	CL = I/O direction (00h = IN instruction, else OUT instruction)
	DX = I/O port address
Return: CF clear if port handled by callback function
	CF set if not handled
	all other registers returned to application executing the IN or OUT
	  instruction (allowing arbitrary changes to port address, data value,
	  etc.)
SeeAlso: #03597,#03598

(Table 03600)
Values for calling QEMM v7.03+ "QPI_GetPortTrap" function:
	AX = 1A08h
	DX = I/O port number
Return: CF clear
	BL = trapping state (00h not being trapped, 01h trap installed)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 03601)
Values for calling QEMM v7.03+ "QPI_SetPortTrap" function:
	AX = 1A09h
	DX = I/O port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 03602)
Values for calling QEMM v7.03+ "QPI_ClearPortTrap" function:
	AX = 1A0Ah
	DX = I/O port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 03603)
Values for calling QEMM v5.11+ QPI function 1B00h:
	AX = 1B00h get EMM Import Structure address
	ES:DI -&gt; buffer for EMM import data structure (see #03643)
Return: CF set on error
	CF clear if successful
SeeAlso: INT 21/AX=4402h/SF=01h

(Table 03604)
Values for calling QEMM v5.11+ QPI function 1B01h:
	AX = 1B01h disable V86 mode
Return: CF set on error
	    (i.e. no Global EMM Import rec. allocated)
	CF clear if successful
Note:	shuts down EMS and initializes Global EMM Import record; this function
	  is invoked from the callback supplied by INT 2F/AX=1605h

(Table 03605)
Values for calling QEMM v5.11+ QPI function 1B02h:
	AX = 1B02h enable V86 mode
Return: CF set on error
	CF clear if successful
Note:	restarts EMS and frees Global EMM Import record; this function is
	  invoked from the callback supplied by INT 2F/AX=1605h

(Table 03606)
Values for calling QEMM v5.11+ QPI function 1B03h:
	AX = 1B03h MS Windows initializing
	CX = segment from which Windows init broadcast made???
	DX = Windows startup flags
	DI = Windows version number (major in upper byte)
Return: CF clear if successful
	    DS:SI -&gt; V86 mode enable/disable callback
		  (see #02634 at INT 2F/AX=1605h)
	    ES:BX -&gt; startup info structure (see #02631 at INT 2F/AX=1605h)
	CF set on error (unable to start Windows)
SeeAlso: INT 2F/AX=1605h

(Table 03607)
Values for calling QEMM v5.11+ QPI function 1B04h:
	AX = 1B04h MS Windows terminating
Return: CF clear

(Table 03608)
Values for calling QEMM v5.11+ QPI function 1B05h:
	AX = 1B05h determine whether program is driver
	DS:DX -&gt; ASCIZ filename
Return: CF clear
	AL = status
	    01h if string ends in ".DRV"
	    FFh if string ends in "GDI.EXE"
	    00h otherwise
Note:	when MS Windows 3.0 standard mode starts, QEMM patches all drivers
	  until GDI.EXE is loaded

(Table 03609)
Values for calling QEMM v5.11+ QPI function 1B06h:
	AX = 1B06h patch protected-mode check in Windows driver
	CX = length of data pointed at by DS:DX
	DS:DX -&gt; buffer containing Windows driver code
Return: CF clear
Note:	patches all SMSW x/TEST x,1 instruction sequences into MOV x,CS/VERW x
	  sequences, which has the effect that the protected-mode check will
	  only indicate protected mode in native protected mode and not in V86
	  mode

(Table 03610)
Values for calling QEMM v5.11+ QPI function 1B07h:
	AX = 1B07h
BUG: QEMM 6.00-7.01 accept this and branch randomly

(Table 03611)
Values for calling QEMM v5.11+ QPI function 1Bxxh:
	AX = 1B08h to 1BFFh
Return: CF set

(Table 03612)
Values for calling QEMM v5.11+ QPI function 1C00h:
	AX = 1C00h disable IRQ0-7 calldowns
Return: CF clear

(Table 03613)
Values for calling QEMM v5.11+ QPI function 1C01h:
	AX = 1C01h set V86-mode IRQ0-7 handlers
	ES:DI -&gt; 8 DWORDs containing V86-mode handler addresses
Return: CF clear

(Table 03614)
Values for calling QEMM v5.11+ QPI function 1C02h:
	AX = 1C02h disable IRQ8-15 handlers
Return: CF clear

(Table 03615)
Values for calling QEMM v5.11+ QPI function 1C03h:
	AX = 1C03h set V86-mode IRQ8-15 handlers
	ES:DI -&gt; 8 DWORDs containing V86-mode handler addresses
BUG:	although the jump table only contains four entries, QEMM 6.00 will
	  attempt to use it for any value of AL between 00h and 2Ah, thus
	  branching unpredictably for AL=04h-2Ah; QEMM v7.01 behaves
	  similarly for AL=04h-1Bh
Note:	when enabled, the appropriate IRQs are reflected back to the specified
	  handlers in virtual-86 mode after the CPU automatically invokes the
	  protected-mode handler inside QEMM

(Table 03616)
Values for calling QEMM v7.03+ "QPI_SimulateHWInt" function:
	AX = 1C04h
	BX = number of interrupt to simulate
Return: ???
Notes:	this function will allow proper simulation of a hardware interrupt
	  under DESQview and DESQview/X, where the correct interrupt handler
	  may be in a different process with a completely different address
	  space
	this function was officially documented with the release of QEMM v7.50

(Table 03617)
Values for calling QEMM v6.0x only QPI function 1D00h:
	AX = 1D00h switch to pre-Stealth interrupt vector table
Return: CF clear if supported (QEMM v6.x)
	CF set if not supported (QEMM v7+)
Notes:	also switches VGA Save table pointer (0040h:00A8h) and overwrites the
	  vectors currently assigned for use by the two interrupt controllers
	  (see INT 67/AX=DE0Ah) with the vectors for INT 08-0F and 70-77 (to
	  avoid crashing the system).
	functions 1Dxxh are not supported by QEMM v7.01, and always return CF
	  set

(Table 03618)
Values for calling QEMM v6.0x only QPI function 1D01h:
	AX = 1D01h restore user interrupt vector table
Return: CF clear if supported (QEMM v6.x)
	CF set if not supported (QEMM v7+)
Notes:	interrupts should be disabled around the AX=1D00h and AX=1D01h calls
	  because QEMM does not modify the memory maps to map in ROM, so
	  an interrupt could be disastrous
	clears any pending IRQ7 at end of function
	functions 1Dxxh are not supported by QEMM v7.01, and always return CF
	  set

(Table 03619)
Values for calling QEMM v6.00+ QPI function 1Dxxh:
	AX = 1D02h to 1DFFh
Return: CF set

(Table 03620)
Values for calling QEMM v6.00+ "QEMM_GET_INFO"/"QPI_GetInfo" function:
	AX = 1E00h get Stealth configuration
Return: CF clear
	BL = memory configuration flags (documented as "reserved") (see #03644)
	BH = (v7.00+) disk buffer flags
	    bit 0: DISKBUFFRAME buffer instead of DISKBUF buffer
	    bit 1: buffer has already been used
	CL = stealth type (00h none, 46h Frame, 4Dh Map, 50h Protect)
	CH = suspend/resume interrupt (00h none)
	DL = (v7.00+) size of QEMM disk buffer in KB (00h none)
	DH = reserved (always 00h for v6.00)
	SI = reserved (always 0000h for v6.00)
	DI = reserved (always 0000h for v6.00)
Note:	this function is officially documented

(Table 03621)
Values for calling QEMM v6.00+ "QPI_GetStealthCount" function:
	AX = 1E01h get number of Stealth'ed ROMs
Return: CF clear
	BX = number of Stealth'ed ROMs
Note:	this function is officially documented

(Table 03622)
Values for calling QEMM v6.00+ "QPI_GetStealthList" function:
	AX = 1E02h
	ES:DI -&gt; buffer for Stealth ROM info (see #03646)
Return: CF clear
	BX = number of Stealth'ed ROMs
	ES:DI buffer filled
Note:	this function is officially documented

(Table 03623)
Values for unimplemented Stealth information functions:
	AX = 1E03h to 1EFFh
Return: CF set


(Table 03624)
Values for calling QEMM v6.00+ "QEMM_GET_PTE"/"QPI_GetPTE" function:
	AX = 1F00h get page table entry
	CX = page number (0000h-010Fh)
Return: CF clear
	EDX = page table entry
Note:	this function is officially documented

(Table 03625)
Values for calling QEMM v6.00+ "QEMM_SET_PTE"/"QPI_SetPTE" function:
	AX = 1F01h set page table entry
	CX = page number (0000h-010Fh)
	EDX = new page table entry
Return: CF clear
Note:	this function is officially documented
SeeAlso: #03549

(Table 03626)
Values for calling QEMM v6.00+ QPI function 1Fxxh:
	AX = 1F02h to 1FFFh
Return: CF set

(Table 03627)
Values for calling QEMM v6.00+ "QEMM_GET_VHI_INFO"/"QPI_GetVHIInfo" function:
	AX = 2000h "QEMM_GET_VHI_INFO" get VirtualHDIRQ information
Return: CF clear
	BL = flags
	    bit 7: VirtualHDIRQ setting respected
		  (set if Stealth active)
	    bits 6-1 reserved
	    bit 0: VirtualHDIRQ currently enabled
		(INT 15/AH=90h suppressed when enabled)
Note:	this function is officially documented
SeeAlso: #03628

(Table 03628)
Values for calling QEMM v6.00+ "QEMM_SET_VHI_INFO"/"QPI_SetVHIInfo" function:
	AX = 2001h set VirtualHDIRQ state
	BL bit 0 = new VirtualHDIRQ state
Return: CF clear
	BL = old VHI setting (bits 0 and 7, see #03627)
Note:	this function is officially documented
SeeAlso: #03627

(Table 03629)
Values for calling QEMM v6.00+ QPI function 20xxh:
	AX = 2002h to 20FFh
Return: CF set

(Table 03630)
Values for calling QEMM v6.00+ "QEMM_COPY_STEALTH_ROMS"/"QPI_CopyStealthRoms":
	AX = 2100h copy data from Stealthed address space
	DS:SI -&gt; start address of hidden memory to copy
	ES:DI -&gt; buffer for copied data
	ECX = number of bytes to copy
Return: CF clear if successful
	CF set on error (no Stealth or DS:SI &lt; C000h:0000h or DS:SI + ECX &gt; 1M)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 03631)
Values for calling QEMM v6.00+ QPI function 21xxh:
	AX = 2101h to 21FFh
Return: CF set

(Table 03632)
Values for calling QEMM v6.03+ QPI function 2200h:
	AX = 2200h DESQview/X support -- get ???
Return: CF clear
	ES:DI -&gt; ???

(Table 03633)
Values for calling QEMM v6.03+ QPI function 2201h:
	AX = 2201h DESQview/X support -- set ???
	ES:DI -&gt; ??? or 0000h:0000h
Return: CF clear if successful
	CF set on error

(Table 03634)
Values for calling QEMM v6.04+ QPI function 2300h:
	AX = 2300h get ???
	BX = which ??? to get (must be 0000h for v6.04)
Return: CF clear if successful
	    ES:DI -&gt; ???
	CF set on error

(Table 03635)
Values for calling QEMM v6.04+ QPI function 2301h:
	AX = 2301h set ???
	BX = which ??? to set (must be 0000h for v6.04)
	ES:DI -&gt; ???
Return: CF clear if successful
	CF set on error

(Table 03636)
Values for calling QEMM v6.04+ QPI function 2302h:
	AX = 2302h clear specified ???
	BX = which ??? to clear (must be 0000h for v6.04)
Return: CF clear if successful
	CF set on error

(Table 03637)
Values for calling QEMM v6.04+ QPI function 23FFh:
	AX = 23FFh clear all ???
Return: CF clear if successful
	CF set on error

(Table 03638)
Values for calling QEMM v6.04+ QPI function 23xxh:
	AX = 2303h to 23FEh
Return: CF set

(Table 03639)
Values for calling QEMM v7.01+ QPI function 24h:
	AH = 24h ST-DBL support
	AL = subfunction
	    00h set ???
		EDX -&gt; information table (EDX = segment SHL 16 + offset)
	    01h ???
Return: CF clear if successful
	CF set on error

(Table 03640)
Values for calling QEMM unimplemented QPI functions:
	AH = 25h to FFh
Return: CF set

Format of QEMM protection level configuration:
Offset	Size	Description	(Table 03641)
 00h	WORD	segment of 128 breakpoint (INT 3) instructions for use in
		  DESQview protection level 3 interrupt vector checking, or
		  0000h to disable; in pl3, INTs 00-7F are pointed at these
		  breakpoints
 02h	DWORD	-&gt; array of actual interrupt handler addresses for INT 00-7F
		  when interrupt vectors are pointed at protection level 3
		  breakpoints
 06h	DWORD	far pointer to ??? region list (see #03642)
 0Ah	DWORD	far pointer to buffer for returned ???
 0Eh	DWORD	seg:ofs of function to call on protection violation???
 12h	WORD	segment of ???
 14h	DWORD	far pointer to DWORD containing number of paragraphs of
		  ??? for segment at offset 12h
	???

Format of protection level Region List:
Offset	Size	Description	(Table 03642)
 00h	WORD	number of PAIRS of pointers to follow
 02h 2N DWORDs	start/end seg:ofs addresses of ??? regions
Note:	QEMM converts the segmented addresses into linear addresses in place

Format of EMM Import structure:
Offset	Size	Description	(Table 03643)
 00h	DWORD	physical address of EMM import struct
 04h	BYTE	major version (v6.00 sets to 01h)
 05h	BYTE	minor version (v6.00 sets to 00h/0Bh)
SeeAlso: INT 21/AX=4402h/SF=01h

Bitfields for memory configuration flags:
Bit(s)	Description	(Table 03644)
 0	conventional memory sorted
 1	conventional memory filled
 2	???
 3	???
 4	expanded memory is in use
 5	???

Format of QEMM 6.0 memory statistics:
Offset	Size	Description	(Table 03645)
 00h	BYTE	01h if Shadow RAM found, 00h otherwise
 01h	DWORD	initial conventional memory in bytes
 05h	DWORD	initial extended memory in bytes
 09h	DWORD	initial expanded memory in bytes
 0Dh	DWORD	initial "top" or "shadow" memory in bytes
 11h	DWORD	Unavailable conventional memory in bytes
 15h	DWORD	Unavailable extended memory in bytes
 19h	DWORD	Unavailable expanded memory in bytes
 1Dh	DWORD	Unavailable "top" or "shadow" memory in bytes
		Add to offset 49h for Total unavailable top/shadow.
 21h	DWORD	QEMM code size in bytes
 25h	DWORD	QEMM data size in bytes
 29h	DWORD	bytes used for TASKS=
 2Dh	DWORD	DMA buffer size
 31h	DWORD	bytes used for MAPS=
 35h	DWORD	bytes of high RAM
 39h	DWORD	bytes used by mapped ROMs
 3Dh	DWORD	bytes of conventional memory provided by QEMM
 41h	DWORD	bytes of extended memory NOT converted by QEMM (EXT=xxx)
 45h	DWORD	bytes of EMS/XMS pool memory provided by QEMM
 49h	DWORD	Unavailable "top" or "shadow" memory in bytes
		Add to offset 1Dh for Total unavailable top/shadow.
 4Dh	DWORD	conventional memory overhead in bytes
		(set to 0 by QEMM.COM prior to call)

Format of Stealth ROM info [array]:
Offset	Size	Description	(Table 03646)
 00h	WORD	starting segment of ROM
 02h	WORD	length of ROM in paragraphs

Format of QEMM EGA/VGA DAC register virtualization buffer:
Offset	Size	Description	(Table 03647)
 00h	BYTE	(temp) current color register number
 01h	BYTE	(temp) number of bytes written so far for current color reg
 02h 768 BYTEs	three bytes per color register

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6740" name="6740"><b>6740</b></a> - INT 67 - LIM EMS - GET MANAGER STATUS<br />
<pre>
INT 67 - LIM EMS - GET MANAGER STATUS
	AH = 40h
Return: AH = status (00h,80h,81h,84h) (see #03648)
Note:	this call can be used only after establishing that the EMS driver is in
	  fact present
SeeAlso: AH=3Fh,AX=FFA5h,@xxxxh:xxxxh"PMM"

(Table 03648)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 82h	busy -- retry later
 83h	invalid handle
 84h	undefined function requested by application
 85h	no more handles available
 86h	error in save or restore of mapping context
 87h	insufficient memory pages in system
 88h	insufficient memory pages available
 89h	zero pages requested
 8Ah	invalid logical page number encountered
 8Bh	invalid physical page number encountered
 8Ch	page-mapping hardware state save area is full
 8Dh	save of mapping context failed
 8Eh	restore of mapping context failed
 8Fh	undefined subfunction
 90h	undefined attribute type
 91h	feature not supported
 92h	successful, but a portion of the source region has been overwritten
 93h	length of source or destination region exceeds length of region
	  allocated to either source or destination handle
 94h	conventional and expanded memory regions overlap
 95h	offset within logical page exceeds size of logical page
 96h	region length exceeds 1M
 97h	source and destination EMS regions have same handle and overlap
 98h	memory source or destination type undefined
 9Ah	specified alternate map register or DMA register set not supported
 9Bh	all alternate map register or DMA register sets currently allocated
 9Ch	alternate map register or DMA register sets not supported
 9Dh	undefined or unallocated alternate map register or DMA register set
 9Eh	dedicated DMA channels not supported
 9Fh	specified dedicated DMA channel not supported
 A0h	no such handle name
 A1h	a handle found had no name, or duplicate handle name
 A2h	attempted to wrap around 1M conventional address space
 A3h	source array corrupted
 A4h	operating system denied access

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6741" name="6741"><b>6741</b></a> - INT 67 - LIM EMS - GET PAGE FRAME SEGMENT<br />
<pre>
INT 67 - LIM EMS - GET PAGE FRAME SEGMENT
	AH = 41h
Return: AH = status (see also AH=40h)
	    00h function successful
		BX = segment of page frame
SeeAlso: AH=58h,AH=68h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6742" name="6742"><b>6742</b></a> - INT 67 - LIM EMS - GET NUMBER OF PAGES<br />
<pre>
INT 67 - LIM EMS - GET NUMBER OF PAGES
	AH = 42h
Return: AH = status (see also AH=40h)
	    00h function successful
		BX = number of unallocated pages
		DX = total number of pages
BUG:	DOS 6.0 EMM386.EXE causes a system lock-up or reboot if in AUTO mode
	  when this call is made; use AH=46h to ensure that EMM386 is ON
	  before making this call
SeeAlso: INT 2F/AX=2702h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6743" name="6743"><b>6743</b></a> - INT 67 - LIM EMS - GET HANDLE AND ALLOCATE MEMORY<br />
<pre>
INT 67 - LIM EMS - GET HANDLE AND ALLOCATE MEMORY
	AH = 43h
	BX = number of logical pages to allocate
Return: AH = status (00h,80h,81h,84h,85h,87h,88h,89h) (see #03648)
	DX = handle if AH=00h
SeeAlso: AH=45h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#674321" name="674321"><b>674321</b></a> - INT 67 - Q87 v4+ - INSTALLATION CHECK<br />
<pre>
INT 67 - Q87 v4+ - INSTALLATION CHECK
	AX = 4321h
	EAX = 87654321h (entire EAX value required)
Return: EAX = 12345678h if Q87 is installed
Note:	this call requires that VCPI services be available; if they are not,
	  this call will not be recognized
BUG:	v4.00-v4.03 will hang on most machines when run under bare DOS with
	  no memory manager, because neither Q87 nor UNLOAD87 checks whether
	  there is a valid INT 67 handler before performing an installation
	  check via INT 67
SeeAlso: AX=2833h,INT 21/AX=4321h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6744" name="6744"><b>6744</b></a> - INT 67 - LIM EMS - MAP MEMORY<br />
<pre>
INT 67 - LIM EMS - MAP MEMORY
	AH = 44h
	AL = physical page number (0-3)
	BX = logical page number
	    or FFFFh to unmap (QEMM)
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Ah,8Bh) (see #03648)
SeeAlso: AH=69h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6745" name="6745"><b>6745</b></a> - INT 67 - LIM EMS - RELEASE HANDLE AND MEMORY<br />
<pre>
INT 67 - LIM EMS - RELEASE HANDLE AND MEMORY
	AH = 45h
	DX = EMM handle
Return: AH = status (00h,80h,81h,83h,84h,86h) (see #03648)
SeeAlso: AH=43h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6746" name="6746"><b>6746</b></a> - INT 67 - LIM EMS - GET EMM VERSION<br />
<pre>
INT 67 - LIM EMS - GET EMM VERSION
	AH = 46h
Return: AH = status (00h,80h,81h,84h) (see #03648)
	AL = EMM version number if AH=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6747" name="6747"><b>6747</b></a> - INT 67 - LIM EMS - SAVE MAPPING CONTEXT<br />
<pre>
INT 67 - LIM EMS - SAVE MAPPING CONTEXT
	AH = 47h
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Ch-8Eh) (see #03648)
SeeAlso: AH=48h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6748" name="6748"><b>6748</b></a> - INT 67 - LIM EMS - RESTORE MAPPING CONTEXT<br />
<pre>
INT 67 - LIM EMS - RESTORE MAPPING CONTEXT
	AH = 48h
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Eh) (see #03648)
SeeAlso: AH=47h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6749" name="6749"><b>6749</b></a> - INT 67 - LIM EMS - reserved - GET I/O PORT ADDRESSES<br />
<pre>
INT 67 - LIM EMS - reserved - GET I/O PORT ADDRESSES
	AH = 49h
Note:	defined in EMS 3.0, but undocumented in EMS 3.2

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#674A" name="674A"><b>674A</b></a> - INT 67 - LIM EMS - reserved - GET TRANSLATION ARRAY<br />
<pre>
INT 67 - LIM EMS - reserved - GET TRANSLATION ARRAY
	AH = 4Ah
Note:	defined in EMS 3.0, but undocumented in EMS 3.2

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#674B" name="674B"><b>674B</b></a> - INT 67 - LIM EMS - GET NUMBER OF EMM HANDLES<br />
<pre>
INT 67 - LIM EMS - GET NUMBER OF EMM HANDLES
	AH = 4Bh
Return: AH = status (00h,80h,81h,83h,84h) (see #03648)
	BX = number of EMM handles if AH=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#674C" name="674C"><b>674C</b></a> - INT 67 - LIM EMS - GET PAGES OWNED BY HANDLE<br />
<pre>
INT 67 - LIM EMS - GET PAGES OWNED BY HANDLE
	AH = 4Ch
	DX = EMM handle
Return: AH = status (see #02785)
	BX = number of logical pages if AH=00h
SeeAlso: AH=4Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#674D" name="674D"><b>674D</b></a> - INT 67 - LIM EMS - GET PAGES FOR ALL HANDLES<br />
<pre>
INT 67 - LIM EMS - GET PAGES FOR ALL HANDLES
	AH = 4Dh
	ES:DI -&gt; array to receive information
Return: AH = status (00h,80h,81h,84h) (see #03648)
	---if AH=00h---
	BX = number of active EMM handles
	array filled with 2-word entries, consisting of a handle and the
	  number of pages allocated to that handle
SeeAlso: AH=4Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#674E" name="674E"><b>674E</b></a> - INT 67 - LIM EMS - GET OR SET PAGE MAP<br />
<pre>
INT 67 - LIM EMS - GET OR SET PAGE MAP
	AH = 4Eh
	AL = subfunction
	    00h get mapping registers
	    01h set mapping registers
	    02h get and set mapping registers at once
	    03h get size of page-mapping array
	DS:SI -&gt; array holding information (AL=01h/02h)
	ES:DI -&gt; array to receive information (AL=00h/02h)
Return: AH = status (00h,80h,81h,84h,8Fh,A3h) (see also AH=40h)
	    00h successful
		AL = bytes in page-mapping array (AL=03h only)
		array pointed to by ES:DI receives mapping info (AL=00h/02h)
Notes:	this function was designed to be used by multitasking operating systems
	  and should not ordinarily be used by appplication software.
	MD386 returns the size of the page-mapping array in AX instead of AL
SeeAlso: AH=4Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#674F" name="674F"><b>674F</b></a> - INT 67 - LIM EMS 4.0 - GET/SET PARTIAL PAGE MAP<br />
<pre>
INT 67 - LIM EMS 4.0 - GET/SET PARTIAL PAGE MAP
	AH = 4Fh
	AL = subfunction
	    00h get partial page map
	       DS:SI -&gt; structure containing list of segments whose mapping
			contexts are to be saved
	       ES:DI -&gt; array to receive page map
	    01h set partial page map
	       DS:SI -&gt; structure containing saved partial page map
	    02h get size of partial page map
	       BX = number of mappable segments in the partial map to be saved
Return: AH = status (00h,80h,81h,84h,8Bh,8Fh,A3h) (see also AH=40h)
	    8Bh one of the specified segments is not mappable
	    A3h contents of partial page map corrupted or count of mappable
		segments exceeds total number of mappable segments in system
	AL = size of partial page map for subfunction 02h
SeeAlso: AH=4Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6750" name="6750"><b>6750</b></a> - INT 67 - LIM EMS 4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES<br />
<pre>
INT 67 - LIM EMS 4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES
	AH = 50h
	AL = subfunction
	    00h use physical page numbers
	    01h use segment addresses
	DX = handle
	CX = number of entries in array
	DS:SI -&gt; mapping array (see #03649)
Return: AH = status (00h,80h,81h,83h,84h,8Ah,8Bh,8Fh) (see #03648)
SeeAlso: AH=40h

Format of EMS mapping array entry:
Offset	Size	Description	(Table 03649)
 00h	WORD	logical page number or FFFFh to unmap physical page
 02h	WORD	physical page number or segment address

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6751" name="6751"><b>6751</b></a> - INT 67 - LIM EMS 4.0 - REALLOCATE PAGES<br />
<pre>
INT 67 - LIM EMS 4.0 - REALLOCATE PAGES
	AH = 51h
	DX = handle
	BX = number of pages to be allocated to handle
Return: AH = status (00h,80h,81h,83h,84h,87h,88h) (see #03650)
	BX = actual number of pages allocated to handle

(Table 03650)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 83h	invalid handle
 84h	undefined function requested
 87h	more pages requested than present in system
 88h	more pages requested than currently available
 8Ah	invalid logical page number encountered
 8Bh	invalid physical page number encountered
 8Fh	undefined subfunction
 90h	undefined attribute type
 91h	feature not supported
 A0h	no such handle name
 A1h	duplicate handle name

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6752" name="6752"><b>6752</b></a> - INT 67 - LIM EMS 4.0 - GET/SET HANDLE ATTRIBUTES<br />
<pre>
INT 67 - LIM EMS 4.0 - GET/SET HANDLE ATTRIBUTES
	AH = 52h
	AL = subfunction
	    00h get handle attributes
		Return: AL = attribute
			    00h handle is volatile
			    01h handle is nonvolatile
	    01h set handle attributes
		BL = new attribute
		   00h handle is volatile
		   01h handle is nonvolatile
	    02h get attribute capability
		Return: AL = attribute capability
			    00h only volatile handles supported
			    01h both volatile and non-volatile supported
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Fh-91h) (see #03648)
SeeAlso: AH=53h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6753" name="6753"><b>6753</b></a> - INT 67 - LIM EMS 4.0 - GET/SET HANDLE NAME<br />
<pre>
INT 67 - LIM EMS 4.0 - GET/SET HANDLE NAME
	AH = 53h
	AL = subfunction
	    00h get handle name
	       ES:DI -&gt; 8-byte buffer for handle name
	    01h set handle name
	       DS:SI -&gt; 8-byte handle name
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Fh,A1h) (see #03648)
SeeAlso: AH=52h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6754" name="6754"><b>6754</b></a> - INT 67 - LIM EMS 4.0 - GET HANDLE DIRECTORY<br />
<pre>
INT 67 - LIM EMS 4.0 - GET HANDLE DIRECTORY
	AH = 54h
	AL = subfunction
	    00h get handle directory
	       ES:DI -&gt; buffer for handle directory (see #03651)
	    01h search for named handle
	       DS:SI -&gt; 8-byte name
	    02h get total number of handles
Return: AL = number of entries in handle directory (subfunction 00h)
	DX = value of named handle (subfunction 01h)
	BX = total number of handles (subfunction 02h)
	AH = status (00h,80h,81h,84h,8Fh,A0h,A1h) (see also #03650)
	    A1h a handle found had no name

Format of EMS handle directory entry:
Offset	Size	Description	(Table 03651)
 00h	WORD	handle
 02h  8 BYTEs	handle's name

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6755" name="6755"><b>6755</b></a> - INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND JUMP<br />
<pre>
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND JUMP
	AH = 55h
	AL = subfunction
	    00h physical page numbers provided by caller
	    01h segment addresses provided by caller
	DX = handle
	DS:SI -&gt; structure containing map and jump address
Return: (at target address unless error)
	AH = status (00h,80h,81h,83h,84h,8Ah,8Bh,8Fh) (see #03648)
SeeAlso: AH=56h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6756" name="6756"><b>6756</b></a> - INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND CALL<br />
<pre>
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND CALL
	AH = 56h
	AL = subfunction
	    00h physical page numbers provided by caller
		DX = handle
		DS:SI -&gt; structure containing page map and call address
	    01h segment addresses provided by caller
		DX = handle
		DS:SI -&gt; structure containing page map and call address
	    02h get page map stack space required
		Return: BX = stack space required
Return: (if successful, the target address is called.  Use a RETF to return
	 and restore mapping context)
	AH = status (00h,80h,81h,83h,84h,8Ah,8Bh,8Fh) (see #03648)
SeeAlso: AH=55h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6756FF" name="6756FF"><b>6756FF</b></a> - INT 67 - RM386 v6.00 - ???<br />
<pre>
INT 67 - RM386 v6.00 - ???
	AX = 56FFh
	DS:SI -&gt; ???
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6757" name="6757"><b>6757</b></a> - INT 67 - LIM EMS 4.0 - MOVE/EXCHANGE MEMORY REGION<br />
<pre>
INT 67 - LIM EMS 4.0 - MOVE/EXCHANGE MEMORY REGION
	AH = 57h
	AL = subfunction
	    00h move memory region
	    01h exchange memory region
	DS:SI -&gt; structure describing source and destination (see #03653)
Return: AH = status (see #03652)
Note:	source and destination may overlap for a move, in which case the copy
	  direction is chosen such that the destination receives an intact copy
	  of the source region

(Table 03652)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware failure
 83h	invalid handle
 84h	undefined function requested
 8Ah	invalid logical page number encountered
 8Fh	undefined subfunction
 92h	successful, but a portion of the source region has been overwritten
 93h	length of source or destination region exceeds length of region
	  allocated to either source or destination handle
 94h	conventional and expanded memory regions overlap
 95h	offset within logical page exceeds size of logical page
 96h	region length exceeds 1M
 97h	source and destination EMS regions have same handle and overlap
 98h	memory source or destination type undefined
 A2h	attempted to wrap around 1M conventional address space

Format of EMS copy data:
Offset	Size	Description	(Table 03653)
 00h	DWORD	region length in bytes
 04h	BYTE	source memory type
		00h conventional
		01h expanded
 05h	WORD	source handle (0000h if conventional memory)
 07h	WORD	source initial offset (within page if EMS, segment if convent)
 09h	WORD	source initial segment (conv mem) or logical page (EMS)
 0Bh	BYTE	destination memory type
		00h conventional
		01h expanded
 0Ch	WORD	destination handle
 0Eh	WORD	destination initial offset
 10h	WORD	destination initial segment or page

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6758" name="6758"><b>6758</b></a> - INT 67 - LIM EMS 4.0 - GET MAPPABLE PHYSICAL ADDRESS ARRAY<br />
<pre>
INT 67 - LIM EMS 4.0 - GET MAPPABLE PHYSICAL ADDRESS ARRAY
	AH = 58h
	AL = subfunction
	    00h get mappable physical address array
		ES:DI -&gt; buffer to be filled with array (see #03654)
	    01h get number of entries in m.p.a. array
Return: CX = number of entries in array
	AH = status (00h,80h,81h,84h,8Fh) (see #03652)
Note:	the returned array for subfunction 00h is filled in physical segment
	  address order

Format of EMS mappable physical address entry:
Offset	Size	Description	(Table 03654)
 00h	WORD	physical page segment
 02h	WORD	physical page number

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675857" name="675857"><b>675857</b></a> - INT 67 U - NETROOM??? - ???<br />
<pre>
INT 67 U - NETROOM??? - ???
	AX = 5857h
	BX = function??? (0057h,0059h,0159h seen)
	???
Return: ???
Note:	BX=0059h appears to be analogous to AX=5800h and BX=0159h appears to
	  be analogous to AX=5801h; BX=0057h appears to indicate whether
	  AX=580xh or AX=5857h/BX=0x59h should be used
SeeAlso: AX=5BF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6759" name="6759"><b>6759</b></a> - INT 67 - LIM EMS 4.0 - GET EXPANDED MEMORY HARDWARE INFORMATION<br />
<pre>
INT 67 - LIM EMS 4.0 - GET EXPANDED MEMORY HARDWARE INFORMATION
	AH = 59h
	AL = subfunction
	    00h get hardware configuration array
		ES:DI -&gt; buffer to be filled with array (see #03655)
	    01h get unallocated raw page count
		Return: BX = unallocated raw pages
			DX = total raw pages
Return: AH = status (see also AH=58h"EMS 4.0")
	    A4h access denied by operating system
Note:	subfunction 00h is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system

Format of EMS hardware configuration array:
Offset	Size	Description	(Table 03655)
 00h	WORD	size of raw EMM pages in paragraphs
 02h	WORD	number of alternate register sets
 04h	WORD	size of mapping-context save area in bytes
 06h	WORD	number of register sets assignable to DMA
 08h	WORD	DMA operation type
		0000h DMA with alternate register sets
		0001h only one DMA register set

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675A" name="675A"><b>675A</b></a> - INT 67 - LIM EMS 4.0 - ALLOCATE STANDARD/RAW PAGES<br />
<pre>
INT 67 - LIM EMS 4.0 - ALLOCATE STANDARD/RAW PAGES
	AH = 5Ah
	AL = subfunction
	    00h allocate standard pages
	    01h allocate raw pages
	BX = number of pages to allocate
Return: DX = handle
	AH = status (00h,80h,81h,84h,85h,87h,88h,8Fh) (see #03648)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675B" name="675B"><b>675B</b></a> - INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET<br />
<pre>
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET
	AH = 5Bh
	AL = subfunction
	    00h get alternate map register set
		Return: BL = current active alternate map register set number
			ES:DI -&gt; map register context save area if BL=00h
	    01h set alternate map register set
		BL = new alternate map register set number
		ES:DI -&gt; map register context save area if BL=0
	    02h get alternate map save array size
		Return: DX = array size in bytes
	    03h allocate alternate map register set
		Return: BL = number of map register set; 00h = not supported
	    04h deallocate alternate map register set
		BL = number of alternate map register set
Return: AH = status (00h,80h,81h,84h,8Fh,9Ah-9Dh,A3h,A4h) (see #03656)
Note:	this function is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system

(Table 03656)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 84h	undefined function requested
 8Fh	undefined subfunction
 9Ah	specified alternate map register or DMA register set not supported
 9Bh	all alternate map register or DMA register sets currently allocated
 9Ch	alternate map register or DMA register sets not supported
 9Dh	undefined or unallocated alternate map register/DMA register set
 9Eh	dedicated DMA channels not supported
 9Fh	specified dedicated DMA channel not supported
 A3h	source array corrupted
 A4h	operating system denied access

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675B_0" name="675B_0"><b>675B</b></a> - INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET - DMA REGISTERS<br />
<pre>
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET - DMA REGISTERS
	AH = 5Bh
	AL = subfunction
	    05h allocate DMA register set
		Return: BL = DMA register set number, 00h if not supported
	    06h enable DMA on alternate map register set
	       BL = DMA register set number
	       DL = DMA channel number
	    07h disable DMA on alternate map register set
	       BL = DMA register set number
	    08h deallocate DMA register set
	       BL = DMA register set number
Return: AH = status (00h,80h,81h,84h,8Fh,9Ah-9Fh,A3h,A4h) (see #03656)
Note:	this function is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675BE0" name="675BE0"><b>675BE0</b></a> - INT 67 - MICEMM v4D, RM386 - GET LINEAR ADDRESS OF MEMORY<br />
<pre>
INT 67 - MICEMM v4D, RM386 - GET LINEAR ADDRESS OF MEMORY
	AX = 5BE0h
	ES:BX -&gt; memory for which to get linear address
Return: AH = 00h
	CX:DX = linear address of physical memory corresponding to ES:BX
Program: RAM-MAN/386 is the memory manager included with Helix's Netroom;
	  MICEMM is a memory manager for some Micronics motherboards
Note:	this has been superceded by AX=DE06h, which should be used instead
SeeAlso: AX=5BF0h,AX=5BF1h,AX=DE06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675BE1" name="675BE1"><b>675BE1</b></a> - INT 67 - RM386 v6.00+ - GET MEMORY MANAGER SIZE<br />
<pre>
INT 67 - RM386 v6.00+ - GET MEMORY MANAGER SIZE
	AX = 5BE1h
Return: AH = 00h
	CX = code and data size in bytes
	DX:BX = physical address of RM386 code
	DI:SI = total size of RM386 area including handle tables
	BP = number of additional pages (high DOS, etc.)
SeeAlso: AX=5BE0h,AX=5BE2h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675BE2" name="675BE2"><b>675BE2</b></a> - INT 67 - RM386 v6.00+ - GET INTERRUPT VECTORS<br />
<pre>
INT 67 - RM386 v6.00+ - GET INTERRUPT VECTORS
	AX = 5BE2h
Return: DS:SI -&gt; V86-mode table (see #03657)
	ES:BX -&gt; ??? (undoc, middle of device driver interrupt routine!)
SeeAlso: AX=5BE0h,AX=5BE1h

Format of RM386 V86-mode table:
Offset	Size	Description	(Table 03657)
 00h	DWORD	original INT 13 vector
 04h	DWORD	original INT 15 vector
 08h	DWORD	original INT 19 vector
 0Ch	DWORD	original INT 21 vector
 10h	DWORD	original INT 4B vector
 14h	DWORD	original INT 67 vector

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675BF0" name="675BF0"><b>675BF0</b></a> - INT 67 - MICEMM v4D, RM386 - INSTALLATION CHECK<br />
<pre>
INT 67 - MICEMM v4D, RM386 - INSTALLATION CHECK
	AX = 5BF0h
Return: AH = 00h if MICEMM or RM386 present
	    BX = code segment of driver
Program: MICEMM is the Micronics Expanded Memory Manager; RM386 is the memory
	  manager included in Helix Software's Netroom
SeeAlso: AH=3Fh,AX=5BE0h,AX=5BF1h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675BF1" name="675BF1"><b>675BF1</b></a> - INT 67 - MICEMM v4D, RM386 - GET ADDRESS MAP<br />
<pre>
INT 67 - MICEMM v4D, RM386 - GET ADDRESS MAP
	AX = 5BF1h
	ES:BX -&gt; 256-byte (MICEMM) or 512-byte (RM386) buffer for memory types
Return: AH = 00h
	ES:BX buffer filled (see #03658)
Note:	each byte in the buffer specifies the type of a 4K page of memory
SeeAlso: AX=5BE0h,AX=5BF0h

(Table 03658)
Values for MICEMM/RM386 memory type:
 00h	unused (MICEMM), RAM/available (RM386)
 02h	DOS extension (XMS UMB)
 04h	shadowed ROM
 08h	mappable EMS
 10h	page frame
 20h	ROM
 40h	reserved (video memory, etc)
 80h	RAM (MICEMM), Windows UMB (RM386)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675BF2" name="675BF2"><b>675BF2</b></a> - INT 67 - RM386 - GET RM386 INTERNAL DATA<br />
<pre>
INT 67 - RM386 - GET RM386 INTERNAL DATA
	AX = 5BF2h
	CX = size of buffer
	DS:SI -&gt; buffer for internal data
	(documentation says ES:BX -&gt; buffer, SI = offset within RM386)
Return: buffer filled
Note:	the data returned by this function is release-specific
SeeAlso: AX=5BF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675BF3" name="675BF3"><b>675BF3</b></a> - INT 67 - RM386 - RETURN TO REAL MODE<br />
<pre>
INT 67 - RM386 - RETURN TO REAL MODE
	AX = 5BF3h
Return: nothing
Note:	use AX=5DE0h instead of this functin
SeeAlso: AX=5BF0h,AX=5DE0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675BF4" name="675BF4"><b>675BF4</b></a> - INT 67 - RM386 v6.00 - GET RM386 GLOBAL FLAGS<br />
<pre>
INT 67 - RM386 v6.00 - GET RM386 GLOBAL FLAGS
	AX = 5BF4h
Return: AH = 00h
	BX = global flags 1 (see #03659)
	CX = global flags 2 (see #03660)
	DX = global flags 3 (see #03661)
	SI = global flags 4 (see #03662)
SeeAlso: AX=5BF0h

Bitfields for RM386 global flags 1:
Bit(s)	Description	(Table 03659)
 0-3	reserved
 4	V86 mode
 5	reserved
 6	80386 or higher CPU
 7,8	reserved
 9	A20 enabled at startup
 10	"HIGH_IO"
 11	ROM
 12	large frame
 13,14	reserved
 15	PS/2-style A20 control

Bitfields for RM386 global flags 2:
Bit(s)	Description	(Table 03660)
 0	HMA in use
 1	XMS present
 2	using XMS driver memory
 3	HIGH (NEAT only)
 4-7	reserved
 8	NOBKTRAP
 9	NORESET
 10	ALTMAP
 11	NOFRAME
 12-15	reserved

Bitfields for RM386 global flags 3:
Bit(s)	Description	(Table 03661)
 0	NOTEST
 1	NOEBDA
 2	Windows3 support
 3	system board mouse
 4	DISKBUF
 5	EBDALOW
 6	A20 global enable flag
 7	A20 flag
 8	EBDA moved to stub
 9	VXD file was found
 10	reserved
 11	NOBOOTMAP
 12	AUTO
 13	PS/2 machine
 14	Compaq ROM merge active
 15	NOHMA set

Bitfields for RM386 global flags 4:
Bit(s)	Description	(Table 03662)
 0	"NOV8259" don't virtualize interrupt controller
 1	NOSCSI
 2	NOSCAN
 3	NOTR
 4	ALTBOOT
 5	NOCOMPQ
 6	KB2TRAP
 7	DESHADOW
 8	Video 7 VGA detected
 9	reserved
 10	NOVGA
 11	NOPS2
 12	DEBUG
 13	NOVKB
 14,15	reserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675BF5" name="675BF5"><b>675BF5</b></a> - INT 67 - RM386 v6.00 - GET RM386 EMS HANDLE COUNT<br />
<pre>
INT 67 - RM386 v6.00 - GET RM386 EMS HANDLE COUNT
	AX = 5BF5h
Return: AH = status
	    00h successful
		BX = current number of allocated EMS handles
	    84h function not available
SeeAlso: AX=5BF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675C" name="675C"><b>675C</b></a> - INT 67 - LIM EMS 4.0 - PREPARE EXPANDED MEMORY HARDWARE FOR WARM BOOT<br />
<pre>
INT 67 - LIM EMS 4.0 - PREPARE EXPANDED MEMORY HARDWARE FOR WARM BOOT
	AH = 5Ch
Return: AH = status (see #03663)
Note:	when MS-DOS v6.xx EMM386 is loaded and the keyboard driver supports
	  INT 15/AH=4Fh (keyboard intercept) calls, the system may hang
	  instead of booting if this function is called just prior to a jump
	  to F000h:FFF0h

(Table 03663)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 84h	undefined function requested

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675D" name="675D"><b>675D</b></a> - INT 67 - LIM EMS 4.0 - ENABLE/DISABLE OS FUNCTION SET FUNCTIONS<br />
<pre>
INT 67 - LIM EMS 4.0 - ENABLE/DISABLE OS FUNCTION SET FUNCTIONS
	AH = 5Dh
	AL = subfunction
	    00h enable OS Function Set
	    01h disable OS Function Set
	    02h return access key (resets memory manager, returns access key at
		next invocation)
	BX,CX = access key returned by first invocation
Return: BX,CX = access key, returned only on first invocation of function
	AH = status (see also AH=5Ch)
	    8Fh undefined subfunction
	    A4h operating system denied access

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675D03" name="675D03"><b>675D03</b></a> - INT 67 u - Nanosoft MD386 - INTERNAL INITIALIZATION<br />
<pre>
INT 67 u - Nanosoft MD386 - INTERNAL INITIALIZATION
	AX = 5D03h
	???
Return: ???
Program: MD386 is a subset EMS memory manager by Nanosoft specifically
	  designed for use with the MultiDOS Plus multitasker
SeeAlso: AX=5D04h,AX=5E00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675D04" name="675D04"><b>675D04</b></a> - INT 67 - Nanosoft MD386 - GET ALTERNATE MAP STRUCTURE<br />
<pre>
INT 67 - Nanosoft MD386 - GET ALTERNATE MAP STRUCTURE
	AX = 5D04h
	BX = alternate register set number
	ES:DI -&gt; 1024-byte buffer for map structure
Return: AH = status (see #03648)
	buffer filled if AH=00h
Note:	used for debugging purposes
SeeAlso: AX=5D05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675D05" name="675D05"><b>675D05</b></a> - INT 67 - Nanosoft MD386 - GET INTERNAL HANDLE TABLE<br />
<pre>
INT 67 - Nanosoft MD386 - GET INTERNAL HANDLE TABLE
	AX = 5D05h
	BX = handle number
	ES:DI -&gt; 1024-byte buffer for handle table
Return: AH = status (see #03648)
	buffer filled if AH=00h
Note:	used for debugging purposes
SeeAlso: AX=5D04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DE0" name="675DE0"><b>675DE0</b></a> - INT 67 - RM386 - DISABLE RM386<br />
<pre>
INT 67 - RM386 - DISABLE RM386
	AX = 5DE0h
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE1h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DE1" name="675DE1"><b>675DE1</b></a> - INT 67 - RM386 - ENABLE RM386<br />
<pre>
INT 67 - RM386 - ENABLE RM386
	AX = 5DE1h
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DE2" name="675DE2"><b>675DE2</b></a> - INT 67 - RM386 - GET PAGE TABLE<br />
<pre>
INT 67 - RM386 - GET PAGE TABLE
	AX = 5DE2h
	ES:DI -&gt; 1088-byte buffer for page table
Return: ES:DI buffer filled
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE3h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DE3" name="675DE3"><b>675DE3</b></a> - INT 67 - RM386 - SET PAGE TABLE<br />
<pre>
INT 67 - RM386 - SET PAGE TABLE
	AX = 5DE3h
	ES:DI -&gt; 1088-byte buffer containing page table
Notes:	only the access bits of the page table are used, the remainder is
	  ignored
	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE2h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DE4" name="675DE4"><b>675DE4</b></a> - INT 67 - RM386 - SET WRITE-PROTECTION FOR PAGE IN FIRST MEGABYTE<br />
<pre>
INT 67 - RM386 - SET WRITE-PROTECTION FOR PAGE IN FIRST MEGABYTE
	AX = 5DE4h
	BL = page number
	BH = access (00h read-only, 01h read-write)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DE5" name="675DE5"><b>675DE5</b></a> - INT 67 - RM386 - MAP PHYSICAL PAGE TO PHYSICAL SEGMENT<br />
<pre>
INT 67 - RM386 - MAP PHYSICAL PAGE TO PHYSICAL SEGMENT
	AX = 5DE5h
	EBX = physical page number
	DX = page number in first megabyte to be remapped (linear-addr SHR 12)
Return: AH = status
	    00h successful
	    8Bh invalid destination page (not in first megabyte)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE6h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DE6" name="675DE6"><b>675DE6</b></a> - INT 67 - RM386 - MAP LOGICAL 4K PAGE TO PHYSICAL SEGMENT<br />
<pre>
INT 67 - RM386 - MAP LOGICAL 4K PAGE TO PHYSICAL SEGMENT
	AX = 5DE6h
	BX = logical page number in 4K pages from beginning of memory for EMS
	      handle
	CX = segment in first megabyte to be remapped
	DX = previously-allocated EMS handle
Return: AH = status
	    00h successful
	    83h invalid handle
	    8Ah invalid logical page (out of handle's range)
	    8Bh invalid destination page (not in first megabyte)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE5h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DE7" name="675DE7"><b>675DE7</b></a> - INT 67 - RM386 - SET PAGE TABLE BITS FOR RANGE OF PAGES<br />
<pre>
INT 67 - RM386 - SET PAGE TABLE BITS FOR RANGE OF PAGES
	AX = 5DE7h
	BL = page table bits to be set (bits 2-0 = U/S, R/W, P)
	CX = number of pages to set
	DX = first page number to set (in first megabyte)
Return: AH = status
	    00h successful
	    8Bh invalid destination page (not in first megabyte)
	    A5h invalid page bits
	    A6h invalid page count (overflows first megabyte)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DE8" name="675DE8"><b>675DE8</b></a> - INT 67 - RM386 - GET PARTIAL PAGE TABLE<br />
<pre>
INT 67 - RM386 - GET PARTIAL PAGE TABLE
	AX = 5DE8h
	BX = starting page number in first megabyte+HMA (0000h-010Fh)
	CX = number of page table entries to get
	ES:DI -&gt; buffer for DWORD page table entries
Return: AH = status (00h successful, 8Bh invalid page)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE9h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DE9" name="675DE9"><b>675DE9</b></a> - INT 67 - RM386 - SET PARTIAL PAGE TABLE<br />
<pre>
INT 67 - RM386 - SET PARTIAL PAGE TABLE
	AX = 5DE9h
	BX = starting page number in first megabyte+HMA (0000h-010Fh)
	CX = number of page table entries to get
	DS:SI -&gt; buffer of DWORD page table entries
Return: AH = status (00h successful, 8Bh invalid destination page)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE8h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DEA" name="675DEA"><b>675DEA</b></a> - INT 67 - RM386 - V86-MODE I/O PORT TRAPPING CONTROL<br />
<pre>
INT 67 - RM386 - V86-MODE I/O PORT TRAPPING CONTROL
	AX = 5DEAh
	BX = function
	    00h globally disable V86-mode trapping
	    01h globally enable V86-mode trapping
		CL = interrupt to use for trapping
	    02h get I/O trapping state
Return: AH = status
	    00h successful
		BX = current trapping state (function 02h)
		    0000h disabled, 0001h enabled
		CX = interrupt used as trap interrupt (functions 00h and 02h)
Notes:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
	when I/O trapping is enabled and I/O port access occurs, RM386
	  simulates an INT instruction for the specified interrupt; the
	  interrupt handler is responsible for decoding the trapped instruction
	  and performing the appropriate action.  INT 2C/AX=002Dh provides a
	  similar but more-easily used interface.
SeeAlso: AX=5DEBh,AH=EFh"RM386",INT 2C/AX=002Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DEB" name="675DEB"><b>675DEB</b></a> - INT 67 - RM386 - V86-MODE I/O TRAPPING PORT CONTROL<br />
<pre>
INT 67 - RM386 - V86-MODE I/O TRAPPING PORT CONTROL
	AX = 5DEBh
	BX = function
	    00h disable V86-mode trapping for specified port
	    01h enable V86-mode trapping for specified port
	    02h get V86-mode trapping state for specified port
	DX = port for which to enable/disable/query trapping
Return: AH = status
	    00h successful
		BX = current trapping state (00h off, 01h on) (function 02)
	    A7h invalid port ID
	    A8h reserved port--cannot trap/untrap (DMA/INT/KBD controllers)
Notes:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DEAh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DFD" name="675DFD"><b>675DFD</b></a> - INT 67 U - RM386 v6.00 - ???<br />
<pre>
INT 67 U - RM386 v6.00 - ???
	AX = 5DFDh
	???
Return: ???
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DFEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DFE" name="675DFE"><b>675DFE</b></a> - INT 67 U - RM386 v6.00 - ???<br />
<pre>
INT 67 U - RM386 v6.00 - ???
	AX = 5DFEh
	???
Return: ???
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DFDh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675DFF" name="675DFF"><b>675DFF</b></a> - INT 67 U - RM386 v6.00 - ???<br />
<pre>
INT 67 U - RM386 v6.00 - ???
	AX = 5DFFh
	???
Return: ???
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DFDh,AX=5DFEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675E00" name="675E00"><b>675E00</b></a> - INT 67 - Nanosoft MD386 - SET HARDWARE BREAKPOINT<br />
<pre>
INT 67 - Nanosoft MD386 - SET HARDWARE BREAKPOINT
	AX = 5E00h
	DH = breakpoint number (0-3)
	DL = breakpoint attributes (used to set DR7)
	CX:BX = linear address of breakpoint
SeeAlso: AX=5D03h,AX=5E01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675E01" name="675E01"><b>675E01</b></a> - INT 67 - Nanosoft MD386 - GET HARDWARE DEBUG REGISTER<br />
<pre>
INT 67 - Nanosoft MD386 - GET HARDWARE DEBUG REGISTER
	AX = 5E01h
	BL = register number (0-3,7)
Return: CX:BX = value of specified DRx register
SeeAlso: AX=5E00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675E02" name="675E02"><b>675E02</b></a> - INT 67 - Nanosoft MD386 - SET DEBUG EXCEPTION HANDLER<br />
<pre>
INT 67 - Nanosoft MD386 - SET DEBUG EXCEPTION HANDLER
	AX = 5E02h
	CX:BX -&gt; exception handler
Note:	the specified exception handler is called with a simulated interrupt
	  whenever a debug exception occurs which was caused by a hardware
	  breakpoint set with the debug registers
SeeAlso: AX=5E04h,AX=5E05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675E03" name="675E03"><b>675E03</b></a> - INT 67 - Nanosoft MD386 - ENABLE/DISABLE MEMORY WRITE PROTECTION<br />
<pre>
INT 67 - Nanosoft MD386 - ENABLE/DISABLE MEMORY WRITE PROTECTION
	AX = 5E03h
	BL = register map set number
	BH = new state (00h read-only, else read-write)
	CX = linear page number (linear address SHR 12)
Note:	setting write protection in map set 0 will cause the setting to become
	  the default for newly-allocated map sets

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675E04" name="675E04"><b>675E04</b></a> - INT 67 - Nanosoft MD386 - GET DEBUG EXCEPTION<br />
<pre>
INT 67 - Nanosoft MD386 - GET DEBUG EXCEPTION
	AX = 5E04h
Return: BL = debug exception (low byte of DR6 register)
SeeAlso: AX=5E02h,AX=5E05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#675E05" name="675E05"><b>675E05</b></a> - INT 67 - Nanosoft MD386 - IGNORE NEXT DEBUG EXCEPTION<br />
<pre>
INT 67 - Nanosoft MD386 - IGNORE NEXT DEBUG EXCEPTION
	AX = 5E05h
Note:	may be required when using AX=5E02h for handling instruction
	  breakpoints
SeeAlso: AX=5E02h,AX=5E04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6760" name="6760"><b>6760</b></a> - INT 67 - EEMS - GET PHYSICAL WINDOW ARRAY<br />
<pre>
INT 67 - EEMS - GET PHYSICAL WINDOW ARRAY
	AH = 60h
	ES:DI -&gt; buffer
Return: AH = status (see also AH=40h)
	AL = number of entries
	buffer at ES:DI filled

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6761" name="6761"><b>6761</b></a> - INT 67 - EEMS - GENERIC ACCELERATOR CARD SUPPORT<br />
<pre>
INT 67 - EEMS - GENERIC ACCELERATOR CARD SUPPORT
	AH = 61h
	???
Return: ???
Note:	can be used by accelerator card manufacturer to flush RAM cache,
	  ensuring that the cache accurately reflects what the processor would
	  see without the cache.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#676100" name="676100"><b>676100</b></a> - INT 67 - EEMS - STB GENERIC ACCELERATOR CARD SUPPORT - INSTALLATION CHECK???<br />
<pre>
INT 67 - EEMS - STB GENERIC ACCELERATOR CARD SUPPORT - INSTALLATION CHECK???
	AX = 6100h
Return: AH = status (00h if installed???)
Note:	STB's RAPIDMAP.SYS EMS driver calls this function and AX=6101h if
	  the signature "GACXXX" is found at offset 0Ah in the INT 67 handler's
	  segment (i.e. a device driver named GACXXX?? has hooked INT 67)
SeeAlso: AX=6101h,INT 02/SI=0714h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#676101" name="676101"><b>676101</b></a> - INT 67 - EEMS - STB GENERIC ACCELERATOR CARD SUPPORT - GET ??? ENTRY POINT<br />
<pre>
INT 67 - EEMS - STB GENERIC ACCELERATOR CARD SUPPORT - GET ??? ENTRY POINT
	AX = 6101h
Return: AH = status
	---if AH=00h---
	ES:BX -&gt; ??? entry point
SeeAlso: AX=6100h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6768" name="6768"><b>6768</b></a> - INT 67 - EEMS - GET ADDRESSES OF ALL PAGE FRAMES IN SYSTEM<br />
<pre>
INT 67 - EEMS - GET ADDRESSES OF ALL PAGE FRAMES IN SYSTEM
	AH = 68h
	ES:DI -&gt; buffer
Return: AH = status (see also AH=40h)
	AL = number of entries
	buffer at ES:DI filled
Note:	equivalent to LIM 4.0 function 58h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#6769" name="6769"><b>6769</b></a> - INT 67 - EEMS - MAP PAGE INTO FRAME<br />
<pre>
INT 67 - EEMS - MAP PAGE INTO FRAME
	AH = 69h
	AL = frame number
	BX = page number
	DX = handle
Return: AH = status (see also AH=40h)
Note:	similar to EMS function 44h
SeeAlso: AH=44h,AH=50h,AH=6Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#676A" name="676A"><b>676A</b></a> - INT 67 - EEMS - PAGE MAPPING<br />
<pre>
INT 67 - EEMS - PAGE MAPPING
	AH = 6Ah
	AL = subfunction
	    00h save partial page map
		CH = first page frame
		CL = number of frames
		ES:DI -&gt; buffer which is to be filled
	    01h restore partial page map
		CH = first page frame
		CL = number of frames
		DI:SI -&gt; previously saved page map
	    02h save and restore partial page map
		CH = first page frame
		CL = number of frames
		ES:DI = buffer for current page map
		DI:SI = new page map
	    03h get size of save array
		CH = first page frame
		CL = number of frames
		Return: AL = size of array in bytes
	    04h switch to standard map register setting
	    05h switch to alternate map register setting
	    06h deallocate pages mapped to frames in conventional memory
		CH = first page frame
		CL = number of frames
Return: AH = status (see #03648)
Note:	similar to EMS function 4Eh, except that a subrange of pages can be
	  specified
SeeAlso: AH=69h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#676B" name="676B"><b>676B</b></a> - INT 67 - DESQview 2.42-2.53 - BUG<br />
<pre>
INT 67 - DESQview 2.42-2.53 - BUG
	AH = 6Bh
Note:	the EMM.DVR portion of DESQview branches to a random location on this
	  function due to a fencepost error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DD" name="67DD"><b>67DD</b></a> - INT 67 - Quadtel QMAPS - API<br />
<pre>
INT 67 - Quadtel QMAPS - API
	AH = DDh
	AL = function
	???
Return: ???
Notes:	details are not yet available
	Hewlett-Packard's HPMM.SYS is a licensed version of QMAPS, and thus
	  supports this API
SeeAlso: AH=3Fh,AX=FFA5h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE00" name="67DE00"><b>67DE00</b></a> - INT 67 - Virtual Control Program Interface - INSTALLATION CHECK<br />
<pre>
INT 67 - Virtual Control Program Interface - INSTALLATION CHECK
	AX = DE00h
Return: AH = status
	    00h VCPI is present
		BH = major version number
		BL = minor version number
	    nonzero  VCPI not present
BUG:	MS Windows 3.00 is reported to "object violently" to this call.
SeeAlso: INT 2F/AX=1687h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE01" name="67DE01"><b>67DE01</b></a> - INT 67 - Virtual Control Program Interface - GET PROTECTED MODE INTERFACE<br />
<pre>
INT 67 - Virtual Control Program Interface - GET PROTECTED MODE INTERFACE
	AX = DE01h
	ES:DI -&gt; 4K page table buffer
	DS:SI -&gt; three descriptor table entries in GDT
		first becomes code segment descriptor, other two for use by
		  main control program
Return: AH = 00h successful
	    DI -&gt; first unused page table entry in buffer
	    EBX -&gt; protected mode entry point in code segment (see #03664)
	AH = nonzero  failed
Note:	protected mode entry point may be called with AX=DE00h-DE05h and
	  AX=DE0Ch (in each case, all other registers as appropriate for
	  the function)
SeeAlso: INT 2F/AX=1687h,INT 67/AH=3Fh

(Table 03664)
Call QEMM v6.03 protected mode entry point additionally with:
	AX = DF00h ???
		???
		Return: ???
	AX = DF01h ???
		???
		Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE02" name="67DE02"><b>67DE02</b></a> - INT 67 - Virtual Control Program Interface - GET MAX PHYSICAL MEMORY ADDRESS<br />
<pre>
INT 67 - Virtual Control Program Interface - GET MAX PHYSICAL MEMORY ADDRESS
	AX = DE02h
Return: AH = 00h  successful
	    EDX = physical address of highest 4K memory page
	AH nonzero: failed
SeeAlso: AH=3Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE03" name="67DE03"><b>67DE03</b></a> - INT 67 - Virtual Control Program Interface - GET NUMBER OF FREE 4K PAGES<br />
<pre>
INT 67 - Virtual Control Program Interface - GET NUMBER OF FREE 4K PAGES
	AX = DE03h
Return: AH = 00h  successful
	    EDX = number of free 4K pages
	AH nonzero: failed
Notes:	returns total number of pages available to ALL tasks in system
	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#03664)
SeeAlso: AX=DE04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE04" name="67DE04"><b>67DE04</b></a> - INT 67 - Virtual Control Program Interface - ALLOCATE A 4K PAGE<br />
<pre>
INT 67 - Virtual Control Program Interface - ALLOCATE A 4K PAGE
	AX = DE04h
Return: AH = 00h successful
	    EDX = physical address of allocated page
	AH nonzero: failed
Notes:	the client program is responsible for freeing all memory allocated
	  with this call before terminating
	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#03664)
SeeAlso: AH=3Fh,AX=DE03h,AX=DE05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE05" name="67DE05"><b>67DE05</b></a> - INT 67 - Virtual Control Program Interface - FREE 4K PAGE<br />
<pre>
INT 67 - Virtual Control Program Interface - FREE 4K PAGE
	AX = DE05h
	EDX = physical address of 4K page
Return: AH = status
	    00h successful
	    nonzero failed
Note:	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#03664)
SeeAlso: AH=3Fh,AX=DE04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE06" name="67DE06"><b>67DE06</b></a> - INT 67 - Virtual Control Program Interface - GET PHYS ADDR OF PAGE IN FIRST MB<br />
<pre>
INT 67 - Virtual Control Program Interface - GET PHYS ADDR OF PAGE IN FIRST MB
	AX = DE06h
	CX = page number (linear address shifted right 12 bits)
Return: AH = status
	    00h successful
		EDX = physical address of page
	    nonzero invalid page number (AH = 8Bh recommended)
SeeAlso: AX=5BE0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE07" name="67DE07"><b>67DE07</b></a> - INT 67 - Virtual Control Program Interface - READ CR0<br />
<pre>
INT 67 - Virtual Control Program Interface - READ CR0
	AX = DE07h
Return: AH = 00h
	EBX = value of Control Register 0
SeeAlso: AH=3Fh,AX=DE07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE08" name="67DE08"><b>67DE08</b></a> - INT 67 - Virtual Control Program Interface - READ DEBUG REGISTERS<br />
<pre>
INT 67 - Virtual Control Program Interface - READ DEBUG REGISTERS
	AX = DE08h
	ES:DI -&gt; array of 8 DWORDs
Return: AH = 00h
	buffer filled with DR0 first, DR7 last, DR4 and DR5 unused
SeeAlso: AH=3Fh,AX=DE09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE09" name="67DE09"><b>67DE09</b></a> - INT 67 - Virtual Control Program Interface - SET DEBUG REGISTERS<br />
<pre>
INT 67 - Virtual Control Program Interface - SET DEBUG REGISTERS
	AX = DE09h
	ES:DI -&gt; array of 8 DWORDs holding new values of debug registers
Return: AH = 00h
Note:	values for DR4 and DR5 ignored
SeeAlso: AH=3Fh,AX=DE08h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE0A" name="67DE0A"><b>67DE0A</b></a> - INT 67 - Virtual Control Program Interface - GET 8259 INTERRUPT VECTOR MAPPINGS<br />
<pre>
INT 67 - Virtual Control Program Interface - GET 8259 INTERRUPT VECTOR MAPPINGS
	AX = DE0Ah
Return: AH = 00h successful
	    BX = first vector used by master 8259 (IRQ0)
	    CX = first vector used by slave 8259 (IRQ8)
	AH nonzero: failed
Note:	CX is undefined in systems without a slave 8259
SeeAlso: AX=DE0Bh,INT 21/AX=250Ch,INT 31/AX=0400h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE0B" name="67DE0B"><b>67DE0B</b></a> - INT 67 - Virtual Control Program Interface - SET 8259 INTERRUPT VECTOR MAPPINGS<br />
<pre>
INT 67 - Virtual Control Program Interface - SET 8259 INTERRUPT VECTOR MAPPINGS
	AX = DE0Bh
	BX = first vector used by master 8259
	CX = first vector used by slave 8259
	interrupts disabled
Return: AH = 00h successful
	AH nonzero: failed
Notes:	This call merely informs the server that the client has changed the
	  interrupt mappings.  The client may not change the mappings if they
	  have already been changed by the server or another client, and is
	  responsible for restoring the original mappings before terminating.
SeeAlso: AX=DE0Ah,INT 2C/AX=002Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE0C" name="67DE0C"><b>67DE0C</b></a> - INT 67 - Virtual Control Program Interface - SWITCH TO PROTECTED MODE<br />
<pre>
INT 67 - Virtual Control Program Interface - SWITCH TO PROTECTED MODE
	AX = DE0Ch
	ESI = linear address in first megabyte of values for system
	      registers (see #03665)
	interrupts disabled
Return: interrupts disabled
	GDTR, IDTR, LDTR, TR loaded
	SS:ESP must have at least 16 bytes space, and the entry point is
	      required to set up a new stack before enabling interrupts
	EAX, ESI, DS, ES, FS, GS destroyed
Note:	in protected mode, calling the protected-mode VCPI entry point with
	  AX = DE0Ch
	  DS = segment selector mapping entire linear address space obtained
		  via AX=DE01h
	  SS:ESP in first megabyte of linear memory
	  STACK:QWORD  return address from FAR call to 32-bit segment
		DWORD  EIP
		DWORD  CS
		DWORD  reserved for EFLAGS
		DWORD  ESP
		DWORD  SS
		DWORD  ES
		DWORD  DS
		DWORD  FS
		DWORD  GS
	  and interrupts disabled, will switch to virtual86 mode with
	    interrupts disabled, all segment registers loaded, and EAX
	    destroyed.
SeeAlso: AH=3Fh,INT 15/AH=89h,INT D4/AH=10h

Format of system register values for switch to protected mode:
Offset	Size	Description	(Table 03665)
 00h	DWORD	value for CR3
 04h	DWORD	linear address in first megabyte of value for GDTR
 08h	DWORD	linear address in first megabyte of value for IDTR
 0Ch	WORD	value for LDTR
 0Eh	WORD	value for TR
 10h	PWORD	CS:EIP of protected mode entry-point

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE0F" name="67DE0F"><b>67DE0F</b></a> - INT 67 - Netroom3 - ???<br />
<pre>
INT 67 - Netroom3 - ???
	AX = DE0Fh
	???
Return: ???
Note:	called by Netroom's DPMI.EXE

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DEE1BX0C55" name="67DEE1BX0C55"><b>67DEE1BX0C55</b></a> - INT 67 - "SB Live!" Sound Blaster 16 Emulation Driver - INSTALLATION CHECK<br />
<pre>
INT 67 - "SB Live!" Sound Blaster 16 Emulation Driver - INSTALLATION CHECK
	AX = DEE1h
	BX = 0C55h
Return: BL = AAh if installed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67EF" name="67EF"><b>67EF</b></a> - INT 67 - RM386 v6.00+ - EXECUTE XMS FUNCTION<br />
<pre>
INT 67 - RM386 v6.00+ - EXECUTE XMS FUNCTION
	AH = EFh
	AL = function (00h-12h,80h-8Fh)
	other register as appropriate for XMS function
Return: varies by function (see INT 2F/AX=4310h"XMS")
Note:	these functions appear to be equivalent to the XMS functions with the
	  same numbers
SeeAlso: AX=5DFFh"RM386",INT 2F/AX=4310h"XMS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67FFA5" name="67FFA5"><b>67FFA5</b></a> - INT 67 - Microsoft EMM386.EXE v4.20+ - INSTALLATION CHECK<br />
<pre>
INT 67 - Microsoft EMM386.EXE v4.20+ - INSTALLATION CHECK
	AX = FFA5h
Return: AX = 845Ah/84A5h if loaded
	    BX:CX -&gt; API entry point (see #03666)
Notes:	this call is available even if EMM386 is not providing EMS
	the returned AX is 845Ah inside of MSWindows, 84A5h under bare DOS
	if no other program has hooked INT 67, an alternate installation
	  check is to test for the string
	  "MICROSOFT EXPANDED MEMORY MANAGER 386" at offset 14h in the INT 67
	  handler's segment; the word immediately preceding this string
	  contains the offset of the API entry point
SeeAlso: AH=3Fh,AX=FFA5h/BX=4345h,INT 21/AX=4402h"EMM386.EXE"

(Table 03666)
Call EMM386.EXE API entry point with:
	AH = 00h get memory manager's status
	    Return: AH = status
			bit 0: not active (OFF)
			bit 1: in "Auto" mode
	AH = 01h set memory manager's state
	    AL = new state (00h ON, 01h OFF, 02h AUTO)
	AH = 02h Weitek coprocessor support
	    AL = subfunction
		00h get Weitek support state
		    Return: AL = status
				bit 0: Weitek coprocessor is present
				bit 1: Weitek support is enabled
		01h turn on Weitek support
		02h turn off Weitek support
     --- v4.20-4.41 only ---
	AH = 03h Windows support???
	    AL = subfunction (00h, 01h)
	AH = 04h print copyright notice to standard output
		 (using INT 21/AH=09h)
	AH = 05h print available report
		 (the one shown when running EMM386 from the DOS prompt)
SeeAlso: #01513 at INT 21/AX=4402h/SF=02h,#02617 at INT 2F/AX=12FFh/BX=0106h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67FFA5BX4345" name="67FFA5BX4345"><b>67FFA5BX4345</b></a> - INT 67 U - Compaq CEMM v5.10+ - PRIVATE API<br />
<pre>
INT 67 U - Compaq CEMM v5.10+ - PRIVATE API
	AX = FFA5h
	BX = 4345h ("CE")
	DX = subfunction
	    0000h unshadow video ROM???
	    0001h shadow video ROM???
	    0002h map pages
		CX = number of pages (00h=one)
		ESI = linear address of first page to map into address space
		EDI = linear starting address at which pages are to be visible
	    0003h get ???
		Return: DX = ??? (0-2)
	    0004h BUG: crashes system due to fencepost error
Return: AH = 84h
	AL = status (84h = error, FFh = success)
Note:	if BX &lt;&gt; 4345h or DX &gt; 0004h on entry, CEMM behaves identically to
	  Microsoft's EMM386 (see AX=FFA5h"EMM386")
SeeAlso: AX=FFA5h"EMM386",#01513 at INT 21/AX=4402h/SF=02h,#03666

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<div class="bottom-nav"><b><a href="./index.html">Home</a></b> <b>Interrupt Index</b>: <a href="./INTERRUP.CAT.HTML">by Category</a> <a href="./INTERRUP.NUM.HTML">by Number</a> <b>TOC</b>: <a href="#__toc">by Order</a> <b><a href="#top">Top</a></b></div>

</body>
</html>
