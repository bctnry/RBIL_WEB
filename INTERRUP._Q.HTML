
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INTERRUP._Q</title>
    <style>
        body {
            font-variant-ligatures: none;
        }
        pre {
            font-family: 'Courier New', Courier, monospace;
        }
        a {
            color: black;
        }
        .bottom-nav {
            position: sticky;
            bottom: 0px;
            background-color: white;
            text-align: right;
        }
        h3, h4 {
            margin: 0;
        }
</style>
</head>
<body>

<b>Interrupt List Release 61 Last change 16jul00</b><br />
<b>Copyright (c) 1989-1999,2000 Ralf Brown</b><br />
<pre>
Index for category Q - DESQview/TopView and Quarterdeck programs,
</pre>

<p>
<a name="__toc"><b>Table of Contents by Order</b></a><br />

<a href="#1080--DX4456"><b>1080--DX4456</b> - INT 10 U - VIDEO - DESQview 2.0x only - internal - SET ??? HANDLER</a><br />
<a href="#1081--DX4456"><b>1081--DX4456</b> - INT 10 U - VIDEO - DESQview 2.0x only - internal - GET ???</a><br />
<a href="#1082--DX4456"><b>1082--DX4456</b> - INT 10 U - VIDEO - DESQview 2.0x only - internal - GET CURRENT WINDOW INFO</a><br />
<a href="#151000"><b>151000</b> - INT 15 - TopView - "PAUSE" - GIVE UP CPU TIME</a><br />
<a href="#151001"><b>151001</b> - INT 15 - TopView - "GETMEM" - ALLOCATE "SYSTEM" MEMORY</a><br />
<a href="#151002"><b>151002</b> - INT 15 - TopView - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY</a><br />
<a href="#151003"><b>151003</b> - INT 15 - TopView - "PRINTC" - DISPLAY CHARACTER/ATTRIBUTE ON SCREEN</a><br />
<a href="#1510_1"><b>1510</b> - INT 15 - TopView - UNIMPLEMENTED IN DV 2.x</a><br />
<a href="#151013"><b>151013</b> - INT 15 - TopView - "GETBIT" - DEFINE A 2ND-LEVEL INTERRUPT HANDLER</a><br />
<a href="#151014"><b>151014</b> - INT 15 - TopView - "FREEBIT" - UNDEFINE A 2ND-LEVEL INTERRUPT HANDLER</a><br />
<a href="#151015"><b>151015</b> - INT 15 - TopView - "SETBIT" - SCHEDULE ONE OR MORE 2ND-LEVEL INTERRUPTS</a><br />
<a href="#151016"><b>151016</b> - INT 15 - TopView - "ISOBJ" - VERIFY OBJECT HANDLE</a><br />
<a href="#151017"><b>151017</b> - INT 15 - TopView - UNIMPLEMENTED IN DV 2.x</a><br />
<a href="#151018"><b>151018</b> - INT 15 - TopView - "LOCATE" - FIND WINDOW AT A GIVEN SCREEN LOCATION</a><br />
<a href="#151019"><b>151019</b> - INT 15 - TopView - "SOUND" - MAKE TONE</a><br />
<a href="#15101A"><b>15101A</b> - INT 15 - TopView - "OSTACK" - SWITCH TO TASK'S INTERNAL STACK</a><br />
<a href="#15101B"><b>15101B</b> - INT 15 - TopView - "BEGINC" - BEGIN CRITICAL REGION</a><br />
<a href="#15101C"><b>15101C</b> - INT 15 - TopView - "ENDC" - END CRITICAL REGION</a><br />
<a href="#15101D"><b>15101D</b> - INT 15 - TopView - "STOP" - STOP TASK</a><br />
<a href="#15101E"><b>15101E</b> - INT 15 - TopView - "START" - START TASK</a><br />
<a href="#15101F"><b>15101F</b> - INT 15 - TopView - "DISPEROR" - POP-UP ERROR WINDOW</a><br />
<a href="#151020"><b>151020</b> - INT 15 - TopView - UNIMPLEMENTED IN DV v2.00+</a><br />
<a href="#151021"><b>151021</b> - INT 15 - TopView - "PGMINT" - INTERRUPT ANOTHER TASK</a><br />
<a href="#151022BX0000"><b>151022BX0000</b> - INT 15 - TopView - "GETVER" - GET VERSION</a><br />
<a href="#151023"><b>151023</b> - INT 15 - TopView - "POSWIN" - POSITION WINDOW</a><br />
<a href="#151024"><b>151024</b> - INT 15 - TopView - "GETBUF" - GET VIRTUAL SCREEN INFO</a><br />
<a href="#151025"><b>151025</b> - INT 15 - TopView - "USTACK" - SWITCH BACK TO USER'S STACK</a><br />
<a href="#1510_2"><b>1510</b> - INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.x</a><br />
<a href="#15102B"><b>15102B</b> - INT 15 - DESQview v2.00+ (TopView???) - "POSTTASK" - AWAKEN TASK</a><br />
<a href="#15102C"><b>15102C</b> - INT 15 - DESQview v2.00+ - "NEWPROC" - START NEW APPLICATION IN NEW PROCESS</a><br />
<a href="#15102D"><b>15102D</b> - INT 15 - DESQview v2.00+ - "KMOUSE" - KEYBOARD MOUSE CONTROL</a><br />
<a href="#15102E"><b>15102E</b> - INT 15 - DESQview v2.40+ - ALLOCATE SYSTEM MEMORY</a><br />
<a href="#1511"><b>1511</b> - INT 15 - TopView commands</a><br />
<a href="#151117BX0000"><b>151117BX0000</b> - INT 15 - DESQview v2.20+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT</a><br />
<a href="#1512--BH00"><b>1512--BH00</b> - INT 15 - TopView - SEND MESSAGE - "HANDLE" - RETURN OBJECT HANDLE</a><br />
<a href="#1512--BH01"><b>1512--BH01</b> - INT 15 - TopView - SEND MESSAGE - "NEW" - CREATE NEW OBJECT</a><br />
<a href="#1512--BH02"><b>1512--BH02</b> - INT 15 - TopView - SEND MESSAGE - "FREE" - FREE AN OBJECT</a><br />
<a href="#1512--BH03"><b>1512--BH03</b> - INT 15 - TopView - SEND MESSAGE - "ADDR" - GET HANDLE OF MESSAGE SENDER</a><br />
<a href="#1512--BH03_0"><b>1512--BH03</b> - INT 15 - DESQview v2.26+ - "CONNECT" - CONNECT TWO WINDOWS</a><br />
<a href="#1512--BX0300"><b>1512--BX0300</b> - INT 15 - TopView - SEND MESSAGE - "DIR" - GET PANEL FILE DIRECTORY</a><br />
<a href="#1512--BH04"><b>1512--BH04</b> - INT 15 - TopView - SEND MESSAGE - "READ" - READ NEXT LOGICAL LINE OF WINDOW</a><br />
<a href="#1512--BH04_0"><b>1512--BH04</b> - INT 15 - TopView - SEND MESSAGE - "READ" - GET NEXT RECORD FROM OBJECT</a><br />
<a href="#1512--BX0400"><b>1512--BX0400</b> - INT 15 - TopView - SEND MESSAGE - "READ" - WAIT FOR TIMER TO EXPIRE</a><br />
<a href="#1512--BX0400_0"><b>1512--BX0400</b> - INT 15 - TopView - SEND MESSAGE - "APPLY" - WRITE PANEL TO WINDOW</a><br />
<a href="#1512--BH05"><b>1512--BH05</b> - INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE TO OBJECT</a><br />
<a href="#1512--BH05_0"><b>1512--BH05</b> - INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE STRING TO WINDOW</a><br />
<a href="#1512--BH06"><b>1512--BH06</b> - INT 15 - DESQview 2.20+ - SEND MESSAGE - "SETPRI" - SET PRIORITY WITHIN OBJECTQ</a><br />
<a href="#1512--BH07"><b>1512--BH07</b> - INT 15 - DESQview 2.20+ - SEND MESSAGE - "GETPRI" - GET PRIORITY WITHIN OBJECTQ</a><br />
<a href="#1512--BH08"><b>1512--BH08</b> - INT 15 - TopView - SEND MESSAGE - "SIZEOF" - GET OBJECT SIZE</a><br />
<a href="#1512--BH09"><b>1512--BH09</b> - INT 15 - TopView - SEND MESSAGE - "LEN" - GET OBJECT LENGTH</a><br />
<a href="#1512--BH0A"><b>1512--BH0A</b> - INT 15 - TopView - SEND MESSAGE - "ADDTO" - WRITE CHARS AND ATTRIBS TO WINDOW</a><br />
<a href="#1512--BH0A_0"><b>1512--BH0A</b> - INT 15 - TopView - SEND MESSAGE - "ADDTO" - SEND MAILBOX MESSAGE/STAT BY VALUE</a><br />
<a href="#1512--BH0A_1"><b>1512--BH0A</b> - INT 15 - TopView - SEND MESSAGE - "ADDTO" - SET OBJECT BITS</a><br />
<a href="#1512--BH0B"><b>1512--BH0B</b> - INT 15 - TopView - SEND MESSAGE - "SUBFROM" - WRITE ATTRIBUTES TO WINDOW</a><br />
<a href="#1512--BH0B_0"><b>1512--BH0B</b> - INT 15 - TopView - SEND MESSAGE - "SUBFROM" - SEND MAILBOX MESSAGE/STAT BY REF</a><br />
<a href="#1512--BH0B_1"><b>1512--BH0B</b> - INT 15 - TopView - SEND MESSAGE - "SUBFROM" - REMOVE OBJECT FROM OBJECTQ</a><br />
<a href="#1512--BH0B_2"><b>1512--BH0B</b> - INT 15 - TopView - SEND MESSAGE - "SUBFROM" - RESET OBJECT BITS</a><br />
<a href="#1512--BH0C"><b>1512--BH0C</b> - INT 15 - TopView - SEND MESSAGE - "OPEN" - OPEN OBJECT</a><br />
<a href="#1512--BH0D"><b>1512--BH0D</b> - INT 15 - TopView - SEND MESSAGE - "CLOSE" - CLOSE OBJECT</a><br />
<a href="#1512--BH0E"><b>1512--BH0E</b> - INT 15 - TopView - SEND MESSAGE - "ERASE" - ERASE OBJECT</a><br />
<a href="#1512--BH0F"><b>1512--BH0F</b> - INT 15 - TopView - SEND MESSAGE - "STATUS" - GET OBJECT STATUS</a><br />
<a href="#1512--BH10"><b>1512--BH10</b> - INT 15 - TopView - SEND MESSAGE - "EOF" - GET OBJECT EOF STATUS</a><br />
<a href="#1512--BH11"><b>1512--BH11</b> - INT 15 - TopView - SEND MESSAGE - "AT" - POSITION OBJECT CURSOR</a><br />
<a href="#1512--BH11_0"><b>1512--BH11</b> - INT 15 - TopView - SEND MESSAGE - "SETNAME" - ASSIGN NAME TO MAILBOX</a><br />
<a href="#1512--BX1100"><b>1512--BX1100</b> - INT 15 - TopView - SEND MESSAGE - "SETSCALE" - SET POINTER SCALE FACTOR</a><br />
<a href="#1512--BH12"><b>1512--BH12</b> - INT 15 - TopView - SEND MESSAGE - "READN" - GET NEXT N OBJECT BYTES</a><br />
<a href="#1512--BH12_0"><b>1512--BH12</b> - INT 15 - DESQview 2.50+ - SEND MESSAGE - "GETNAME" - GET NAME OF MAILBOX</a><br />
<a href="#1512--BX1200"><b>1512--BX1200</b> - INT 15 - TopView - SEND MESSAGE - "GETSCALE" - GET POINTER SCALE FACTOR</a><br />
<a href="#1512--BH13"><b>1512--BH13</b> - INT 15 - TopView - SEND MESSAGE - "REDRAW" - REDRAW WINDOW</a><br />
<a href="#1512--BH13_0"><b>1512--BH13</b> - INT 15 - DESQview 2.50+ - SEND MESSAGE - "READINTO" - GET NEXT MAIL MESSAGE</a><br />
<a href="#1512--BX1300"><b>1512--BX1300</b> - INT 15 - TopView - SEND MESSAGE - "SETICON" - SPECIFY POINTER ICON</a><br />
<a href="#1512--BH14"><b>1512--BH14</b> - INT 15 - TopView - SEND MESSAGE - "SETESC" - SET ESCAPE ROUTINE ADDRESS</a><br />
<a href="#1512--BH14_0"><b>1512--BH14</b> - INT 15 - TopView - SEND MESSAGE - "LOCK" - REQUEST EXCLUSIVE ACCESS TO RESOURCE</a><br />
<a href="#1512--BH15"><b>1512--BH15</b> - INT 15 - DESQview v2.20+ - SEND MESSAGE - "SETFLAGS" - SET OBJECT FLAGS</a><br />
<a href="#1512--BH16"><b>1512--BH16</b> - INT 15 - DESQview v2.20+ - SEND MESSAGE - "GETFLAGS" - GET OBJECT FLAGS</a><br />
<a href="#1512--BH17"><b>1512--BH17</b> - INT 15 - DESQview v2.42-2.52 - BUG</a><br />
<a href="#1512--BH80"><b>1512--BH80</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 00h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH81"><b>1512--BH81</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 01h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH82"><b>1512--BH82</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 02h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH83"><b>1512--BH83</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 03h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH84"><b>1512--BH84</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 04h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH85"><b>1512--BH85</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 05h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH86"><b>1512--BH86</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 06h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH87"><b>1512--BH87</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 07h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH88"><b>1512--BH88</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 08h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH89"><b>1512--BH89</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 09h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH8A"><b>1512--BH8A</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Ah WITH ERROR RECOVERY</a><br />
<a href="#1512--BH8B"><b>1512--BH8B</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Bh WITH ERROR RECOVERY</a><br />
<a href="#1512--BH8C"><b>1512--BH8C</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Ch WITH ERROR RECOVERY</a><br />
<a href="#1512--BH8D"><b>1512--BH8D</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Dh WITH ERROR RECOVERY</a><br />
<a href="#1512--BH8E"><b>1512--BH8E</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Eh WITH ERROR RECOVERY</a><br />
<a href="#1512--BH8F"><b>1512--BH8F</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Fh WITH ERROR RECOVERY</a><br />
<a href="#1512--BH90"><b>1512--BH90</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 10h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH91"><b>1512--BH91</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 11h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH92"><b>1512--BH92</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 12h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH93"><b>1512--BH93</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 13h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH94"><b>1512--BH94</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 14h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH95"><b>1512--BH95</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 15h WITH ERROR RECOVERY</a><br />
<a href="#1512--BH96"><b>1512--BH96</b> - INT 15 - DESQview v2.50+ - SEND MESSAGE 16h WITH ERROR RECOVERY</a><br />
<a href="#15DE00"><b>15DE00</b> - INT 15 - DESQview - GET PROGRAM NAME</a><br />
<a href="#15DE01"><b>15DE01</b> - INT 15 - DESQview - UPDATE "OPEN WINDOW" MENU</a><br />
<a href="#15DE02"><b>15DE02</b> - INT 15 - DESQview 1.x only - SET ??? FLAG FOR CURRENT WINDOW</a><br />
<a href="#15DE03"><b>15DE03</b> - INT 15 - DESQview 1.x only - GET ??? FOR CURRENT WINDOW</a><br />
<a href="#15DE04"><b>15DE04</b> - INT 15 - DESQview - GET AVAILABLE COMMON MEMORY</a><br />
<a href="#15DE05"><b>15DE05</b> - INT 15 - DESQview - GET AVAILABLE CONVENTIONAL MEMORY</a><br />
<a href="#15DE06"><b>15DE06</b> - INT 15 - DESQview - GET AVAILABLE EXPANDED MEMORY</a><br />
<a href="#15DE07"><b>15DE07</b> - INT 15 - DESQview - "APPNUM" - GET CURRENT PROGRAM'S NUMBER</a><br />
<a href="#15DE08"><b>15DE08</b> - INT 15 - DESQview - GET ???</a><br />
<a href="#15DE09"><b>15DE09</b> - INT 15 - DESQview - UNIMPLEMENTED</a><br />
<a href="#15DE0A"><b>15DE0A</b> - INT 15 - DESQview v2.00+ - "DBGPOKE" - DISPLAY CHARACTER ON STATUS LINE</a><br />
<a href="#15DE0B"><b>15DE0B</b> - INT 15 - DESQview v2.00+ - "APILEVEL" - DEFINE MINIMUM API LEVEL REQUIRED</a><br />
<a href="#15DE0C"><b>15DE0C</b> - INT 15 - DESQview v2.00+ - "GETMEM" - ALLOCATE "SYSTEM" MEMORY</a><br />
<a href="#15DE0D"><b>15DE0D</b> - INT 15 - DESQview v2.00+ - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY</a><br />
<a href="#15DE0E"><b>15DE0E</b> - INT 15 - DESQview v2.00+ - "FINDMAIL" - FIND MAILBOX BY NAME</a><br />
<a href="#15DE0F"><b>15DE0F</b> - INT 15 - DESQview v2.00+ - ENABLE DESQview EXTENSIONS</a><br />
<a href="#15DE10"><b>15DE10</b> - INT 15 - DESQview v2.00+ - "PUSHKEY" - PUT KEY INTO KEYBOARD INPUT STREAM</a><br />
<a href="#15DE11BL00"><b>15DE11BL00</b> - INT 15 - DESQview v2.00+ - "JUSTIFY" - EN/DISABLE AUTOM. WINDOW JUSTIFICATION</a><br />
<a href="#15DE12BX0000"><b>15DE12BX0000</b> - INT 15 - DESQview v2.01+ - "CSTYLE" - SET "C"-COMPATIBLE CONTROL CHAR INTERPRET</a><br />
<a href="#15DE13"><b>15DE13</b> - INT 15 - DESQview v2.20+ - "GETCRIT" - GET CRITICAL NESTING COUNT</a><br />
<a href="#15DE14"><b>15DE14</b> - INT 15 - DESQview v2.20+ - GET OBJECT TYPE</a><br />
<a href="#15DE15"><b>15DE15</b> - INT 15 - DESQview v2.20+ - SET ERROR HANDLING</a><br />
<a href="#15DE16"><b>15DE16</b> - INT 15 - DESQview v2.20+ - GET ERROR HANDLING</a><br />
<a href="#15DE17"><b>15DE17</b> - INT 15 - DESQview v2.20-2.25 - reserved</a><br />
<a href="#15DE17_0"><b>15DE17</b> - INT 15 - DESQview v2.26+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT</a><br />
<a href="#15DE18"><b>15DE18</b> - INT 15 - DESQview v2.20+ - internal - ???</a><br />
<a href="#15DE19"><b>15DE19</b> - INT 15 - DESQview v2.23+ - "GETCOMMON" - ALLOCATE "COMMON" MEMORY</a><br />
<a href="#15DE1A"><b>15DE1A</b> - INT 15 - DESQview v2.23+ - "PUTCOMMON" - DEALLOCATE "COMMON" MEMORY</a><br />
<a href="#15DE1B"><b>15DE1B</b> - INT 15 - DESQview v2.23+ internal - DECREMENT CRITICAL NESTING COUNT</a><br />
<a href="#15DE1C"><b>15DE1C</b> - INT 15 - DESQview v2.23+ - "ENTERC" - INCREMENT CRITICAL NESTING COUNT</a><br />
<a href="#15DE1D"><b>15DE1D</b> - INT 15 - DESQview v2.23+ - "PUTKEY" - FAKE USER KEYSTROKES</a><br />
<a href="#15DE1E"><b>15DE1E</b> - INT 15 - DESQview v2.23+ - "SCRNINFO" - GET TRUE VIDEO PARAMETERS</a><br />
<a href="#15DE1F"><b>15DE1F</b> - INT 15 - DESQview v2.23+ - "DOSUSER" - GET HANDLE OF TASK CURRENTLY USING DOS</a><br />
<a href="#15DE20"><b>15DE20</b> - INT 15 - DESQview v2.26+ - "DISPATCHINT" - INTERRUPT ANOTHER TASK</a><br />
<a href="#15DE21"><b>15DE21</b> - INT 15 - DESQview v2.26+ - "ASSERTVIR" - CONTROL 386 SCREEN VIRTUALIZATION</a><br />
<a href="#15DE22"><b>15DE22</b> - INT 15 - DESQview v2.26+ - "PROCESSMEM" - GET TASK MEMORY STATUS</a><br />
<a href="#15DE23"><b>15DE23</b> - INT 15 U - DESQview v2.31+ - ???</a><br />
<a href="#15DE24"><b>15DE24</b> - INT 15 - DESQview v2.40+ - "XNEWPROC" - START NEW APPLICATION</a><br />
<a href="#15DE25"><b>15DE25</b> - INT 15 - DESQview v2.40+ - "GETDVPATH" - GET DESQview DIRECTORY</a><br />
<a href="#15DE26"><b>15DE26</b> - INT 15 - DESQview v2.40+ - "GETFOREGROUND" - GET KEYBOARD FOCUS</a><br />
<a href="#15DE27"><b>15DE27</b> - INT 15 - DESQview v2.50+ - "ADDINSTANCEDATA" - ADD PER-TASK SAVE/RESTORE AREA</a><br />
<a href="#15DE28"><b>15DE28</b> - INT 15 U - DESQview v2.50+ - ???</a><br />
<a href="#15DE29BX0000"><b>15DE29BX0000</b> - INT 15 U - DESQview/X - ???</a><br />
<a href="#15DE29BX0001"><b>15DE29BX0001</b> - INT 15 U - DESQview/X - ???</a><br />
<a href="#15DE29BX0002"><b>15DE29BX0002</b> - INT 15 U - DESQview/X - ???</a><br />
<a href="#15DE29BX0003"><b>15DE29BX0003</b> - INT 15 U - DESQview/X - ???</a><br />
<a href="#15DE29BX0004"><b>15DE29BX0004</b> - INT 15 U - DESQview/X - GET DISPLAY NAME</a><br />
<a href="#15DE29BX0005"><b>15DE29BX0005</b> - INT 15 U - DESQview/X - ???</a><br />
<a href="#15DE2A"><b>15DE2A</b> - INT 15 - DESQview v2.50+ - "DISPATCHINTAFTERDOS" - INTERRUPT ANOTHER TASK</a><br />
<a href="#15DE2B"><b>15DE2B</b> - INT 15 - DESQview v2.50+ - "OBJNEXT" - TRAVERSE OBJECT LIST</a><br />
<a href="#15DE2C"><b>15DE2C</b> - INT 15 - DESQview v2.50+ - "WININFO" - GET WINDOW INFORMATION</a><br />
<a href="#15DE2D"><b>15DE2D</b> - INT 15 U - DESQview v2.50+ - GET/SET SOCKET HANDLER</a><br />
<a href="#15DE2E"><b>15DE2E</b> - INT 15 U - DESQview v2.50+ - SOCKET API</a><br />
<a href="#15DE2F"><b>15DE2F</b> - INT 15 - DESQview v2.50+ - "VIDEONOTIFY" - HAS DIRECT WINDOW BEEN ACTIVE?</a><br />
<a href="#15DE30"><b>15DE30</b> - INT 15 - DESQview v2.50+ - "GETDVXVERSION" - GET DESQview/X VERSION</a><br />
<a href="#15DE31"><b>15DE31</b> - INT 15 - DESQview/X v1.10 - ???</a><br />
<a href="#212B--CX4445"><b>212B--CX4445</b> - INT 21 - DESQview - INSTALLATION CHECK</a><br />
<a href="#214402_8"><b>214402</b> - INT 21 U - Quarterdeck - HOOKROM.SYS - GET HOOKED VECTOR TABLE</a><br />
<a href="#2FD200BX5144"><b>2FD200BX5144</b> - INT 2F - Quarterdeck RPCI - INSTALLATION CHECK</a><br />
<a href="#2FDE00BX4456"><b>2FDE00BX4456</b> - INT 2F - DESQview v2.26+ External Device Interface - INSTALLATION CHECK</a><br />
<a href="#2FDE01"><b>2FDE01</b> - INT 2F - DESQview v2.26+ External Device Interface - DRIVER CUSTOM SUBFUNCTION</a><br />
<a href="#2FDE01BX4450"><b>2FDE01BX4450</b> - INT 2F U - Quarterdeck QDPMI.SYS v1.0 - INSTALLATION CHECK</a><br />
<a href="#2FDE01BXFFFE"><b>2FDE01BXFFFE</b> - INT 2F U - DESQview v2.26+ XDI - DVXMS.DVR - ???</a><br />
<a href="#2FDE02"><b>2FDE02</b> - INT 2F C - DESQview v2.26+ External Dev Interface - DV INITIALIZATION COMPLETE</a><br />
<a href="#2FDE03"><b>2FDE03</b> - INT 2F C - DESQview v2.26+ External Dev Interface - DV TERMINATION</a><br />
<a href="#2FDE04"><b>2FDE04</b> - INT 2F C - DESQview v2.26+ External Dev Interface - ADD PROCESS</a><br />
<a href="#2FDE05"><b>2FDE05</b> - INT 2F C - DESQview v2.26+ External Dev Interface - REMOVE PROCESS</a><br />
<a href="#2FDE06"><b>2FDE06</b> - INT 2F C - DESQview v2.26+ External Dev Interface - CREATE TASK</a><br />
<a href="#2FDE07"><b>2FDE07</b> - INT 2F C - DESQview v2.26+ External Dev Interface - TERMINATE TASK</a><br />
<a href="#2FDE08"><b>2FDE08</b> - INT 2F C - DESQview v2.26+ External Dev Interface - SAVE STATE</a><br />
<a href="#2FDE09"><b>2FDE09</b> - INT 2F C - DESQview v2.26+ External Dev Interface - RESTORE STATE</a><br />
<a href="#2FDE0A"><b>2FDE0A</b> - INT 2F C - DESQview v2.26+ External Dev Interface - CHANGE KEYBOARD FOCUS</a><br />
<a href="#2FDE0B"><b>2FDE0B</b> - INT 2F C - DESQview v2.26+ External Dev Interface - DVP PROCESSING COMPLETE</a><br />
<a href="#2FDE0C"><b>2FDE0C</b> - INT 2F C - DESQview v2.26+ External Dev Interface - SWAP OUT PROCESS</a><br />
<a href="#2FDE0D"><b>2FDE0D</b> - INT 2F C - DESQview v2.26+ External Dev Interface - SWAP IN PROCESS</a><br />
<a href="#2FDE0E"><b>2FDE0E</b> - INT 2F C - DESQview v2.26+ External Dev Interface - DVP START FAILED</a><br />
<a href="#2FDE0F"><b>2FDE0F</b> - INT 2F C - DESQview v2.50+ External Dev Interface - INITIALIZE DV</a><br />
<a href="#2FDE10"><b>2FDE10</b> - INT 2F C - DESQview v2.50+ External Dev Interface - FREE TASK</a><br />
<a href="#2FDF00BX5445"><b>2FDF00BX5445</b> - INT 2F U - Quarterdeck TELTSR.COM - INSTALLATION CHECK</a><br />
<a href="#2FDF01"><b>2FDF01</b> - INT 2F U - Quarterdeck TELTSR.COM - CLOSE CONNECTION</a><br />
<a href="#2FDF02"><b>2FDF02</b> - INT 2F U - Quarterdeck TELTSR.COM - OPEN CONNECTION</a><br />
<a href="#4B810D"><b>4B810D</b> - INT 4B - QEMM-386 - BUG</a><br />
<a href="#63_5"><b>63</b> - INT 63 - DESQview/X - SOCKET API</a><br />
<a href="#BE_0"><b>BE</b> - INT BE - DESQview/X - ???</a><br />
<a href="#FF_2"><b>FF</b> - INT FF U - QEMM-386.SYS v6.0+ - internal</a><br />

<hr />

<a href="#1080--DX4456" name="1080--DX4456"><b>1080--DX4456</b></a> - INT 10 U - VIDEO - DESQview 2.0x only - internal - SET ??? HANDLER<br />
<pre>
INT 10 U - VIDEO - DESQview 2.0x only - internal - SET ??? HANDLER
	AH = 80h
	DX = 4456h ('DV')
	ES:DI -&gt; FAR subroutine to be called on ???
Return: DS = segment of DESQview data structure for video buffer
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
	the subroutine seems to be called when the DESQview menu is accessed;
	  on entry, AL = 03h or 04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1081--DX4456" name="1081--DX4456"><b>1081--DX4456</b></a> - INT 10 U - VIDEO - DESQview 2.0x only - internal - GET ???<br />
<pre>
INT 10 U - VIDEO - DESQview 2.0x only - internal - GET ???
	AH = 81h
	DX = 4456h ('DV')
Return: ES = segment of DESQview data structure for video buffer
	    BYTE ES:[0] = current window number in DV 2.0x
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
SeeAlso: AH=82h"DESQview"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1082--DX4456" name="1082--DX4456"><b>1082--DX4456</b></a> - INT 10 U - VIDEO - DESQview 2.0x only - internal - GET CURRENT WINDOW INFO<br />
<pre>
INT 10 U - VIDEO - DESQview 2.0x only - internal - GET CURRENT WINDOW INFO
	AH = 82h
	DX = 4456h ('DV')
Return: DS = segment in DESQview for data structure
	     in DV 2.00,
		  BYTE DS:[0] = window number
		  WORD DS:[1] = segment of other data structure
		  WORD DS:[3] = segment of window's object handle
	ES = segment of DESQview data structure for video buffer
	AL = current window number
	AH = ???
	BL = direct screen writes
	    00h program does not do direct writes
	    01h program does direct writes, so shadow buffer not usable
	BH = ???
	CL = current video mode
	CH = ???
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
SeeAlso: AH=81h"DESQview"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151000" name="151000"><b>151000</b></a> - INT 15 - TopView - "PAUSE" - GIVE UP CPU TIME<br />
<pre>
INT 15 - TopView - "PAUSE" - GIVE UP CPU TIME
	AX = 1000h
Return: after other processes run
Note:	under DESQview, if the process issuing this call has hooked INT 08h,
	  the current time-slice is set to expire at the next clock tick rather
	  than immediately
SeeAlso: AH=00h"MultiDOS",AX=5305h,INT 21/AH=89h,INT 21/AH=EEh"DoubleDOS"
SeeAlso: INT 2F/AX=1680h,INT 60/DI=0106h,INT 62/AH=01h,INT 6F/AH=2Ah"F_YIELD"
SeeAlso: INT 7A/BX=000Ah,INT 7F/AH=02h"MultiLink",INT 7F/AH=E8h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151001" name="151001"><b>151001</b></a> - INT 15 - TopView - "GETMEM" - ALLOCATE "SYSTEM" MEMORY<br />
<pre>
INT 15 - TopView - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
	AX = 1001h
	BX = number of bytes to allocate
Return: ES:DI -&gt; block of memory or 0000h:0000h (DV v2.26+)
	AX = status (DV v2.42)
	    0000h successful
	    0001h failed
Note:	use SETERROR (AX=DE15h) to avoid a user prompt if there is insufficient
	  common memory.  Under DV v2.42, this call never generates a user
	  prompt regardless of the SETERROR value; instead, it always returns
	  AX=0001h and ES:DI=0000h:0000h if out of memory
SeeAlso: AX=1002h,AX=102Eh,AX=DE0Ch,AX=DE15h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151002" name="151002"><b>151002</b></a> - INT 15 - TopView - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY<br />
<pre>
INT 15 - TopView - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
	AX = 1002h
	ES:DI -&gt; previously allocated block
Return: block freed
SeeAlso: AX=1001h,AX=DE0Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151003" name="151003"><b>151003</b></a> - INT 15 - TopView - "PRINTC" - DISPLAY CHARACTER/ATTRIBUTE ON SCREEN<br />
<pre>
INT 15 - TopView - "PRINTC" - DISPLAY CHARACTER/ATTRIBUTE ON SCREEN
	AX = 1003h
	BH = attribute
	BL = character
	DX = segment of object handle for window
Return: nothing
Note:	BX=0000h does not display anything, it only positions the hardware
	  cursor to the logical cursor's current position

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1510_1" name="1510_1"><b>1510</b></a> - INT 15 - TopView - UNIMPLEMENTED IN DV 2.x<br />
<pre>
INT 15 - TopView - UNIMPLEMENTED IN DV 2.x
	AH = 10h
	AL = 04h thru 12h
Return: pops up "Programming error" window in DV 2.x

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151013" name="151013"><b>151013</b></a> - INT 15 - TopView - "GETBIT" - DEFINE A 2ND-LEVEL INTERRUPT HANDLER<br />
<pre>
INT 15 - TopView - "GETBIT" - DEFINE A 2ND-LEVEL INTERRUPT HANDLER
	AX = 1013h
	ES:DI -&gt; FAR service routine
Return: BX = bit mask indicating which bit was allocated
	    0000h if no more bits available
SeeAlso: AX=1014h,AX=1015h
Note:	only a few TopView/DESQview API calls are allowed during a hardware
	  interrupt; if other calls need to be made, the interrupt handler
	  must schedule a 2nd-level interrupt with "SETBIT" (AX=1015h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151014" name="151014"><b>151014</b></a> - INT 15 - TopView - "FREEBIT" - UNDEFINE A 2ND-LEVEL INTERRUPT HANDLER<br />
<pre>
INT 15 - TopView - "FREEBIT" - UNDEFINE A 2ND-LEVEL INTERRUPT HANDLER
	AX = 1014h
	BX = bit mask from INT 15/AX=1013h
Return: nothing
SeeAlso: AX=1013h,AX=1015h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151015" name="151015"><b>151015</b></a> - INT 15 - TopView - "SETBIT" - SCHEDULE ONE OR MORE 2ND-LEVEL INTERRUPTS<br />
<pre>
INT 15 - TopView - "SETBIT" - SCHEDULE ONE OR MORE 2ND-LEVEL INTERRUPTS
	AX = 1015h
	BX = bit mask for interrupts to post
Return: indicated routines will be called: (DV 2.0x) at next task switch
					   (DV 2.2x) immediately on return from
						     hardware interrupt
Notes:	this is one of the few TopView calls which are allowed from a hardware
	  interrupt handler
	the handler will be called with ES containing the segment of the handle
	  of the next task to be executed; on return, ES must be the segment of
	  a task handle
SeeAlso: AX=1013h,AX=1014h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151016" name="151016"><b>151016</b></a> - INT 15 - TopView - "ISOBJ" - VERIFY OBJECT HANDLE<br />
<pre>
INT 15 - TopView - "ISOBJ" - VERIFY OBJECT HANDLE
	AX = 1016h
	ES:DI = possible object handle
Return: BX = status
	    FFFFh if ES:DI is a valid object handle (see #00414)
	    0000h if ES:DI is not
Note:	under DESQview versions prior to 2.50, an object handle is always a
	  pointer to the object; for versions 2.50 and up, only task handles
	  are always pointers--other handles may consist of a unique object
	  number and offset into DESQview's common memory (see #00423)
SeeAlso: AX=DE14h,AX=DE2Bh,AX=DE2Ch

(Table 00413)
Values for DESQview object type:
 00h	window/task
 01h	mailbox
 02h	keyboard
 03h	timer
 04h	pointer
 05h	panel
 06h	objectq

Format of DESQview object:
Offset	Size	Description	(Table 00414)
 00h	WORD	offset in common memory of previous object of same type
 02h	WORD	offset in common memory of next object of same type
 04h	WORD	signature FEDCh (DV 2.42-)
		signature FEDCh or object number (DV 2.50+)
 06h	WORD	object type (see #00413)
 08h	DWORD	object handle to return to caller
 0Ch	DWORD	canonicalized object address (segment = common memory)
 10h	WORD	offset in common memory of owning task
		(0000h for unowned OBJECTQs)
 12h	WORD	mapping context
		offset in common memory of mapping context record (see #00416)
	remainder varies by object type and DESQview version
---v2.42 keyboard object---
 14h	WORD	flag bits (see also AH=12h/BH=0Ah"OBJECT")
		bit 15: keyboard opened
 16h  4 BYTEs	???
 1Ah	WORD	priority in OBJECTQ???
 1Ch	...
 25h	WORD	offset in common memory of ??? task
 27h  4 BYTEs	???
---v2.42 objectq object---
 14h	WORD	flag bits (see also AH=12h/BH=0Ah"OBJECT")
		bit 15: OBJECTQ opened
 16h  2 BYTEs	???
 18h	WORD	offset in common memory of ??? task
 1Ah  6 BYTEs	???
---v2.42 mailbox object---
 14h	WORD	flag bits (see also AH=12h/BH=0Ah"OBJECT")
		bit 15: mailbox opened
 1Ah	WORD	priority in OBJECTQ???
 1Ch  6 BYTEs	???
 22h	WORD	offset in common memory of mailbox name (counted string)
		0000h if no name
    &lt;= 5 BYTEs	???
---v2.22-2.42,2.52,2.60 window/task object---
 14h	BYTE	00h window, 01h task
 15h	BYTE	internal (not Switch menu) window number???
 16h	BYTE	internal (not Switch menu) window number???
 17h	WORD	segment of internal window record (see #00417)
 19h  2 BYTEs	???
 1Bh	BYTE	cursor row
 1Ch	BYTE	cursor column
 1Dh	BYTE	visible window origin, row
 1Eh	BYTE	visible window origin, column
 1Fh	BYTE	window height (logical)
 20h	BYTE	window width (logical)
 21h	BYTE	window position, row
 22h	BYTE	window position, column
 23h	BYTE	window height (visible)
 24h	BYTE	window width (visible)
 25h	BYTE	row of top of frame (or window if unframed)
 26h	BYTE	column of left of frame (or window if unframed)
 27h	BYTE	window height (physical, including frame)
 28h	BYTE	window width (physical, including frame)
 29h	BYTE	unzoomed visible origin, row (00h before first zoom)
 2Ah	BYTE	unzoomed visible origin, column (00h before first zoom)
 2Bh	BYTE	unzoomed window position, row (00h before first zoom)
 2Ch	BYTE	unzoomed window position, column (00h before first zoom)
 2Dh	BYTE	unzoomed window height (00h before first zoom)
 2Eh	BYTE	unzoomed window width (00h before first zoom)
		unzoomed parameters above are updated when window is zoomed
		  to full screen
 2Fh	BYTE	??? initially logical window height
 30h	BYTE	??? initially logical window width
 31h  2 BYTEs	???
 33h	BYTE	minimum height of window
 34h	BYTE	minimum width of window
 35h	BYTE	maximum height of window
 36h	BYTE	maximum width of window
 37h  3 BYTEs	???
 3Ah  8 BYTEs	window frame characters: ul,ur,ll,lr,t,b,l,r
 42h 24 BYTEs	attributes???
 5Ah  8 BYTEs	window frame characters: ul,ur,ll,lr,t,b,l,r
 62h  3 BYTEs	???
 65h	BYTE	??? bitflags
 66h	BYTE	bit 0: window is zoomed
 67h	BYTE	???
 68h	WORD	offset in common memory of window name or 0000h if untitled
 6Ah	WORD	length of window name
 6Ch  2 BYTEs	???
 6Eh	WORD	offset of logical cursor in window (in character cells)
 70h	DWORD	pointer to field table for window
 74h	BYTE	???
 75h  2 BYTEs	???
 77h	BYTE	number of last-visited field
 78h	DWORD	pointer to field table entry for last-visited field
 7Ch  3 BYTEs	???
 7Fh	BYTE	select field marker character
 80h	BYTE	??? bit flags
		bit 0: allow ECh window stream opcode to change reverse logattr
		bit 1: alternate field processing mode selected
 81h	BYTE	???
 82h	DWORD	notification function (manager stream opcode 8Ah)
		no notification if segment = 0000h
 86h	DWORD	notification argument (manager stream opcode 8Bh)
 8Ah	WORD	offset in common memory of ??? window object or 0000h
 8Ch	WORD	offset in common memory of ??? window object or 0000h
 8Eh	WORD	offset in common memory of ??? window object or 0000h
 90h	BYTE	??? bitflags
 91h	BYTE	???
 ---task object only
 92h	BYTE	bit flags (bits 0-4)
 93h	BYTE	character for ??? (default 20h)
 94h	BYTE	??? flag
 95h	WORD	offset in common memory of ???
 97h  2 BYTEs	???
 99h	WORD	???
 9Bh	BYTE	??? bit flags
		bit 3: ???
		bit 6: perform protected-attribute processing on select fields
 9Ch	BYTE	???
 9Dh	WORD	offset in common memory of current register save record
		  (see #00415).	No register save record in use if &lt; 01C0h
 9Fh	WORD	offset in common memory of task's keyboard object
 A1h	WORD	offset in common memory of task's OBJECTQ object
 A3h	WORD	offset in common memory of task's mailbox object
 A5h	WORD	semaphore: FFFFh if on user stack, else on task's private stack
 A7h	DWORD	user's SS:SP
 ABh	WORD	task's private SP (SS read from offset 0Ah)
 ADh  6 BYTEs	???
 B3h	BYTE	??? bit flags
		bit 0: run in foreground only
 B4h	BYTE	???
 B5h	BYTE	??? bitflags
 B6h	BYTE	task status (see #00555 at AX=DE2Ch)
 B7h  9 BYTEs	???
 C0h	WORD	head pointer for keyboard buffer (wraps back to 00h after 80h)
 C2h	WORD	tail pointer for keyboard buffer (wraps back to 00h after 80h)
 C4h  2 BYTEs	??? (0000h)
 C6h	WORD	segment of keyboard buffer for task
 C8h	WORD	offset in common memory of ??? keyboard object
 CAh	BYTE	???
---v2.22-2.42
 CBh	WORD	offset in common memory of ??? object
 CEh	BYTE	??? flag
 CFh	WORD	offset in common memory of default notify window for task
		  or 0000h if none
 D1h  4 BYTEs	???
 D5h	BYTE	window number on Switch Window menu
 D6h  5 BYTEs	???
 DBh	WORD	offset in common memory of ??? object
 DDh  2 BYTEs	???
 DFh	WORD	API level for task
 E1h	WORD	offset in common memory of object task is waiting on if task
		  status is 'waiting', else 0000h
 E7h	WORD	segment of ???
 E9h 4	BYTEs	???
 EDh	WORD	EMS handle of virtualization buffer, 0000h if no virtualization
 F1h 12 BYTEs	???
 FBh	WORD	???
 FDh	BYTE	???
 FFh 12 BYTEs	???
10Bh	DWORD	pointer to process record (see #00418,#00419)
10Dh 10 BYTEs	???
119h	DWORD	SS:SP for ???
11Dh  4 BYTEs	???
121h	DWORD	pointer to ???
125h 25 BYTEs	???
13Eh	DWORD	pointer to ??? in system memory
---v2.22
142h  3 BYTEs	???
145h		task's default keyboard object
---v2.42
142h	DWORD	pointer to first task instance data record in system memory
148h	DWORD	pointer to last task instance data record in system memory
		(see #00420)
14Ah	BYTE	???
14Dh 42 BYTEs	task's default keyboard object
177h 32 BYTEs	task's ObjectQ object
197h 41 BYTEs	task's default mailbox object
1C0h 24 BYTEs	first register save record
450h	--	default top of private stack
---v2.52 (probably all DV/X)
Same as v2.60 below except there is an extra 29 bytes inserted somewhere
  before offset 9Fh, but not yet known exactly where.  Also, for the WAIT_ON
  field (v2.60 offset E3h), some X apps (probably waiting on a socket) have
  0000h even when waiting.
---v2.60
 CBh	WORD	??? (added in 2.50 - rest is same as 2.42)
 CDh	WORD	offset in common memory of ??? object
 D0h	BYTE	??? flag
 D1h	WORD	offset in common memory of default notify window for task
		  or 0000h if none
 D3h  4 BYTEs	???
 D7h	BYTE	window number on Switch Window menu
 D8h  5 BYTEs	???
 DDh	WORD	offset in common memory of ??? object
 DFh  2 BYTEs	???
 E1h	WORD	API level for task
 E3h	WORD	If status at B6h=waiting, offset in common memory of object
		  that task is waiting on, else 0000h. (Task with CPU also
		  has 0000h here)
 E9h	WORD	segment of ???
 EBh 4	BYTEs	???
 EFh	WORD	EMS handle of virtualization buffer, 0 if no virtualization
 F3h 12 BYTEs	???
 FDh	WORD	???
 FFh	BYTE	???
101h  8 BYTEs	???
109h	DWORD	pointer to process record in system memory
10Dh 14 BYTEs  ???
11Bh	DWORD	SS:SP for ???
11Fh  4 BYTEs	???
123h	DWORD	pointer to ???
127h 25 BYTEs	???
140h	DWORD	pointer to ??? in system memory
144h	DWORD	pointer to first task instance data record in system memory
148h	DWORD	pointer to last task instance data record in system memory
		(from INT 15/AX=DE27h) (see #00420)
14Ch	BYTE	???
14Eh 42 BYTEs	task's default keyboard object
179h 32 BYTEs	task's ObjectQ object
199h 41 BYTEs	task's default mailbox object
1C2h 24 BYTEs	first register save record
452h	--	default top of private stack

Format of DESQview Register Save Record:
Offset	Size	Description	(Table 00415)
 00h	WORD	AX
 02h	WORD	BX
 04h	WORD	CX
 06h	WORD	DX
 08h	WORD	DI
 0Ah	WORD	SI
 0Eh	WORD	DS
 10h	WORD	ES
 12h	DWORD	return address
 16h	WORD	original flags

Format of DESQview mapping context record:
Offset	Size	Description	(Table 00416)
 00h	WORD	lowest segment in process's memory
		(often start of system memory chain)
 02h	WORD	size of process's memory in paragraphs
 04h	BYTE	flag: 00h if process swapped out, 01h otherwise
 05h	BYTE	flag: 00h if allocated in conventional memory, 01h if EMS
 06h  2 BYTEs	???
 08h	WORD	EMS handle if in EMS, else 0
 0Ah  2 BYTEs	??? (nonzero if system memory resides in shared mem???)
 0Ch	WORD	segment of system memory block that contains process record,
		  referenced from segment of start of system memory chain
 0Eh	BYTE	???
 0Fh	WORD	size of system memory block that contains process record
		  and DOS memory in paragraphs
 11h	BYTE	bit flags
		Bit 0: Swapped out???
		Bit 1: ???
		Bit 2: Swapped out???
 12h	BYTE	???
 13h	BYTE	reference count
 ---v2.31
 14h 10 BYTEs	???
 1Eh	WORD	segment of process record
 20h  2 BYTEs	???
 22h	WORD	segment of ???	(in first free system memory block???)
 24h	WORD	segment of end of system memory chain
 26h	WORD	segment of start of system memory chain
 28h  8 BYTEs	???
 2Ah	DWORD	pointer to ??? (process record???)
 2Dh 10 BYTEs	???
 37h	BYTE	lowest interrupt vector to save on context switch
 38h	BYTE	highest interrupt vector to save on context switch
 39h	WORD	offset in common memory of main task with this context
 3Ah 12 BYTEs	???
 46h	BYTE	internal mapping context number
 47h 12 BYTEs	???
 ---v2.5x-2.60
 14h  6 BYTEs	???
 1Ah	WORD	segment of process record
 1Ch  2 BYTEs	???
 1Eh	WORD	segment of first free system memory block
 20h	WORD	segment of start of system memory chain
 22h	WORD	segment of end of system memory chain
 24h 8	BYTEs	???
 2Ch	DWORD	pointer to ??? (1 segment into process record???)
 30h 3	BYTEs	???
 33h	WORD	Offset in common memory of main task with this context
 35h 7	BYTEs	???
 3Ch	BYTE	internal mapping context number
 3Dh 14 BYTEs	???
 4Bh	WORD	first DOS memory segment (first MCB segment+1)
 4Dh	BYTE	??? (flag???)
 ---v2.53 (2.5x???)
 4Eh 12 BYTEs	???
 ---v2.60
 4Eh	WORD	segment of script buffer (see #00421)
 50h  6 BYTEs	???

Format of DESQview Internal Window Record (v2.31-2.60):
Offset	Size	Description	(Table 00417)
 00h	BYTE	internal window number???
 01h	BYTE	display page???
 02h	BYTE	video mode
 03h  3 BYTEs	???
 06h	BYTE	logical window height
 07h	BYTE	logical window width
 08h	DWORD	pointer to text video buffer
 0Ch 116 BYTEs	???

Format of DESQview process record (v2.31):
Offset	Size	Description	(Table 00418)
-470h 13 BYTEs	filename of ??? Script
-463h 1117 BYTEs ??? (script buffer???)
 -6h  6 BYTEs	???
 00h	WORD	segment of parent PSP in process
 02h  5 BYTEs	???
 07h	WORD	segment of current PSP in process
 09h	WORD	segment of first MCB in process
 0Bh 13 BYTEs	???
 18h 1024 BYTEs process's interrupt vector table
418h 376 BYTEs	???
590h		first MCB in process
SeeAlso: #00419

Format of DESQview process record (v2.52-v2.60) (probably also 2.5x):
Offset	Size	Description	(Table 00419)
 00h 28 BYTEs	EXE header of last EXE, ??? if last program run was COM
 1Ch ??? BYTEs	overwritten with ASCIZ filename of last program run (EXE/COM)
11Ch	WORD	segment of parent PSP in process
11Eh  4 BYTEs	???
122h	WORD	segment of current PSP
124h	WORD	segment of current PSP
126h	WORD	segment of first MCB in process
128h  4 BYTEs	???
12Ch	DWORD	pointer to first process instance data record in system memory
130h	DWORD	pointer to last process instance data record in system memory
		(from INT 15/AX=DE27h) (see #00420)
134h  8 BYTEs	???
13Ch	WORD	size of current environment
13Eh	WORD	segment of current environment
140h	WORD	segment of current PSP
142h	DWORD	entry point of current program
146h 10 BYTEs	???
---v2.52 (v2.5x???)
150h	BYTE	???
151h	WORD	segment of parent PSP in process
153h	WORD	???
155h	WORD	???
157h	WORD	???
159h  4 BYTEs	???
15Dh	WORD	segment of current environment
15Fh	WORD	segment of current PSP
161h	WORD	segment of ???
162h	WORD	???
164h  3 BYTEs	???
168h 1024 BYTEs process's interrupt vector table
568h 120 BYTEs	???
5E0h		first MCB in process
---v2.60
150h	WORD	segment of parent PSP in process
152h	WORD	???
154h	WORD	???
156h	WORD	???
158h  4 BYTEs	???
15Ch	WORD	segment of current environment
15Eh	WORD	segment of current PSP
160h	WORD	segment of ???
162h	WORD	???
164h 1024 BYTEs process's interrupt vector table
564h 108 BYTEs	???
5D0h		first MCB in process
SeeAlso: #00418

Format of DESQview task or process instance data record (v2.5x???, v2.60):
Offset	Size	Description	(Table 00420)
 00h	DWORD	pointer to next record of same type or 00000000
 04h	DWORD	pointer to previous record of same type or 00000000
 08h	DWORD	pointer to source area of memory during restore state
 0Ch	WORD	number of bytes to save/restore
 0Eh	DWORD	pointer to destination area of memory during restore state
 12h	WORD	??? (0)
 14h  N BYTEs	source memory buffer during restore state

Format of DESQview script buffer (v2.60):
Offset	Size	Description	(Table 00421)
 00h 13 BYTEs	ASCIZ Script filename
 0Dh 80 BYTEs	???
 5Eh  N BYTEs	script records (see #00422)

Format of one DESQview script record (v2.60):
Offset	Size	Description	(Table 00422)
 00h	BYTE	signature 12h
 01h 18 BYTEs	blank-padded script name
 13h	BYTE	ASCII code of key attached to script or 0 if non-ASCII key
 14h	BYTE	scan code of key attached to script if non-ASCII, else 0
 15h	BYTE	???
 16h	WORD	size of script in bytes
 18h  N	BYTEs	script (ASCII code of each keystroke; if 0, next byte is
		  scan code of non-ASCII key)
SeeAlso: #00421

Format of DESQview Common Memory Header (v2.31-2.60):
Offset	Size	Description	(Table 00423)
 00h	WORD	offset of lowest used block
 02h	WORD	bytes of commom memory, including header
 04h	WORD	offset of first free block
 06h  N BYTEs	size depends of DV version, ??? (DVP buffer???)
Note:	the above is located at the beginning of the commom memory segment
SeeAlso: #00424,#00425,#00433

Format of DESQview Free block header:
Offset	Size	Description	(Table 00424)
 00h	WORD	size of block in bytes including header
 02h	WORD	offset of next free block
 04h  N BYTEs	free block
SeeAlso: #00423,#00425

Format of DESQview Used block header:
Offset	Size	Description	(Table 00425)
 00h	WORD	size of block in bytes including header
 02h  N BYTEs	used block
SeeAlso: #00423,#00424

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151017" name="151017"><b>151017</b></a> - INT 15 - TopView - UNIMPLEMENTED IN DV 2.x<br />
<pre>
INT 15 - TopView - UNIMPLEMENTED IN DV 2.x
	AX = 1017h
Return: pops up "Programming error" window in DV 2.x

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151018" name="151018"><b>151018</b></a> - INT 15 - TopView - "LOCATE" - FIND WINDOW AT A GIVEN SCREEN LOCATION<br />
<pre>
INT 15 - TopView - "LOCATE" - FIND WINDOW AT A GIVEN SCREEN LOCATION
	AX = 1018h
	BH = column
	BL = row
	ES = segment of object handle for window below which to search
	    0000h = start search with topmost window
Return: ES = segment of object handle for window which is visible at the
	       indicated position, or covered by indicated window
	    0000h if no window
SeeAlso: AX=1023h,AX=1024h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151019" name="151019"><b>151019</b></a> - INT 15 - TopView - "SOUND" - MAKE TONE<br />
<pre>
INT 15 - TopView - "SOUND" - MAKE TONE
	AX = 1019h
	BX = frequency in Hertz (0000h = silence)
	CX = duration in clock ticks (18.2 ticks/sec)
Return: immediately, tone continues to completion
Notes:	if another tone is already playing, the new tone does not start until
	  completion of the previous one.  Up to 32 tones may be queued before
	  the process is blocked until a note completes.
	in DV 2.00, the lowest tone allowed is 20 Hz
	if CX = 0, the current note is cancelled; if BX = 0 as well, all queued
	  notes are also cancelled
SeeAlso: AH=82h"HUNTER",INT 16/AH=73h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15101A" name="15101A"><b>15101A</b></a> - INT 15 - TopView - "OSTACK" - SWITCH TO TASK'S INTERNAL STACK<br />
<pre>
INT 15 - TopView - "OSTACK" - SWITCH TO TASK'S INTERNAL STACK
	AX = 101Ah
Return: stack switched
Notes:	this call may not be nested; a second call must be preceded by a call
	  to "USTACK" (AX=1025h)
	while TopView requires many API calls to be executed while on the
	  task's internal stack, DESQview allows those calls to be executed
	  regardless of the current stack
SeeAlso: AX=1025h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15101B" name="15101B"><b>15101B</b></a> - INT 15 - TopView - "BEGINC" - BEGIN CRITICAL REGION<br />
<pre>
INT 15 - TopView - "BEGINC" - BEGIN CRITICAL REGION
	AX = 101Bh
Return: task-switching temporarily disabled
Notes:	will not task-switch until "ENDC" (AX = 101Ch) called unless task
	  voluntarily releases the CPU (upon regaining the CPU, task-switching
	  will again be disabled)
	suspends the caller until DOS is free
SeeAlso: AH=0Dh"MultiDOS",AX=101Ch,AX=DE13h,AX=DE1Ch,INT 2F/AX=1681h
SeeAlso: INT 60/DI=0602h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15101C" name="15101C"><b>15101C</b></a> - INT 15 - TopView - "ENDC" - END CRITICAL REGION<br />
<pre>
INT 15 - TopView - "ENDC" - END CRITICAL REGION
	AX = 101Ch
Return: task-switching enabled
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,AX=DE13h,AX=DE1Bh,INT 2F/AX=1682h,INT 60/DI=0603h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15101D" name="15101D"><b>15101D</b></a> - INT 15 - TopView - "STOP" - STOP TASK<br />
<pre>
INT 15 - TopView - "STOP" - STOP TASK
	AX = 101Dh
	ES = segment of object handle for task to be stopped
	    (== handle of main window for that task)
Return: indicated task will not get any CPU time until restarted with AX=101Eh
Note:	once a task has been stopped, additional "STOP"s are ignored
BUG:	in DV 2.00, this function is ignored unless the indicated task is the
	  current task
SeeAlso: AX=101Eh,AX=102Bh,AH=12h"VMiX",INT 21/AH=81h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15101E" name="15101E"><b>15101E</b></a> - INT 15 - TopView - "START" - START TASK<br />
<pre>
INT 15 - TopView - "START" - START TASK
	AX = 101Eh
	ES = segment of object handle for task to be started
	    (== handle of main window for that task)
Return: indicated task is started up again
Note:	once a task has been started, additional "START"s are ignored
SeeAlso: AX=101Dh,AX=102Bh,INT 21/AH=82h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15101F" name="15101F"><b>15101F</b></a> - INT 15 - TopView - "DISPEROR" - POP-UP ERROR WINDOW<br />
<pre>
INT 15 - TopView - "DISPEROR" - POP-UP ERROR WINDOW
	AX = 101Fh
	BX = bit fields
	    bits 0-12: number of characters to display
	    bits 13,14: which mouse button may be pressed to remove window
			 00 = either
			 01 = left
			 10 = right
			 11 = either
	    bit 15: beep if 1
	ES:DI -&gt; text of message
	CH = width of error window (0 = default)
	CL = height of error window (0 = default)
	DX = segment of object handle
Return: BX = status: 1 = left button, 2 = right, 27 = ESC pressed
Note:	window remains on-screen until ESC or indicated mouse button is pressed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151020" name="151020"><b>151020</b></a> - INT 15 - TopView - UNIMPLEMENTED IN DV v2.00+<br />
<pre>
INT 15 - TopView - UNIMPLEMENTED IN DV v2.00+
	AX = 1020h
Return: pops up "Programming error" window in DV v2.00+

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151021" name="151021"><b>151021</b></a> - INT 15 - TopView - "PGMINT" - INTERRUPT ANOTHER TASK<br />
<pre>
INT 15 - TopView - "PGMINT" - INTERRUPT ANOTHER TASK
	AX = 1021h
	BX = segment of object handle for task to interrupt (not self)
	DX:CX -&gt; FAR routine to jump to next time task is run
Return: nothing
Notes:	the FAR routine is entered with the current ES, DS, SI, DI, and BP
	  values, using the task's internal stack (see AX=101Ah); only SS:SP
	  needs to be preserved
	multiple PGMINTs to a single task are processed last-in first-out
	if the other task is in a DOS or DV API call, the interruption will
	  occur on return from that call

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151022BX0000" name="151022BX0000"><b>151022BX0000</b></a> - INT 15 - TopView - "GETVER" - GET VERSION<br />
<pre>
INT 15 - TopView - "GETVER" - GET VERSION
	AX = 1022h
	BX = 0000h
Return: BX nonzero, TopView or compatible loaded
	(BL = major version, BH = minor version)
Notes:	TaskView returns BX = 0001h, DESQview v2.00+ returns BX = 0A01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151023" name="151023"><b>151023</b></a> - INT 15 - TopView - "POSWIN" - POSITION WINDOW<br />
<pre>
INT 15 - TopView - "POSWIN" - POSITION WINDOW
	AX = 1023h
	BX = segment of object handle for parent window within which to
	       position the window (0 = full screen)
	ES = segment of object handle for window to be positioned
	DL = general window position (see #00426)
	CH = number of columns to offset from position specified by DL
	CL = number of rows to offset from position specified by DL
Return: nothing

Bitfields for TopView general window position:
Bit(s)	Description	(Table 00426)
 0,1	horizontal position
	00 = current, 01 = center, 10 = left, 11 = right
 2,3	vertical position
	00 = current, 01 = center, 10 = top, 11 = bottom
 4	don't redraw screen if set
 5-7	not used

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151024" name="151024"><b>151024</b></a> - INT 15 - TopView - "GETBUF" - GET VIRTUAL SCREEN INFO<br />
<pre>
INT 15 - TopView - "GETBUF" - GET VIRTUAL SCREEN INFO
	AX = 1024h
	BX = segment of object handle for window (0000h = use default)
Return: ES:DI -&gt; virtual screen
	CX = size of virtual screen in bytes
	DL = screen type
	    00h text screen
	    01h graphics screen
SeeAlso: INT 10/AH=FEh,INT 21/AH=2Bh/CX=4445h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151025" name="151025"><b>151025</b></a> - INT 15 - TopView - "USTACK" - SWITCH BACK TO USER'S STACK<br />
<pre>
INT 15 - TopView - "USTACK" - SWITCH BACK TO USER'S STACK
	AX = 1025h
Return: stack switched back
Notes:	call only after having switched to internal stack with AX=101Ah
	while TopView requires many API calls to be executed while on the
	  task's private stack, DESQview allows those calls to be executed
	  regardless of the current stack
SeeAlso: AX=101Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1510_2" name="1510_2"><b>1510</b></a> - INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.x<br />
<pre>
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.x
	AH = 10h
	AL = 26h thru 2Ah
Return: pops up "Programming error" window in DV 2.x

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15102B" name="15102B"><b>15102B</b></a> - INT 15 - DESQview v2.00+ (TopView???) - "POSTTASK" - AWAKEN TASK<br />
<pre>
INT 15 - DESQview v2.00+ (TopView???) - "POSTTASK" - AWAKEN TASK
	AX = 102Bh
	BX = segment of object handle for task
Return: nothing
Note:	forces a task which is waiting on its objectq to continue by placing
	  the handle for the task on the objectq
SeeAlso: AX=101Dh,AX=101Eh,INT 21/AH=82h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15102C" name="15102C"><b>15102C</b></a> - INT 15 - DESQview v2.00+ - "NEWPROC" - START NEW APPLICATION IN NEW PROCESS<br />
<pre>
INT 15 - DESQview v2.00+ - "NEWPROC" - START NEW APPLICATION IN NEW PROCESS
	AX = 102Ch
	ES:DI -&gt; contents of .PIF/.DVP file (see #00427)
	BX = size of .PIF/.DVP info
Return: BX = segment of object handle for new task
	    0000h on error
SeeAlso: AX=DE24h,INT 21/AH=4Bh

Format of .PIF/.DVP file:
Offset	Size	Description	(Table 00427)
 00h	BYTE	reserved (0)
 01h	BYTE	checksum of bytes 02h through 170h
 02h 30 BYTEs	blank-padded program title
 20h	WORD	maximum memory to allocate to partition in KB
 22h	WORD	minimum memory required in KB
 24h 64 BYTEs	ASCIZ program pathname
 64h	BYTE	default drive letter ('A',...)
 65h 64 BYTEs	ASCIZ default directory name
 A5h 64 BYTEs	ASCIZ program parameters
 E5h	BYTE	initial screen mode (0-7) (also see offset 189h)
 E6h	BYTE	number of text pages used
 E7h	BYTE	number of first interrupt to save
 E8h	BYTE	number of last interrupt to save
 E9h	BYTE	rows in virtual screen buffer
 EAh	BYTE	columns in virtual screen buffer
 EBh	BYTE	initial window position, row
 ECh	BYTE	initial window position, column
 EDh	WORD	system memory in KB
 EFh 64 BYTEs	ASCIZ shared program name
12Fh 64 BYTEs	ASCIZ shared program data file
16Fh	BYTE	program flags 1 (see #00428)
170h	BYTE	flags2
		bit 6: uses command-line parameters in field at A5h
		bit 5: swaps interrupt vectors
---information unique to .DVP files---
171h  2 BYTEs	keys to use on open menu
173h	WORD	size of script buffer in bytes
175h	WORD	automatically give up CPU after this many tests for keyboard
		  input in one clock tick (default 0 = never)
177h	BYTE	nonzero = "uses own colors"
178h	BYTE	nonzero if application swappable
179h  3 BYTEs	reserved (0) according to Quarterdeck documentation
		in actual .DVP files, frequently 01h
17Ch	BYTE	nonzero to automatically close on exit (see also #00430)
17Dh	BYTE	nonzero if copy-protect floppy is required
---information unique to DESQview 2.0+---
17Eh	BYTE	.DVP version number
		00h DESQview v1.2+
		01h DESQview v2.0+
		02h DESQview v2.2+
17Fh	BYTE	reserved (0)
180h	BYTE	initial number of rows in physical window
181h	BYTE	initial number of columns in physical window
182h	WORD	maximum expanded memory to allow, in KB
184h	BYTE	DVP program flags 3 (see #00429)
185h	BYTE	keyboard conflict level (0-4 for DV&lt;2.26, 00h-0Fh for DV2.26+)
		(see #00431)
186h	BYTE	number of graphics pages used
187h	WORD	extra system memory size
189h	BYTE	initial screen mode (FFh = default) (overrides offset E5h)
---information unique to DESQview 2.2+---
18Ah	BYTE	serial port usage
		FFh uses all serial ports
		00h no serial ports
		01h only COM1
		02h only COM2
18Bh	BYTE	DVP program flags 4 (see #00430)
18Ch	BYTE	protection level for 386 machines
18Dh 19 BYTEs	reserved (0) for regular DESQview
---information unique to DESQview/X 1.0---
18Dh	BYTE	X flags
		bits 3-7: unused (0)
		bit 2: don't display wait message when opening window
		bit 1: don't display DOS window
		bit 0: (XNEWPROC) use DOS client layer (DOS-to-X)
		       (NEWPROC) inherit DOS client layer usage
18Eh	BYTE	X keyboard behavior (0-3)
18Fh	BYTE	font scaling
		00h fixed fonts
		01h scalable fonts
190h 10 BYTEs	reserved (0)
19Ah	WORD	length of data follownig XDVP signature
19Ch  4 BYTEs	signature "XDVP"
1A0h  N BYTEs	list of variable length records (see #00432)

Bitfields for .PIF/.DVP program flags 1:
Bit(s)	Description	(Table 00428)
 7	writes text directly to screen
 6	runs in foreground only (see also #00427 offset 184h)
 5	uses math coprocessor
 4	accesses system keyboard buffer directly
 3-1	reserved (0)
 0	swappable
SeeAlso: #00427,#00429,#00430

Bitfields for .DVP program flags 3:
Bit(s)	Description	(Table 00429)
 7	automatically assign window position
 5	maximum memory value has been specified
 4	disallow "Close" command
 3	foreground-only when doing graphics
	set by DV 2.3+ when "Runs in Background" = "D" (undoc)
 2	don't virtualize (see also #00430)
 1	foreground-only during DOS calls
	set by DV 2.3+ when "Runs in Background" = "D" (undoc)
SeeAlso: #00427,#00428,#00430

Bitfields for .DVP program flags 4:
Bit(s)	Description	(Table 00430)
 7	automatically close application on exit if .COM or .EXE	specified
	(see also #00427 offset 17Ch)
 6	swappable if not using serial ports
 5	start program with window hidden (v2.26+)
 4	start program in background (v2.26+)
 3	virtualize text (see also #00429)
 2	virtualize graphics (see also #00429)
 1	share CPU when foreground
 0	share EGA when foreground and zoomed
SeeAlso: #00427,#00428,#00429

Bitfields for DESQview keyboard conflict level:
Bit(s)	Description	(Table 00431)
 3	save/restore entire INT 09 handler state every taskswtch
 2	take special precautions for programs which read the BIOS keyboard
	  buffer directly from memory
 1	never indicate keystroke available during scripts/xfers
 0	only indicate keystroke available every sixth poll
SeeAlso: #00427

Format of DESQview/X variable length record:
Offset	Size	Description	(Table 00432)
 00h	WORD	length of following record, 0000h if end of record list
 02h	BYTE	record type
		01h script filename, up to 64 characters
		02h command-line parameters (allows &gt;64 characters on cmdline)
		03h environment inheritance
		04h environment string
		05h starting window position
---types 01h,02h,04h---
 03h  N BYTEs	ASCII data
---type 03h---
 03h	BYTE	inheritance
		00h do not inherit
		01h inherit environment
---type 05h---
 03h  N BYTEs	ASCII copy of fields as typed into DVPMAN, separated by commas:
		starting row, starting column, starting height, starting width
Note:	if there are multiple occurrences of record types 01h, 02h, or 03h,
	  only the last instance of each type is used; multiple occurrences of
	  type 04h are concatenated
SeeAlso: #00427

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15102D" name="15102D"><b>15102D</b></a> - INT 15 - DESQview v2.00+ - "KMOUSE" - KEYBOARD MOUSE CONTROL<br />
<pre>
INT 15 - DESQview v2.00+ - "KMOUSE" - KEYBOARD MOUSE CONTROL
	AX = 102Dh
	BL = subfunction
	    00h determine whether using keyboard mouse
		Return: BL = 00h using real mouse
			     01h using keyboard mouse
	    01h turn keyboard mouse on
	    02h turn keyboard mouse off
SeeAlso: INT 33/AX=0024h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15102E" name="15102E"><b>15102E</b></a> - INT 15 - DESQview v2.40+ - ALLOCATE SYSTEM MEMORY<br />
<pre>
INT 15 - DESQview v2.40+ - ALLOCATE SYSTEM MEMORY
	AX = 102Eh
	BX = number of bytes
Return: AX = status
	    0000h successful
		ES:DI -&gt; allocated system memory (see #00433)
	    0001h failed
		ES:DI = 0000h:0000h
Note:	under DV 2.42, this call is identical to AX=1001h
SeeAlso: AX=1001h,AX=1002h,AX=DE0Ch

Format of DESQview system memory block header:
Offset	Size	Description	(Table 00433)
 00h	WORD	segment of next header or 0000h
 02h	WORD	segment of previous header or 0000h
 04h	WORD	size of block in paragraphs, including header
 06h	BYTE	availability flag (00h in use, 01h free)
Note:	this header is located one paragraph before the memory block proper
SeeAlso: #00423

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1511" name="1511"><b>1511</b></a> - INT 15 - TopView commands<br />
<pre>
INT 15 - TopView commands
	AH = 11h
	AL = various (except 17h)
Return: varies by function
Note:	in DESQview 2.x, these function calls are identical to AH=DEh, so
	  see those below
SeeAlso: AX=DE00h,AX=DE22h,AX=DE30h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#151117BX0000" name="151117BX0000"><b>151117BX0000</b></a> - INT 15 - DESQview v2.20+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT<br />
<pre>
INT 15 - DESQview v2.20+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT
	AX = 1117h
	BX = 0000h	get current mapping context without setting
	     nonzero	set new mapping context
Return: BX = mapping context in effect before call
	interrupts enabled
Notes:	this function differs from AX = DE17h for DESQview v2.20 through 2.25
	mapping contexts determine conventional-memory addressability; setting
	  a mapping context ensures that the associated program and data areas
	  are in memory for access.  Usable by drivers, TSRs and shared
	  programs.
	caller need not be running under DESQview, but must ensure that the
	  stack in use will not be mapped out by the call
SeeAlso: AX=DE17h,INT 2F/AX=1685h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH00" name="1512--BH00"><b>1512--BH00</b></a> - INT 15 - TopView - SEND MESSAGE - "HANDLE" - RETURN OBJECT HANDLE<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "HANDLE" - RETURN OBJECT HANDLE
	AH = 12h
	BH = 00h
	BL = which handle to return
	    00h handle in DWORD on top of stack
	    01h current task's window handle
	    02h given task's mailbox handle (task's handle on stack)
	    03h current task's mailbox handle
	    04h given task's keyboard handle (task's handle on stack)
	    05h current task's keyboard object handle
	    06h given task's OBJECTQ handle (task's handle on stack)
	    07h current task's OBJECTQ handle
	    08h	  \
	      thru &gt; return 0000:0000 under DV &lt; 2.26
	    10h	  /
	    0Ch (2.26+) task owning object with handle in DWORD on top of stack
	    0Dh (2.26+) task handle of owner (parent) of current task
Return: DWORD on top of stack is object handle
Note:	BL=0Ch,0Dh returns 00000000h if the object is not open (keyboard,
	  mailbox, panel, pointer, and timer objects) or is an orphan (task,
	  window)
SeeAlso: AH=12h/BH=02h,AH=12h/BH=80h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH01" name="1512--BH01"><b>1512--BH01</b></a> - INT 15 - TopView - SEND MESSAGE - "NEW" - CREATE NEW OBJECT<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "NEW" - CREATE NEW OBJECT
	AH = 12h
	BH = 01h
	BL = object type to create (see #00435)
	STACK: (only if window object or WINDOW class)
	       DWORD address to jump to (no new task if high word == 0)
	       DWORD (reserved) 0 = non-task window, FFFFh = task window
	       DWORD bytes for task's private stack (FFFFh == default of 0100h)
	       DWORD bytes system memory for input buffer for READ/READN
			(0 == none, -1 == default--same as logical window size)
	       DWORD window size, columns
	       DWORD window size, rows
	       DWORD length of window title
	       DWORD address of window title
Return: DWORD on top of stack is new object handle
Notes:	if a new task is created, it is started with
	  AX = BX = SI = DI = BP = 0
	  DX:CX = handle of parent task
	  DS = ES = SS = segment of private stack (and new task's handle)
	new windows are orphans, inherit the colors/hidden status of the
	  creating task's window, and are placed in the upper left hand corner
	  of the screen but not automatically redrawn
	new keyboards are closed, and have all object bits cleared except for
	  the hardware cursor bit
SeeAlso: AH=12h/BH=02h,AH=12h/BH=81h

(Table 00435)
Values for TopView/DESQview object type (for creation):
 00h	(DV 2.0x only) handle is DWORD on top of stack
 01h	(DV 2.0x only) use task's window handle
 02h	(DV 2.0x only) given task's mailbox (task's handle on stack)
 03h	(DV 2.0x only) current task's mailbox
 04h	(DV 2.0x only) given task's keyboard (task's handle on stack)
 05h	(DV 2.0x only) current task's keyboard object
 08h	WINDOW class
 09h	MAILBOX class
 0Ah	KEYBOARD class
 0Bh	TIMER object (counts down 32-bit time in 10ms increments)
 0Fh	POINTER object
 10h	PANEL object

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH02" name="1512--BH02"><b>1512--BH02</b></a> - INT 15 - TopView - SEND MESSAGE - "FREE" - FREE AN OBJECT<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "FREE" - FREE AN OBJECT
	AH = 12h
	BH = 02h
	BL = object
	    00h handle in DWORD on top of stack
		window: close window and free
		timer: free timer
		panel: free panel object
		pointer: free pointer
	    01h task's window handle - kills task, never returns
	    02h given task's mailbox (task's handle on top of stack)
	    03h current task's mailbox
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's keyboard object
Return: STACK popped if handle passed on stack
Notes:	when a window is freed, its keyboard and pointer objects are freed;
	  task windows also free any mailbox, objectq, and panel objects held
	  by the task and any child tasks
	if the keyboard being freed is the default keyboard for a task, this
	  call is equivalent to CLOSE
	panel and pointer objects are automatically closed if open
SeeAlso: AH=12h/BH=01h,AH=12h/BH=0Dh,AH=12h/BH=82h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH03" name="1512--BH03"><b>1512--BH03</b></a> - INT 15 - TopView - SEND MESSAGE - "ADDR" - GET HANDLE OF MESSAGE SENDER<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "ADDR" - GET HANDLE OF MESSAGE SENDER
	AH = 12h
	BH = 03h
	BL = object
	    00h mailbox handle in DWORD on top of stack
	    02h sender of last msg read from mailbox (task's handle on stack)
	    03h sender of last msg read from current task's mailbox
Return: DWORD on stack is task handle of message sender
SeeAlso: AH=12h/BH=00h,AH=12h/BH=83h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH03_0" name="1512--BH03_0"><b>1512--BH03</b></a> - INT 15 - DESQview v2.26+ - "CONNECT" - CONNECT TWO WINDOWS<br />
<pre>
INT 15 - DESQview v2.26+ - "CONNECT" - CONNECT TWO WINDOWS
	AH = 12h
	BH = 03h
	BL = window to be connected
	    00h handle of window to be attached in DWORD on top of stack
	    01h attach current task's main window
	STACK: DWORD handle of window to attach to or 00000000h to detach
Return: STACK popped
Notes:	when two windows are connected, both will move if the user moves either
	multiple windows may be attached to a single window, but each window
	  may only be attached to one window at a time
SeeAlso: AH=12h/BH=83h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BX0300" name="1512--BX0300"><b>1512--BX0300</b></a> - INT 15 - TopView - SEND MESSAGE - "DIR" - GET PANEL FILE DIRECTORY<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "DIR" - GET PANEL FILE DIRECTORY
	AH = 12h
	BX = 0300h
	STACK: DWORD handle of panel object (see #00436)
Return: STACK: DWORD length of directory (always multiple of 14 bytes)
	       DWORD address of directory
Note:	a null string is returned if the object is not open
SeeAlso: AH=12h/BX=0400h"APPLY",AH=12h/BH=83h

Format of TopView panel file:
Offset	Size	Description	(Table 00436)
 00h  2 BYTEs	C0h C3h
 02h	BYTE	number of panels in file
 03h	for each panel in file:
	    8 BYTEs  blank-padded panel name
	      DWORD  panel offset in file
	      WORD   panel length
	data for panels (each consists of one or more window/query/manager
	  streams); first byte of each panel must be 1Bh, fifth byte must be
	  E5h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH04" name="1512--BH04"><b>1512--BH04</b></a> - INT 15 - TopView - SEND MESSAGE - "READ" - READ NEXT LOGICAL LINE OF WINDOW<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "READ" - READ NEXT LOGICAL LINE OF WINDOW
	AH = 12h
	BH = 04h
	BL = window to read from
	    00h handle is DWORD on top of stack
	    01h use calling task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent task of current task
Return: STACK:	DWORD number of bytes read
		DWORD address of buffer
Notes:	reading starts at the current logical cursor position; the cursor is
	  updated to point at the character following the last one read
	any translucent blanks (FFh) which are visible on screen are changed
	  to the character which is seen through them
	the string produced by the read is placed in an input buffer which may
	  be reused by the next READ or READN of a window
	window stream opcodes D8h and D9h determine whether the read returns
	  characters or attributes
SeeAlso: AH=12h/BH=05h"WINDOW",AH=12h/BH=12h,AH=12h/BH=84h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH04_0" name="1512--BH04_0"><b>1512--BH04</b></a> - INT 15 - TopView - SEND MESSAGE - "READ" - GET NEXT RECORD FROM OBJECT<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "READ" - GET NEXT RECORD FROM OBJECT
	AH = 12h
	BH = 04h
	BL = object
	    00h handle is DWORD on top of stack
		mailbox: wait for and get next message
		keyboard: wait for and get pointer to next input buffer
		pointer: wait for and get next message
	    02h get next message from mailbox (task's handle on top of stack)
	    03h get next message from current task's mailbox
	    04h get the next input from keyboard (handle on top of stack)
	    05h get the next input from task's default keyboard
	    06h wait for input from any object in OBJECTQ (handle on stack)
	    07h wait for input from any object in task's default OBJECTQ
Return: STACK: (if objectq) DWORD handle of object with input
	       (otherwise)  DWORD number of bytes
			    DWORD address of pointer message (see #00437)
Notes:	for a keyboard in keystroke mode, the input buffer is a single byte
	  containing the character code as returned by the BIOS; the BIOS scan
	  code is available via the STATUS call if the character is zero
	for a keyboard in field mode, the input buffer format is determined
	  by the field table header for the window the keyboard is attached to
	keyboard input buffers and mailbox message buffers may be invalidated
	  by the next READ, ERASE, CLOSE, or FREE message to the same object
SeeAlso: AH=12h/BH=05h"OBJECT",AH=12h/BH=84h

Format of DESQview pointer message:
Offset	Size	Description	(Table 00437)
 00h	WORD	row
 02h	WORD	column
 04h	BYTE	status (see #00438)
 05h	BYTE	field number or zero (APILEVEL &gt;= 2.00 only)

Bitfields for DESQview pointer status:
Bit(s)	Description	(Table 00438)
 7-2	number of clicks-1 if multiple-click mode active
 7	set when press/release mode active and button pressed
 6	set when press/release mode active and button released
 1-0	button pressed (00=none,01=button1,10=button2)
SeeAlso: #00437

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BX0400" name="1512--BX0400"><b>1512--BX0400</b></a> - INT 15 - TopView - SEND MESSAGE - "READ" - WAIT FOR TIMER TO EXPIRE<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "READ" - WAIT FOR TIMER TO EXPIRE
	AH = 12h
	BX = 0400h
	STACK: DWORD timer's handle
Return: after timer expires
	STACK: DWORD time in 1/100 sec after midnight when timer expired
SeeAlso: AH=12h/BH=0Ah,AH=12h/BH=84h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BX0400_0" name="1512--BX0400_0"><b>1512--BX0400</b></a> - INT 15 - TopView - SEND MESSAGE - "APPLY" - WRITE PANEL TO WINDOW<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "APPLY" - WRITE PANEL TO WINDOW
	AH = 12h
	BX = 0400h
	STACK: DWORD handle of panel object
	       DWORD window's handle (or 0 for current task's window)
	       DWORD length of panel name
	       DWORD pointer to panel name
Return: STACK: DWORD handle of window which was used
	       DWORD handle of keyboard or 0
Notes:	status of APPLY may be checked with STATUS message
	panel MUST have the following format
	  first byte must be 1Bh (i.e. must start with a stream)
	  first opcode in stream must be E5h
	    single byte arg of opcode is interpreted thus:
	      bits 7,6	11 means create new window
			10 means create new field table for existing window
			01 means use existing window and field table
	      bit 5 if set, panel contains a field table
			(creates a new keyboard and puts it in field mode)
	      bit 4 if set, panel contains input fields
	      bit 3 if set, panel contains select fields but no input fields
	if the panel contains input or select fields, a keyboard handle is
	  returned; either the window's current open keyboard or a
	  newly-created keyboard object.  The caller should read that keyboard
	  to obtain input from the panel.
SeeAlso: AH=12h/BH=84h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH05" name="1512--BH05"><b>1512--BH05</b></a> - INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE TO OBJECT<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE TO OBJECT
	AH = 12h
	BH = 05h
	BL = object
	    00h handle is DWORD on top of stack
		timer: start timer to end at a specified time
		keyboard: add input buffer to queue
		pointer: move pointer icon to specified position
	    02h send message by value/status=0 to mbox (task's handle on stack)
	    03h send message by value/status=0 to current task's mailbox
	    04h add input buffer to KEYBOARD queue (handle on top of stack)
	    05h add input buffer to task's default KEYBOARD queue
	    06h add an object to OBJECTQ (handle on top of stack)
	    07h add an object to task's default OBJECTQ
	STACK: (if mailbox)  DWORD length
			     DWORD address
	       (if keyboard) DWORD status (scan code in keystroke mode)
			     DWORD length (should be 1 in keystroke mode)
			     DWORD address
	       (if objectq)  DWORD handle of object to add
	       (if timer)    DWORD 1/100ths seconds since midnight (actually
				   only accurate to 1/18 sec)
	       (if pointer)  DWORD column relative to origin of window
			     DWORD row relative to origin of window
Return: STACK popped
Notes:	under DV 2.2+, failed mailbox writes may return CF set (see AX=DE15h)
	the data and status written to a keyboard object must match the format
	  returned by the keyboard object in the current mode
	the pointer position is scaled according to the current scaling factors
SeeAlso: AH=12h/BH=04h,AH=12h/BH=85h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH05_0" name="1512--BH05_0"><b>1512--BH05</b></a> - INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE STRING TO WINDOW<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE STRING TO WINDOW
	AH = 12h
	BH = 05h
	BL = window to write to
	    00h DWORD on top of stack is window handle
	    01h write string to task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK: DWORD object handle if handle passed on stack
	       DWORD total length of string (high word == 0)
	       DWORD address of string to display (see #00439)
Return: indicated actions performed
	a. non-control characters are displayed (opcodes DEh and DFh control
	   whether the attributes are left or changed to the current attrib)
	b. CR/LF/BS/Tab cause the usual cursor movement
	c. ESC starts a data structure with additional commands if following
	   byte is less than 20h; otherwise, it is written to the window
	STACK:	DWORD handle of new window if window stream opcode E6h
		else nothing (arguments have been popped)
SeeAlso: AH=12h/BH=04h,AH=12h/BH=85h

Format of stream data structure:
Offset	Size	Description	(Table 00439)
 00h	BYTE	1Bh magic value identifying start of stream
 01h	BYTE	stream type (00h, 01h, 10h, 14h-1Fh legal)
		(see #00440,#00446,#00447,#00448)
 02h	WORD	length of remainder of stream in bytes
	var-length fields follow, each an OPCODE followed by
	     zero or more args

(Table 00440)
Values for MODE 00h (set or display values) "WINDOW STREAM" opcodes:
Opcodes:args
 00h  display 20h blanks with the default attribute
 01h-1Fh display OPCODE blanks with the default attribute
 20h  display char with default attribute 20h times
	BYTE char to repeat
 21h-3Fh display char with default attribute OPCODE-20h times
	BYTE char to repeat
 40h  display 20h blanks with specified attribute
	BYTE attribute of blanks
 41h-5Fh display OPCODE-40h blanks with specified attribute
	BYTE attribute of blanks
 60h  display next 20h characters
	20h BYTEs characters to display
 61h-7Fh display next OPCODE-60h characters
	N BYTEs characters to display
 80h-87h display N blanks with default attribute
	BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		  [000h means 800h]
 88h-8Fh display N copies of the character
	BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		  [000h means 800h]
	BYTE character to repeat
 90h-97h display N blanks with specified attribute
	BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		  [000h means 800h]
	BYTE attribute
 98h-9Fh display string at logical cursor pos
	BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		  [000h means 800h]
	N BYTEs string to display
 A0h  set logical cursor row
	BYTE row number (0 is top)
 A1h  set logical cursor column
	BYTE column number (0 is leftmost)
 A2h  set top edge of scrolling region
	BYTE row
 A3h  set left edge of scrolling region
	BYTE column
 A4h  set row of physical window position
	BYTE line
 A5h  set column of physical window position
	BYTE column
 A6h  set height of physical window
	BYTE number of rows
 A7h  set width of physical window
	BYTE number of columns
 A8h  set viewport row
	BYTE row
 A9h  set viewport column
	BYTE column
 AAh  set virtual screen height [contents of window unpredictable after]
	BYTE rows
 ABh  set virtual screen width [contents of window unpredictable after]
	BYTE columns
 ACh-AEh unused
 AFh  set compatible/preferred video modes
	BYTE compatibility/preference mask
		bit 7	compatible with monochrome
		bit 6	compatible with color text, EGA/VGA graphics
		bit 5	compatible with medium-resolution CGA graphics
		bit 4	compatible with high-resolution CGA graphics
		bit 3	prefer monochrome
		bit 2	prefer color text, EGA/VGA graphics
		bit 1	prefer medium-resolution CGA graphics
		bit 0	prefer high-resolution CGA graphics
 B0h  move logical cursor down
	BYTE number of rows (signed, negative values move up)
		[if rows=0 and hardware cursor owner, update hardware cursor]
 B1h  move logical cursor right
	BYTE number of columns (signed, negative values move left)
		[if cols=0 and hardware cursor owner, update hardware cursor]
 B2h  shift top edge of scrolling region
	BYTE number of rows (signed)
 B3h  shift left edge of scrolling region
	BYTE number of columns (signed)
 B4h  shift physical window down
	BYTE number of lines (signed)
 B5h  shift physical window right
	BYTE number of columns (signed)
 B6h  expand physical window vertically
	BYTE number of lines (signed)
 B7h  expand physical window horizontally
	BYTE number of columns (signed)
 B8h  adjust viewport row
	BYTE number of rows (signed)
 B9h  adjust viewport column
	BYTE number of columns (signed)
 BAh  adjust virtual screen height [contents of window unpredict after]
	BYTE number of rows to increase (signed)
 BBh  adjust virtual screen width [contents of window unpredictbl after]
	BYTE number of columns to increase (signed)
 BCh-BFh reserved (currently unused)
 C0h  set logical cursor position
	BYTE row number (0 is top border)
	BYTE column number (0 is left border)
 C1h  set top left corner of scrolling region
	BYTE row
	BYTE column
 C2h  set physical window pos
	BYTE upper left row (no top border if 0)
	BYTE upper left column (no left border if 0)
 C3h  set current window size
	BYTE number of rows
	BYTE number of columns
 C4h  set upper left corner of viewport (portion of virtual screen displayed
	  in window)
	BYTE row
	BYTE column
 C5h  set size of virtual screen [contents unpredictable afterwards]
	BYTE number of rows
	BYTE number of columns
 C6h  unused
 C7h  unused
 C8h  set logical cursor relative to current position
	BYTE number of rows to move down (signed)
	BYTE number of columns to move right (signed)
		[if rows=cols=0 and hardware cursor owner, update hardw cursor]
 C9h  shift top left corner of scrolling region
	BYTE number of rows (signed)
	BYTE number of columns (signed)
 CAh  set window pos relative to current position
	BYTE number of rows to shift down (signed)
	BYTE number of columns to shift right (signed)
 CBh  set window size relative to current size
	BYTE number of rows to expand (signed)
	BYTE number of cols to expand (signed)
 CCh  shift viewport relative to current position
	BYTE rows to shift (signed)
	BYTE cols to shift (signed)
 CDh  resize virtual screen
	BYTE number of rows to expand (signed)
	BYTE number of columns to expand (signed)
 CEh  scroll text when using E8h-EBh/F8h-FBh opcodes (default)
 CFh  scroll attributes when using  E8h-EBh/F8h-FBh opcodes
 D0h  allow window frame to extend beyond screen
 D1h  always display a complete frame, even if window extends beyond edge of
	  screen
 D2h  allow DV to change logical colors on video mode switch (default)
 D3h  application changes logical attributes
 D4h  window is visible [must redraw to actually make visible]
 D5h  window is hidden [must redraw to actually remove]
 D6h  window has frame (default)
 D7h  window unframed [must redraw to actually remove frame]
 D8h  READ/READN will read characters from window (default)
 D9h  READ/READN will read attributes from window
 DAh  use logical attributes, which may be remapped (see #00441)
 DBh  use physical attributes for characters
 DCh  enable special actions for control characters (default)
 DDh  disable special control char handling, all chars displayable by BIOS TTY
	  call
 DEh  write both character and attribute (default)
 DFh  write character only, leave attribute untouched
 E0h  repeat following commands through E1h opcode
	BYTE number of times to repeat (00h means 256 times)
 E1h  end of commands to repeat, start repeating them
 E2h  set current output color
	BYTE color
 E3h  clear virtual screen from scroll origin to end using current color
 E4h  redraw window
 E5h  select menu style
	BYTE style (normally 18h)
		bits 5,4 = 01 use two-letter menu entries for remainder of
		  this stream
 E5h  (panel file only)
	BYTE modifier
		bits 7,6 = 11 panel stream creates new window
			 = 10 panel defines new field table for existing window
			 = 01 panel stream uses existing window & field table
		bit 5 = 1 stream contains a field table (create kyboard object)
		bit 4 = 1 stream defines input fields (create keyboard object)
		bit 3 = 1 stream defines select fields but not input fields
		bit 2 = 1 stream defines exclusive input window (DV 2.2)
		bit 1 reserved
		bit 0 reserved
 E6h  create new window and perform rest of manipulations in new window
	BYTE number of rows
	BYTE number of columns
	Return: DWORD object handle of new window returned on stack at end
	Note:	the window is created with a physical size of 0x0 at the
		  same position as the window to which this stream was sent
 E7h  no operation
 E8h  scroll area up (top left corner defined by opcode C1h)
	BYTE height
	BYTE width
 E9h  scroll area down (top left corner defined by opcode C1h)
	BYTE height
	BYTE width
 EAh  scroll area left (top left corner defined by opcode C1h)
	BYTE height
	BYTE width
 EBh  scroll area right (top left corner defined by opcode C1h)
	BYTE height
	BYTE width
 ECh  set logical attributes for window contents
	BYTE video modes command applies to
		bit 7	monochrome
		bit 6	color text, EGA/VGA graphics
		bit 5	medium-resolution CGA graphics
		bit 4	high-resolution CGA graphics
	BYTE which attributes to set
		bit 7	if set, copy single following byte to indicated attribs
		bits 4-6  number of first attribute to change - 1
		bits 0-3  number of consecutive attributes to change
	N BYTEs new attributes
 EDh  set logical attributes for window frame
	BYTE video modes command applies to (also see opcode ECh)
	BYTE which attributes to set
		bit 7	if set, copy single following byte to indicated attrs
		bits 4-6  number of first attribute to change - 1
		bits 0-3  number of consecutive attributes to change
	N BYTEs new attributes
		  attributes
		       1 = top left corner
		       2 = top right corner
		       3 = bottom left corner
		       4 = bottom right corner
		       5 = top edge
		       6 = bottom edge
		       7 = left edge
		       8 = right edge
 EEh  set characters for window frame
	BYTE video modes command applies to (also see opcode ECh)
	BYTE which characters to set
		bit 7	if set, copy single following byte to indicated chars
		bits 4-6  number of first character to change - 1
		bits 0-3  number of consecutive characters to change
	N BYTEs new chars (same relative position as attributes above)
 EFh  set window name
	BYTE length of name (should be in range 0 to logical screen width)
	N BYTEs name
 F0h  clear input field to blanks
	BYTE field number
 F1h  fill input field with character
	BYTE field number
	BYTE char
 F2h  set color of input field
	BYTE field number (1-N)
	BYTE attribute
 F3h  set initial contents of input field
	BYTE field number (1-N)
	N BYTEs enough chars to exactly fill field as defined by op FFh
 F4h  position cursor to start of specific input field
	BYTE field number (1-N)
 F5h  change field table entry
	BYTE field number
	7-8 BYTEs field table entry (also see opcode FFh below)
 F6h  set field type
	BYTE field number
	BYTE type
		00h inactive
		40h output field
		80h input field
		C0h deselected field
		C2h selected field
 F7h  "broadcast write"	write data to fields with program output bit set in
	  the field table entry, in field number order
	N BYTEs (total length of all program output fields)
 F8h  scroll field up a line
	BYTE field number
 F9h  scroll field down a line
	BYTE field number
 FAh  scroll field left
	BYTE field number
 FBh  scroll field right
	BYTE field number
 FCh  set field table header
	6 BYTEs	field table header (see #00442)
 FDh  reset modified bit for all fields
 FEh  reset selected and modified bits for all fields
 FFh  set up input fields
	6 BYTEs	table header (see #00442)
	7/8N BYTEs the field table entries, one for each field (see #00444)
	Note:	DESQview uses and updates the actual copy of the information
		  which is contained in the stream.  Thus this info must remain
		  intact until after the data entry is complete.
SeeAlso: #00439,#00446

(Table 00441)
Values for TopView logical attributes:
 01h	normal text
 02h	highlighted normal text
 03h	help text
 04h	highlighted help text
 05h	error message
 06h	highlighted error message
 07h	emphasized text
 08h	marked text
 9-16	reverse video versions of 1-8
SeeAlso: #00440

Format of TopView field table header:
Offset	Size	Description	(Table 00442)
 00h	BYTE	number of fields (must be &lt;= existing number of fields)
 01h	BYTE	screen behavior bits (see #00443)
 02h	BYTE	current input field (updated by DESQview)
 03h	BYTE	current select field (updated by DESQview)
 04h	BYTE	attribute for select fields when they are pointed at
 05h	BYTE	attribute for select fields which have been selected
SeeAlso: #00440,#00444

Bitfields for TopView screen behavior bits:
Bit(s)	Description	(Table 00443)
 7	reserved
 6	menu items may be selected via keyboard
 5	left mouse button in "status" mode (press anywhere in window
	  immediately returns control to application)
 4	right mouse button in "status" mode
 3	select fields return contents or blanks rather than 'Y' or 'N'
 2	modified bits reset on return to application
 1-0	type of data returned
	00 no data returned on read of keyboard
	01 data returned as array of characters containing all fields packed
	      together, with no field numbers
	10 data returned as numbered variable-length records for all fields
	11 data returned as numbered variable-length records for the fields
	      which were modified
SeeAlso: #00440

Format of TopView field table entry:
Offset	Size	Description	(Table 00444)
 00h	BYTE	start row    \
 01h	BYTE	start column  \ if menu selection and start is to
 02h	BYTE	end row	      / right or below end, select from kbd only
 03h	BYTE	end column   /
 04h	BYTE	field type (see #00445)
 05h	BYTE	modifier
		if type is fill-in, then bit flags to determine behavior
		  bit 7	 automatically enter CR when field full
		  bit 6	 move to next field when current field is full
		  bit 5	 enter text from right end (for numbers)
		  bit 4	 force input to uppercase
		  bit 3	 clear old contents on first keystroke
		  bit 2	 input returned when cursor moves out of
			  modified field ("validate", API level 2.02+)
		  bit 1	 reserved
		  bit 0	 reserved
		if select field, first key to press to activate
		  00h if have to point-&-click or is an extended-ASCII
		      keystroke (only if two-key menus enabled)
 06h	BYTE	(select field only) normal color of field
 07h	BYTE	second key for select field.  This byte is present iff
		  two-letter menu entries selected with opcode E5h, and in that
		  case is present regardless of field type
SeeAlso: #00442

Bitfields for TopView field type:
Bit(s)	Description	(Table 00445)
 7,6	field class
	00 inactive (non-entry) field
	01 echos keystrokes input to make menu selection
	10 fill-in field
	11 select field
 5	field can be filled by broadcast write (F7h opcode)
 4	reserved
 3	reserved
 2	reserved
 1	set if field selected
 0	set if field modified
SeeAlso: #00444

(Table 00446)
Values for MODE 01h "QUERY STREAM" opcodes:
(valid only for those opcodes listed here)
 A0h return logical cursor row in next byte
 A1h return logical cursor column in next byte
 A2h return top row of scrolling region in next byte
 A3h return left column of scrolling region in next byte
 A4h return row of physical window origin in next byte
 A5h return column of physical window origin in next byte
 A6h return height of physcial window in next byte
 A7h return width of physical window in next byte
 A8h return row of viewport origin in next byte
 A9h return column of viewport origin in next byte
 AAh return height of virtual screen in next byte
 ABh return width of virtual screen in next byte
 AFh return current video mode in next byte
 C0h return current logical cursor position in next two bytes
 C1h return top left corner of scrolling region in next two bytes
 C2h return current window position in next two bytes
 C3h return current window size in next two bytes
 C4h return current viewport origin in next two bytes
 C5h return current virtual screen size in next two bytes
 D0h \ overwritten with D0h if frames may fall off screen edge
 D1h /		       D1h if frames always displayed entirely
 D2h \ overwritten with D2h if DESQview controls color palette
 D3h /		       D3h if application changes color palette
 D4h \ overwritten with D4h if window visible
 D5h /		       D5h if window hidden
 D6h \ overwritten with D6h if window has frame
 D7h /		       D7h if window unframed
 D8h \ overwritten with D8h if reading characters from window
 D9h /		       D9h if reading attributes from window
 DAh \ overwritten with DAh if using logical attributes
 DBh /		       DBh if using physical attributes
 DCh \ overwritten with DCh if TTY control char interpretation on
 DDh /		       DDh if TTY control char interpretation off
 DEh \ overwritten with DEh if writing both characters and attributes
 DFh /		       DFh if leaving attributes untouched
 E2h return current color in next byte
 ECh get logical attributes for window contents
	BYTE execute call if currently in specified video mode
		bit 7	monochrome
		bit 6	color text, EGA/VGA graphics
		bit 5	medium-resolution CGA graphics
		bit 4	high-resolution CGA graphics
	BYTE which attributes to get
		bit 7	unused???
		bits 4-6 first attribute to get - 1
		bits 0-3 number of consecutive attributes
	N BYTEs buffer to hold attributes
 EDh get logical attributes for window frame
	BYTE execute call if currently in video mode (also see opcode ECh)
	BYTE which attributes to get
		bit 7	unused???
		bits 4-6 first attribute to get - 1
		bits 0-3 number of consecutive attributes
	N BYTEs buffer to hold attributes
 EEh get characters for window frame
	BYTE execute call if currently in video mode (also see opcode ECh)
	BYTE which attributes to get
		bit 7	unused???
		bits 4-6 first char to get - 1
		bits 0-3 number of consecutive chars
	N BYTEs buffer to hold chars
 EFh return first N characters of current window name
	BYTE	max length of returned name
	N BYTEs buffer to hold window name
 F3h return contents of specified field
	BYTE field number
	N BYTEs buffer to hold field contents (size equal to field size)
 F5h get field table entry
	BYTE field number
	7-8 BYTEs buffer to hold field table entry (see #00444)
	Notes:	DV &lt; 2.26 always returns 7 bytes
		DV 2.26+ w/ APILEVEL &lt; 2.26 returns 8 bytes iff field table
		  is using 8-byte entries and eighth byte after	F5h is E7h
		  (NOP); otherwise, 7 bytes are returned
		DV 2.26+ w/ APILEVEL &gt; 2.26 returns 7 or 8 bytes depending
		  on the field table entry size
 F6h get type of a field
	BYTE field number
	BYTE type
 FCh get field table header
	6 BYTEs buffer to store field table header (see #00442)
SeeAlso: #00439,#00447

(Table 00447)
Values for MODE 10h "MANAGER STREAM" opcodes (valid only for those listed):
 00h allow window to be moved horizontally
 01h allow window to be moved vertically
 02h allow window to change width
 03h allow window to change height
 04h allow window to be scrolled horizontally
 05h allow window to be scrolled vertically
 06h allow "Close Window" menu selection for application
 07h allow "Hide Window" menu selection for application
 08h allow application to be suspended ("Rearrange/Freeze")
 0Eh allow "Scissors" menu
 10h allow DESQview main menu to be popped up
 11h allow "Switch Windows" menu
 12h allow "Open Window" menu
 13h allow "Quit" menu selection
 20h-33h opposite of 00h-13h, disallow specified action
 40h notify if horizontal position of window changes
 41h notify if vertical position of window changes
 42h notify if width of window changes
 43h notify if height of window changes
 44h notify if window scrolled horizontally
 45h notify if window scrolled vertically
 46h notify if window is closed--program has to clean up and exit itself
 47h notify if window is hidden
 48h notify if "?" on main menu selected
 49h notify if pointer message sent to window
 4Ah notify if window is placed in foreground
 4Bh notify if window is placed in background
 4Ch notify if video mode changes
 4Dh notify if "Scissors" menu "Cut" option selected
 4Eh notify if "Scissors" menu "Copy" option selected
 4Fh notify if "Scissors" menu "Paste" option selected
 50h notify if DESQview main menu about to pop up
 51h notify if DESQview main menu popped down
 60h-71h	 opposite of 40h-51h: don't notify on specified event
 84h attach window to parent task's window (both move together)
 85h detach window from parent task's window (may move independently)
 86h disable background operation for application
 87h enable running in background
 88h set minimum size of physical window
	BYTE rows
	BYTE columns
 89h set maximum size of physical window
	BYTE rows
	BYTE cols
 8Ah set primary asynchronous notification routine (see #00449)
	DWORD address of routine, 0000h:0000h means none (see also below)
 8Bh set async notification parameter
	DWORD 32-bit value passed to 8Ah async routine in DS:SI
 ACh (DV2.2+) perform regular select field attribute processing
 ADh (DV2.2+) protect attributes in selected field from being lost
 AEh make window default notify window for owning app (API level 2.00+)
 AFh set selected field marker character
	BYTE character to display at left edge of selected fields
 BCh set standard field processing mode
 BDh set alternate field processing mode (enables cursor pad for menus)
 BEh disables changing reverse logical attributes with ECh opcode
 BFh enables changing reverse logical attributes with ECh opcode
 C0h make current window topmost in system
 C1h force current process into foreground
 C2h make current window topmost in process
 C3h position mouse pointer relative to origin of current field
	BYTE rows below upper left corner of field
	BYTE columns to right of upper left corner of field
 C4h position mouse pointer relative to origin of given field
	BYTE field number
	BYTE rows below upper left corner of field
	BYTE columns to right of upper left corner of field
 C5h orphan current window (also hides it)
	Note: must be last in stream; all subsequent commands ignored
 C6h show all windows for this process
 C7h hide all windows for this process
 C8h suspend process and hide all its windows
 C9h force current process into background
 CAh make current window bottom-most in process
 CBh cancel current window manager operation, remove DV menu, give control
	  to topmost application
 CCh orphan window and give it to the system for use as paste data
 CEh reorder windows
	DWORD pointer to null-terminated list of words; each word is segment
		  of object handle for a window
 FFh no operation
SeeAlso: #00439,#00446,#00448

(Table 00448)
Values for MODES 14h to 1Fh "USER STREAMS":
	normally NOPs, but may be defined by SETESC message to invoke FAR
	routines, one for each mode number
	  on entry to handler,
		DS:SI -&gt; first byte of actual stream (not header)
		CX = number of bytes in stream
		ES:DI = window's handle
SeeAlso: #00446,#00447

(Table 00449)
Values asynchronous notification routine defined by man.stream 8Ah called with:
	ES:DI = handle of window
	DS:SI is 32-bit value set by 8Bh manager stream opcode
	   mailbox contains message indicating event
	      Opcode
	       40h  horizontal movement
		   DWORD object handle of window
		   BYTE	 new row
		   BYTE	 new col
	       41h  vertical movement
		   DWORD object handle of window
		   BYTE	 new row
		   BYTE	 new col
	       42h  horizontal size change
		   DWORD object handle of window
		   BYTE	 new rows
		   BYTE	 new cols
	       43h  vertical size change
		   DWORD object handle of window
		   BYTE	 new rows
		   BYTE	 new cols
	       44h  scrolled horizontally
		   DWORD object handle of window
		   BYTE	 mouse row within window
		   BYTE	 mouse column within window
		   BYTE	 field mouse is on, 0 if none
		   BYTE	 amount moved: &gt;0 right, &lt;0 left, 0 done
	       45h  scrolled vertically
		   DWORD object hande of window
		   BYTE	 mouse row within window
		   BYTE	 mouse column within window
		   BYTE	 field mouse is on, 0 if none
		   BYTE	 amount moved: &gt;0 down, &lt;0 up, 0 done
	       46h  window close request
		   DWORD object handle of window
		   BYTE	 mouse pointer row
		   BYTE	 mouse pointer column
		   BYTE	 field mouse is on, 0 if none
	       47h  application's windows hidden
	       48h  Help for Program selected
		   DWORD object handle of window
		   BYTE	 mouse pointer row
		   BYTE	 mouse pointer column
		   BYTE	 field mouse is on, 0 if none
	       49h  pointer message sent to window
		   DWORD pointer handle which received message
	       4Ah  switched to window from another ("raise")
	       4Bh  switched away from the window ("lower")
	       4Ch  video mode changed
		   BYTE new BIOS video mode
	       4Dh  Scissors/cUt selected
		   DWORD object handle of window
		   BYTE	 row of upper left corner
		   BYTE	 column of upper left corner
		   BYTE	 field number ul corner is in, 0=none
		   DWORD handle of orphaned window created with
			 copy of data from specified region
		   BYTE	 height of region
		   BYTE	 width of region
	       4Eh  Scissors/Copy selected
		   DWORD object handle of window
		   BYTE	 row of upper left corner
		   BYTE	 column of upper left corner
		   BYTE	 field number ul corner is in, 0=none
		   DWORD handle of orphaned window created with
			 copy of data from specified region
		   BYTE	 height of region
		   BYTE	 width of region
	       4Fh  Scissors/Paste selected
		   DWORD object handle of window
		   BYTE	 row of upper left corner
		   BYTE	 column of upper left corner
		   BYTE	 field number ul corner is in, 0=none
		   DWORD handle of orphaned window with data
		   BYTE	 height of region
		   BYTE	 width of region
			Note: orphaned data window should be adopted or freed
				when done
	       50h  main menu about to pop up
	       51h  main menu popped down
Return: all registers unchanged

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH06" name="1512--BH06"><b>1512--BH06</b></a> - INT 15 - DESQview 2.20+ - SEND MESSAGE - "SETPRI" - SET PRIORITY WITHIN OBJECTQ<br />
<pre>
INT 15 - DESQview 2.20+ - SEND MESSAGE - "SETPRI" - SET PRIORITY WITHIN OBJECTQ
	AH = 12h
	BH = 06h
	BL = object
	    00h object handle in DWORD on top of stack
		mailbox, keyboard, pointer, or timer
		(DV 2.50+) window
	    01h (DV 2.50+) current task's window
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's default keyboard
	STACK: DWORD new priority of object in task's OBJECTQ
			(new priority of task if window handle)
Return: STACK popped
Notes:	initially all objects have the same default value.  Should only make
	  relative adjustments to this default value.
	when changing priorities, all objects already on the objectq are
	  reordered
	for window handles, only the non-blocked task(s) with the highest
	  priority receive CPU time under DESQview 2.50-2.52; the default
	  priority is 0Ah
SeeAlso: AH=12h/BH=07h,AH=12h/BH=87h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH07" name="1512--BH07"><b>1512--BH07</b></a> - INT 15 - DESQview 2.20+ - SEND MESSAGE - "GETPRI" - GET PRIORITY WITHIN OBJECTQ<br />
<pre>
INT 15 - DESQview 2.20+ - SEND MESSAGE - "GETPRI" - GET PRIORITY WITHIN OBJECTQ
	AH = 12h
	BH = 07h
	BL = object
	    00h object handle in DWORD on top of stack
		mailbox, keyboard, pointer, or timer
		(DV 2.50+) window
	    01h (DV 2.50+) current task's window
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's default keyboard
Return: STACK: DWORD object priority
Note:	initially all objects have the same default value.  Should only make
	  relative adjustments to this default value.
SeeAlso: AH=12h/BH=06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH08" name="1512--BH08"><b>1512--BH08</b></a> - INT 15 - TopView - SEND MESSAGE - "SIZEOF" - GET OBJECT SIZE<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "SIZEOF" - GET OBJECT SIZE
	AH = 12h
	BH = 08h
	BL = object
	    00h handle in DWORD on top of stack
		window: total character positions in window
		timer: elapsed time since timer started
		pointer: number of messages queued to pointer object
		panel: number of panels in panel file
		keyboard: number of input buffers queued
	    01h total chars in current task's default window
	    02h number of messages in task's mailbox (task's handle on stack)
	    03h number of messages in current task's mailbox
	    04h number of input buffers queued in task's kbd (handle on stack)
	    05h number of input buffers queued for current task's default kbd
	    06h number of objects queued in OBJECTQ (task's handle on stack)
	    07h number of objects queued in current task's OBJECTQ
	    0Ch (DV 2.26+) total chars in window owning handle on top of stack
	    0Dh (DV 2.26+) total chars in parent task's window
Return: DWORD on top of stack is result (any handle on stack has been popped)
Note:	for panel objects, a count of zero is returned if no panel file is open
	  for the object
SeeAlso: AH=12h/BH=04h,AH=12h/BH=09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH09" name="1512--BH09"><b>1512--BH09</b></a> - INT 15 - TopView - SEND MESSAGE - "LEN" - GET OBJECT LENGTH<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "LEN" - GET OBJECT LENGTH
	AH = 12h
	BH = 09h
	BL = object
	    00h handle in DWORD on top of stack
		window: get chars/line
		timer: get 1/100 seconds remaining before timer expires
		mailbox: (DV/X) get number of bytes queued to mailbox
	    01h get number of chars/line in current task's default window
	    0Ch (DV 2.26+) get chars/line in window owning handle on top of stk
	    0Dh (DV 2.26+) get chars/line in parent task's window
Return: DWORD on top of stack is length (any handle on stack has been popped)
SeeAlso: AH=12h/BH=08h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH0A" name="1512--BH0A"><b>1512--BH0A</b></a> - INT 15 - TopView - SEND MESSAGE - "ADDTO" - WRITE CHARS AND ATTRIBS TO WINDOW<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "ADDTO" - WRITE CHARS AND ATTRIBS TO WINDOW
	AH = 12h
	BH = 0Ah
	BL = window to write to
	    00h window handle is DWORD on top of stack
	    01h current task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK:	DWORD count of attributes
		DWORD address of attribute string
		DWORD count of characters
		DWORD address of character string
Return: STACK popped
Notes:	if one string is longer than the other, the shorter one will be reused
	  until the longer one is exhausted
	the cursor is left just after the last character written
SeeAlso: AH=12h/BH=0Bh"WINDOW"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH0A_0" name="1512--BH0A_0"><b>1512--BH0A</b></a> - INT 15 - TopView - SEND MESSAGE - "ADDTO" - SEND MAILBOX MESSAGE/STAT BY VALUE<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "ADDTO" - SEND MAILBOX MESSAGE/STAT BY VALUE
	AH = 12h
	BH = 0Ah
	BL = mailbox to write to
	    00h handle is DWORD on top of stack
	    02h default mailbox of task whose handle is on top of stack
	    03h current task's default mailbox
	STACK:	DWORD	status (low byte)
		DWORD	length of message
		DWORD	address of message
Return: STACK popped
Notes:	the message is copied into either system or common memory
	insufficient memory normally causes the process to be aborted; under
	  DESQview 2.2+, failed writes may return CF set instead (see AX=DE15h)
SeeAlso: AH=12h/BH=0Bh"MAILBOX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH0A_1" name="1512--BH0A_1"><b>1512--BH0A</b></a> - INT 15 - TopView - SEND MESSAGE - "ADDTO" - SET OBJECT BITS<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "ADDTO" - SET OBJECT BITS
	AH = 12h
	BH = 0Ah
	BL = object
	    00h handle is DWORD on top of stack
		timer: start timer for specified interval
		pointer: set control flags (see #00451)
		keyboard: set control flags (see #00450)
	    04h set control flags on KEYBOARD object (handle on top of stack)
	    05h set control flags on task's default KEYBOARD object
	STACK: (if timer)   DWORD duration in 1/100 seconds
	       (otherwise)  DWORD bits to set
Return: STACK popped
SeeAlso: AH=12h/BH=0Bh"OBJECT"

Bitfields for DESQview keyboard object bits:
Bit(s)	Description	(Table 00450)
 15	reserved, can't be set
 14	unused
 13	reserved, can't be set
 12-6	unused
 5	(DV 2.2+) exclusive input
 4	filter all keys (used with handler established by SETESC)
	if 0, only keys that would normally be displayed are filtered
 3	program continues executing while input in progress
 2	insert mode active for field mode
 1	hardware cursor displayed when task is hardware cursor owner
	must be set if keyboard in field mode and field table includes input
	  fields
 0	keyboard is in field mode rather than keystroke mode

Bitfields for DESQview pointer object bits:
Bit(s)	Description	(Table 00451)
 15	reserved, can't be set
 14-8	unused
 7	mouse pointer is hidden while in window
 6	get messages even if window not topmost
 5	get messages even if window not foreground
 4	multiple clicks separated by less than 1/3 second are counted and
	  returned in a single message
 3	pointer position is relative to screen origin, not window origin
 2	send message on button release as well as button press
 1	(DV 2.23+) send message with row=FFFFh and col=FFFFh whenever the
	  pointer leaves the window
 0	send message only on button activity, not movement
	DV-specific, and INT 15/AX=DE0Fh must have been called first

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH0B" name="1512--BH0B"><b>1512--BH0B</b></a> - INT 15 - TopView - SEND MESSAGE - "SUBFROM" - WRITE ATTRIBUTES TO WINDOW<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - WRITE ATTRIBUTES TO WINDOW
	AH = 12h
	BH = 0Bh
	BL = window to write attributes to
	    00h handle is DWORD on top of stack
	    01h current task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK:	DWORD number of attributes to write
		DWORD address of attributes
Return: STACK popped
Note:	the attributes are written starting at the current cursor position; the
	  cursor is left just after the last position written
SeeAlso: AH=12h/BH=0Ah"WINDOW"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH0B_0" name="1512--BH0B_0"><b>1512--BH0B</b></a> - INT 15 - TopView - SEND MESSAGE - "SUBFROM" - SEND MAILBOX MESSAGE/STAT BY REF<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - SEND MAILBOX MESSAGE/STAT BY REF
	AH = 12h
	BH = 0Bh
	BL = mailbox to write to
	    00h handle is DWORD on top of stack
	    02h default mailbox of task whose handle is on top of stack
	    03h current task's default mailbox
	STACK:	DWORD	status (low byte)
		DWORD	length of message
		DWORD	address of message
Return: STACK popped
Notes:	only a pointer to the message is stored, but the write may still fail
	  due to insufficient memory
	under DV 2.2+, failed mailbox writes may return CF set (see AX=DE15h)
SeeAlso: AH=12h/BH=0Ah"MAILBOX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH0B_1" name="1512--BH0B_1"><b>1512--BH0B</b></a> - INT 15 - TopView - SEND MESSAGE - "SUBFROM" - REMOVE OBJECT FROM OBJECTQ<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - REMOVE OBJECT FROM OBJECTQ
	AH = 12h
	BH = 0Bh
	BL = OBJECTQ from which to remove all copies of a particular object
	    06h OBJECTQ of task whose handle is on top of stack
	    07h task's default OBJECTQ
	STACK:	DWORD	handle of object to remove
Return: STACK popped
Note:	should be sent whenever an object is erased or closed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH0B_2" name="1512--BH0B_2"><b>1512--BH0B</b></a> - INT 15 - TopView - SEND MESSAGE - "SUBFROM" - RESET OBJECT BITS<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - RESET OBJECT BITS
	AH = 12h
	BH = 0Bh
	BL = object
	    00h handle is DWORD on top of stack
		pointer: reset control flags
		keyboard: reset control flags
	    04h clear control flags on KEYBOARD object (handle on top of stack)
	    05h clear control flags on task's default KEYBOARD object
	STACK:	DWORD	which bits to clear (see #00450,#00451)
Return: STACK popped
SeeAlso: AH=12h/BH=0Ah"OBJECT"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH0C" name="1512--BH0C"><b>1512--BH0C</b></a> - INT 15 - TopView - SEND MESSAGE - "OPEN" - OPEN OBJECT<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "OPEN" - OPEN OBJECT
	AH = 12h
	BH = 0Ch
	BL = object
	    00h handle is DWORD on top of stack
		window:	  fill with given character from scroll origin to end
		keyboard: attach to a window
		timer:	  open
		pointer:  start taking input for window
		panel:	  associate with a panel file
	    01h fill task's default window with given char from scrl org to end
	    02h open given task's mailbox for input (task's handle on stack)
	    03h open current task's mailbox
	    04h attach a KEYBOARD to a window (handle on top of stack)
	    05h attach task's default KEYBOARD to a window
	    06h open a task's OBJECTQ (task's handle on top of stack)
	    07h open current task's OBJECTQ
	    0Ch (DV 2.26+) fill def window of task owning handle on top of stck
	    0Dh (DV 2.26+) fill default window of parent of current task
	 STACK: (if window)   DWORD character to fill with
		(if keyboard) DWORD handle of window to attach to
		(if pointer)  DWORD handle of window to attach to
		(if panel)    DWORD length of filename or resident panel
			      DWORD address of filename or resident panel
		(otherwise)   nothing
Return: STACK popped
Notes:	if first byte of panel file name is 1Bh, then the "name" IS a panel
	if first two bytes of panel file "name" are C0hC3h, then the "name" IS
	  the panel file
	result code of open may be retrieved with STATUS message
	logical cursor is left at scroll origin after filling window
	the task opening a mailbox becomes its owner, and the only task allowed
	  to read the mailbox
	messages are only sent to a pointer object when the mouse is positioned
	  in the window to which the pointer has been attached
	there is no need to explicitly open a timer object, as ADDTO and WRITE
	  messages automatically open the timer
SeeAlso: AH=12h/BH=0Dh,AH=12h/BH=14h"LOCK"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH0D" name="1512--BH0D"><b>1512--BH0D</b></a> - INT 15 - TopView - SEND MESSAGE - "CLOSE" - CLOSE OBJECT<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "CLOSE" - CLOSE OBJECT
	AH = 12h
	BH = 0Dh
	BL = object
	    00h handle is DWORD on top of stack
		timer:	  close
		keyboard: detach from window and discard queued input
		pointer:  stop taking input
		panel:	  close
		mailbox:  close, unlock, and discard any pending messages
	    02h close given task's mailbox (task's handle on top of stack)
	    03h close task's default mailbox
	    04h close KEYBOARD object (handle on top of stack)
	    05h close task's default KEYBOARD
	    06h close given task's OBJECTQ (task's handle on top of stack)
	    07h close current task's OBJECTQ
Return: STACK popped if handle passed on stack
Notes:	when an OBJECTQ is closed, each object in the OBJECTQ is sent an
	  ERASE message (AH=12h/BH=0Eh)
	when a panel object is closed, the panel file and any panels currently
	  in use are freed; window and keyboard objects created by APPLY are
	  not affected, but field mode input ceases
	open but idle timer objects consume a small amount of CPU time
SeeAlso: AH=12h/BH=0Ch,AH=12h/BH=0Eh,AH=12h/BH=14h"LOCK"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH0E" name="1512--BH0E"><b>1512--BH0E</b></a> - INT 15 - TopView - SEND MESSAGE - "ERASE" - ERASE OBJECT<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "ERASE" - ERASE OBJECT
	AH = 12h
	BH = 0Eh
	BL = object
	    00h handle is DWORD on top of stack
		window:	  clear from scroll origin to end of window
		keyboard: discard input
		timer:	  cancel current interval
		pointer:  discard all pending messages
		mailbox:  discard all pending messages
	    01h clear task's default window from scroll origin to end
	    02h discard all queued messages in mailbox (handle on top of stack)
	    03h discard all queued messages in current task's default mailbox
	    04h discard all input queued to KEYBOARD (handle on top of stack)
	    05h discard all input queued to task's default KEYBOARD
	    06h remove all objects from OBJECTQ (task's handle on top of stack)
	    07h remove all objects from current task's OBJECTQ
	    0Ch (DV 2.26+) clear window of task owning handle on top of stack
	    0Dh (DV 2.26+) clear default window of parent of current task
Return: STACK popped if handle passed on stack
Note:	when an OBJECTQ is erased, each object in the OBJECTQ is also erased
SeeAlso: AH=12h/BH=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH0F" name="1512--BH0F"><b>1512--BH0F</b></a> - INT 15 - TopView - SEND MESSAGE - "STATUS" - GET OBJECT STATUS<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "STATUS" - GET OBJECT STATUS
	AH = 12h
	BH = 0Fh
	BL = object
	    00h handle is DWORD on top of stack
		timer:	 is it running?
		pointer: return status of last message
		panel:	 verify success of last OPEN or APPLY
	    02h return status of last msg READ from mailbox (handle on stack)
	    03h return status of last msg READ from task's default mailbox
	    04h get stat of last msg from task's KEYBOARD (task handle on stk)
	    05h get status of last msg from task's default KEYBOARD
	    06h return whether OBJECTQ is open or not (handle on top of stack)
	    07h return whether task's default OBJECTQ is open or not
Return: DWORD on top of stack is status (any handle passed on stack popped)
Notes:	if object is a panel object, the status indicates the error code:
	  00h successful
	  14h panel name not in panel directory
	  15h not enough memory to apply panel
	  16h invalid panel format
	  17h panel file already open
	  81h-92h  DOS error codes+80h			\  codes &gt; 80h indicate
	  95h not enough memory to open panel file	 &gt; that the panel was
	  98h null panel file name			/  not opened
	if object is a timer, the status is:
	  00000000h open but not running
	  40000000h open and running
	  80000000h closed
	if object is an OBJECTQ, the status is:
	  00000000h open
	  80000000h closed
	if object is a keyboard in keystroke mode, the status is the extended
	  character code (scan code) of the last keystroke
	if object is a keyboard in field mode, the status indicates the reason
	  for the last return from the field manager
	  00h Enter key pressed
	  01h Button 1 or keystroke selection
	  02h Button 2
	  03h validation
	  04h auto Enter on field
	  1Bh Escape pressed
	  46h ^Break pressed
	  other: extended code for key terminating input
	the status of mailbox messages sent by the window manager is always 80h
	the status of a pointer message is the same as the status field in the
	  message
SeeAlso: AH=12h/BH=04h"READ"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH10" name="1512--BH10"><b>1512--BH10</b></a> - INT 15 - TopView - SEND MESSAGE - "EOF" - GET OBJECT EOF STATUS<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "EOF" - GET OBJECT EOF STATUS
	AH = 12h
	BH = 10h
	BL = object
	    00h handle is DWORD on top of stack
		window: return TRUE if logical cursor past end of window
		mailbox: ???
	    01h returns TRUE if logical cursor past end of task's def window
	    02h return ??? for task's mailbox (task's handle on top of stack)
	    03h return ??? for current task's mailbox
	    0Ch (DV 2.26+) check log crsr of window owning handle on top of stk
	    0Dh (DV 2.26+) check log cursor of window of parent task
Return: DWORD on top of stack is status (any handle on stack has been popped)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH11" name="1512--BH11"><b>1512--BH11</b></a> - INT 15 - TopView - SEND MESSAGE - "AT" - POSITION OBJECT CURSOR<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "AT" - POSITION OBJECT CURSOR
	AH = 12h
	BH = 11h
	BL = window for which to move cursor
	    00h window's handle is DWORD on top of stack
	    01h task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK: DWORD column
	       DWORD row
Return: STACK popped

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH11_0" name="1512--BH11_0"><b>1512--BH11</b></a> - INT 15 - TopView - SEND MESSAGE - "SETNAME" - ASSIGN NAME TO MAILBOX<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "SETNAME" - ASSIGN NAME TO MAILBOX
	AH = 12h
	BH = 11h
	BL = mailbox to name
	    00h DWORD on top of stack is mailbox handle
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
	STACK: DWORD length of name
	       DWORD address of name
Return: STACK popped
SeeAlso: AH=12h/BH=12h"GETNAME",AX=DE0Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BX1100" name="1512--BX1100"><b>1512--BX1100</b></a> - INT 15 - TopView - SEND MESSAGE - "SETSCALE" - SET POINTER SCALE FACTOR<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "SETSCALE" - SET POINTER SCALE FACTOR
	AH = 12h
	BX = 1100h
	STACK: DWORD object handle for pointer object
	       DWORD number of colums to scale pointer position to
	       DWORD number of rows to scale pointer position to
Return: STACK popped
SeeAlso: AH=12h/BX=1200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH12" name="1512--BH12"><b>1512--BH12</b></a> - INT 15 - TopView - SEND MESSAGE - "READN" - GET NEXT N OBJECT BYTES<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "READN" - GET NEXT N OBJECT BYTES
	AH = 12h
	BH = 12h
	BL = window to read from
	    00h handle is DWORD on top of stack
	    01h read next N chars or attributes on task's default window
	    0Ch (DV 2.26+) read window of task owning handle on top of stack
	    0Dh (DV 2.26+) read default window of parent of current task
	STACK: DWORD count
Return: STACK: DWORD number of bytes actually read
	       DWORD address of buffer containing data
Notes:	reading starts at the current logical cursor position; the cursor is
	  updated to point at the character following the last one read
	any translucent blanks (FFh) which are visible on screen are changed
	  to the character which is seen through them
	the string produced by the read is placed in an input buffer which may
	  be reused by the next READ or READN of a window
	window stream opcodes D8h and D9h determine whether the read returns
	  characters or attributes
SeeAlso: AH=12h/BH=04h"WINDOW",AH=12h/BH=05h"WINDOW"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH12_0" name="1512--BH12_0"><b>1512--BH12</b></a> - INT 15 - DESQview 2.50+ - SEND MESSAGE - "GETNAME" - GET NAME OF MAILBOX<br />
<pre>
INT 15 - DESQview 2.50+ - SEND MESSAGE - "GETNAME" - GET NAME OF MAILBOX
	AH = 12h
	BH = 12h
	BL = mailbox for which to retrieve name
	    00h DWORD on top of stack is mailbox handle
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
	STACK: DWORD length of buffer for name
	       DWORD pointer to buffer
Return: STACK: DWORD length of returned name (or size of buffer, if less)
Program: DESQview 2.5x is distributed as part of DESQview/X 1.0x
Note:	the returned name is not NUL-terminated
SeeAlso: AH=12h/BH=11h"SETNAME",AX=DE0Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BX1200" name="1512--BX1200"><b>1512--BX1200</b></a> - INT 15 - TopView - SEND MESSAGE - "GETSCALE" - GET POINTER SCALE FACTOR<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "GETSCALE" - GET POINTER SCALE FACTOR
	AH = 12h
	BX = 1200h
	STACK: DWORD object handle for pointer
Return: STACK: DWORD pointer pos scaled as if window were this many colums wide
	       DWORD pointer pos scaled as if window were this many rows high
SeeAlso: AH=12h/BX=1100h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH13" name="1512--BH13"><b>1512--BH13</b></a> - INT 15 - TopView - SEND MESSAGE - "REDRAW" - REDRAW WINDOW<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "REDRAW" - REDRAW WINDOW
	AH = 12h
	BH = 13h
	BL = window object
	    00h DWORD on top of stack is handle for window to redraw
	    01h redraw task's default window
	    0Ch (DV 2.26+) redraw window of task owning handle on top of stack
	    0Dh (DV 2.26+) redraw default window of parent of current task
Return: STACK popped if handle was passed on stack
SeeAlso: AH=12h/BH=05h"WINDOW",AH=12h/BH=0Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH13_0" name="1512--BH13_0"><b>1512--BH13</b></a> - INT 15 - DESQview 2.50+ - SEND MESSAGE - "READINTO" - GET NEXT MAIL MESSAGE<br />
<pre>
INT 15 - DESQview 2.50+ - SEND MESSAGE - "READINTO" - GET NEXT MAIL MESSAGE
	AH = 12h
	BH = 13h
	BL = mailbox from which to read
	    00h DWORD on top of stack is mailbox handle
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
	STACK: DWORD size of buffer in bytes
	       DWORD pointer to buffer
Return: STACK: DWORD number of bytes read
Program: DESQview 2.5x is distributed as part of DESQview/X 1.0x
Notes:	this call blocks if no input is available, but will return less than
	  the requested number of bytes if some (but insufficient) data is
	  available
	use this call instead of AH=12h/BH=04h if the mailbox has flag bits
	  4 or 5 set, as common memory may be exhausted by that call when
	  attempting to read the next message
SeeAlso: AH=12h/BH=04h"READ",AH=12h/BH=05h,AH=12h/BH=16h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BX1300" name="1512--BX1300"><b>1512--BX1300</b></a> - INT 15 - TopView - SEND MESSAGE - "SETICON" - SPECIFY POINTER ICON<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "SETICON" - SPECIFY POINTER ICON
	AH = 12h
	BX = 1300h
	STACK: DWORD object handle for pointer
	       DWORD character to use for pointer
Return: STACK popped

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH14" name="1512--BH14"><b>1512--BH14</b></a> - INT 15 - TopView - SEND MESSAGE - "SETESC" - SET ESCAPE ROUTINE ADDRESS<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "SETESC" - SET ESCAPE ROUTINE ADDRESS
	AH = 12h
	BH = 14h
	BL = message modifier
	    00h handle is DWORD on top of stack
	    01h define user stream
	    04h intercept keystrokes from KEYBOARD to window (handle on stack)
	    05h intercept keystrokes from task's default KEYBOARD to a window
	STACK: (if window)   DWORD user stream number (14h-1Fh)
			     DWORD address of FAR user stream handler
	       (if keyboard) DWORD address of FAR filter function (see #00452)
Return: STACK popped

(Table 00452)
Values keyboard filter function is called with when keyboard is in field mode:
	AL = character
	AH = 00h or extended ASCII code if AL = 00h
	BL = field number
	CH = cursor column
	CL = cursor row
	DL = field type modifier (sixth item in field table entry)
	DH = seventh item in field table entry
	ES:SI = window's handle
	DS:DI -&gt; field table entry for field containing the cursor
Return: AH = action to take
	    00h use keystroke
	    01h ignore keystroke
	    FFh beep and ignore keystroke
Note: the filter function is not allowed to make INT 15, DOS, or BIOS calls

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH14_0" name="1512--BH14_0"><b>1512--BH14</b></a> - INT 15 - TopView - SEND MESSAGE - "LOCK" - REQUEST EXCLUSIVE ACCESS TO RESOURCE<br />
<pre>
INT 15 - TopView - SEND MESSAGE - "LOCK" - REQUEST EXCLUSIVE ACCESS TO RESOURCE
	AH = 12h
	BH = 14h
	BL = object
	    00h mailbox handle is DWORD on top of stack
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
Return: STACK popped if BL=00h
Note:	release exclusive access by sending CLOSE message to mailbox
	access may be requested multiple times, and requires multiple CLOSEs
SeeAlso: AH=12h/BH=0Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH15" name="1512--BH15"><b>1512--BH15</b></a> - INT 15 - DESQview v2.20+ - SEND MESSAGE - "SETFLAGS" - SET OBJECT FLAGS<br />
<pre>
INT 15 - DESQview v2.20+ - SEND MESSAGE - "SETFLAGS" - SET OBJECT FLAGS
	AH = 12h
	BH = 15h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
	STACK: DWORD flags (see #00453,#00454)
Return: STACK popped
Notes:	only available if the API level has been set to at least 2.20
	equivalent to performing SUBFROM and ADDTO calls on the object
	if a mailbox has bits 4 or 5 set, you must use "READINTO" rather than
	  "READ" (see AH=12h/BH=13h"READINTO") to retrieve messages
SeeAlso: AH=12h/BH=0Ah,AH=12h/BH=0Bh,AH=12h/BH=16h

Bitfields for DESQview mailbox object flags:
Bit(s)	Description	(Table 00453)
 0	all mail messages in common memory
 1	allow write even if closed
 2	don't erase messages when mailbox closed
 4	(DV/X) append messages with like status and sender (stream-oriented
	  mail)
 5	(DV/X) store mail in expanded memory (pool grows as needed)
 6	(DV/X) make mailbox into non-owned mailbox

Bitfields for DESQview keyboard object flags:
Bit(s)	Description	(Table 00454)
 5	exclusive input when keyboard in use for input

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH16" name="1512--BH16"><b>1512--BH16</b></a> - INT 15 - DESQview v2.20+ - SEND MESSAGE - "GETFLAGS" - GET OBJECT FLAGS<br />
<pre>
INT 15 - DESQview v2.20+ - SEND MESSAGE - "GETFLAGS" - GET OBJECT FLAGS
	AH = 12h
	BH = 16h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
Return: STACK: DWORD current control flags (see #00453,#00454)
Notes:	only available if the API level has been set to at least 2.20
	if a mailbox has bits 4 or 5 set, you must use "READINTO" rather than
	  "READ" (see AH=12h/BH=13h"READINTO") to retrieve messages
SeeAlso: AH=12h/BH=0Ah,AH=12h/BH=0Bh,AH=12h/BH=13h"READINTO",AH=12h/BH=15h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH17" name="1512--BH17"><b>1512--BH17</b></a> - INT 15 - DESQview v2.42-2.52 - BUG<br />
<pre>
INT 15 - DESQview v2.42-2.52 - BUG
	AH = 12h
	BH = 17h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
Return: STACK popped if handle passed on stack
Notes:	due to a fencepost error, message 17h is accepted for mailboxes,
	  keyboards, and pointers, but causes a random branch
	DESQview v2.50-2.52 are distributed as part of DESQview/X v1.02

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH80" name="1512--BH80"><b>1512--BH80</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 00h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 00h WITH ERROR RECOVERY
	AH = 12h
	BH = 80h
Note:	this function is identical to AH=12h/BH=00h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=00h

(Table 00455)
Values for DESQview error code:
 00h	no error
 01h	invalid values
 02h	alias invalid
 03h	handle valid but wrong type
 04h	invalid handle

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH81" name="1512--BH81"><b>1512--BH81</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 01h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 01h WITH ERROR RECOVERY
	AH = 12h
	BH = 81h
Note:	this function is identical to AH=12h/BH=01h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH82" name="1512--BH82"><b>1512--BH82</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 02h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 02h WITH ERROR RECOVERY
	AH = 12h
	BH = 82h
Note:	this function is identical to AH=12h/BH=02h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH83" name="1512--BH83"><b>1512--BH83</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 03h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 03h WITH ERROR RECOVERY
	AH = 12h
	BH = 83h
Note:	this function is identical to AH=12h/BH=03h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=03h,AH=12h/BX=0300h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH84" name="1512--BH84"><b>1512--BH84</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 04h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 04h WITH ERROR RECOVERY
	AH = 12h
	BH = 84h
Note:	this function is identical to AH=12h/BH=04h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=04h,AH=12h/BX=0400h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH85" name="1512--BH85"><b>1512--BH85</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 05h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 05h WITH ERROR RECOVERY
	AH = 12h
	BH = 85h
Note:	this function is identical to AH=12h/BH=05h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH86" name="1512--BH86"><b>1512--BH86</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 06h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 06h WITH ERROR RECOVERY
	AH = 12h
	BH = 86h
Note:	this function is identical to AH=12h/BH=06h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH87" name="1512--BH87"><b>1512--BH87</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 07h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 07h WITH ERROR RECOVERY
	AH = 12h
	BH = 87h
Note:	this function is identical to AH=12h/BH=07h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH88" name="1512--BH88"><b>1512--BH88</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 08h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 08h WITH ERROR RECOVERY
	AH = 12h
	BH = 88h
Note:	this function is identical to AH=12h/BH=08h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=08h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH89" name="1512--BH89"><b>1512--BH89</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 09h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 09h WITH ERROR RECOVERY
	AH = 12h
	BH = 89h
Note:	this function is identical to AH=12h/BH=09h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH8A" name="1512--BH8A"><b>1512--BH8A</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Ah WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Ah WITH ERROR RECOVERY
	AH = 12h
	BH = 8Ah
Note:	this function is identical to AH=12h/BH=0Ah, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=0Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH8B" name="1512--BH8B"><b>1512--BH8B</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Bh WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Bh WITH ERROR RECOVERY
	AH = 12h
	BH = 8Bh
Note:	this function is identical to AH=12h/BH=0Bh, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=0Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH8C" name="1512--BH8C"><b>1512--BH8C</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Ch WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Ch WITH ERROR RECOVERY
	AH = 12h
	BH = 8Ch
Note:	this function is identical to AH=12h/BH=0Ch, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=0Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH8D" name="1512--BH8D"><b>1512--BH8D</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Dh WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Dh WITH ERROR RECOVERY
	AH = 12h
	BH = 8Dh
Note:	this function is identical to AH=12h/BH=0Dh, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=0Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH8E" name="1512--BH8E"><b>1512--BH8E</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Eh WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Eh WITH ERROR RECOVERY
	AH = 12h
	BH = 8Eh
Note:	this function is identical to AH=12h/BH=0Eh, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=0Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH8F" name="1512--BH8F"><b>1512--BH8F</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 0Fh WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Fh WITH ERROR RECOVERY
	AH = 12h
	BH = 8Fh
Note:	this function is identical to AH=12h/BH=0Fh, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=0Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH90" name="1512--BH90"><b>1512--BH90</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 10h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 10h WITH ERROR RECOVERY
	AH = 12h
	BH = 90h
Note:	this function is identical to AH=12h/BH=10h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH91" name="1512--BH91"><b>1512--BH91</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 11h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 11h WITH ERROR RECOVERY
	AH = 12h
	BH = 91h
Note:	this function is identical to AH=12h/BH=11h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=11h,AH=12h/BX=1100h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH92" name="1512--BH92"><b>1512--BH92</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 12h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 12h WITH ERROR RECOVERY
	AH = 12h
	BH = 92h
Note:	this function is identical to AH=12h/BH=12h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=12h,AH=12h/BX=1200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH93" name="1512--BH93"><b>1512--BH93</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 13h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 13h WITH ERROR RECOVERY
	AH = 12h
	BH = 93h
Note:	this function is identical to AH=12h/BH=13h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=13h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH94" name="1512--BH94"><b>1512--BH94</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 14h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 14h WITH ERROR RECOVERY
	AH = 12h
	BH = 94h
Note:	this function is identical to AH=12h/BH=14h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=14h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH95" name="1512--BH95"><b>1512--BH95</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 15h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 15h WITH ERROR RECOVERY
	AH = 12h
	BH = 95h
Note:	this function is identical to AH=12h/BH=15h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=15h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1512--BH96" name="1512--BH96"><b>1512--BH96</b></a> - INT 15 - DESQview v2.50+ - SEND MESSAGE 16h WITH ERROR RECOVERY<br />
<pre>
INT 15 - DESQview v2.50+ - SEND MESSAGE 16h WITH ERROR RECOVERY
	AH = 12h
	BH = 96h
Note:	this function is identical to AH=12h/BH=16h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see #00455)
SeeAlso: AH=12h/BH=16h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE00" name="15DE00"><b>15DE00</b></a> - INT 15 - DESQview - GET PROGRAM NAME<br />
<pre>
INT 15 - DESQview - GET PROGRAM NAME
	AX = DE00h
Return: AX = offset into DESQVIEW.DVO of program most recently selected from
	      the "Switch Windows" menu (see #00550)
Note:	always returns AX=0000h under DESQview/X
SeeAlso: AX=DE07h

Format of program entry in DESQVIEW.DVO:
Offset	Size	Description	(Table 00550)
 00h	BYTE	length of name (FFh if end of file)
 01h  N BYTEs	name
      2 BYTEs	keys to invoke program (second = 00h if only one key used)
	BYTE	program type
		00h normal program
		04h divider
		80h Delete a Program
		81h Change a Program
	WORD	??? apparently always 0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE01" name="15DE01"><b>15DE01</b></a> - INT 15 - DESQview - UPDATE "OPEN WINDOW" MENU<br />
<pre>
INT 15 - DESQview - UPDATE "OPEN WINDOW" MENU
	AX = DE01h
Return: nothing
Notes:	reads DESQVIEW.DVO, disables Open menu if file not in current directory
	NOP for DESQview/X

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE02" name="15DE02"><b>15DE02</b></a> - INT 15 - DESQview 1.x only - SET ??? FLAG FOR CURRENT WINDOW<br />
<pre>
INT 15 - DESQview 1.x only - SET ??? FLAG FOR CURRENT WINDOW
	AX = DE02h
Return: nothing
Note:	this call is a NOP in DV 2.x
SeeAlso: AX=DE03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE03" name="15DE03"><b>15DE03</b></a> - INT 15 - DESQview 1.x only - GET ??? FOR CURRENT WINDOW<br />
<pre>
INT 15 - DESQview 1.x only - GET ??? FOR CURRENT WINDOW
	AX = DE03h
Return: AX = ??? for current window
	BX = ??? for current window
Note:	this call is a NOP in DV 2.x
SeeAlso: AX=DE02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE04" name="15DE04"><b>15DE04</b></a> - INT 15 - DESQview - GET AVAILABLE COMMON MEMORY<br />
<pre>
INT 15 - DESQview - GET AVAILABLE COMMON MEMORY
	AX = DE04h
Return: BX = bytes of common memory available
	CX = largest block available
	DX = total common memory in bytes
SeeAlso: AX=DE05h,AX=DE06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE05" name="15DE05"><b>15DE05</b></a> - INT 15 - DESQview - GET AVAILABLE CONVENTIONAL MEMORY<br />
<pre>
INT 15 - DESQview - GET AVAILABLE CONVENTIONAL MEMORY
	AX = DE05h
Return: BX = KB of memory available
	CX = largest block available
	DX = total conventional memory in KB
SeeAlso: AX=DE04h,AX=DE06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE06" name="15DE06"><b>15DE06</b></a> - INT 15 - DESQview - GET AVAILABLE EXPANDED MEMORY<br />
<pre>
INT 15 - DESQview - GET AVAILABLE EXPANDED MEMORY
	AX = DE06h
Return: BX = KB of expanded memory available
	CX = largest block available
	DX = total expanded memory in KB
SeeAlso: AX=DE04h,AX=DE05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE07" name="15DE07"><b>15DE07</b></a> - INT 15 - DESQview - "APPNUM" - GET CURRENT PROGRAM'S NUMBER<br />
<pre>
INT 15 - DESQview - "APPNUM" - GET CURRENT PROGRAM'S NUMBER
	AX = DE07h
Return: AX = number of program as it appears on the "Switch Windows" menu
Note:	this API call may be made from a hardware interrupt handler
SeeAlso: AX=DE00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE08" name="15DE08"><b>15DE08</b></a> - INT 15 - DESQview - GET ???<br />
<pre>
INT 15 - DESQview - GET ???
	AX = DE08h
Return: AX = 0000h if ??? is not set to the current task
	     0001h if ??? is set to the current task

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE09" name="15DE09"><b>15DE09</b></a> - INT 15 - DESQview - UNIMPLEMENTED<br />
<pre>
INT 15 - DESQview - UNIMPLEMENTED
	AX = DE09h
Return: nothing (NOP in DV 1.x and 2.x)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE0A" name="15DE0A"><b>15DE0A</b></a> - INT 15 - DESQview v2.00+ - "DBGPOKE" - DISPLAY CHARACTER ON STATUS LINE<br />
<pre>
INT 15 - DESQview v2.00+ - "DBGPOKE" - DISPLAY CHARACTER ON STATUS LINE
	AX = DE0Ah
	BL = character
Return: character displayed, next call will display in next position (which
	wraps back to the start of the line if off the right edge of screen)
Notes:	displays character on bottom line of *physical* screen, regardless
	  of current size of window (even entirely hidden)
	does not know about graphics display modes, just pokes the characters
	  into display memory
	this API call may be made from a hardware interrupt handler
SeeAlso: AX=1003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE0B" name="15DE0B"><b>15DE0B</b></a> - INT 15 - DESQview v2.00+ - "APILEVEL" - DEFINE MINIMUM API LEVEL REQUIRED<br />
<pre>
INT 15 - DESQview v2.00+ - "APILEVEL" - DEFINE MINIMUM API LEVEL REQUIRED
	AX = DE0Bh
	BL = API level minor version number
	BH = API level major version number
Return: AX = maximum API level (AH = major, AL = minor)
Notes:	if the requested API level is greater than the version of DESQview, a
	  "You need a newer version" error window is popped up
	the API level defaults to 1.00, and is inherited by child tasks

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE0C" name="15DE0C"><b>15DE0C</b></a> - INT 15 - DESQview v2.00+ - "GETMEM" - ALLOCATE "SYSTEM" MEMORY<br />
<pre>
INT 15 - DESQview v2.00+ - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
	AX = DE0Ch
	BX = number of bytes
Return: ES:DI -&gt; allocated block or 0000h:0000h (DV 2.26+)
Note:	use SETERROR (AX=DE15h) to avoid a user prompt if there is insufficient
	  system memory
SeeAlso: AX=1001h,AX=102Eh,AX=DE0Dh,AX=DE15h,AX=DE19h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE0D" name="15DE0D"><b>15DE0D</b></a> - INT 15 - DESQview v2.00+ - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY<br />
<pre>
INT 15 - DESQview v2.00+ - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
	AX = DE0Dh
	ES:DI -&gt; previously allocated block
Return: nothing
SeeAlso: AX=1002h,AX=DE0Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE0E" name="15DE0E"><b>15DE0E</b></a> - INT 15 - DESQview v2.00+ - "FINDMAIL" - FIND MAILBOX BY NAME<br />
<pre>
INT 15 - DESQview v2.00+ - "FINDMAIL" - FIND MAILBOX BY NAME
	AX = DE0Eh
	ES:DI -&gt; name to find (see #00551)
	CX = length of name
Return: BX = 0000h not found
	     0001h found
		DS:SI = object handle
SeeAlso: AH=12h/BH=11h,AH=12h/BH=12h"GETNAME"

(Table 00551)
Values for special DESQview mailbox names:
 "COM1" ... "COM4"	RBcomm using COM1 ... COM4
 "DESQview/X Help Engine"
 "DESQview/X Network Server"  Network Manager
 "DESQview X Server0"	X-Windows server
 "DESQview X Server7"	X-Windows printing service
 "INBOX"		DESQview/X LPD requests
 "OUTBOX"		DESQview/X LPD responses
 "WAITBOX"		semaphore to synchronize DESQview/X LPD communications
 "_DVNM_"		DV/X v1.10 network manager

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE0F" name="15DE0F"><b>15DE0F</b></a> - INT 15 - DESQview v2.00+ - ENABLE DESQview EXTENSIONS<br />
<pre>
INT 15 - DESQview v2.00+ - ENABLE DESQview EXTENSIONS
	AX = DE0Fh
Return: AX and BX destroyed (seems to be bug, weren't saved&restored)
Notes:	sends a manager stream with opcodes AEh, BDh, and BFh to task's window
	enables an additional mouse mode

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE10" name="15DE10"><b>15DE10</b></a> - INT 15 - DESQview v2.00+ - "PUSHKEY" - PUT KEY INTO KEYBOARD INPUT STREAM<br />
<pre>
INT 15 - DESQview v2.00+ - "PUSHKEY" - PUT KEY INTO KEYBOARD INPUT STREAM
	AX = DE10h
	BH = scan code
	BL = character
Return: nothing
Notes:	a later read will get the keystroke as if it had been typed by the user
	multiple pushes are read last-in first-out
	if a script exists for the pushed key in the current application, the
	  script will be executed
	early copies of DV 2.00 destroy AX, BX, ES, and DI
SeeAlso: INT 16/AH=05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE11BL00" name="15DE11BL00"><b>15DE11BL00</b></a> - INT 15 - DESQview v2.00+ - "JUSTIFY" - EN/DISABLE AUTOM. WINDOW JUSTIFICATION<br />
<pre>
INT 15 - DESQview v2.00+ - "JUSTIFY" - EN/DISABLE AUTOM. WINDOW JUSTIFICATION
	AX = DE11h
	BL = 00h      viewport will not move automatically
	     nonzero  viewport will move to keep cursor visible (default)
Return: nothing

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE12BX0000" name="15DE12BX0000"><b>15DE12BX0000</b></a> - INT 15 - DESQview v2.01+ - "CSTYLE" - SET "C"-COMPATIBLE CONTROL CHAR INTERPRET<br />
<pre>
INT 15 - DESQview v2.01+ - "CSTYLE" - SET "C"-COMPATIBLE CONTROL CHAR INTERPRET
	AX = DE12h
	BX = 0000h    select normal style (linefeed only moves down)
	     nonzero  select C style (linefeed moves to start of next line)
Return: nothing
Note:	set on a per-task basis, and inherited from the parent task

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE13" name="15DE13"><b>15DE13</b></a> - INT 15 - DESQview v2.20+ - "GETCRIT" - GET CRITICAL NESTING COUNT<br />
<pre>
INT 15 - DESQview v2.20+ - "GETCRIT" - GET CRITICAL NESTING COUNT
	AX = DE13h
Return: BX = number of calls to BEGINC or ENTERC
	      (see INT 15/AX=101Bh,INT 15/AX=DE1Ch) without matching ENDC
	      (see INT 15/AX=101Ch)
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,AX=101Ch,AX=DE1Bh,AX=DE1Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE14" name="15DE14"><b>15DE14</b></a> - INT 15 - DESQview v2.20+ - GET OBJECT TYPE<br />
<pre>
INT 15 - DESQview v2.20+ - GET OBJECT TYPE
	AX = DE14h
	ES:DI -&gt; object
Return: BL = 00h not an object
	     08h window or task
	     09h mailbox
	     0Ah keyboard
	     0Bh timer
	     0Ch objectq
	     0Fh pointer
	     10h panel
SeeAlso: AX=1016h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE15" name="15DE15"><b>15DE15</b></a> - INT 15 - DESQview v2.20+ - SET ERROR HANDLING<br />
<pre>
INT 15 - DESQview v2.20+ - SET ERROR HANDLING
	AX = DE15h
	BL = error handling mode
	    00h post system error on all error conditions
	    01h return carry flag set on calls to ADDTO, SUBFROM, and WRITE
		messages sent to mailboxes which fail due to lack of system
		or common memory
	    02h (v2.26+) same as 01h, but also return null pointer for GETMEM
		calls which fail due to lack of system memory
Return: nothing
SeeAlso: AX=DE0Ch,AX=DE16h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE16" name="15DE16"><b>15DE16</b></a> - INT 15 - DESQview v2.20+ - GET ERROR HANDLING<br />
<pre>
INT 15 - DESQview v2.20+ - GET ERROR HANDLING
	AX = DE16h
Return: BL = current mode
	    00h always post system error
	    01h return carry flag set on failed mailbox writes
	    02h return CF set on failed mailbox writes and NULL on failed
		GETMEM calls
SeeAlso: AX=DE15h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE17" name="15DE17"><b>15DE17</b></a> - INT 15 - DESQview v2.20-2.25 - reserved<br />
<pre>
INT 15 - DESQview v2.20-2.25 - reserved
	AX = DE17h
Return: pops up "Programming error" window
Note:	AX = 1117h is NOT identical to this call under DESQview 2.20 thru 2.25
SeeAlso: AX=1117h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE17_0" name="15DE17_0"><b>15DE17</b></a> - INT 15 - DESQview v2.26+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT<br />
<pre>
INT 15 - DESQview v2.26+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT
	AX = DE17h
	BX = function
	    0000h   get current mapping context without setting
	    nonzero set new mapping context to BX
Return: BX = mapping context in effect before call
Notes:	mapping contexts determine conventional-memory addressability; setting
	  a mapping context ensures that the associated program and data areas
	  are in memory for access.  Usable by drivers, TSRs and shared
	  programs.
	caller need not be running under DESQview
	this API call may be made from a hardware interrupt handler
SeeAlso: AX=1016h,AX=1117h,AX=DE21h,INT 2F/AX=1685h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE18" name="15DE18"><b>15DE18</b></a> - INT 15 - DESQview v2.20+ - internal - ???<br />
<pre>
INT 15 - DESQview v2.20+ - internal - ???
	AX = DE18h
	BP = function number
	    high byte must be 10h
	    low byte is function
		00h set ???
		    BL = ???  (00h-10h, video mode???)
		    BH = value to store
		03h set ???
		    BL = ??? (stored in driver)
		0Ah get ???
		    ES:DI -&gt; 18-byte buffer to hold ???
Note:	calls video driver (NOP for Hercules driver,probably CGA and MCGA also)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE19" name="15DE19"><b>15DE19</b></a> - INT 15 - DESQview v2.23+ - "GETCOMMON" - ALLOCATE "COMMON" MEMORY<br />
<pre>
INT 15 - DESQview v2.23+ - "GETCOMMON" - ALLOCATE "COMMON" MEMORY
	AX = DE19h
	BX = number of bytes to allocate
Return: AX = 0000h successful
		ES:DI -&gt; allocated block
	     nonzero insufficient memory
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=DE0Ch,AX=DE15h,AX=DE1Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE1A" name="15DE1A"><b>15DE1A</b></a> - INT 15 - DESQview v2.23+ - "PUTCOMMON" - DEALLOCATE "COMMON" MEMORY<br />
<pre>
INT 15 - DESQview v2.23+ - "PUTCOMMON" - DEALLOCATE "COMMON" MEMORY
	AX = DE1Ah
	ES:DI -&gt; previously allocated block
Return: AX = 0000h (successful)
Note:	this function may be called from within a hardware interrupt handler
SeeAlso: AX=DE0Dh,AX=DE19h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE1B" name="15DE1B"><b>15DE1B</b></a> - INT 15 - DESQview v2.23+ internal - DECREMENT CRITICAL NESTING COUNT<br />
<pre>
INT 15 - DESQview v2.23+ internal - DECREMENT CRITICAL NESTING COUNT
	AX = DE1Bh
Return: nothing
SeeAlso: AX=101Ch,AX=DE13h,AX=DE1Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE1C" name="15DE1C"><b>15DE1C</b></a> - INT 15 - DESQview v2.23+ - "ENTERC" - INCREMENT CRITICAL NESTING COUNT<br />
<pre>
INT 15 - DESQview v2.23+ - "ENTERC" - INCREMENT CRITICAL NESTING COUNT
	AX = DE1Ch
Return: nothing
Notes:	similar to AX=101Bh, but begins the critical region without ensuring
	  that DOS is free
	the official documentation states that this call should be paired with
	  "ENDC" (AX=101Ch); no mention is made of AX=DE1Bh
	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,AX=101Ch,AX=DE13h,AX=DE1Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE1D" name="15DE1D"><b>15DE1D</b></a> - INT 15 - DESQview v2.23+ - "PUTKEY" - FAKE USER KEYSTROKES<br />
<pre>
INT 15 - DESQview v2.23+ - "PUTKEY" - FAKE USER KEYSTROKES
	AX = DE1Dh
	DX = segment of handle for task to receive keystroke
	BL = character
	BH = scan code
Return: AX = 0000h if successful
	   nonzero if receiver's keyboard buffer was full
Notes:	the key is treated as though the user had pressed it, ignoring any
	  script which may be bound to the key, and using the current field
	  table if the keyboard object is in field processing mode
	multiple PUTKEYs are seen in the order in which they are executed
SeeAlso: AX=DE10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE1E" name="15DE1E"><b>15DE1E</b></a> - INT 15 - DESQview v2.23+ - "SCRNINFO" - GET TRUE VIDEO PARAMETERS<br />
<pre>
INT 15 - DESQview v2.23+ - "SCRNINFO" - GET TRUE VIDEO PARAMETERS
	AX = DE1Eh
Return: CL = actual number of rows on screen
	CH = actual number of columns on screen
	BL = actual video mode (may differ from INT 10/AH=0Fh return) (v2.26+)
Note:	this API call may be made from a hardware interrupt handler
SeeAlso: INT 10/AH=0Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE1F" name="15DE1F"><b>15DE1F</b></a> - INT 15 - DESQview v2.23+ - "DOSUSER" - GET HANDLE OF TASK CURRENTLY USING DOS<br />
<pre>
INT 15 - DESQview v2.23+ - "DOSUSER" - GET HANDLE OF TASK CURRENTLY USING DOS
	AX = DE1Fh
Return: BX = segment of task handle or 0000h if no tasks are using DOS
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=DE13h,INT 21/AH=34h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE20" name="15DE20"><b>15DE20</b></a> - INT 15 - DESQview v2.26+ - "DISPATCHINT" - INTERRUPT ANOTHER TASK<br />
<pre>
INT 15 - DESQview v2.26+ - "DISPATCHINT" - INTERRUPT ANOTHER TASK
	AX = DE20h
	BX = segment of handle of task to interupt
	DX:CX -&gt; FAR interrupt routine
	BP,SI,DI,DS,ES as required by interrupt routine
Return: nothing
Notes:	unlike "PGMINT" (AX=1021h), DISPATCHINT may be applied to the task
	  making the DISPATCHINT call
	multiple "DISPATCHINT" calls are processed in the order in which they
	  were executed
	the FAR routine is entered with the current ES, DS, SI, DI, and BP
	  values, using the task's internal stack (see AX=101Ah); only SS:SP
	  needs to be preserved
	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=1021h,AX=DE2Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE21" name="15DE21"><b>15DE21</b></a> - INT 15 - DESQview v2.26+ - "ASSERTVIR" - CONTROL 386 SCREEN VIRTUALIZATION<br />
<pre>
INT 15 - DESQview v2.26+ - "ASSERTVIR" - CONTROL 386 SCREEN VIRTUALIZATION
	AX = DE21h
	BX = new state
	    0000h turn off
	    nonzero turn on
Return: BX = old state of virtualization
Notes:	this API call may be made from within a hardware interrupt handler
	under DV 2.40 and 2.42, this call appears to have no effect and always
	  returns a nonzero value in BX which appears to be the offset within
	  the DV common memory segment of the caller's task object; it may
	  only have an effect within a hardware interrupt handler
SeeAlso: AX=1117h,AX=DE17h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE22" name="15DE22"><b>15DE22</b></a> - INT 15 - DESQview v2.26+ - "PROCESSMEM" - GET TASK MEMORY STATUS<br />
<pre>
INT 15 - DESQview v2.26+ - "PROCESSMEM" - GET TASK MEMORY STATUS
	AX = DE22h
	DX = segment of task handle
Return: DX = total amount of memory in paragraphs
	BX = amount of system memory in paragraphs
	CX = largest block of system memory available in paragraphs
	AX = memory flags (see #00552)
Notes:	if the task handle is a child task, the returned values will be for the
	  process containing the task, rather than the task itself
	if the process's system memory is swapped out, BX,CX,DX remain
	  unchanged, because the memory usage cannot be determined
SeeAlso: AX=DE04h,AX=DE05h,AX=DE06h

Bitfields for DESQview process memory flags:
Bit(s)	Description	(Table 00552)
 0	system memory resides in shared memory
 1	process's memory is swapped out
 2	process's system memory is swapped out

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE23" name="15DE23"><b>15DE23</b></a> - INT 15 U - DESQview v2.31+ - ???<br />
<pre>
INT 15 U - DESQview v2.31+ - ???
	AX = DE23h
	BX = ??? IRQ number on first PIC?
	CX = ??? IRQ number on second PIC?
Return: ???
Note:	called by QEMM 6.00+

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE24" name="15DE24"><b>15DE24</b></a> - INT 15 - DESQview v2.40+ - "XNEWPROC" - START NEW APPLICATION<br />
<pre>
INT 15 - DESQview v2.40+ - "XNEWPROC" - START NEW APPLICATION
	AX = DE24h
	BX = length of .DVP data
	CX = length of ??? string
	DS:SI -&gt; ??? string
	ES:DI -&gt; .DVP data (see #00427 at AX=102Ch)
Return: BX = segment of task handle??? or 0000h on error
Note:	this call is similar to AX=102Ch except that it can interpret the
	  extended DVP data
SeeAlso: AX=102Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE25" name="15DE25"><b>15DE25</b></a> - INT 15 - DESQview v2.40+ - "GETDVPATH" - GET DESQview DIRECTORY<br />
<pre>
INT 15 - DESQview v2.40+ - "GETDVPATH" - GET DESQview DIRECTORY
	AX = DE25h
	ES:DI -&gt; 67-byte buffer for ASCIZ directory name
Return: ES:DI buffer filled with directory from which DESQview was started
BUG:	DV 2.42 does not place a terminating NUL at the end of the directory
	  name, so if the buffer is not cleared to zeros before the call,
	  there is no way to tell where the directory name ends.  This bug
	  has been fixed in DV 2.52 (DV/X 1.02)
SeeAlso: AX=DE2Eh,INT 21/AH=47h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE26" name="15DE26"><b>15DE26</b></a> - INT 15 - DESQview v2.40+ - "GETFOREGROUND" - GET KEYBOARD FOCUS<br />
<pre>
INT 15 - DESQview v2.40+ - "GETFOREGROUND" - GET KEYBOARD FOCUS
	AX = DE26h
Return: BX = segment of handle for task with keyboard focus
Note:	under DESQview/X, the X server always has the keyboard focus unless a
	  "direct" window is active
SeeAlso: AX=DE2Fh,INT 2F/AX=DE0Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE27" name="15DE27"><b>15DE27</b></a> - INT 15 - DESQview v2.50+ - "ADDINSTANCEDATA" - ADD PER-TASK SAVE/RESTORE AREA<br />
<pre>
INT 15 - DESQview v2.50+ - "ADDINSTANCEDATA" - ADD PER-TASK SAVE/RESTORE AREA
	AX = DE27h
	BX = type
	    0000h process
	    0001h task
	ES:DI -&gt; list of Instance Item Structures (see #00553)
Return: CF clear if successful
	    AX = ???
	    BX = ???
	CF set on error
	    AX = error code???
		0004h invalid BX value
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
SeeAlso: INT 2F/AX=DE08h,INT 2F/AX=DE09h

Format of DESQview Instance Item Structure [one element of list]:
Offset	Size	Description	(Table 00553)
 00h	WORD	length of data area DESQview should save and restore on context
		  switches (0000h = end of list)
 02h	DWORD	pointer to area to be saved/restored

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE28" name="15DE28"><b>15DE28</b></a> - INT 15 U - DESQview v2.50+ - ???<br />
<pre>
INT 15 U - DESQview v2.50+ - ???
	AX = DE28h
	BX = segment of ??? or 0000h for default
	???
Return: ???
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
SeeAlso: AX=DE2Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE29BX0000" name="15DE29BX0000"><b>15DE29BX0000</b></a> - INT 15 U - DESQview/X - ???<br />
<pre>
INT 15 U - DESQview/X - ???
	AX = DE29h
	BX = 0000h
	???
Return: CF clear if successful
	    ???
	CF set on error
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	under DESQview 2.60, this function and all other subfunctions of
	  AX=DE29h always return CF set, as they are unique to DESQview/X

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE29BX0001" name="15DE29BX0001"><b>15DE29BX0001</b></a> - INT 15 U - DESQview/X - ???<br />
<pre>
INT 15 U - DESQview/X - ???
	AX = DE29h
	BX = 0001h
	DX = segment of window handle
Return: CF clear if successful
	    AX = ???
	    DX = ???
	CF set on error
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE29BX0002" name="15DE29BX0002"><b>15DE29BX0002</b></a> - INT 15 U - DESQview/X - ???<br />
<pre>
INT 15 U - DESQview/X - ???
	AX = DE29h
	BX = 0002h
	DX = segment of window handle
Return: CF clear if successful
	    AX = ???
	    DX = ???
	CF set on error
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE29BX0003" name="15DE29BX0003"><b>15DE29BX0003</b></a> - INT 15 U - DESQview/X - ???<br />
<pre>
INT 15 U - DESQview/X - ???
	AX = DE29h
	BX = 0003h
	DX = segment of window handle
Return: CF clear if successful
	    ???
	CF set on error
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE29BX0004" name="15DE29BX0004"><b>15DE29BX0004</b></a> - INT 15 U - DESQview/X - GET DISPLAY NAME<br />
<pre>
INT 15 U - DESQview/X - GET DISPLAY NAME
	AX = DE29h
	BX = 0004h
	CX = size of buffer in bytes
	DX = segment of window handle
	ES:DI -&gt; buffer for display name
Return: CF clear if successful
	    buffer filled with ASCIZ display name (truncated if necessary) or
	      null string if no display
	CF set on error
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	the name ":0" refers to the local display

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE29BX0005" name="15DE29BX0005"><b>15DE29BX0005</b></a> - INT 15 U - DESQview/X - ???<br />
<pre>
INT 15 U - DESQview/X - ???
	AX = DE29h
	BX = 0005h
	???
Return: CF clear if successful
	    ???
	CF set on error
Note:	under DESQview 2.60, this function and all other subfunctions of
	  AX=DE29h always return CF set, as they are unique to DESQview/X

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE2A" name="15DE2A"><b>15DE2A</b></a> - INT 15 - DESQview v2.50+ - "DISPATCHINTAFTERDOS" - INTERRUPT ANOTHER TASK<br />
<pre>
INT 15 - DESQview v2.50+ - "DISPATCHINTAFTERDOS" - INTERRUPT ANOTHER TASK
	AX = DE2Ah
	BX = segment of handle for task to interrupt or 0000h for caller
	DX:CX -&gt; interrupt routine
	BP,SI,DI,DS,ES as required by interrupt routine
Return: nothing
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	this call is the same as AX=DE20h except that it will delay
	  interrupting the specified task until after it has exited DOS
SeeAlso: AX=1021h,AX=DE20h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE2B" name="15DE2B"><b>15DE2B</b></a> - INT 15 - DESQview v2.50+ - "OBJNEXT" - TRAVERSE OBJECT LIST<br />
<pre>
INT 15 - DESQview v2.50+ - "OBJNEXT" - TRAVERSE OBJECT LIST
	AX = DE2Bh
	ES:DI -&gt; starting object
		0000h:0000h for first object in list???
Return: AX = status
	    0000h successful
		ES:DI -&gt; next object of same type (window/non-window)
	    0001h failed (ES:DI was not a valid handle)
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	there are two separate lists, one for window/task objects and one
	  for all other objects
SeeAlso: AX=1016h,AX=DE2Ah,AX=DE2Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE2C" name="15DE2C"><b>15DE2C</b></a> - INT 15 - DESQview v2.50+ - "WININFO" - GET WINDOW INFORMATION<br />
<pre>
INT 15 - DESQview v2.50+ - "WININFO" - GET WINDOW INFORMATION
	AX = DE2Ch
	DX = window information format version (0100h for DESQview 2.5x)
	BX = segment of window handle or 0000h for default
	ES:DI -&gt; buffer for window information (see #00554)
Return: AX = status
	    0000h successful
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
SeeAlso: AX=1000h,AX=1016h,AX=DE01h,AX=DE2Bh

Format of DESQview window information:
Offset	Size	Description	(Table 00554)
 00h	BYTE	task flag: 00h window, 01h task
 01h	BYTE	process number if owner task
		00h if non-owner task
 02h	WORD	segment of owner's handle, 0000h if orphaned
 04h	WORD	mapping context (see #00416 at AX=1016h)
 06h	BYTE	task status (see #00555)
 07h	BYTE	unused
 08h	WORD	status bits (see #00556)
 0Ah	BYTE	01h if foreground-only window

(Table 00555)
Values for DESQview task status:
 00h	"Waiting" waiting for input
 01h	"Idle" keyboard poll limit reached
 03h	same as 01h
 04h	"Pausing" INT 15/AX=1000h pause called
 04h	DV/X direct: user did something to allow task switch
 05h	"ModeChg" video mode about to be changed
 06h	"ModeNtf" notify that video mode changed
 07h	"MoniCh" requested change to other monitor
 08h	"StartPgm" control relinquished to start new process
 09h	"MgrCan" made window manager CANCEL command
 0Ah	"Slicing" time slice expired
 0Bh	"Exit DOS" notify on DOS calls
 0Ch	"Enter DOS" process is re-entering DOS
 0Dh	"Terminate" INT 21/AH=4Ch or task freed
 0Eh	"BrkNxt" Control-Break pressed
 0Fh	"MgrCol" keyboard focus taken away
 10h	"PgmInt" interrupted by API call from another task
 11h	"BldOpen" call to INT 15/AX=DE01h

Bitfields for DESQview task status bits:
Bit(s)	Description	(Table 00556)
 6	task is freeing another task
 5	process is being created
 4	user suspended process
 3	process suspended itself
 2	process is resized direct window (suspended)
 1	process swapped out
 0	DESQview process

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE2D" name="15DE2D"><b>15DE2D</b></a> - INT 15 U - DESQview v2.50+ - GET/SET SOCKET HANDLER<br />
<pre>
INT 15 U - DESQview v2.50+ - GET/SET SOCKET HANDLER
	AX = DE2Dh
	CX = direction
	    FFFFh set socket handler
		DX:BX -&gt; FAR function for socket interface
			must be of the format described under INT 63"DESQview"
			  at #03515
	    other get socket handler
		Return: DX:BX -&gt; socket handler (see #03515)
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	the "set" subfunction is normally called only by SOCKET.DVR
SeeAlso: AX=DE2Eh,INT 63"DESQview",#03515

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE2E" name="15DE2E"><b>15DE2E</b></a> - INT 15 U - DESQview v2.50+ - SOCKET API<br />
<pre>
INT 15 U - DESQview v2.50+ - SOCKET API
	AX = DE2Eh
	DX:BX -&gt; socket record (see #00558)
		0000h:0000h to create a new socket record
Return: CX = size of socket record in bytes
	DX:BX -&gt; socket record which was used
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	socket records are allocated from common memory
	for Unix compatibility, each socket and connection on a socket is
	  allocated a DOS file handle (referencing an SFT for NUL) which is
	  used on various calls to specify which of possibly multiple
	  connections is to be operated upon
SeeAlso: AX=DE2Dh,INT 61/AX=0001h/SF=0001h"VINES",INT 63"DESQview"

(Table 00557)
Values for DESQview/X socket API function number:
 0000h	initialize socket???
 0001h	"gethostname"
 0002h	"ioctl" check for input
 0003h	"sleep" delay for specified period
 0004h	"htons" convert word to network (big-endian) byte order
 0005h	"select"
 0006h	"bsd_close"/"so_close" close socket
 0007h	NOP
 0008h	"connect" initiate connection on socket
 0009h	"recv"/"recvfrom" read from socket
 000Ah	"socket"
 000Bh	???
 000Ch	"gethostbyname"
 000Dh	"send"/"sendto" write to socket
 000Eh	??? (does something to all connections for process)
 000Fh	"getpid" get process identifier
 0010h	"gettimeofday"
 0011h	"bind" assign name to socket
 0012h	"listen" listen for connections on socket
 0013h	"accept" accept connection on socket
 0014h	connect to X server
 0015h	"gethostbyaddr" get host information for an address
 0016h	"getprotobyname"
 0017h	"getprotobynumber"
 0018h	"getservbyname"
 0019h	"getservbyport"
 001Ah	"getsockname" determine name bound to socket
 001Bh	"getpeername" get name of connected peer
 001Ch	"getsockopt"/"setsockopt"
 001Dh	"so_exit"	 close all sockets for calling process
 001Eh	"issock" determine whether file handle references socket
 001Fh	"so_attach" reattach previously detached socket
 0020h	"so_detach" temporarily detach socket
 0021h	"dvpath" get DESQview directory (see also AX=DE24h)
 0022h	"NewProc" start new application (see also AX=102Ch)
 0023h	"so_linkup"
 0024h	"CanonicalPath" canonicalize filename (see also INT 21/AH=60h)
 0025h	indirect INT 15h call
 0026h	Network Manager interface
 0027h	"so_unlink"    close connection from "so_linkup"
 0028h	"raisepriority"
 0029h	"lowerpriority"
 002Ah	"so_private" ???
 FFFFh	"NetExit" (appears to be a NOP)

Format of DESQview/X socket record:
Offset	Size	Description	(Table 00558)
 00h	WORD	signature F0ADh
 02h	WORD	function number (see #00557)
 04h	WORD	returned error code (see #00578)
 06h	WORD	maximum message size??? (usually 0400h)
 08h	WORD	PSP segment to use or 0000h if socket not valid
 0Ah	WORD	scratch space (JFT size)
 0Ch	DWORD	scratch space (JFT address)
 10h	DWORD	mailbox handle (initialized by function 0000h)
 14h	DWORD	timer object handle (initialized by function 0000h)
---function 0000h---
 18h	WORD	(ret) ???
---function 0001h---
 18h	WORD	(ret) status???
 1Ah 128 BYTEs	(ret) ASCIZ hostname (empty string if not on network)
 9Ah	WORD	maximum length of hostname to return
---function 0002h---
 18h	WORD	(ret) status
 1Ah	WORD	socket's file handle
 1Ch	WORD	IOCTL function
		05h "FIONREAD" determine available input
		06h "FIONBIO" set blocking state of socket
 1Eh	WORD	(return, subfn 05h) number of bytes available for reading
		(call, subfn 06h) 0000h blocking, nonzero nonblocking
---function 0003h---
 18h  2 BYTEs	unused
 1Ah	WORD	delay time in seconds
---function 0004h---
 18h	WORD	(ret) result in network (big-endian) byte order
 1Ah	WORD	value to convert to network byte order
---function 0005h---
 18h	WORD	(ret) number of handles meeting the specified conditions???
 1Ah	WORD	number of file handles in each bitset
 1Ch	DWORD	bitset of socket handles to check for readability
 20h	DWORD	bitset of socket handles to check for writability
 24h	DWORD	bitset of socket handles to check for errors
 28h	WORD	timeout in ??? or 0000h to block until some socket ready
 2Ah	DWORD	???
 2Eh	DWORD	???
---function 0006h---
 18h	WORD	(ret) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
---function 0008h---
 18h	WORD	(ret) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	0001h if socket name specified, 0000h if not
 1Eh	WORD	length of socket name
 20h  N BYTEs	name of socket to which to connect
---function 0009h---
 18h	WORD	(ret) number of bytes actually read, 0000h if connection
			closed, or FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	number of bytes to read
 1Eh	WORD	flags
 20h	WORD	0000h if no source address desired
		0001h if source address is to be stored (datagram sockets)
 22h	WORD	length of source address
 24h 110 BYTEs	source address
 92h 1K BYTEs	buffer for data to be read
---function 000Ah---
 18h	WORD	(ret) socket's file handle or FFFFh on error
 1Ah	WORD	address family (0001h,0002h)
 1Ch	WORD	socket type
 1Eh	WORD	protocol
---function 000Bh---
 18h	WORD	(ret) 0001h if ??? or FFFFh on error
 1Ah	WORD	socket's file handle
 1Eh	WORD	(call) ???
---function 000Ch---
 18h 128 BYTEs	ASCIZ hostname (special case if empty string or "unix")
 98h	???	(ret) packed 'hostent' structure
 A2h	???	(ret) ???
---function 000Dh---
 18h	WORD	(ret) number of bytes actually written or FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	number of bytes to write
 1Eh	WORD	number of bytes to follow in subsequent writes???
 20h	WORD	flags
 22h	WORD	0000h if no destination specified, 0001h if destination present
 24h	WORD	0001h if broadcast message???, 0000h if not
		(ignored if no destination specified)
 26h	WORD	length of destination address
 28h 110 BYTEs	destination address
 96h 1K BYTEs	buffer containing data to be written
---function 000Eh---
 no additional fields
---function 000Fh---
 18h	DWORD	(ret) DESQview task handle of calling process
---function 0010h---
 18h	DWORD	(ret) current time
 1Ch	DWORD	(ret) ???
---function 0011h---
 18h	WORD	(ret) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	length of name
 1Eh  N BYTEs	buffer for socket name
---function 0012h---
 18h	WORD	(ret) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	maximum backlog of pending connections allowed on socket
---function 0013h---
 18h	WORD	(ret) file handle for new connection or FFFFh on error
 1Ah	WORD	listen()ing socket's file handle
 1Ch	WORD	(call) length of buffer for connecting entity's address
		(ret) actual length of address
 1Eh  N BYTEs	buffer for connecting entity's address (110 bytes???)
---function 0014h---
 18h	WORD	(ret) socket's file handle or FFFFh on error
 1Ah  4 BYTEs	(ret) ???
 1Eh	WORD	(ret) ???
 20h	WORD	(ret) ???
 22h 256 BYTEs	ASCIZ X display name
122h	???
---function 0015h---
 18h	WORD	(call) type of address??? (test for 0001h seen)
 1Ah	WORD	(call) length of buffer for host address
 1Ch 110 BYTEs	buffer containing ASCIZ host address
 8Ah	WORD	(ret) offset of official host name
 8Ch	WORD	(ret) offset of alias list???
 8Eh	WORD	(ret) address type???
 90h	WORD	(ret) length of an address in bytes???
 92h	WORD	(ret) offset of address???
 9Ah  N BYTEs	(ret) buffer for hostname, alias list, and host address
---function 0016h---
 18h	???	buffer for ASCIZ protocol name
 98h	???
---function 0017h---
 18h	WORD	(call) protocol number
 1Ah	WORD	(ret) ??? or 0001h
---function 0018h---
 18h 128 BYTEs	buffer containing ASCIZ ???
 98h 128 BYTEs	buffer containing ASCIZ ???
118h	WORD	(ret) ???
---function 0019h---
 18h	WORD	port number
 1Ah 128 BYTEs	(call) ASCIZ host name
		(ret) packed servent strctures???
 9Ah	WORD	(ret) ???
---function 001Ah---
 18h	WORD	(ret) 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	(call) length of buffer for socket name
		(ret) actual length of socket name
 1Eh  N BYTEs	buffer for socket name
---function 001Bh---
 18h	WORD	(ret) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	(call) size of buffer for name
		(ret) actual size of name
 1Eh  N BYTEs	buffer for peer's name
---function 001Ch---
 18h	WORD	(ret) status: 0000h if successful, FFFFh on error
 1Ah	WORD	direction: 0000h to get, 0001h to set
 1Ch	WORD	socket's file handle
 1Eh	WORD	option level
 20h	WORD	option name
 22h	WORD	(call) length of buffer for option value
		(ret) actual length of option value
 24h  N BYTEs	buffer for option value
---function 001Dh---
 no additional fields
---function 001Eh---
 18h	WORD	(ret) status: 0000h ??? or 0001h ???
 1Ah	WORD	file handle which may or may not be a socket
---function 001Fh---
 18h	WORD	(ret) file handle or FFFFh on error
 1Ah	DWORD	(call) pointer to Socket Context Record (see #00579) of a
			previously detached socket
---function 0020h---
 18h	WORD	(ret) status: 0000h if successful or FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	DWORD	(ret) pointer to Socket Context Record (see #00579) for
			the file handle
---function 0021h---
 18h 64 BYTEs	buffer for DESQview startup directory (see AX=DE25h)
---function 0022h---
 18h	DWORD	(ret) task handle of new application
 1Ch	WORD	size of .DVP data
 1Eh 129 BYTEs	ASCIZ ???
 9Fh  N BYTEs	.DVP data (see #00427 at AX=102Ch)
---function 0023h---
 18h	WORD	(ret) ??? or FFFFh on error
 1Ah	WORD	socket's file handle???
---function 0024h---
 18h	WORD	(ret) DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
			0000h if successful
 1Ah 129 BYTEs	ASCIZ filename/pathname
11Bh 129 BYTEs	ASCIZ canonicalized filename/pathname (see INT 21/AH=60h)
---function 0025h---
 18h	WORD	value of AX
 1Ah	WORD	value of BX
 1Ch	WORD	(call) value of CX for call if AH value other than 12h
		(call) number of stack parameters if AH value is 12h
		(ret) returned CX for calls other than INT 15/AH=12h
 1Eh	WORD	value of DX
 20h	WORD	value of DI
 22h	WORD	value of SI
 24h	WORD	value of DS
 26h	WORD	value of ES
 28h	WORD	(ret) value of FLAGS after call
 2Ah  N DWORDs	(call) stack parameters for INT 15/AH=12h call
		(ret) stack results from INT 15/AH=12h call
---function 0026h---
 18h	WORD	(call) Network Manager subfunction (see #00559)
		(ret) status??? (0000h on error)
 1Ah	WORD	(call) size of parameter data
		(ret) size of returned data
 1Ch  N BYTEs	(call) parameter data required by call (see #00560,#00561,#00577)
		(ret) result data (see #00570,#00571,#00576)
---function 0027h---
 18h	WORD	(ret) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
---functions 0028h,0029h---
 18h	WORD	(call) file handle for which to set priority low/high
			FFFFh to change calling task's priority
---function 002Ah---
 no additional fields

(Table 00559)
Values for DESQview/X Network Manager subfunction:
 0004h	"so_exit"???
 0005h	"gethostbyname"
 0006h	"gethostname"
 0009h	"socket"
 000Dh	"gethostbyaddr"
 000Fh	"getprotobyname"
 0010h	get protocol name for protocol number
 0011h	"getservbyname"
 0012h	"getservbyport" (see #00563)
 0013h	"getsockname"??? (see #00564)
 0016h	"shutdown" (see #00565)
 0017h	kill Network Manager
 0018h	"getpeername"??? (see #00566)
 0019h	??? (called by socket function 0000h) (see #00567)
 001Ah	??? (see #00568)
 001Bh	"so_linkup" (see #00569)
 001Dh	"getnetstatus" get network services (see #00570)
 001Fh	"getpwuid"
 0020h	"getpwnam"
 0021h	"getpwvar"
 0022h	"crypt"
 0023h	"so_unlink"
 0024h	"getlogin" (see #00571)
 0028h	"sethostent"
 0029h	"gethostent"
 002Ah	"soaddhost"
 002Bh	"soupdatehost"
 002Ch	"sodeletehost"
 002Dh	"setservent"
 002Eh	"getservent"
 002Fh	"setpwent"
 0030h	"getpwent" (see #00572)
 0031h	"sethostpath" (see #00573)
 0032h	"endservent"
 0033h	"endhostent"
 0034h	"getnettype" get IP network number (see #00574)
 0035h	??? (pops up Network Manager window)
 0037h	"getnettimeout" (see #00575)
 0038h	get machine name and IP address (see #00576)
 0039h	"getuid" (see #00577)
---DV/X v2.0+ ---
 0041h	"deletepwnam"
 0045h	"renamepw"

Format of Function 0026h/Subfunction 000Fh data:
Offset	Size	Description	(Table 00560)
 00h  8 BYTEs	(ret) ???

Format of Function 0026h/Subfunction 0010h data:
Offset	Size	Description	(Table 00561)
 00h  2 BYTEs	(ret) ???
 02h	WORD	(ret) protocol number
 04h	WORD	(call) protocol number for which to get name
 06h	WORD	(ret) ???
 08h	var	(ret) ASCIZ protocol name
 N	var	(ret) ASCIZ protocol name

Format of Function 0026h/Subfunction 0011h data:
Offset	Size	Description	(Table 00562)
 00h  8 BYTEs	???
 08h	var	(ret) ASCIZ protocol name
	var	(ret) ASCIZ ??? name
	var	(ret) ASCIZ ??? name

Format of Function 0026h/Subfunction 0012h data:
Offset	Size	Description	(Table 00563)
 00h  8 BYTEs	(ret) ???

Format of Function 0026h/Subfunction 0013h data:
Offset	Size	Description	(Table 00564)
 00h 116 BYTEs	(ret) ???

Format of Function 0026h/Subfunction 0016h ("shutdown") data:
Offset	Size	Description	(Table 00565)
 00h	WORD	(ret) shutdown status (0000h successful, FFFFh error)
 02h  4 BYTEs	(ret) ???
 04h	WORD	(call) socket handle
 06*h	WORD	(call) what (0 = receives, 1 = sends, 2 = both)

Format of Function 0026h/Subfunction 0018h data:
Offset	Size	Description	(Table 00566)
 00h 116 BYTEs	(ret) ???

Format of Function 0026h/Subfunction 0019h data:
Offset	Size	Description	(Table 00567)
 00h  4 BYTEs	(ret) ???
 04h	DWORD	(ret) task handle of ???

Format of Function 0026h/Subfunction 001Ah data:
Offset	Size	Description	(Table 00568)
 00h 38 BYTEs	(ret) ???

Format of Function 0026h/Subfunction 001Bh data:
Offset	Size	Description	(Table 00569)
 00h 10 BYTEs	(ret) ???

Format of Function 0026h/Subfunction 001Dh return data [array]:
Offset	Size	Description	(Table 00570)
 00h	WORD	??? or FFFFh if end of array
 02h  7 BYTEs	???
 09h 27 BYTEs	ASCIZ name of service

Format of Function 0026h/Subfunction 0024h return data:
Offset	Size	Description	(Table 00571)
 00h	var	ASCIZ username

Format of Function 0026h/Subfunction 0030h data:
Offset	Size	Description	(Table 00572)
 00h	WORD	(call) UID or 0000h for current user
		(ret) ???
 02h	WORD	(ret) UID
 04h  6 BYTEs	(ret) ???
 0Ah	var	(ret) ASCIZ username
	var	(ret) ASCIZ encrypted password
	var	(ret) ASCIZ initial ("home") directory

Format of Function 0026h/Subfunction 0031h ("sethostpath") data:
Offset	Size	Description	(Table 00573)
 00h   4 BYTEs	???
 04h 144 BYTEs	ASCIZ ???

Format of Function 0026h/Subfunction 0034h data:
Offset	Size	Description	(Table 00574)
 00h  1-3 BYTEs IP network number of caller's machine (low byte first)

Format of Function 0026h/Subfunction 0037h ("getnettimeout") return data:
Offset	Size	Description	(Table 00575)
 00h	WORD	(ret) timeout
 02h  2 BYTEs	(ret) ???

Format of Function 0026h/Subfunction 0038h return data:
Offset	Size	Description	(Table 00576)
 00h	BYTE	???
 01h  4 BYTEs	IP address
 05h	var	ASCIZ machine name
	???

Format of Function 0026h/Subfunction 0039h ("getuid") return data:
Offset	Size	Description	(Table 00577)
 00h	WORD	user ID
 02h  2 BYTEs	???
SeeAlso: #00573,#00576

(Table 00578)
Values for DESQview/X socket error code:
 0000h	successful
 0009h	"BADF" bad file handle
 000Ch	"ENOMEM" out of memory
 000Eh	"EFAULT" bad address
 0016h	"EINVAL" invalid argument
 0018h	"EMFILE" too many open files
 0020h	"EPIPE" ??? broken pipe
 0023h	"EWOULDBLOCK" operation cannot be completed at this time
 0024h	"EINPROGRESS" operation now in progress
 0026h	"ENOTSOCK" socket invalid
 0028h	"EMSGSIZE" message too long to send atomically
 002Ch	"ESOCKTNOSUPPORT" socket type not supported
 002Fh	"EAFNOSUPPORT" address family not supp. by protocol fam.
 0031h	"EDOM" argument too large
 0038h	"EISCONN" socket is already connected
 0039h	"ENOTCONN" socket is not connected

Format of DESQview/X Socket Context Record:
Offset	Size	Description	(Table 00579)
 00h	DWORD	pointer to next Socket Context Record, 0000h:0000h if last
 04h	WORD	SFT index for socket, 00FFh if not connected, FFFFh if detached
 06h	WORD	PSP segment of owner or 0000h
 08h	WORD	mapping context of owning window (see #00416 at AX=1016h)
 0Ah  2 BYTEs	???
 0Ch	WORD	address family
 0Eh	WORD	socket type
 10h	WORD	protocol
 12h	WORD	socket state
		0001h created
		0002h bound
		0003h listening???
		0005h connected
 14h	DWORD	timer object handle
 18h	DWORD	object handle (mailbox???)
 1Ch	DWORD	object handle of parent of above object or 0000h:0000h
 20h	DWORD	pointer to ??? or 0000h
 24h  6 BYTEs	???
 2Ah	WORD	file handle for socket or FFFFh
 2Ch  2 BYTEs	???
 2Eh	WORD	nonzero if socket nonblocking
---network connections only---
 30h  2 BYTEs	???
 32h	WORD	???
 34h  4 BYTEs	(big-endian) IP address of remote
 38h  6 BYTEs	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE2F" name="15DE2F"><b>15DE2F</b></a> - INT 15 - DESQview v2.50+ - "VIDEONOTIFY" - HAS DIRECT WINDOW BEEN ACTIVE?<br />
<pre>
INT 15 - DESQview v2.50+ - "VIDEONOTIFY" - HAS DIRECT WINDOW BEEN ACTIVE?
	AX = DE2Fh
Return: BX = status
	    0001h keyboard focus has been given to a direct window since the
		last call
	    0000h if not
Notes:	DESQview 2.50-2.53 are distributed as part of DESQview/X v1.00-1.10.
	Quarterdeck stated that this call would not be available under future
	  versions of DESQview Classic, but it is still present in v2.60

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE30" name="15DE30"><b>15DE30</b></a> - INT 15 - DESQview v2.50+ - "GETDVXVERSION" - GET DESQview/X VERSION<br />
<pre>
INT 15 - DESQview v2.50+ - "GETDVXVERSION" - GET DESQview/X VERSION
	AX = DE30h
Return: BX = version (BH=major, BL=minor) or 0000h if not DESQview/X
Notes:	DESQview 2.50-2.53 are distributed as part of DESQview/X v1.00-1.10.
	you must first check the DESQview version to verify that it is 2.50 or
	  greater
SeeAlso: INT 21/AH=2Bh/CX=4445h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15DE31" name="15DE31"><b>15DE31</b></a> - INT 15 - DESQview/X v1.10 - ???<br />
<pre>
INT 15 - DESQview/X v1.10 - ???
	AX = DE31h
	CX = ???
	    0000h ???
	    nonzero ???
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212B--CX4445" name="212B--CX4445"><b>212B--CX4445</b></a> - INT 21 - DESQview - INSTALLATION CHECK<br />
<pre>
INT 21 - DESQview - INSTALLATION CHECK
	AH = 2Bh
	CX = 4445h ('DE')
	DX = 5351h ('SQ')
	AL = subfunction (DV v2.00+)
	    01h get version
		Return: BX = version (BH = major, BL = minor)
		Note: early copies of v2.00 return 0002h
	    02h get shadow buffer info, and start shadowing
		Return: BH = rows in shadow buffer
			BL = columns in shadow buffer
			DX = segment of shadow buffer
	    04h get shadow buffer info
		Return: BH = rows in shadow buffer
			BL = columns in shadow buffer
			DX = segment of shadow buffer
	    05h stop shadowing
Return: AL = FFh if DESQview not installed
Notes:	in DESQview v1.x, there were no subfunctions; this call only identified
	  whether or not DESQview was loaded.  DESQview v2.52 performs function
	  01h for all subfunction requests 0Ch and higher and appears to ignore
	  all lower-numbered functions not listed here.
	DESQview versions 2.50-2.52 are part of DESQview/X v1.0x; version 2.53
	  is part of DESQview/X v1.10; and version 2.63 is part of DESQview/X
	  v2.00.
BUG:	subfunction 05h does not appear to work correctly in DESQview 2.52
SeeAlso: INT 10/AH=FEh,INT 10/AH=FFh,INT 15/AX=1024h,INT 15/AX=DE30h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214402_8" name="214402_8"><b>214402</b></a> - INT 21 U - Quarterdeck - HOOKROM.SYS - GET HOOKED VECTOR TABLE<br />
<pre>
INT 21 U - Quarterdeck - HOOKROM.SYS - GET HOOKED VECTOR TABLE
	AX = 4402h
	BX = file handle for device "HOOKROM$"
	CX = 0004h
	DS:DX -&gt; DWORD buffer for address of hooked vector table (see #01451)
Return: CF clear if successful
	    DS:DX buffer filled
	CF set on error
	    AX = error code (01h,05h,06h,0Dh) (see #01680 at AH=59h/BX=0000h)
SeeAlso: AX=4402h/SF=01h

Format of HOOKROM.SYS hooked vector table entry:
Offset	Size	Description	(Table 01451)
 00h  5 BYTEs	FAR jump to actual interrupt handler
		(end of table if first byte is not EAh)
 05h	BYTE	interrupt vector number

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD200BX5144" name="2FD200BX5144"><b>2FD200BX5144</b></a> - INT 2F - Quarterdeck RPCI - INSTALLATION CHECK<br />
<pre>
INT 2F - Quarterdeck RPCI - INSTALLATION CHECK
	AX = D200h
	BX = 5144h ("QD")
	CX = 4D45h ("ME")
	DX = 4D30h ("M0")
Return: AL = FFh installed
	if BX,CX,DX registers were as specified on entry:
	    BX = 4D45h ("ME")
	    CX = 4D44h ("MD")
	    DX = 5652h ("VR")
Range:	AH=C0h to AH=FFh, selected by scanning AH=D2h-FFh, then AH=C0h-D1h
Notes:	the Quarterdeck RPCI (Resident Program Communication Interface) is
	  supported by QEMM v5.0+, QRAM, MANIFEST, VIDRAM, etc.
	for AL &lt;&gt; 0, if the BX/CX/DX values don't match the identifier of a
	  Quarterdeck product, it just chains to the previous INT 2F handler
SeeAlso: AX=D201h/BX=4849h,AX=D201h/BX=4D41h,AX=D201h/BX=4D45h
SeeAlso: AX=D201h/BX=5145h,AX=D201h/BX=5649h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE00BX4456" name="2FDE00BX4456"><b>2FDE00BX4456</b></a> - INT 2F - DESQview v2.26+ External Device Interface - INSTALLATION CHECK<br />
<pre>
INT 2F - DESQview v2.26+ External Device Interface - INSTALLATION CHECK
	AX = DE00h
	BX = 4456h ("DV")
	CX = 5844h ("XD")
	DX = 4931h ("I1")
Return: AL = FFh if installed (even if other registers do not match)
	if BX,CX, and DX were as specified on entry,
	    BX = 4845h ("HE")
	    CX = 5245h ("RE")
	    DX = 4456h ("DV")
Range:	AH=C0h to AH=FFh, selected by scanning AH=DEh-FFh, then AH=C0h-DDh
Note:	the XDI handler should not issue any DOS or BIOS calls, nor should it
	  issue DESQview API calls other than those allowed from hardware ints
SeeAlso: AX=DE02h,INT 15/AX=5400h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE01" name="2FDE01"><b>2FDE01</b></a> - INT 2F - DESQview v2.26+ External Device Interface - DRIVER CUSTOM SUBFUNCTION<br />
<pre>
INT 2F - DESQview v2.26+ External Device Interface - DRIVER CUSTOM SUBFUNCTION
	AX = DE01h
	BX = driver ID
	other registers as needed by driver
Notes:	XDI drivers should pass this call through to previous handler if ID
	  does not match
	DESQview never calls this function

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE01BX4450" name="2FDE01BX4450"><b>2FDE01BX4450</b></a> - INT 2F U - Quarterdeck QDPMI.SYS v1.0 - INSTALLATION CHECK<br />
<pre>
INT 2F U - Quarterdeck QDPMI.SYS v1.0 - INSTALLATION CHECK
	AX = DE01h
	BX = 4450h ("DP")
	CX = 4D49h ("MI")
	DX = 3039h ("09")
Return: AL = FFh if installed
	    BX = 4D42h ("MB")
	    CX = 4921h ("I!")
	    DX = 8F4Fh
	    ES:DI -&gt; filename of DPMI host overlay
InstallCheck:	test for the existence of the character device QDPMI$$$
SeeAlso: INT 2F/AX=1687h,INT 31/AX=0000h
Index:	installation check;QDPMI

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE01BXFFFE" name="2FDE01BXFFFE"><b>2FDE01BXFFFE</b></a> - INT 2F U - DESQview v2.26+ XDI - DVXMS.DVR - ???<br />
<pre>
INT 2F U - DESQview v2.26+ XDI - DVXMS.DVR - ???
	AX = DE01h
	BX = FFFEh
	CX = 4D47h ("MG")
	DX = 0052h (0,"R")
Return: AL = FFh
	DX = 584Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE02" name="2FDE02"><b>2FDE02</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - DV INITIALIZATION COMPLETE<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - DV INITIALIZATION COMPLETE
	AX = DE02h
	BX = mapping context of DESQview
	DX = handle of DESQview system task
Note:	driver should pass this call to previous handler after doing its work
SeeAlso: AX=DE03h,AX=DE0Fh,INT 15/AX=5400h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE03" name="2FDE03"><b>2FDE03</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - DV TERMINATION<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - DV TERMINATION
	AX = DE03h
	BX = mapping context of DESQview
	DX = handle of DESQview system task
Notes:	driver should pass this call to previous handler before doing its work
	DESQview makes this call when it is exiting, but before unhooking any
	  interrupt vectors
SeeAlso: AX=DE02h,AX=DE0Fh,INT 15/AX=5407h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE04" name="2FDE04"><b>2FDE04</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - ADD PROCESS<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - ADD PROCESS
	AX = DE04h
	BX = mapping context of new process (see #00416 at INT 15/AX=1016h)
	DX = handle of process
Return: nothing
Notes:	XMS XDI handler (installed by default) allocates a 22-byte record
	  (see #03104) from "common" memory to control access to XMS memory
	all DOS, BIOS, and DV API calls are valid in handler
	driver should pass this call to previous handler after processing it
SeeAlso: AX=DE05h,AX=DE06h,INT 15/AX=5401h

Format of XMS XDI structure:
Offset	Size	Description	(Table 03104)
 00h	DWORD	pointer to 10-byte record???
 04h	DWORD	pointer to next XMS XDI structure
 08h	WORD	mapping context
 0Ah	BYTE	???
 0Bh  5 BYTEs	XMS entry point to return for INT 2F/AX=4310h"XMS"
		(FAR jump to next field)
 10h  6 BYTEs	FAR handler for XMS driver entry point
		(consists of a FAR CALL followed by RETF)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE05" name="2FDE05"><b>2FDE05</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - REMOVE PROCESS<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - REMOVE PROCESS
	AX = DE05h
	BX = mapping context of process (see #00416 at INT 15/AX=1016h)
	DX = handle of last task in process
Return: nothing
Notes:	XMS XDI handler releases the structure allocated by AX=DE04h
	driver should pass this call to previous handler before processing it
	all DOS, BIOS, and DV API calls except those generating a task switch
	  are valid in handler
SeeAlso: AX=DE04h,AX=DE07h,INT 15/AX=5402h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE06" name="2FDE06"><b>2FDE06</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - CREATE TASK<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - CREATE TASK
	AX = DE06h
	BX = mapping context of process containing task
	DX = handle of new task
Notes:	driver should pass this call to previous handler after processing it
	all DOS, BIOS, and DV API calls are valid in handler

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE07" name="2FDE07"><b>2FDE07</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - TERMINATE TASK<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - TERMINATE TASK
	AX = DE07h
	BX = mapping context of process containing task
	DX = handle of task
Notes:	driver should pass this call to previous handler before processing it
	all DOS, BIOS, and DV API calls except those generating a task switch
	  are valid in handler
SeeAlso: AX=DE04h,AX=DE06h,AX=DE10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE08" name="2FDE08"><b>2FDE08</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - SAVE STATE<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - SAVE STATE
	AX = DE08h
	BX = mapping context of task being switched from
	      (see #00416 at INT 15/AX=1016h)
	DX = handle of task being switched from
Notes:	invoked prior to task swap, interrupts, etc
	driver should pass this call to previous handler after processing it
SeeAlso: AX=DE09h,INT 15/AX=5403h,INT 15/AX=DE27h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE09" name="2FDE09"><b>2FDE09</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - RESTORE STATE<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - RESTORE STATE
	AX = DE09h
	BX = mapping context of task being switched to
	      (see #00416 at INT 15/AX=1016h)
	DX = handle of task being switched to
Notes:	state is restored except for interrupts
	driver should pass this call to previous handler before processing it
SeeAlso: AX=DE08h,INT 15/AX=5404h,INT 15/AX=DE27h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0A" name="2FDE0A"><b>2FDE0A</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - CHANGE KEYBOARD FOCUS<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - CHANGE KEYBOARD FOCUS
	AX = DE0Ah
	BX = mapping context of task receiving focus
	DX = handle of running task
Notes:	driver should pass this call to previous handler before processing it
	this call often occurs inside a keyboard interrupt
	DV 2.42 does not provide this call to XDI handlers running inside a
	  window; instead, it directly calls the INT 2F handler which was
	  active at the time DV started
SeeAlso: INT 15/AX=DE26h,INT 15/AX=DE2Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0B" name="2FDE0B"><b>2FDE0B</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - DVP PROCESSING COMPLETE<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - DVP PROCESSING COMPLETE
	AX = DE0Bh
	BX = mapping context of DESQview system task
	CX = number of system memory paragraphs required for the use of all
	      XDI drivers (DV will add this to system memory in DVP buffer)
	DX = handle of DESQview system task
	SI = mapping context of new process if it starts
	ES:DI -&gt; DVP buffer
Return: CX incremented as needed
Notes:	once DV invokes this function, the DVP buffer contents may be changed
	driver should pass this call to previous handler before processing it

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0C" name="2FDE0C"><b>2FDE0C</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - SWAP OUT PROCESS<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - SWAP OUT PROCESS
	AX = DE0Ch
	BX = mapping context of task being swapped out
	      (see #00416 at INT 15/AX=1016h)
	DX = handle of DESQview system task
Note:	driver should pass this call to previous handler after processing it

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0D" name="2FDE0D"><b>2FDE0D</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - SWAP IN PROCESS<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - SWAP IN PROCESS
	AX = DE0Dh
	BX = mapping context of process just swapped in
	      (see #00416 at INT 15/AX=1016h)
	DX = handle of DESQview system task
Note:	driver should pass this call to previous handler before processing it

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0E" name="2FDE0E"><b>2FDE0E</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - DVP START FAILED<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - DVP START FAILED
	AX = DE0Eh
	BX = mapping context of DESQview system task
	DX = handle of DESQview system task
	SI = mapping context of failed process (same as for call to AX=DE0Bh)
Note:	driver should pass this call to previous handler after processing it

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0F" name="2FDE0F"><b>2FDE0F</b></a> - INT 2F C - DESQview v2.50+ External Dev Interface - INITIALIZE DV<br />
<pre>
INT 2F C - DESQview v2.50+ External Dev Interface - INITIALIZE DV
	AX = DE0Fh
Note:	DESQview 2.50+ calls this function just before it completes its
	  initialization.  At the time of the call, DESQview has not yet
	  changed any interrupt vectors
SeeAlso: AX=DE02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE10" name="2FDE10"><b>2FDE10</b></a> - INT 2F C - DESQview v2.50+ External Dev Interface - FREE TASK<br />
<pre>
INT 2F C - DESQview v2.50+ External Dev Interface - FREE TASK
	AX = DE10h
	BX = mapping context of process (see #00416 at INT 15/AX=1016h)
	DX = task handle of process
Note:	DESQview 2.50+ calls this function before it frees the task; it is
	  similar to AX=DE07h but allows the XDI handler to make calls which
	  cause context switches
SeeAlso: AX=DE06h,AX=DE07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDF00BX5445" name="2FDF00BX5445"><b>2FDF00BX5445</b></a> - INT 2F U - Quarterdeck TELTSR.COM - INSTALLATION CHECK<br />
<pre>
INT 2F U - Quarterdeck TELTSR.COM - INSTALLATION CHECK
	AX = DF00h
	BX = 5445h ('TE')
	CX = 4C54h ('LT')
	DX = 5352h ('SR')
Return: BX = 5454h ('TT') if installed
	CX = 494Eh ('IN') if installed
	DX = 5454h ('ST') if installed
Program: TELTSR is a Telnet TSR included with Quarterdeck's DESQview/X v2.00
	  which provides an INT 14h interface to the network
Range:	AH=DEh to AH=FFh and AH=C0h to AH=DDh, selected by scanning
SeeAlso: AX=DF01h"TELTSR",AX=DF02h"TELTSR",INT 14/AH=56h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDF01" name="2FDF01"><b>2FDF01</b></a> - INT 2F U - Quarterdeck TELTSR.COM - CLOSE CONNECTION<br />
<pre>
INT 2F U - Quarterdeck TELTSR.COM - CLOSE CONNECTION
	AX = DF01h
Return: nothing???
Note:	invokes the DESQview/X socket API (see INT 15/AX=DE2Eh) function 0006h
	  to close the socket corresponding to the file handle set with
	  AX=DF02h; NOP if no file handle was ever set
SeeAlso: AX=DF00h"TELTSR",AX=DF02h"TELTSR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDF02" name="2FDF02"><b>2FDF02</b></a> - INT 2F U - Quarterdeck TELTSR.COM - OPEN CONNECTION<br />
<pre>
INT 2F U - Quarterdeck TELTSR.COM - OPEN CONNECTION
	AX = DF02h
	BX = file handle for connection's socket
Return: AX = status
	    0000h successful
	    FFFFh no more room in TELTSR's JFT
Program: TELTSR is a Telnet TSR included with Quarterdeck's DESQview/X v2.00
Notes:	the indicated file handle becomes owned by TELTSR, and is closed in
	  the caller's JFT
	multiple calls to this function will override the previous assignment
	  without closing the previous file; use AX=DF01h before further calls
SeeAlso: AX=DF00h"TELTSR",AX=DF01h"TELTSR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#4B810D" name="4B810D"><b>4B810D</b></a> - INT 4B - QEMM-386 - BUG<br />
<pre>
INT 4B - QEMM-386 - BUG
	AX = 810Dh
Note:	the code in QEMM v5.11 and 6.00 jumps to an invalid location on this
	  call

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#63_5" name="63_5"><b>63</b></a> - INT 63 - DESQview/X - SOCKET API<br />
<pre>
INT 63 - DESQview/X - SOCKET API
InstallCheck:	test for the string "dvxunix" (yes, lowercase) at offset 9
	  from the interrupt handler start (see #03515)
Notes:	parameters are passed by patching (!) data field immediately following
	  the entry point, as detailed below (see #03515); the preferred
	  method for calling the socket API is via INT 15/AX=DE2Eh
SeeAlso: INT 15/AX=DE2Eh,INT BE"DESQview"
Index:	installation check;DESQview/X socket interface

Format of DESQview/X socket interrupt handler entry:
Offset	Size	Description	(Table 03515)
 00h  3 BYTEs	near jump or short jump + NOP to actual interrupt handler
 03h	WORD	offset from following pointer for initial top of local stack
 05h	DWORD	pointer to argument/stack block (see INT 15/AX=DE2Eh)
 09h  7 BYTEs	signature "dvxunix"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#BE_0" name="BE_0"><b>BE</b></a> - INT BE - DESQview/X - ???<br />
<pre>
INT BE - DESQview/X - ???
Note:	points at an IRET
SeeAlso: INT 15/AX=BFDEh/BX=0006h,INT 63"DESQview"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#FF_2" name="FF_2"><b>FF</b></a> - INT FF U - QEMM-386.SYS v6.0+ - internal<br />
<pre>
INT FF U - QEMM-386.SYS v6.0+ - internal
Notes:	requires that a byte in the conventional-memory stub be set to the
	  desired function number (00h through 0Ch)
SeeAlso: #04081

(Table 04081)
Values for QEMM internal functions:
 00h	reflect back to Virtual86-mode interrupt handler (default)
 01h	???
 02h	access DR7???
 03h	QPI upcall (see INT 67/AH=3Fh)
 04h	???
 05h	???
 06h	INT 15/AH=87h
 07h	EMS services (see INT 67/AH=40h,INT 67/AH=5Dh)
 08h	???
 09h	QEMM exception handler
 0Ah	XMS services (see INT 2F/AX=4310h"XMS")
 0Bh	Virtual DMA Services (see INT 4B/AX=8102h)
 0Ch	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<div class="bottom-nav"><b><a href="./index.html">Home</a></b> <b>Interrupt Index</b>: <a href="./INTERRUP.CAT.HTML">by Category</a> <a href="./INTERRUP.NUM.HTML">by ID</a> <b>TOC</b>: <a href="#__toc">by Order</a> <b><a href="#top">Top</a></b></div>

</body>
</html>
