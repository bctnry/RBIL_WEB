
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INTERRUP._2F</title>
    <style>
        body {
            font-variant-ligatures: none;
        }
        pre {
            font-family: 'Courier New', Courier, monospace;
        }
        a {
            color: black;
        }
        .bottom-nav {
            position: sticky;
            bottom: 0px;
            background-color: white;
            text-align: right;
        }
        h3, h4 {
            margin: 0;
        }
</style>
</head>
<body>

<b>Interrupt List Release 61 Last change 16jul00</b><br />
<b>Copyright (c) 1989-1999,2000 Ralf Brown</b><br />
<pre>
Index for interrupt INT 2F
</pre>

<p>
<a name="__toc"><b>Table of Contents by Order</b></a><br />

<a href="#2F"><b>2F</b> - INT 2F - Multiplex - NOTES</a><br />
<a href="#2F_0"><b>2F</b> - INT 2F - BMB Compuscience Canada Utilities Interface - INSTALLATION CHECK</a><br />
<a href="#2F_1"><b>2F</b> - INT 2F - Ross Wentworth's Turbo Pascal POPUP LIBRARY</a><br />
<a href="#2F_2"><b>2F</b> - INT 2F - CiriSOFT Spanish University of Valladolid TSR's Interface</a><br />
<a href="#2F00"><b>2F00</b> - INT 2F U - DOS 2.x only PRINT.COM - SUBMIT FILE FOR PRINTING</a><br />
<a href="#2F00_0"><b>2F00</b> - INT 2F U - PSPRINT - PRINT JOB CONTROL</a><br />
<a href="#2F0080"><b>2F0080</b> - INT 2F - DOS 3.1+ PRINT - GIVE PRINT A TIME SLICE</a><br />
<a href="#2F00D8"><b>2F00D8</b> - INT 2F - Personal NetWare - VLM - ???</a><br />
<a href="#2F01"><b>2F01</b> - INT 2F U - DOS 2.x only PRINT.COM - REMOVE FILE FROM PRINT QUEUE</a><br />
<a href="#2F0100"><b>2F0100</b> - INT 2F - DOS 3.0+ PRINT - INSTALLATION CHECK</a><br />
<a href="#2F0100SI20D6"><b>2F0100SI20D6</b> - INT 2F U - PrintCache 3.1 PRINT.COM - INSTALLATION CHECK</a><br />
<a href="#2F0101"><b>2F0101</b> - INT 2F - DOS 3.0+ PRINT - SUBMIT FILE FOR PRINTING</a><br />
<a href="#2F0101SI20D6"><b>2F0101SI20D6</b> - INT 2F U - PrintCache v3.1 PRINT.COM - SUBMIT FILE FOR PRINTING</a><br />
<a href="#2F0102"><b>2F0102</b> - INT 2F - DOS 3.0+ PRINT - REMOVE FILE FROM PRINT QUEUE</a><br />
<a href="#2F0103"><b>2F0103</b> - INT 2F - DOS 3.0+ PRINT - CANCEL ALL FILES IN PRINT QUEUE</a><br />
<a href="#2F0104"><b>2F0104</b> - INT 2F - DOS 3.0+ PRINT - FREEZE PRINT QUEUE TO READ JOB STATUS</a><br />
<a href="#2F0105"><b>2F0105</b> - INT 2F - DOS 3.0+ PRINT - RESTART PRINT QUEUE AFTER STATUS READ</a><br />
<a href="#2F0106"><b>2F0106</b> - INT 2F - DOS 3.3+ PRINT - GET PRINTER DEVICE</a><br />
<a href="#2F0107"><b>2F0107</b> - INT 2F U - PrintCache v3.1 PRINT.COM - SET TRAILING FORM FEEDS</a><br />
<a href="#2F0200"><b>2F0200</b> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - INSTALLATION CHECK</a><br />
<a href="#2F0201"><b>2F0201</b> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???</a><br />
<a href="#2F0202"><b>2F0202</b> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???</a><br />
<a href="#2F0203"><b>2F0203</b> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???</a><br />
<a href="#2F0204"><b>2F0204</b> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???</a><br />
<a href="#2F_3"><b>2F</b> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???</a><br />
<a href="#2F0500"><b>2F0500</b> - INT 2F U - DOS 3.0+ CRITICAL ERROR HANDLER - INSTALLATION CHECK</a><br />
<a href="#2F05"><b>2F05</b> - INT 2F CU - DOS 3.0+ CRITICAL ERROR HANDLER - EXPAND ERROR INTO STRING</a><br />
<a href="#2F0600"><b>2F0600</b> - INT 2F - DOS 3.0+ ASSIGN - INSTALLATION CHECK</a><br />
<a href="#2F0601"><b>2F0601</b> - INT 2F U - DOS 3.0+ ASSIGN - GET DRIVE ASSIGNMENT TABLE</a><br />
<a href="#2F0800"><b>2F0800</b> - INT 2F U - DRIVER.SYS support - INSTALLATION CHECK</a><br />
<a href="#2F0801"><b>2F0801</b> - INT 2F U - DRIVER.SYS support - ADD NEW BLOCK DEVICE</a><br />
<a href="#2F0802"><b>2F0802</b> - INT 2F U - DRIVER.SYS support - EXECUTE DEVICE DRIVER REQUEST</a><br />
<a href="#2F0803"><b>2F0803</b> - INT 2F U - DOS 4.0+ DRIVER.SYS support - GET DRIVE DATA TABLE LIST</a><br />
<a href="#2F1000"><b>2F1000</b> - INT 2F - SHARE - INSTALLATION CHECK</a><br />
<a href="#2F1001"><b>2F1001</b> - INT 2F U - DR DOS 6.0+ FDOS EXTENSIONS - INSTALL FDOS HOOK (SHARE / DELWATCH)</a><br />
<a href="#2F1002CHFF"><b>2F1002CHFF</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - READ BUFFERS</a><br />
<a href="#2F1003"><b>2F1003</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - FLUSH BUFFERS</a><br />
<a href="#2F1004"><b>2F1004</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - FREE FAT CHAIN</a><br />
<a href="#2F1005"><b>2F1005</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - ALLOCATE CLUSTER</a><br />
<a href="#2F1006"><b>2F1006</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - NEXT CLUSTER / READ FAT???</a><br />
<a href="#2F1007"><b>2F1007</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - UPDATE FAT ENTRY / WRITE FAT???</a><br />
<a href="#2F1008"><b>2F1008</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - FIXUP CHECKSUMS / DIR UPDATE???</a><br />
<a href="#2F1009"><b>2F1009</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - DIRECTORY BUFFER INFO</a><br />
<a href="#2F1010CX0000"><b>2F1010CX0000</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - SUPERSTOR - QUERY PHYS FREE SPACE</a><br />
<a href="#2F1020"><b>2F1020</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - CREATE PASSWORD ENTRY</a><br />
<a href="#2F1021"><b>2F1021</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - CHANGE PASSWORD ENTRY</a><br />
<a href="#2F1022"><b>2F1022</b> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - CHECK PASSWORD ENTRY</a><br />
<a href="#2F1040"><b>2F1040</b> - INT 2F U - DOS 4 only SHARE internal - ???</a><br />
<a href="#2F1080"><b>2F1080</b> - INT 2F U - DOS 4 only SHARE internal - TURN ON FILE SHARING CHECKS</a><br />
<a href="#2F1081"><b>2F1081</b> - INT 2F U - DOS 4 only SHARE internal - TURN OFF FILE SHARING CHECKS</a><br />
<a href="#2F10FE"><b>2F10FE</b> - INT 2F U - DR DOS 6.0+ DELWATCH.EXE - INSTALLATION CHECK</a><br />
<a href="#2F10FF"><b>2F10FF</b> - INT 2F U - DR DOS 5.0 - FIXUP SHARE STUB TABLE???</a><br />
<a href="#2F1100"><b>2F1100</b> - INT 2F C - NETWORK REDIRECTOR - INSTALLATION CHECK</a><br />
<a href="#2F1100SFDADA"><b>2F1100SFDADA</b> - INT 2F - MSCDEX (MS CD-ROM Extensions) - INSTALLATION CHECK</a><br />
<a href="#2F1101"><b>2F1101</b> - INT 2F CU - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY</a><br />
<a href="#2F1102"><b>2F1102</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - REMOVE REMOTE DIRECTORY</a><br />
<a href="#2F1103"><b>2F1103</b> - INT 2F CU - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY</a><br />
<a href="#2F1104"><b>2F1104</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - MAKE REMOTE DIRECTORY</a><br />
<a href="#2F1105"><b>2F1105</b> - INT 2F CU - NETWORK REDIRECTOR - CHDIR</a><br />
<a href="#2F1106"><b>2F1106</b> - INT 2F CU - NETWORK REDIRECTOR - CLOSE REMOTE FILE</a><br />
<a href="#2F1107"><b>2F1107</b> - INT 2F CU - NETWORK REDIRECTOR - COMMIT REMOTE FILE</a><br />
<a href="#2F1108"><b>2F1108</b> - INT 2F CU - NETWORK REDIRECTOR - READ FROM REMOTE FILE</a><br />
<a href="#2F1109"><b>2F1109</b> - INT 2F CU - NETWORK REDIRECTOR - WRITE TO REMOTE FILE</a><br />
<a href="#2F110A"><b>2F110A</b> - INT 2F CU - NETWORK REDIRECTOR (DOS 3.x only) - LOCK REGION OF FILE</a><br />
<a href="#2F110A_0"><b>2F110A</b> - INT 2F CU - NETWORK REDIRECTOR (DOS 4.0+) - LOCK/UNLOCK REGION OF FILE</a><br />
<a href="#2F110B"><b>2F110B</b> - INT 2F CU - NETWORK REDIRECTOR (DOS 3.x only) - UNLOCK REGION OF FILE</a><br />
<a href="#2F110C"><b>2F110C</b> - INT 2F CU - NETWORK REDIRECTOR - GET DISK INFORMATION</a><br />
<a href="#2F110D"><b>2F110D</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - SET REMOTE FILE'S ATTRIBUTES</a><br />
<a href="#2F110E"><b>2F110E</b> - INT 2F CU - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES</a><br />
<a href="#2F110F"><b>2F110F</b> - INT 2F CU - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES AND SIZE</a><br />
<a href="#2F1110"><b>2F1110</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - GET REMOTE FILE'S ATTRIBUTES AND SIZE</a><br />
<a href="#2F1111"><b>2F1111</b> - INT 2F CU - NETWORK REDIRECTOR - RENAME REMOTE FILE</a><br />
<a href="#2F1112"><b>2F1112</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - RENAME REMOTE FILE</a><br />
<a href="#2F1113"><b>2F1113</b> - INT 2F CU - NETWORK REDIRECTOR - DELETE REMOTE FILE</a><br />
<a href="#2F1114"><b>2F1114</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - DELETE REMOTE FILE</a><br />
<a href="#2F1115"><b>2F1115</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - OPEN REMOTE FILE</a><br />
<a href="#2F1116"><b>2F1116</b> - INT 2F CU - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE</a><br />
<a href="#2F1117"><b>2F1117</b> - INT 2F CU - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE</a><br />
<a href="#2F1118"><b>2F1118</b> - INT 2F CU - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE WITHOUT CDS</a><br />
<a href="#2F1119"><b>2F1119</b> - INT 2F CU - NETWORK REDIRECTOR - FIND FIRST FILE WITHOUT CDS</a><br />
<a href="#2F111A"><b>2F111A</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - FIND NEXT FILE WITHOUT CDS</a><br />
<a href="#2F111B"><b>2F111B</b> - INT 2F CU - NETWORK REDIRECTOR - FINDFIRST</a><br />
<a href="#2F111C"><b>2F111C</b> - INT 2F CU - NETWORK REDIRECTOR - FINDNEXT</a><br />
<a href="#2F111D"><b>2F111D</b> - INT 2F CU - NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS (ABORT)</a><br />
<a href="#2F111E"><b>2F111E</b> - INT 2F CU - NETWORK REDIRECTOR - DO REDIRECTION</a><br />
<a href="#2F111F"><b>2F111F</b> - INT 2F CU - NETWORK REDIRECTOR - PRINTER SETUP</a><br />
<a href="#2F1120"><b>2F1120</b> - INT 2F CU - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS</a><br />
<a href="#2F1121"><b>2F1121</b> - INT 2F CU - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE</a><br />
<a href="#2F1122"><b>2F1122</b> - INT 2F CU - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK</a><br />
<a href="#2F1123"><b>2F1123</b> - INT 2F CU - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME</a><br />
<a href="#2F1124"><b>2F1124</b> - INT 2F CU - NETWORK REDIRECTOR - TURN OFF REMOTE PRINTER</a><br />
<a href="#2F1125"><b>2F1125</b> - INT 2F CU - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE</a><br />
<a href="#2F1126"><b>2F1126</b> - INT 2F CU - NETWORK REDIRECTOR - REMOTE PRINTER ECHO ON/OFF</a><br />
<a href="#2F1127"><b>2F1127</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - UNUSED</a><br />
<a href="#2F1127BX4E57"><b>2F1127BX4E57</b> - INT 2F - NetWare 4.0 - REMOTE FILE COPY</a><br />
<a href="#2F1128"><b>2F1128</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - UNUSED</a><br />
<a href="#2F1129"><b>2F1129</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - UNUSED</a><br />
<a href="#2F112A"><b>2F112A</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - CLOSE ALL FILES FOR PROCESS</a><br />
<a href="#2F112B"><b>2F112B</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - GENERIC IOCTL</a><br />
<a href="#2F112C"><b>2F112C</b> - INT 2F CU - NETWORK REDIRECTOR (DOS 4.0+) - "UPDATE_CB" - ???</a><br />
<a href="#2F112D"><b>2F112D</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - EXTENDED ATTRIBUTES</a><br />
<a href="#2F112E"><b>2F112E</b> - INT 2F CU - NETWORK REDIRECTOR (DOS 4.0+) - EXTENDED OPEN/CREATE FILE</a><br />
<a href="#2F112F"><b>2F112F</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - IFS IOCTL</a><br />
<a href="#2F1130"><b>2F1130</b> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - GET IFSFUNC SEGMENT</a><br />
<a href="#2F1180"><b>2F1180</b> - INT 2F - LAN Manager Enhanced DOS Services - ???</a><br />
<a href="#2F1181"><b>2F1181</b> - INT 2F - LAN Manager Enhanced DOS Services - SET USER NAME???</a><br />
<a href="#2F1182"><b>2F1182</b> - INT 2F - LAN Manager Enhanced DOS Services - INSTALL SERVICE</a><br />
<a href="#2F1184"><b>2F1184</b> - INT 2F - LAN Manager Enhanced DOS - ???</a><br />
<a href="#2F1186"><b>2F1186</b> - INT 2F - LAN Manager Enhanced DOS - DosReadAsynchNmPipe</a><br />
<a href="#2F118A"><b>2F118A</b> - INT 2F - LAN Manager 2.0+ DOS Enhanced ENCRYPT.EXE - STREAM ENCRYPTION SERVICE</a><br />
<a href="#2F118B"><b>2F118B</b> - INT 2F - LAN Manager Enhanced DOS - ???</a><br />
<a href="#2F118C"><b>2F118C</b> - INT 2F - LAN Manager Enhanced DOS - ???</a><br />
<a href="#2F118E"><b>2F118E</b> - INT 2F - LAN Manager Enhanced DOS - ???</a><br />
<a href="#2F118F"><b>2F118F</b> - INT 2F - LAN Manager Enhanced DOS - DosWriteAsynchNmPipe</a><br />
<a href="#2F1190"><b>2F1190</b> - INT 2F - LAN Manager Enhanced DOS - DosReadAsynchNmPipe2</a><br />
<a href="#2F1191"><b>2F1191</b> - INT 2F - LAN Manager Enhanced DOS - DosWriteAsynchNmPipe2</a><br />
<a href="#2F11F0"><b>2F11F0</b> - INT 2F - Novell ??? - REMOTE FILE COPY</a><br />
<a href="#2F1200"><b>2F1200</b> - INT 2F U - DOS 3.0+ internal - INSTALLATION CHECK</a><br />
<a href="#2F1201"><b>2F1201</b> - INT 2F U - DOS 3.0+ internal - CLOSE CURRENT FILE</a><br />
<a href="#2F1202"><b>2F1202</b> - INT 2F U - DOS 3.0+ internal - GET INTERRUPT ADDRESS</a><br />
<a href="#2F1203"><b>2F1203</b> - INT 2F U - DOS 3.0+ internal - GET DOS DATA SEGMENT</a><br />
<a href="#2F1204"><b>2F1204</b> - INT 2F U - DOS 3.0+ internal - NORMALIZE PATH SEPARATOR</a><br />
<a href="#2F1205"><b>2F1205</b> - INT 2F U - DOS 3.0+ internal - OUTPUT CHARACTER TO STANDARD OUTPUT</a><br />
<a href="#2F1206"><b>2F1206</b> - INT 2F U - DOS 3.0+ internal - INVOKE CRITICAL ERROR</a><br />
<a href="#2F1207"><b>2F1207</b> - INT 2F U - DOS 3.0+ internal - MAKE DISK BUFFER MOST-RECENTLY USED</a><br />
<a href="#2F1208"><b>2F1208</b> - INT 2F U - DOS 3.0+ internal - DECREMENT SFT REFERENCE COUNT</a><br />
<a href="#2F1209"><b>2F1209</b> - INT 2F U - DOS 3.0+ internal - FLUSH AND FREE DISK BUFFER</a><br />
<a href="#2F120A"><b>2F120A</b> - INT 2F U - DOS 3.0+ internal - PERFORM CRITICAL ERROR INTERRUPT</a><br />
<a href="#2F120B"><b>2F120B</b> - INT 2F U - DOS 3.0+ internal - SIGNAL SHARING VIOLATION TO USER</a><br />
<a href="#2F120C"><b>2F120C</b> - INT 2F U - DOS 3.0+ internal - OPEN DEVICE AND SET SFT OWNER/MODE</a><br />
<a href="#2F120D"><b>2F120D</b> - INT 2F U - DOS 3.0+ internal - GET DATE AND TIME</a><br />
<a href="#2F120E"><b>2F120E</b> - INT 2F U - DOS 3.0+ internal - MARK ALL DISK BUFFERS UNREFERENCED</a><br />
<a href="#2F120F"><b>2F120F</b> - INT 2F U - DOS 3.0+ internal - MAKE BUFFER MOST RECENTLY USED</a><br />
<a href="#2F1210"><b>2F1210</b> - INT 2F U - DOS 3.0+ internal - FIND UNREFERENCED DISK BUFFER</a><br />
<a href="#2F1211"><b>2F1211</b> - INT 2F U - DOS 3.0+ internal - NORMALIZE ASCIZ FILENAME</a><br />
<a href="#2F1212"><b>2F1212</b> - INT 2F U - DOS 3.0+ internal - GET LENGTH OF ASCIZ STRING</a><br />
<a href="#2F1213"><b>2F1213</b> - INT 2F U - DOS 3.0+ internal - UPPERCASE CHARACTER</a><br />
<a href="#2F1214"><b>2F1214</b> - INT 2F U - DOS 3.0+ internal - COMPARE FAR POINTERS</a><br />
<a href="#2F1215"><b>2F1215</b> - INT 2F U - DOS 3.0+ internal - FLUSH BUFFER</a><br />
<a href="#2F1216"><b>2F1216</b> - INT 2F U - DOS 3.0+ internal - GET ADDRESS OF SYSTEM FILE TABLE ENTRY</a><br />
<a href="#2F1217"><b>2F1217</b> - INT 2F U - DOS 3.0+ internal - GET CURRENT DIRECTORY STRUCTURE FOR DRIVE</a><br />
<a href="#2F1218"><b>2F1218</b> - INT 2F U - DOS 3.0+ internal - GET CALLER'S REGISTERS</a><br />
<a href="#2F1219"><b>2F1219</b> - INT 2F U - DOS 3.0+ internal - SET DRIVE???</a><br />
<a href="#2F121A"><b>2F121A</b> - INT 2F U - DOS 3.0+ internal - GET FILE'S DRIVE</a><br />
<a href="#2F121B"><b>2F121B</b> - INT 2F U - DOS 3.0+ internal - SET YEAR/LENGTH OF FEBRUARY</a><br />
<a href="#2F121C"><b>2F121C</b> - INT 2F U - DOS 3.0+ internal - CHECKSUM MEMORY</a><br />
<a href="#2F121D"><b>2F121D</b> - INT 2F U - DOS 3.0+ internal - SUM MEMORY</a><br />
<a href="#2F121E"><b>2F121E</b> - INT 2F U - DOS 3.0+ internal - COMPARE FILENAMES</a><br />
<a href="#2F121F"><b>2F121F</b> - INT 2F U - DOS 3.0+ internal - BUILD CURRENT DIRECTORY STRUCTURE</a><br />
<a href="#2F1220"><b>2F1220</b> - INT 2F U - DOS 3.0+ internal - GET JOB FILE TABLE ENTRY</a><br />
<a href="#2F1221"><b>2F1221</b> - INT 2F U - DOS 3.0+ internal - CANONICALIZE FILE NAME</a><br />
<a href="#2F1222"><b>2F1222</b> - INT 2F U - DOS 3.0+ internal - SET EXTENDED ERROR INFO</a><br />
<a href="#2F1223"><b>2F1223</b> - INT 2F U - DOS 3.0+ internal - CHECK IF CHARACTER DEVICE</a><br />
<a href="#2F1224"><b>2F1224</b> - INT 2F U - DOS 3.0+ internal - SHARING RETRY DELAY</a><br />
<a href="#2F1225"><b>2F1225</b> - INT 2F U - DOS 3.0+ internal - GET LENGTH OF ASCIZ STRING</a><br />
<a href="#2F1226"><b>2F1226</b> - INT 2F U - DOS 3.3+ internal - OPEN FILE</a><br />
<a href="#2F1227"><b>2F1227</b> - INT 2F U - DOS 3.3+ internal - CLOSE FILE</a><br />
<a href="#2F1228BP4200"><b>2F1228BP4200</b> - INT 2F U - DOS 3.3+ internal - MOVE FILE POINTER</a><br />
<a href="#2F1229"><b>2F1229</b> - INT 2F U - DOS 3.3+ internal - READ FROM FILE</a><br />
<a href="#2F122A"><b>2F122A</b> - INT 2F U - DOS 3.3+ internal - SET FASTOPEN ENTRY POINT</a><br />
<a href="#2F122B"><b>2F122B</b> - INT 2F U - DOS 3.3+ internal - IOCTL</a><br />
<a href="#2F122C"><b>2F122C</b> - INT 2F U - DOS 3.3+ internal - GET DEVICE CHAIN</a><br />
<a href="#2F122D"><b>2F122D</b> - INT 2F U - DOS 3.3+ internal - GET EXTENDED ERROR CODE</a><br />
<a href="#2F122E"><b>2F122E</b> - INT 2F U - DOS 4.0+ internal - GET OR SET ERROR TABLE ADDRESSES</a><br />
<a href="#2F122F"><b>2F122F</b> - INT 2F U - DOS 4.x internal - SET DOS VERSION NUMBER TO RETURN</a><br />
<a href="#2F1230"><b>2F1230</b> - INT 2F U - Windows95 - FIND SFT ENTRY IN INTERNAL FILE TABLES</a><br />
<a href="#2F1231"><b>2F1231</b> - INT 2F U - Windows95 - SET/CLEAR "REPORT WINDOWS TO DOS PROGRAMS" FLAG</a><br />
<a href="#2F1250"><b>2F1250</b> - INT 2F U - PTS-DOS - SET MACHINE ID</a><br />
<a href="#2F1251"><b>2F1251</b> - INT 2F U - PTS-DOS - GET MACHINE ID</a><br />
<a href="#2F1252"><b>2F1252</b> - INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - SET SFT INCREMENT</a><br />
<a href="#2F1253"><b>2F1253</b> - INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - GET SFT INCREMENT</a><br />
<a href="#2F1260"><b>2F1260</b> - INT 2F C - PTS-DOS 6.51, S/DOS 1.0+ - "EMPTY" (RESERVED FOR INPUT STRING)</a><br />
<a href="#2F1261"><b>2F1261</b> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET FIRST UMB</a><br />
<a href="#2F1262"><b>2F1262</b> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET DOS COLOR</a><br />
<a href="#2F1263"><b>2F1263</b> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - SET DOS COLOR</a><br />
<a href="#2F1270"><b>2F1270</b> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - "SYSBELL" - EMIT A BEEP</a><br />
<a href="#2F1271"><b>2F1271</b> - INT 2F C - PTS-DOS, S/DOS - RESERVED FOR BEEP</a><br />
<a href="#2F12F0"><b>2F12F0</b> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - BACKDOOR INTERCEPT INT 2Fh CHAIN</a><br />
<a href="#2F12F1"><b>2F12F1</b> - INT 2F - PTS-DOS, S/DOS - RESERVED</a><br />
<a href="#2F12FFBL00"><b>2F12FFBL00</b> - INT 2F - FreeDOS - FDAK-DDT - INSTALLATION CHECK / STATUS CHECK</a><br />
<a href="#2F12FFBL01"><b>2F12FFBL01</b> - INT 2F - FreeDOS - FDAK-DDT - ENABLE FDAK DRIVERS</a><br />
<a href="#2F12FFBL02"><b>2F12FFBL02</b> - INT 2F - FreeDOS - FDAK-DDT - DISABLE FDAK DRIVERS</a><br />
<a href="#2F12FFBL03"><b>2F12FFBL03</b> - INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-ONLY</a><br />
<a href="#2F12FFBL04"><b>2F12FFBL04</b> - INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-WRITE</a><br />
<a href="#2F12FFBL05"><b>2F12FFBL05</b> - INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR ON</a><br />
<a href="#2F12FFBL06"><b>2F12FFBL06</b> - INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR OFF</a><br />
<a href="#2F12FFBL07"><b>2F12FFBL07</b> - INT 2F - FreeDOS - FDAK-DDT - UNINSTALL</a><br />
<a href="#2F12FFBX0000"><b>2F12FFBX0000</b> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BDOS</a><br />
<a href="#2F12FFBX0001"><b>2F12FFBX0001</b> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BDOS</a><br />
<a href="#2F12FFBX0002"><b>2F12FFBX0002</b> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BIOS</a><br />
<a href="#2F12FFBX0003"><b>2F12FFBX0003</b> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BIOS</a><br />
<a href="#2F12FFBX0005"><b>2F12FFBX0005</b> - INT 2F U - DR DOS 6.0+ - BOOT PHASE BROADCASTS FOR MEMORYMAX/RPLOADER/SECURITY</a><br />
<a href="#2F12FFBX0006"><b>2F12FFBX0006</b> - INT 2F U - DR DOS 6+, Novell DOS 7+ - EMM386.EXE - VIDEO MEMORY SPACE CONTROL</a><br />
<a href="#2F12FFBX0007"><b>2F12FFBX0007</b> - INT 2F U - Novell DOS 7 - SCRIPT.EXE - GET ???</a><br />
<a href="#2F12FFBX0009"><b>2F12FFBX0009</b> - INT 2F - DR DOS 6.0+ IBMBIO.COM - REGISTER ROOT OF UPPER MEMORY LINK</a><br />
<a href="#2F12FFBX0106"><b>2F12FFBX0106</b> - INT 2F U - Novell DOS 7+ - MEMORYMAX INSTALLATION CHECK</a><br />
<a href="#2F12FFBX0206"><b>2F12FFBX0206</b> - INT 2F - Novell DOS 7+ - MEMORYMAX GET PAGE TABLE ENTRY</a><br />
<a href="#2F12FFBX0306"><b>2F12FFBX0306</b> - INT 2F - Novell DOS 7+ - MEMORYMAX SET PAGE TABLE ENTRY</a><br />
<a href="#2F12FFBX0406"><b>2F12FFBX0406</b> - INT 2F - Novell DOS 7+ - MEMORYMAX CREATE ACCESS KEY</a><br />
<a href="#2F12FFBX0506"><b>2F12FFBX0506</b> - INT 2F - Novell DOS 7+ - MEMORYMAX DESTROY ACCESS KEY</a><br />
<a href="#2F12FFBL06_0"><b>2F12FFBL06</b> - INT 2F U - Novell DOS 7 - EMM386.EXE - ???</a><br />
<a href="#2F12FFBX0EDC"><b>2F12FFBX0EDC</b> - INT 2F U - Novell DOS 7 - EMM386.EXE - CHECK IF MULTITASKING SUPPORT LOADED???</a><br />
<a href="#2F13"><b>2F13</b> - INT 2F U - DOS 3.2+ - SET DISK INTERRUPT HANDLER</a><br />
<a href="#2F13_0"><b>2F13</b> - INT 2F U - MS-NET - ???</a><br />
<a href="#2F1400"><b>2F1400</b> - INT 2F C - NLSFUNC.COM - INSTALLATION CHECK</a><br />
<a href="#2F1400BX0EDC"><b>2F1400BX0EDC</b> - INT 2Fh - DR-DOS NLSFUNC 4.01+ - ENHANCED INSTALLATION CHECK</a><br />
<a href="#2F1400_0"><b>2F1400</b> - INT 2F - European MS-DOS 4.0 POPUP - "CheckPu" - INSTALLATION CHECK</a><br />
<a href="#2F1401"><b>2F1401</b> - INT 2F CU - NLSFUNC.COM - CHANGE CODE PAGE</a><br />
<a href="#2F1401_0"><b>2F1401</b> - INT 2F - European MS-DOS 4.0 POPUP - "PostPu" - OPEN/CLOSE POPUP SCREEN</a><br />
<a href="#2F1402"><b>2F1402</b> - INT 2F CU - NLSFUNC.COM - GET EXTENDED COUNTRY INFO</a><br />
<a href="#2F1402_0"><b>2F1402</b> - INT 2F - European MS-DOS 4.0 POPUP - "SavePu" - SAVE POPUP SCREEN</a><br />
<a href="#2F1403"><b>2F1403</b> - INT 2F CU - NLSFUNC.COM - SET CODE PAGE</a><br />
<a href="#2F1403_0"><b>2F1403</b> - INT 2F - European MS-DOS 4.0 POPUP - "RestorePu" - RESTORE SCREEN</a><br />
<a href="#2F1404"><b>2F1404</b> - INT 2F CU - NLSFUNC.COM - GET COUNTRY INFO</a><br />
<a href="#2F14FE"><b>2F14FE</b> - INT 2F U - DR DOS 5.0 NLSFUNC - GET EXTENDED COUNTRY INFORMATION</a><br />
<a href="#2F14FF"><b>2F14FF</b> - INT 2F U - DR DOS 5.0+ NLSFUNC - PREPARE CODE PAGE</a><br />
<a href="#2F1500"><b>2F1500</b> - INT 2F - DOS 4.00 GRAPHICS.COM - INSTALLATION CHECK</a><br />
<a href="#2F1500BX0000"><b>2F1500BX0000</b> - INT 2F - CD-ROM - INSTALLATION CHECK</a><br />
<a href="#2F1500CH90"><b>2F1500CH90</b> - INT 2F U - CDBLITZ v2.11 - INSTALLATION CHECK</a><br />
<a href="#2F1500CH91"><b>2F1500CH91</b> - INT 2F U - CDBLITZ v2.11 - GET STATISTICS</a><br />
<a href="#2F1500CH92"><b>2F1500CH92</b> - INT 2F U - CDBLITZ v2.11 - ENABLE CACHE</a><br />
<a href="#2F1500CH93"><b>2F1500CH93</b> - INT 2F U - CDBLITZ v2.11 - DISABLE CACHE</a><br />
<a href="#2F1500CH94"><b>2F1500CH94</b> - INT 2F U - CDBLITZ v2.11 - SET 'MAX' MODE (CACHE BOTH DIRECTORIES AND DATA)</a><br />
<a href="#2F1500CH95"><b>2F1500CH95</b> - INT 2F U - CDBLITZ v2.11 - SET 'MIN' MODE (CACHE ONLY DIRECTORY ENTRIES)</a><br />
<a href="#2F1500CH96"><b>2F1500CH96</b> - INT 2F U - CDBLITZ v2.11 - FLUSH CACHE</a><br />
<a href="#2F1500CH97"><b>2F1500CH97</b> - INT 2F U - CDBLITZ v2.11 - GET CACHE STATISTICS</a><br />
<a href="#2F1500CH99"><b>2F1500CH99</b> - INT 2F U - CDBLITZ v2.11 - UNINSTALL</a><br />
<a href="#2F1501"><b>2F1501</b> - INT 2F - CD-ROM - GET DRIVE DEVICE LIST</a><br />
<a href="#2F1502"><b>2F1502</b> - INT 2F - CD-ROM - GET COPYRIGHT FILE NAME</a><br />
<a href="#2F1503"><b>2F1503</b> - INT 2F - CD-ROM - GET ABSTRACT FILE NAME</a><br />
<a href="#2F1504"><b>2F1504</b> - INT 2F - CD-ROM - GET BIBLIOGRAPHIC DOC FILE NAME</a><br />
<a href="#2F1505"><b>2F1505</b> - INT 2F - CD-ROM - READ VTOC</a><br />
<a href="#2F1506"><b>2F1506</b> - INT 2F - CD-ROM - TURN DEBUGGING ON</a><br />
<a href="#2F1507"><b>2F1507</b> - INT 2F - CD-ROM - TURN DEBUGGING OFF</a><br />
<a href="#2F1508"><b>2F1508</b> - INT 2F - CD-ROM - ABSOLUTE DISK READ</a><br />
<a href="#2F1509"><b>2F1509</b> - INT 2F - CD-ROM - ABSOLUTE DISK WRITE</a><br />
<a href="#2F150A"><b>2F150A</b> - INT 2F - CD-ROM - RESERVED</a><br />
<a href="#2F150B"><b>2F150B</b> - INT 2F - CD-ROM v2.00+ - DRIVE CHECK</a><br />
<a href="#2F150CBX0000"><b>2F150CBX0000</b> - INT 2F - CD-ROM v2.00+ - GET MSCDEX.EXE VERSION (GET VERSION)</a><br />
<a href="#2F150D"><b>2F150D</b> - INT 2F - CD-ROM v2.00+ - GET CD-ROM DRIVE LETTERS</a><br />
<a href="#2F150E"><b>2F150E</b> - INT 2F - CD-ROM v2.00+ - GET/SET VOLUME DESCRIPTOR PREFERENCE</a><br />
<a href="#2F150F"><b>2F150F</b> - INT 2F - CD-ROM v2.00+ - GET DIRECTORY ENTRY</a><br />
<a href="#2F1510"><b>2F1510</b> - INT 2F - CD-ROM v2.10+ - SEND DEVICE DRIVER REQUEST</a><br />
<a href="#2F15FFBX0000"><b>2F15FFBX0000</b> - INT 2F - CD-ROM - CORELCDX - INSTALLATION CHECK</a><br />
<a href="#2F1600"><b>2F1600</b> - INT 2F - MS Windows - WINDOWS ENHANCED MODE INSTALLATION CHECK</a><br />
<a href="#2F1602"><b>2F1602</b> - INT 2F - MS Windows/386 2.x - GET API ENTRY POINT</a><br />
<a href="#2F1603"><b>2F1603</b> - INT 2F C - MS Windows/386 - GET INSTANCE DATA</a><br />
<a href="#2F1605"><b>2F1605</b> - INT 2F C - MS Windows - WINDOWS ENHANCED MODE & 286 DOSX INIT BROADCAST</a><br />
<a href="#2F1606"><b>2F1606</b> - INT 2F C - MS Windows - WINDOWS ENHANCED MODE & 286 DOSX EXIT BROADCAST</a><br />
<a href="#2F1607"><b>2F1607</b> - INT 2F C - MS Windows - VIRTUAL DEVICE CALL OUT API</a><br />
<a href="#2F1607BX0006"><b>2F1607BX0006</b> - INT 2F C - MS Windows - "V86MMGR" VIRTUAL DEVICE API</a><br />
<a href="#2F1607BX000C"><b>2F1607BX000C</b> - INT 2F C - MS Windows - "VMD" VIRTUAL MOUSE DEVICE API</a><br />
<a href="#2F1607BX000D"><b>2F1607BX000D</b> - INT 2F C - MS Windows95 - "VKD" VIRTUAL DEVICE - ??? CALLOUT</a><br />
<a href="#2F1607BX0010"><b>2F1607BX0010</b> - INT 2F C - MS Windows 3.1 - "BLOCKDEV" VIRTUAL HARD DISK DEVICE API</a><br />
<a href="#2F1607BX0014"><b>2F1607BX0014</b> - INT 2F C - MS Windows - "VNETBIOS" VIRTUAL DEVICE API</a><br />
<a href="#2F1607BX0015"><b>2F1607BX0015</b> - INT 2F C - MS Windows - "DOSMGR" VIRTUAL DEVICE API</a><br />
<a href="#2F1607BX0018"><b>2F1607BX0018</b> - INT 2F C - MS Windows - "VMPoll" VIRTUAL DEVICE - IDLE CALLOUT</a><br />
<a href="#2F1607BX0021"><b>2F1607BX0021</b> - INT 2F C - MS Windows - "PageFile" VIRTUAL DEVICE - GET LOCK BYTE</a><br />
<a href="#2F1607BX002D"><b>2F1607BX002D</b> - INT 2F C - MS Windows - "W32S" VIRTUAL DEVICE - ??? CALLOUT</a><br />
<a href="#2F1607BX0040"><b>2F1607BX0040</b> - INT 2F C - MS Windows - "IFSMgr" VIRTUAL DEVICE - ??? CALLOUT</a><br />
<a href="#2F1607BX0446"><b>2F1607BX0446</b> - INT 2F C - MS Windows - "VADLIBD" VIRTUAL DEVICE - ??? CALLOUT</a><br />
<a href="#2F1607BX0484"><b>2F1607BX0484</b> - INT 2F C - MS Windows - "IFSMgr" VIRTUAL DEVICE - ??? CALLOUT</a><br />
<a href="#2F1607BX0487"><b>2F1607BX0487</b> - INT 2F C - MS Windows - "NWSUP" VIRTUAL DEVICE - ??? CALLOUT</a><br />
<a href="#2F1607BX22C0"><b>2F1607BX22C0</b> - INT 2F C - Rational Systems DOS/4GW - ???</a><br />
<a href="#2F1607BX28A1"><b>2F1607BX28A1</b> - INT 2F C - MS Windows - "PharLap" VIRTUAL DEVICE - ??? CALLOUT</a><br />
<a href="#2F1607BX7A5F"><b>2F1607BX7A5F</b> - INT 2F C - MS Windows - "SIWVID" VIRTUAL DEVICE - ??? CALLOUT</a><br />
<a href="#2F1608"><b>2F1608</b> - INT 2F C - MS Windows - WINDOWS ENHANCED MODE INIT COMPLETE BROADCAST</a><br />
<a href="#2F1609"><b>2F1609</b> - INT 2F C - MS Windows - WINDOWS ENHANCED MODE BEGIN EXIT BROADCAST</a><br />
<a href="#2F160A"><b>2F160A</b> - INT 2F - MS Windows 3.1 - IDENTIFY WINDOWS VERSION AND TYPE</a><br />
<a href="#2F160B"><b>2F160B</b> - INT 2F - MS Windows 3.1 - IDENTIFY TSRs</a><br />
<a href="#2F160C"><b>2F160C</b> - INT 2F - MS Windows 3.1 - DETECT ROMs</a><br />
<a href="#2F160E"><b>2F160E</b> - INT 2F U - MS-DOS 7 kernel - BOOT LOGO SUPPORT???</a><br />
<a href="#2F160F"><b>2F160F</b> - INT 2F U - MS-DOS 7 kernel - GET/SET ??? HANDLER</a><br />
<a href="#2F1610"><b>2F1610</b> - INT 2F - XMS v1.x only - GET DRIVER ADDRESS</a><br />
<a href="#2F1611"><b>2F1611</b> - INT 2F U - MS-DOS 7 kernel - GET SHELL PARAMETERS</a><br />
<a href="#2F1612"><b>2F1612</b> - INT 2F U - MS-DOS 7 kernel - GET ???</a><br />
<a href="#2F1613"><b>2F1613</b> - INT 2F - MS-DOS 7 kernel - GET SYSTEM.DAT (REGISTRY FILE) PATHNAME</a><br />
<a href="#2F1614"><b>2F1614</b> - INT 2F U - MS-DOS 7 kernel - SET SYSTEM.DAT (REGISTRY FILE) PATHNAME</a><br />
<a href="#2F1615"><b>2F1615</b> - INT 2F - Windows95 - SAVE32.COM - INSTALLATION CHECK</a><br />
<a href="#2F1680"><b>2F1680</b> - INT 2F - MS Windows, DPMI, various - RELEASE CURRENT VIRTUAL MACHINE TIME-SLICE</a><br />
<a href="#2F1681"><b>2F1681</b> - INT 2F - MS Windows 3+ - BEGIN CRITICAL SECTION</a><br />
<a href="#2F1682"><b>2F1682</b> - INT 2F - MS Windows 3+ - END CRITICAL SECTION</a><br />
<a href="#2F1683"><b>2F1683</b> - INT 2F - MS Windows 3+ - GET CURRENT VIRTUAL MACHINE ID</a><br />
<a href="#2F1684"><b>2F1684</b> - INT 2F - MS Windows - GET DEVICE API ENTRY POINT</a><br />
<a href="#2F1684BX0001"><b>2F1684BX0001</b> - INT 2F - MS Windows95 - VMM - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0003"><b>2F1684BX0003</b> - INT 2F - MS Windows - VPICD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0005"><b>2F1684BX0005</b> - INT 2F - MS Windows - VTD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0006"><b>2F1684BX0006</b> - INT 2F P - MS Windows95 - V86MMGR - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0009"><b>2F1684BX0009</b> - INT 2F P - MS Windows - REBOOT - GET API ENTRY POINT</a><br />
<a href="#2F1684BX000A"><b>2F1684BX000A</b> - INT 2F P - MS Windows - VDD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX000C"><b>2F1684BX000C</b> - INT 2F - MS Windows - VMD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX000D"><b>2F1684BX000D</b> - INT 2F P - MS Windows - VKD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX000E"><b>2F1684BX000E</b> - INT 2F P - MS Windows - VCD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX000F"><b>2F1684BX000F</b> - INT 2F P - MS Windows - VPD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0010"><b>2F1684BX0010</b> - INT 2F - MS Windows - IOS - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0011"><b>2F1684BX0011</b> - INT 2F - MS Windows - VMCPD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0015"><b>2F1684BX0015</b> - INT 2F - MS Windows - DOSMGR - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0017"><b>2F1684BX0017</b> - INT 2F U - MS Windows - SHELL - GET API ENTRY POINT</a><br />
<a href="#2F1684BX001A"><b>2F1684BX001A</b> - INT 2F - MS Windows - VNETWARE - GET API ENTRY POINT</a><br />
<a href="#2F1684BX001D"><b>2F1684BX001D</b> - INT 2F P - MS Windows - WINDEBUG - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0021"><b>2F1684BX0021</b> - INT 2F PU - MS Windows - PAGEFILE - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0022"><b>2F1684BX0022</b> - INT 2F P - MS Windows - APIX - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0026"><b>2F1684BX0026</b> - INT 2F P - MS Windows - VPOWERD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0027"><b>2F1684BX0027</b> - INT 2F - MS Windows95 - VXDLDR - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0028"><b>2F1684BX0028</b> - INT 2F - MS Windows - NDIS - GET API ENTRY POINT</a><br />
<a href="#2F1684BX002A"><b>2F1684BX002A</b> - INT 2F P - MS Windows - VWIN32 - GET API ENTRY POINT</a><br />
<a href="#2F1684BX002B"><b>2F1684BX002B</b> - INT 2F - MS Windows - VCOMM - GET API ENTRY POINT</a><br />
<a href="#2F1684BX002D"><b>2F1684BX002D</b> - INT 2F P - MS Windows - W32S - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0030"><b>2F1684BX0030</b> - INT 2F P - MS Windows - MACH32 - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0032"><b>2F1684BX0032</b> - INT 2F - MS Windows - SERVER / VSERVER - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0033"><b>2F1684BX0033</b> - INT 2F - MS Windows - CONFIGMG - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0034"><b>2F1684BX0034</b> - INT 2F - Intel Plug-and-Play - CONFIGURATION MANAGER - GET ENTRY POINT</a><br />
<a href="#2F1684BX0036"><b>2F1684BX0036</b> - INT 2F - MS Windows - VFBACKUP - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0037"><b>2F1684BX0037</b> - INT 2F - MS Windows - ENABLE.VXD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0038"><b>2F1684BX0038</b> - INT 2F - MS Windows - VCOND - GET API ENTRY POINT</a><br />
<a href="#2F1684BX003B"><b>2F1684BX003B</b> - INT 2F - MS Windows - DSVXD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX003D"><b>2F1684BX003D</b> - INT 2F - MS Windows - BIOS VxD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX003E"><b>2F1684BX003E</b> - INT 2F - MS Windows - WSOCK - GET API ENTRY POINT</a><br />
<a href="#2F1684BX011F"><b>2F1684BX011F</b> - INT 2F P - MS Windows - VFLATD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0200"><b>2F1684BX0200</b> - INT 2F - MS Windows - VIPX - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0202"><b>2F1684BX0202</b> - INT 2F - MS Windows - WINICE - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0203"><b>2F1684BX0203</b> - INT 2F P - MS Windows - VCLIENT - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0205"><b>2F1684BX0205</b> - INT 2F - MS Windows - BCW - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0207"><b>2F1684BX0207</b> - INT 2F R - MS Windows - DPMS VxD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0234"><b>2F1684BX0234</b> - INT 2F - MS Windows - VCOMMUTE - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0442"><b>2F1684BX0442</b> - INT 2F P - MS Windows - VTDAPI - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0444"><b>2F1684BX0444</b> - INT 2F - MS Windows - VADMAD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0445"><b>2F1684BX0445</b> - INT 2F - MS Windows - VSBD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0446"><b>2F1684BX0446</b> - INT 2F - MS Windows - VADLIBD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0449"><b>2F1684BX0449</b> - INT 2F P - MS Windows - vjoyd - GET API ENTRY POINT</a><br />
<a href="#2F1684BX044A"><b>2F1684BX044A</b> - INT 2F - MS Windows - mmdevldr - GET API ENTRY POINT</a><br />
<a href="#2F1684BX045D"><b>2F1684BX045D</b> - INT 2F P - MS Windows - VflatD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX045F"><b>2F1684BX045F</b> - INT 2F - MS Windows - azt16 - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0460"><b>2F1684BX0460</b> - INT 2F P - MS Windows - UNIMODEM - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0480"><b>2F1684BX0480</b> - INT 2F - MS Windows - VNetSup - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0482"><b>2F1684BX0482</b> - INT 2F - MS Windows - VBrowse - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0483"><b>2F1684BX0483</b> - INT 2F - MS Windows - VSHARE - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0484"><b>2F1684BX0484</b> - INT 2F P - MS Windows - IFSMgr - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0486"><b>2F1684BX0486</b> - INT 2F - MS Windows - VFAT - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0487"><b>2F1684BX0487</b> - INT 2F - MS Windows - NWLINK - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0489"><b>2F1684BX0489</b> - INT 2F R - MS Windows - VIP - GET API ENTRY POINT</a><br />
<a href="#2F1684BX048A"><b>2F1684BX048A</b> - INT 2F - MS Windows 3.11 - VXDLDR - GET API ENTRY POINT</a><br />
<a href="#2F1684BX048A_0"><b>2F1684BX048A</b> - INT 2F - MS Windows - VCACHE - GET API ENTRY POINT</a><br />
<a href="#2F1684BX048D"><b>2F1684BX048D</b> - INT 2F - MS Windows - RASMAC - GET API ENTRY POINT</a><br />
<a href="#2F1684BX048E"><b>2F1684BX048E</b> - INT 2F - MS Windows - NWREDIR - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0494"><b>2F1684BX0494</b> - INT 2F - MS Windows - NSCL - GET API ENTRY POINT</a><br />
<a href="#2F1684BX0499"><b>2F1684BX0499</b> - INT 2F - MS Windows - PPPMAC - GET API ENTRY POINT</a><br />
<a href="#2F1684BX049A"><b>2F1684BX049A</b> - INT 2F - MS Windows - VDHCP - GET API ENTRY POINT</a><br />
<a href="#2F1684BX049B"><b>2F1684BX049B</b> - INT 2F - MS Windows - VNBT - GET API ENTRY POINT</a><br />
<a href="#2F1684BX1021"><b>2F1684BX1021</b> - INT 2F - MS Windows - VMB - GET API ENTRY POINT</a><br />
<a href="#2F1684BX28A0"><b>2F1684BX28A0</b> - INT 2F - MS Windows - PHARLAPX - GET API ENTRY POINT</a><br />
<a href="#2F1684BX28A1"><b>2F1684BX28A1</b> - INT 2F - MS Windows - PharLap VxD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX2925"><b>2F1684BX2925</b> - INT 2F - MS Windows - EDOS - GET API ENTRY POINT</a><br />
<a href="#2F1684BX292D"><b>2F1684BX292D</b> - INT 2F - MS Windows - VSBPD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX295A"><b>2F1684BX295A</b> - INT 2F - MS Windows - GRVSULTR - GET API ENTRY POINT</a><br />
<a href="#2F1684BX304C"><b>2F1684BX304C</b> - INT 2F - Intel Plug-and-Play - CONFIGURATION ACCESS - GET ENTRY POINT</a><br />
<a href="#2F1684BX3099"><b>2F1684BX3099</b> - INT 2F - MS Windows - VVidramD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX30F6"><b>2F1684BX30F6</b> - INT 2F P - MS Windows - WSVV - GET API ENTRY POINT</a><br />
<a href="#2F1684BX310E"><b>2F1684BX310E</b> - INT 2F - MS Windows - WPS - GET API ENTRY POINT</a><br />
<a href="#2F1684BX3110"><b>2F1684BX3110</b> - INT 2F - MS Windows - VSGLX16.386 - GET API ENTRY POINT</a><br />
<a href="#2F1684BX31CF"><b>2F1684BX31CF</b> - INT 2F - MS Windows - STAT.386 - GET API ENTRY POINT</a><br />
<a href="#2F1684BX34DC"><b>2F1684BX34DC</b> - INT 2F - QEMM v8.01 - MAGNARAM VxD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX357E"><b>2F1684BX357E</b> - INT 2F - MS Windows - DSOUND - GET API ENTRY POINT</a><br />
<a href="#2F1684BX377B"><b>2F1684BX377B</b> - INT 2F - MS Windows - MX1501HAD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX38DA"><b>2F1684BX38DA</b> - INT 2F - MS Windows - VIWD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX4321"><b>2F1684BX4321</b> - INT 2F - MS Windows - POSTMSG - GET API ENTRY POINT</a><br />
<a href="#2F1684BX7FE0"><b>2F1684BX7FE0</b> - INT 2F - MS Windows - VSWITCHD - GET API ENTRY POINT</a><br />
<a href="#2F1684BX8888"><b>2F1684BX8888</b> - INT 2F - MS Windows - VbillD - GET API ENTRY POINT</a><br />
<a href="#2F1685"><b>2F1685</b> - INT 2F - MS Windows - SWITCH VMs AND CALLBACK</a><br />
<a href="#2F1686"><b>2F1686</b> - INT 2F - DOS Protected-Mode Interface - DETECT MODE</a><br />
<a href="#2F1687"><b>2F1687</b> - INT 2F - DOS Protected-Mode Interface - INSTALLATION CHECK</a><br />
<a href="#2F1688BX0BAD"><b>2F1688BX0BAD</b> - INT 2F U - MS Windows 3.0, 386MAX v6.01 - GET ALIAS SELECTOR TO LDT</a><br />
<a href="#2F1689"><b>2F1689</b> - INT 2F U - MS Windows 3.0+ - KERNEL IDLE CALL</a><br />
<a href="#2F168A"><b>2F168A</b> - INT 2F - DPMI 0.9+ - GET VENDOR-SPECIFIC API ENTRY POINT</a><br />
<a href="#2F168B"><b>2F168B</b> - INT 2F - MS Windows 3.1 - SET FOCUS TO SPECIFIED VIRTUAL MACHINE</a><br />
<a href="#2F168C"><b>2F168C</b> - INT 2F - MS Windows 3.1 - RESTART COMMAND</a><br />
<a href="#2F168EDX0000"><b>2F168EDX0000</b> - INT 2F - Windows95 - TITLE - SET APPLICATION TITLE</a><br />
<a href="#2F168EDX0001"><b>2F168EDX0001</b> - INT 2F - Windows95 - TITLE - SET VIRTUAL MACHINE TITLE</a><br />
<a href="#2F168EDX0002"><b>2F168EDX0002</b> - INT 2F - Windows95 - TITLE - GET APPLICATION TITLE</a><br />
<a href="#2F168EDX0003"><b>2F168EDX0003</b> - INT 2F - Windows95 - TITLE - GET VIRTUAL MACHINE TITLE</a><br />
<a href="#2F168FDH00"><b>2F168FDH00</b> - INT 2F - Windows95 - CLOSE-AWARENESS - ENABLE/DISABLE CLOSE COMMAND</a><br />
<a href="#2F168FDH01"><b>2F168FDH01</b> - INT 2F - Windows95 - CLOSE-AWARENESS - QUERY CLOSE</a><br />
<a href="#2F168FDH02"><b>2F168FDH02</b> - INT 2F - Windows95 - CLOSE-AWARENESS - ACKNOWLEDGE CLOSE</a><br />
<a href="#2F168FDH03"><b>2F168FDH03</b> - INT 2F - Windows95 - CLOSE-AWARENESS - CANCEL CLOSE</a><br />
<a href="#2F1690"><b>2F1690</b> - INT 2F U - MS-DOS 7 kernel - GET/SET ???</a><br />
<a href="#2F1700"><b>2F1700</b> - INT 2F - MS Windows "WINOLDAP" - IDENTIFY WinOldAp VERSION</a><br />
<a href="#2F1701"><b>2F1701</b> - INT 2F - MS Windows "WINOLDAP" - OPEN CLIPBOARD</a><br />
<a href="#2F1702"><b>2F1702</b> - INT 2F - MS Windows "WINOLDAP" - EMPTY CLIPBOARD</a><br />
<a href="#2F1703"><b>2F1703</b> - INT 2F - MS Windows "WINOLDAP" - SET CLIPBOARD DATA</a><br />
<a href="#2F1704"><b>2F1704</b> - INT 2F - MS Windows "WINOLDAP" - GET CLIPBOARD DATA SIZE</a><br />
<a href="#2F1705"><b>2F1705</b> - INT 2F - MS Windows "WINOLDAP" - GET CLIPBOARD DATA</a><br />
<a href="#2F1708"><b>2F1708</b> - INT 2F - MS Windows "WINOLDAP" - CloseClipboard</a><br />
<a href="#2F1709"><b>2F1709</b> - INT 2F - MS Windows "WINOLDAP" - COMPACT CLIPBOARD</a><br />
<a href="#2F170A"><b>2F170A</b> - INT 2F - MS Windows "WINOLDAP" - GET DEVICE CAPABILITIES</a><br />
<a href="#2F18"><b>2F18</b> - INT 2F U - MS-Manager</a><br />
<a href="#2F1900"><b>2F1900</b> - INT 2F U - DOS 4.x only SHELLB.COM - INSTALLATION CHECK</a><br />
<a href="#2F1901"><b>2F1901</b> - INT 2F U - DOS 4.x only SHELLB.COM - SHELLC.EXE INTERFACE</a><br />
<a href="#2F1902"><b>2F1902</b> - INT 2F U - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE</a><br />
<a href="#2F1903"><b>2F1903</b> - INT 2F U - DOS 4.x only SHELLB.COM - COMMAND.COM interface</a><br />
<a href="#2F1904"><b>2F1904</b> - INT 2F U - DOS 4.x only SHELLB.COM - SHELLB transient to TSR interface</a><br />
<a href="#2F1980"><b>2F1980</b> - INT 2F U - IBM ROM-DOS v4.0 - INSTALLATION CHECK</a><br />
<a href="#2F1981"><b>2F1981</b> - INT 2F U - IBM ROM-DOS v4.0 - GET ??? STRING</a><br />
<a href="#2F1982"><b>2F1982</b> - INT 2F U - IBM ROM-DOS v4.0 - GET ??? TABLE</a><br />
<a href="#2F1A00"><b>2F1A00</b> - INT 2F - DOS 4.0+ ANSI.SYS - INSTALLATION CHECK</a><br />
<a href="#2F1A00BX414E"><b>2F1A00BX414E</b> - INT 2F - ANSIPLUS.SYS v2.00+ - INSTALLATION CHECK</a><br />
<a href="#2F1A00BX4156"><b>2F1A00BX4156</b> - INT 2F - AVATAR.SYS - INSTALLATION CHECK</a><br />
<a href="#2F1A01"><b>2F1A01</b> - INT 2F U - DOS 4.0+ ANSI.SYS internal - GET/SET DISPLAY INFORMATION</a><br />
<a href="#2F1A02"><b>2F1A02</b> - INT 2F U - DOS 4.0+ ANSI.SYS internal - MISCELLANEOUS REQUESTS</a><br />
<a href="#2F1A21"><b>2F1A21</b> - INT 2F - AVATAR.SYS - SET DRIVER STATE</a><br />
<a href="#2F1A3C"><b>2F1A3C</b> - INT 2F U - AVATAR.SYS v0.11 - ???</a><br />
<a href="#2F1A3E"><b>2F1A3E</b> - INT 2F U - AVATAR.SYS v0.11 - ???</a><br />
<a href="#2F1A3F"><b>2F1A3F</b> - INT 2F - AVATAR.SYS - QUERY DRIVER STATE</a><br />
<a href="#2F1A42BX4156"><b>2F1A42BX4156</b> - INT 2F - AVATAR Serial Dispatcher - INSTALL IRQ3 HANDLER</a><br />
<a href="#2F1A43BX4156"><b>2F1A43BX4156</b> - INT 2F - AVATAR Serial Dispatcher - INSTALL IRQ4 HANDLER</a><br />
<a href="#2F1A44BX4156"><b>2F1A44BX4156</b> - INT 2F - AVATAR.SYS v0.11+ - GET DATA SEGMENT</a><br />
<a href="#2F1A52"><b>2F1A52</b> - INT 2F U - AVATAR.SYS v0.11 - GET ???</a><br />
<a href="#2F1A53"><b>2F1A53</b> - INT 2F U - AVATAR.SYS v0.11 - ???</a><br />
<a href="#2F1A62BX4156"><b>2F1A62BX4156</b> - INT 2F - AVATAR Serial Dispatcher - UNINSTALL IRQ3 HANDLER</a><br />
<a href="#2F1A63BX4156"><b>2F1A63BX4156</b> - INT 2F - AVATAR Serial Dispatcher - UNINSTALL IRQ4 HANDLER</a><br />
<a href="#2F1A72"><b>2F1A72</b> - INT 2F U - AVATAR.SYS v0.11 - GET ??? SIZE</a><br />
<a href="#2F1A7B"><b>2F1A7B</b> - INT 2F U - AVATAR.SYS v0.11 - ???</a><br />
<a href="#2F1A7D"><b>2F1A7D</b> - INT 2F U - AVATAR.SYS v0.11 - ???</a><br />
<a href="#2F1AA3"><b>2F1AA3</b> - INT 2F - ANSIPLUS v4.03+ - GET/SET ANSIPLUS INTERNAL VARIABLES</a><br />
<a href="#2F1AA4"><b>2F1AA4</b> - INT 2F - ANSIPLUS v4.02+ - GET/SET ANSIPLUS SMOOTH SCROLLING RATE</a><br />
<a href="#2F1AA5"><b>2F1AA5</b> - INT 2F - ANSIPLUS v4.00+ - GET/SET ANSIPLUS CLIPBOARD</a><br />
<a href="#2F1AA6"><b>2F1AA6</b> - INT 2F - ANSIPLUS v4.00+ - ENABLE/DISABLE ANSIPLUS DRIVER</a><br />
<a href="#2F1AA7"><b>2F1AA7</b> - INT 2F - ANSIPLUS v4.00+ - ENABLE/DISABLE ANSIPLUS FEATURES</a><br />
<a href="#2F1AA8"><b>2F1AA8</b> - INT 2F - ANSIPLUS v3.10+ - GET NEXT ANSIPLUS SCROLLBACK LINE</a><br />
<a href="#2F1AA9"><b>2F1AA9</b> - INT 2F - ANSIPLUS v3.10+ - GET ANSIPLUS SCROLLBACK INFORMATION</a><br />
<a href="#2F1AAA"><b>2F1AAA</b> - INT 2F - ANSIPLUS v3.01+ - GET/SET ANSIPLUS SCREEN SAVER BLANKING TIME</a><br />
<a href="#2F1AAB"><b>2F1AAB</b> - INT 2F - ANSIPLUS v3.01+ - SET ANSIPLUS KEY REPEAT RATE</a><br />
<a href="#2F1AAC"><b>2F1AAC</b> - INT 2F - ANSIPLUS v3.00+ - LOAD CHARACTER GENERATOR</a><br />
<a href="#2F1AAD"><b>2F1AAD</b> - INT 2F - ANSIPLUS v2.00+ - ANSIPLUS DEVICE STATUS REPORT</a><br />
<a href="#2F1AADDX0000"><b>2F1AADDX0000</b> - INT 2F U - AVATAR.SYS v0.11 - ???</a><br />
<a href="#2F1B00"><b>2F1B00</b> - INT 2F U - DOS 4+ XMA2EMS.SYS extension internal - INSTALLATION CHECK</a><br />
<a href="#2F1B"><b>2F1B</b> - INT 2F U - DOS 4+ XMA2EMS.SYS extension internal - GET HIDDEN FRAME INFORMATION</a><br />
<a href="#2F2300"><b>2F2300</b> - INT 2F - DR DOS 5.0 GRAFTABL - INSTALLATION CHECK</a><br />
<a href="#2F23"><b>2F23</b> - INT 2F - DR DOS 5.0 GRAFTABL - GET GRAPHICS DATA</a><br />
<a href="#2F2700"><b>2F2700</b> - INT 2F - DR DOS 6.0 TaskMAX - INSTALLATION CHECK</a><br />
<a href="#2F2701"><b>2F2701</b> - INT 2F - DR DOS 6.0 TaskMAX - GET STATUS</a><br />
<a href="#2F2702"><b>2F2702</b> - INT 2F - DR DOS 6.0 TaskMAX - GET PER-TASK EMS LIMIT</a><br />
<a href="#2F2703"><b>2F2703</b> - INT 2F - DR DOS 6.0 TaskMAX - SET PER-TASK EMS LIMIT</a><br />
<a href="#2F2704"><b>2F2704</b> - INT 2F - DR DOS 6.0 TaskMAX - REGISTER/UNREGISTER TASK MANAGER</a><br />
<a href="#2F2705"><b>2F2705</b> - INT 2F - DR DOS 6.0 TaskMAX - ENABLE/DISABLE DIRECT SWITCHING</a><br />
<a href="#2F2706"><b>2F2706</b> - INT 2F - DR DOS 6.0 TaskMAX - SWITCH TO SPECIFIED TASK</a><br />
<a href="#2F2707"><b>2F2707</b> - INT 2F - DR DOS 6.0 TaskMAX - CREATE NEW TASK</a><br />
<a href="#2F2708"><b>2F2708</b> - INT 2F - DR DOS 6.0 TaskMAX - DELETE TASK</a><br />
<a href="#2F2709"><b>2F2709</b> - INT 2F - DR DOS 6.0 TaskMAX - NAME TASK</a><br />
<a href="#2F270A"><b>2F270A</b> - INT 2F - DR DOS 6.0 TaskMAX - CONVERT TASK INDEX TO TASK ID</a><br />
<a href="#2F270B"><b>2F270B</b> - INT 2F - DR DOS 6.0 TaskMAX - CONVERT TASK ID TO TASK INDEX</a><br />
<a href="#2F270C"><b>2F270C</b> - INT 2F - DR DOS 6.0 TaskMAX - CHECK OPEN FILES</a><br />
<a href="#2F270D"><b>2F270D</b> - INT 2F - DR DOS 6.0 TaskMAX - CHECK IF TASK RUNNING PRIMARY COMMAND INTERPRETER</a><br />
<a href="#2F270E"><b>2F270E</b> - INT 2F - DR DOS 6.0 TaskMAX - GET/SET TEXT PASTE LEAD-IN</a><br />
<a href="#2F270F"><b>2F270F</b> - INT 2F - DR DOS 6.0 TaskMAX - GET/SET NUMERIC PASTE LEAD-IN</a><br />
<a href="#2F2710"><b>2F2710</b> - INT 2F - DR DOS 6.0 TaskMAX - GET/SET PASTE LINE TERMINATOR STRING</a><br />
<a href="#2F2711"><b>2F2711</b> - INT 2F - DR DOS 6.0 TaskMAX - GET/SET NUMERIC PASTE DECIMAL POINT</a><br />
<a href="#2F2712"><b>2F2712</b> - INT 2F - DR DOS 6.0 TaskMAX - INITIATE EXPORTING TASK DATA</a><br />
<a href="#2F2713"><b>2F2713</b> - INT 2F - DR DOS 6.0 TaskMAX - INITIATE PASTE OPERATION</a><br />
<a href="#2F2714"><b>2F2714</b> - INT 2F - DR DOS 6.0 TaskMAX - GET SWAP SPACE INFO</a><br />
<a href="#2F2715"><b>2F2715</b> - INT 2F - DR DOS 6.0 TaskMAX - SWITCH TO TASK MANAGER</a><br />
<a href="#2F2716"><b>2F2716</b> - INT 2F - DR DOS 6.0 TaskMAX - GET PASTE BUFFER STATUS</a><br />
<a href="#2F2717"><b>2F2717</b> - INT 2F - DR DOS 6.0 TaskMAX - PASTE DATA DIRECTLY TO APPLICATION BUFFER</a><br />
<a href="#2F2718"><b>2F2718</b> - INT 2F - DR DOS 6.0 TaskMAX - COPY DATA DIRECTLY INTO PASTE BUFFER</a><br />
<a href="#2F2719"><b>2F2719</b> - INT 2F - Novell DOS 7 TaskMGR - NOP</a><br />
<a href="#2F271C"><b>2F271C</b> - INT 2F U - Novell DOS 7 TaskMGR - ???</a><br />
<a href="#2F2780CL01"><b>2F2780CL01</b> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - SUPERVISOR MODULE</a><br />
<a href="#2F2780CL02"><b>2F2780CL02</b> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - REAL-TIME MONITOR</a><br />
<a href="#2F2780CL03"><b>2F2780CL03</b> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - MEMORY</a><br />
<a href="#2F2780CL04"><b>2F2780CL04</b> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - DOMAINS</a><br />
<a href="#2F2780CL05"><b>2F2780CL05</b> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - VIRTUAL MACHINES</a><br />
<a href="#2F2780CL06"><b>2F2780CL06</b> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - DPMI SERVICES</a><br />
<a href="#2F2780"><b>2F2780</b> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - AVAILABLE FOR APPS</a><br />
<a href="#2F2781"><b>2F2781</b> - INT 2F U - Novell DOS 7 TaskMGR - BEGIN CRITICAL SECTION???</a><br />
<a href="#2F2782"><b>2F2782</b> - INT 2F U - Novell DOS 7 TaskMGR - END CRITICAL SECTION???</a><br />
<a href="#2F2783"><b>2F2783</b> - INT 2F U - Novell DOS 7 - EMM386.EXE - GET ???</a><br />
<a href="#2F278F"><b>2F278F</b> - INT 2F U - Novell DOS 7 TaskMGR - ??? API</a><br />
<a href="#2F2A"><b>2F2A</b> - INT 2F - Gammafax DOS Dispatcher INTERFACE</a><br />
<a href="#2F2E00"><b>2F2E00</b> - INT 2F U - Novell DOS 7 - GRAFTABL - INSTALLATION CHECK</a><br />
<a href="#2F2E"><b>2F2E</b> - INT 2F U - Novell DOS 7 - GRAFTABL - GET FONT TABLE</a><br />
<a href="#2F3900"><b>2F3900</b> - INT 2F - Kingswood TSR INTERFACE - COMPATIBILITY MODE</a><br />
<a href="#2F39--BL00"><b>2F39--BL00</b> - INT 2F - Kingswood TSR INTERFACE - INSTALLATION CHECK</a><br />
<a href="#2F39--BL01"><b>2F39--BL01</b> - INT 2F - Kingswood TSR INTERFACE - REMOVAL CHECK</a><br />
<a href="#2F39"><b>2F39</b> - INT 2F - Kingswood TSR INTERFACE - APPLICATION-SPECIFIC FUNCTION CALLS</a><br />
<a href="#2F3901BL02"><b>2F3901BL02</b> - INT 2F - Kingswood TSR Windows - OPEN WINDOW</a><br />
<a href="#2F3901BL03"><b>2F3901BL03</b> - INT 2F - Kingswood TSR Windows - HIDE WINDOWS</a><br />
<a href="#2F3901BL04"><b>2F3901BL04</b> - INT 2F - Kingswood TSR Windows - SHOW WINDOWS</a><br />
<a href="#2F3901BL05"><b>2F3901BL05</b> - INT 2F - Kingswood TSR Windows - CLOSE WINDOW</a><br />
<a href="#2F3901BL06"><b>2F3901BL06</b> - INT 2F - Kingswood TSR Windows - SET WINDOW TITLE</a><br />
<a href="#2F3901BL07"><b>2F3901BL07</b> - INT 2F - Kingswood TSR Windows - POSITION CURSOR</a><br />
<a href="#2F3901BL08"><b>2F3901BL08</b> - INT 2F - Kingswood TSR Windows - DISPLAY STRING</a><br />
<a href="#2F3901BL09"><b>2F3901BL09</b> - INT 2F - Kingswood TSR Windows - SCROLL WINDOW</a><br />
<a href="#2F3901BL0A"><b>2F3901BL0A</b> - INT 2F - Kingswood TSR Windows - SOUND BEEPER</a><br />
<a href="#2F3901BL0B"><b>2F3901BL0B</b> - INT 2F - Kingswood TSR Windows - ADD OR REMOVE USER</a><br />
<a href="#2F3912BL03"><b>2F3912BL03</b> - INT 2F - Kingswood ANSI display driver - SET COMPATIBILITY MODE</a><br />
<a href="#2F3912BL04"><b>2F3912BL04</b> - INT 2F - Kingswood ANSI display driver - SET FLAGS</a><br />
<a href="#2F4000"><b>2F4000</b> - INT 2F - Windows 3+ (OS/2 2.x???) - GET VIRTUAL DEVICE DRIVER (VDD) CAPABILTIES</a><br />
<a href="#2F4001"><b>2F4001</b> - INT 2F C - OS/2 compatibility box - SWITCHING DOS TO BACKGROUND</a><br />
<a href="#2F4002"><b>2F4002</b> - INT 2F C - OS/2 compatibility box - SWITCHING DOS TO FOREGROUND</a><br />
<a href="#2F4003"><b>2F4003</b> - INT 2F - Windows 3.x - ENTERING VIDEO DRIVER CRITICAL SECTION</a><br />
<a href="#2F4004"><b>2F4004</b> - INT 2F - Windows 3.x - EXITING VIDEO DRIVER CRITICAL SECTION</a><br />
<a href="#2F4005"><b>2F4005</b> - INT 2F C - Windows 3.x - SWITCHING DOS TO BACKGROUND</a><br />
<a href="#2F4006"><b>2F4006</b> - INT 2F C - Windows 3.x - SWITCHING DOS TO FOREGROUND</a><br />
<a href="#2F4007"><b>2F4007</b> - INT 2F - Windows 3.x - ENABLE VDD TRAPPING OF VIDEO REGISTERS</a><br />
<a href="#2F4010"><b>2F4010</b> - INT 2F - OS/2 v2.0+ - INSTALLATION CHECK / GET VERSION</a><br />
<a href="#2F4011"><b>2F4011</b> - INT 2F - OS/2 - GET VDD API ENTRY POINT</a><br />
<a href="#2F4021"><b>2F4021</b> - INT 2F UC - Diamond Stealth64 Video - STLTH64.VXD - ???</a><br />
<a href="#2F4022"><b>2F4022</b> - INT 2F UC - Diamond Stealth64 Video - STLTH64.VXD - ???</a><br />
<a href="#2F4023"><b>2F4023</b> - INT 2F UC - Diamond Stealth64 Video - STLTH64.VXD - ???</a><br />
<a href="#2F4027"><b>2F4027</b> - INT 2F UC - Diamond Stealth64 Video - DMSSTL.DRV - ???</a><br />
<a href="#2F4040"><b>2F4040</b> - INT 2F - PharLap 286|DOS-Extender Lite v2.5 - ???</a><br />
<a href="#2F4100"><b>2F4100</b> - INT 2F - DOS Enhanced LAN Manager 2.0+ MINIPOP/NETPOPUP - INSTALLATION CHECK</a><br />
<a href="#2F4103"><b>2F4103</b> - INT 2F - DOS Enhanced LAN Manager 2.0+ MINIPOP/NETPOPUP - ???</a><br />
<a href="#2F4104"><b>2F4104</b> - INT 2F - DOS Enhanced LAN Manager 2.0+ MINIPOP/NETPOPUP - ???</a><br />
<a href="#2F42"><b>2F42</b> - INT 2F - LAN Manager 2.0 DOS Enhanced MSRV.EXE - MESSENGER SERVICE</a><br />
<a href="#2F4300"><b>2F4300</b> - INT 2F - EXTENDED MEMORY SPECIFICATION (XMS) v2+ - INSTALLATION CHECK</a><br />
<a href="#2F4308"><b>2F4308</b> - INT 2F U - HIMEM.SYS v2.77+ - GET A20 HANDLER NUMBER</a><br />
<a href="#2F4309"><b>2F4309</b> - INT 2F U - HIMEM.SYS v3.09+ - GET XMS HANDLE TABLE</a><br />
<a href="#2F4310"><b>2F4310</b> - INT 2F - EXTENDED MEMORY SPECIFICATION (XMS) v2+ - GET DRIVER ADDRESS</a><br />
<a href="#2F4310_0"><b>2F4310</b> - INT 2F - Cloaking - REAL-MODE API</a><br />
<a href="#2F4310_1"><b>2F4310</b> - INT 2F - Helix Netroom RM386 v6.00 - XMS EXTENSIONS</a><br />
<a href="#2F4310_2"><b>2F4310</b> - INT 2F - NEC PC-9800 - XMZ - PRIVATE API</a><br />
<a href="#2F4320"><b>2F4320</b> - INT 2F U - HIMEM.SYS - Mach 20 SUPPORT</a><br />
<a href="#2F4330"><b>2F4330</b> - INT 2F CU - HIMEM.SYS v2.77+ - GET EXTERNAL A20 HANDLER ADDRESS</a><br />
<a href="#2F43D6"><b>2F43D6</b> - INT 2F - Multiplex - ???</a><br />
<a href="#2F43E0BX0000"><b>2F43E0BX0000</b> - INT 2F - DOS Protected Mode Services (DPMS) v1.0 - INSTALLATION CHECK</a><br />
<a href="#2F43E1"><b>2F43E1</b> - INT 2F - DOS Protected Mode Services (DPMS) v1.0 - REGISTER CLIENT</a><br />
<a href="#2F43E2"><b>2F43E2</b> - INT 2F - DOS Protected Mode Services (DPMS) v1.0 - ENABLE/DISABLE DPMS</a><br />
<a href="#2F43E3BX0000"><b>2F43E3BX0000</b> - INT 2F C - DOS Protected Mode Services (DPMS) v1.0 - DPMS STARTUP BROADCAST</a><br />
<a href="#2F43E4BX0000"><b>2F43E4BX0000</b> - INT 2F C - DOS Protected Mode Services (DPMS) v1.0 - DPMS EXIT BROADCAST</a><br />
<a href="#2F44"><b>2F44</b> - INT 2F U - DOS Extender support???</a><br />
<a href="#2F4500"><b>2F4500</b> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - INSTALLATION CHECK</a><br />
<a href="#2F4501"><b>2F4501</b> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - SETUP PROFILER</a><br />
<a href="#2F4502"><b>2F4502</b> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - SET SAMPLING RATE</a><br />
<a href="#2F4503"><b>2F4503</b> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - START PROFILING</a><br />
<a href="#2F4504"><b>2F4504</b> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - STOP PROFILING</a><br />
<a href="#2F4505"><b>2F4505</b> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - CLEAR PROFILING DATA</a><br />
<a href="#2F4506"><b>2F4506</b> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - "ProfFlush"</a><br />
<a href="#2F4507"><b>2F4507</b> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - "ProfFinish"</a><br />
<a href="#2F4508"><b>2F4508</b> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - ALTERNATE SEGDEBUG IFACE</a><br />
<a href="#2F4601"><b>2F4601</b> - INT 2F CU - MS Windows WINOLDAP - SWITCHING ???</a><br />
<a href="#2F4602"><b>2F4602</b> - INT 2F CU - MS Windows WINOLDAP - SWITCHING ???</a><br />
<a href="#2F46"><b>2F46</b> - INT 2F U - Windows/286 DOS Extender</a><br />
<a href="#2F4653CX0002"><b>2F4653CX0002</b> - INT 2F - F-PROT v1.x only - F-LOCK.EXE - API</a><br />
<a href="#2F4653CX0003"><b>2F4653CX0003</b> - INT 2F - F-PROT v1.x only - F-XCHK.EXE - API</a><br />
<a href="#2F4653CX0004"><b>2F4653CX0004</b> - INT 2F - F-PROT v1.x only - F-POPUP.EXE - API</a><br />
<a href="#2F4653CX0005"><b>2F4653CX0005</b> - INT 2F - F-PROT v1.x only - F-DLOCK.EXE - API</a><br />
<a href="#2F4653CX0007"><b>2F4653CX0007</b> - INT 2F - F-PROT v2.x - VIRSTOP - ENABLE/DISABLE BOOTSECTOR READ CHECKING</a><br />
<a href="#2F4653CX0008"><b>2F4653CX0008</b> - INT 2F - F-PROT v2.x - ???</a><br />
<a href="#2F4653CX0008_0"><b>2F4653CX0008</b> - INT 2F - F-PROT v2.x - VIRSTOP - INSTALLATION CHECK</a><br />
<a href="#2F4680"><b>2F4680</b> - INT 2F U - MS Windows v3.0 - INSTALLATION CHECK</a><br />
<a href="#2F47"><b>2F47</b> - INT 2F U - ???</a><br />
<a href="#2F4800"><b>2F4800</b> - INT 2F - DOS 5+ DOSKEY - INSTALLATION CHECK</a><br />
<a href="#2F4800_0"><b>2F4800</b> - INT 2F - PCED v2.1 - INSTALLATION CHECK</a><br />
<a href="#2F4810"><b>2F4810</b> - INT 2F - DOS 5+ DOSKEY, PCED v2.1 - READ INPUT LINE FROM CONSOLE</a><br />
<a href="#2F48C0"><b>2F48C0</b> - INT 2F - PCED v2.1 - PCED API</a><br />
<a href="#2F48C1BL00"><b>2F48C1BL00</b> - INT 2F - PCED/VSTACK - INSTALLATION CHECK</a><br />
<a href="#2F48C2BL00"><b>2F48C2BL00</b> - INT 2F - PCED/ATTRIB - INSTALLATION CHECK</a><br />
<a href="#2F48C3BL00"><b>2F48C3BL00</b> - INT 2F - PCED/KEYDEF - INSTALLATION CHECK</a><br />
<a href="#2F48C4BL00"><b>2F48C4BL00</b> - INT 2F - PCED/FLIST - INSTALLATION CHECK</a><br />
<a href="#2F48C5BL00"><b>2F48C5BL00</b> - INT 2F - PCED/ASSOC - INSTALLATION CHECK</a><br />
<a href="#2F48C5BL01"><b>2F48C5BL01</b> - INT 2F - PCED/ASSOC - GET VERSION</a><br />
<a href="#2F48C5BL02"><b>2F48C5BL02</b> - INT 2F - PCED/ASSOC - ASSOCIATION TEST</a><br />
<a href="#2F49"><b>2F49</b> - INT 2F U - DOS 5.0+ SETUP</a><br />
<a href="#2F4A00CX0000"><b>2F4A00CX0000</b> - INT 2F CU - DOS 5+ - FLOPPY-DISK LOGICAL DRIVE CHANGE NOTIFICATION</a><br />
<a href="#2F4A01"><b>2F4A01</b> - INT 2F - DOS 5+ - QUERY FREE HMA SPACE</a><br />
<a href="#2F4A02"><b>2F4A02</b> - INT 2F - DOS 5+ - ALLOCATE HMA SPACE</a><br />
<a href="#2F4A03"><b>2F4A03</b> - INT 2F U - Windows95 - DOS KERNEL - (DE)ALLOCATE HMA MEMORY BLOCK</a><br />
<a href="#2F4A04"><b>2F4A04</b> - INT 2F U - Windows95 - DOS KERNEL - GET START OF HMA MEMORY CHAIN</a><br />
<a href="#2F4A05"><b>2F4A05</b> - INT 2F U - DOS 5+ DOSSHELL - TASK SWITCHING API???</a><br />
<a href="#2F4A06"><b>2F4A06</b> - INT 2F CU - DOS 5+ - DOS SUPERVISOR "REBOOT PANEL" - ADJUST MEMORY SIZE</a><br />
<a href="#2F4A07"><b>2F4A07</b> - INT 2F U - RESERVED FOR PROTMAN SUPPORT</a><br />
<a href="#2F4A10BX0000"><b>2F4A10BX0000</b> - INT 2F - SMARTDRV v4.00+ - INSTALLATION CHECK AND HIT RATIOS</a><br />
<a href="#2F4A10BX0000_0"><b>2F4A10BX0000</b> - INT 2F U - Novell NWCACHE - INSTALLATION CHECK AND STATISTICS</a><br />
<a href="#2F4A10BX0001"><b>2F4A10BX0001</b> - INT 2F - SMARTDRV v4.00+ - FLUSH BUFFERS (COMMIT CACHE)</a><br />
<a href="#2F4A10BX0001_0"><b>2F4A10BX0001</b> - INT 2F U - Novell NWCACHE - ???</a><br />
<a href="#2F4A10BX0002"><b>2F4A10BX0002</b> - INT 2F - SMARTDRV v4.00+ - RESET CACHE</a><br />
<a href="#2F4A10BX0003"><b>2F4A10BX0003</b> - INT 2F - SMARTDRV v4.00+ - STATUS</a><br />
<a href="#2F4A10BX0004"><b>2F4A10BX0004</b> - INT 2F - SMARTDRV v4.00+ - GET CACHE SIZE</a><br />
<a href="#2F4A10BX0005"><b>2F4A10BX0005</b> - INT 2F - SMARTDRV v4.00+ - GET DOUBLE-BUFFER STATUS</a><br />
<a href="#2F4A10BX0006"><b>2F4A10BX0006</b> - INT 2F CU - SMARTDRV v4.00+ - CHECK IF DRIVE CACHEABLE</a><br />
<a href="#2F4A10BX0007"><b>2F4A10BX0007</b> - INT 2F - SMARTDRV v4.00+ - GET DEVICE DRIVER FOR DRIVE</a><br />
<a href="#2F4A10BX0008"><b>2F4A10BX0008</b> - INT 2F - SMARTDRV v4.20+ - GET/SET FLUSH BEFORE PROMPT, CD-ROM SUPPORT</a><br />
<a href="#2F4A10BX000A"><b>2F4A10BX000A</b> - INT 2F - SMARTDRV v4.00+ - GET ELEMENT STATUS TABLE</a><br />
<a href="#2F4A10BX1234"><b>2F4A10BX1234</b> - INT 2F - SMARTDRV v4.00+ - SIGNAL SERIOUS ERROR</a><br />
<a href="#2F4A11BX0000"><b>2F4A11BX0000</b> - INT 2F - DBLSPACE.BIN - "GetVersion" - INSTALLATION CHECK</a><br />
<a href="#2F4A11BX0001"><b>2F4A11BX0001</b> - INT 2F - DBLSPACE.BIN - "GetDriveMapping" - GET DRIVE MAPPING</a><br />
<a href="#2F4A11BX0002"><b>2F4A11BX0002</b> - INT 2F - DBLSPACE.BIN - "Swap Drive" - SWAP DRIVE LETTERS OF CVF AND HOST DRIVE</a><br />
<a href="#2F4A11BX0003"><b>2F4A11BX0003</b> - INT 2F - DBLSPACE.BIN - "DSGetEntryPoints" - GET DEVICE DRIVER ENTRY POINTS</a><br />
<a href="#2F4A11BX0004"><b>2F4A11BX0004</b> - INT 2F - DBLSPACE.BIN - "DSSetEntryPoints" - SET DEVICE DRIVER ENTRY POINTS</a><br />
<a href="#2F4A11BX0005"><b>2F4A11BX0005</b> - INT 2F - DBLSPACE.BIN - "ActivateDrive" - MOUNT COMPRESSED DRIVE</a><br />
<a href="#2F4A11BX0006"><b>2F4A11BX0006</b> - INT 2F - DBLSPACE.BIN - "DeactivateDrive" - UNMOUNT COMPRESSED DRIVE</a><br />
<a href="#2F4A11BX0007"><b>2F4A11BX0007</b> - INT 2F - DBLSPACE.BIN - "GetDriveSpace" - GET SPACE AVAIL ON COMPRESSED DRIVE</a><br />
<a href="#2F4A11BX0008"><b>2F4A11BX0008</b> - INT 2F - DBLSPACE.BIN - "GetFileFragmentSpace" - GET SIZE OF FRAGMENT HEAP</a><br />
<a href="#2F4A11BX0009"><b>2F4A11BX0009</b> - INT 2F - DBLSPACE.BIN - "GetExtraInfo" - DETERMINE NUMBER OF DISK_UNIT STRUCTS</a><br />
<a href="#2F4A11BX000A"><b>2F4A11BX000A</b> - INT 2F - DBLSPACE.BIN v6.2 - SET AUTOMOUNT DRIVES</a><br />
<a href="#2F4A11BX000B"><b>2F4A11BX000B</b> - INT 2F - DBLSPACE.BIN v6.2 - GET AUTOMOUNT DRIVES</a><br />
<a href="#2F4A11BXFFFE"><b>2F4A11BXFFFE</b> - INT 2F U - DBLSPACE.BIN - RELOCATE</a><br />
<a href="#2F4A11BXFFFF"><b>2F4A11BXFFFF</b> - INT 2F U - DBLSPACE.BIN - GET RELOCATION SIZE</a><br />
<a href="#2F4A12CX4D52"><b>2F4A12CX4D52</b> - INT 2F - Microsoft Realtime Compression Interface (MRCI) - RAM-BASED SERVER</a><br />
<a href="#2F4A12CX5354"><b>2F4A12CX5354</b> - INT 2F - Stacker 4 LZS Compression Interface (LZSAPI)</a><br />
<a href="#2F4A13"><b>2F4A13</b> - INT 2F U - DBLSPACE.BIN - DBLSPACE/MRCI STEALTH PACKET API</a><br />
<a href="#2F4A15BX0000"><b>2F4A15BX0000</b> - INT 2F - MS EMM386.EXE v4.46+ - INSTALL I/O VIRTUALIZATION HANDLER</a><br />
<a href="#2F4A16"><b>2F4A16</b> - INT 2F U - Windows95 - OPEN BOOT LOG</a><br />
<a href="#2F4A17"><b>2F4A17</b> - INT 2F U - Windows95 - WRITE TO BOOT LOG</a><br />
<a href="#2F4A18"><b>2F4A18</b> - INT 2F U - Windows95 - CLOSE BOOT LOG</a><br />
<a href="#2F4A21"><b>2F4A21</b> - INT 2F U - Windows95 - ???</a><br />
<a href="#2F4A31"><b>2F4A31</b> - INT 2F U - Windows95 - ???</a><br />
<a href="#2F4A32"><b>2F4A32</b> - INT 2F U - Windows95 - PATCH ???</a><br />
<a href="#2F4A33"><b>2F4A33</b> - INT 2F - Windows95 - CHECK MS-DOS VERSION 7</a><br />
<a href="#2F4B"><b>2F4B</b> - INT 2F - LAN Manager 2.0 DOS Enh NETWKSTA.EXE - NETWORK WORKSTATION REDIRECTOR</a><br />
<a href="#2F4B01"><b>2F4B01</b> - INT 2F C - DOS 5+ TASK SWITCHER - BUILD CALLOUT CHAIN</a><br />
<a href="#2F4B02BX0000"><b>2F4B02BX0000</b> - INT 2F - DOS 5+ TASK SWITCHER - INSTALLATION CHECK</a><br />
<a href="#2F4B03"><b>2F4B03</b> - INT 2F - DOS 5+ TASK SWITCHER - ALLOCATE SWITCHER ID</a><br />
<a href="#2F4B04"><b>2F4B04</b> - INT 2F - DOS 5+ TASK SWITCHER - FREE SWITCHER ID</a><br />
<a href="#2F4B05"><b>2F4B05</b> - INT 2F C - DOS 5+ TASK SWITCHER - IDENTIFY INSTANCE DATA</a><br />
<a href="#2F4B06"><b>2F4B06</b> - INT 2F - MS Windows - WIN.COM - GET ??? POINTER TO WIN.COM</a><br />
<a href="#2F4B20"><b>2F4B20</b> - INT 2F - MS Windows 3+ - WIN.COM - SET PROGRAM TO EXECUTE ON EXIT</a><br />
<a href="#2F4B21"><b>2F4B21</b> - INT 2F - Windows95 - WIN.COM - GET NESTING LEVEL</a><br />
<a href="#2F4B52"><b>2F4B52</b> - INT 2F - KeyRus v7.3 - API</a><br />
<a href="#2F4B80"><b>2F4B80</b> - INT 2F - MS Windows - WSWAP.EXE - RESET INTERNAL VARIABLES</a><br />
<a href="#2F4C"><b>2F4C</b> - INT 2F U - Advanced Power Management</a><br />
<a href="#2F4D"><b>2F4D</b> - INT 2F U - KKCFUNC</a><br />
<a href="#2F4E53BL00"><b>2F4E53BL00</b> - INT 2F - SilverNET v2+ - INSTALLATION CHECK</a><br />
<a href="#2F4E53BL01"><b>2F4E53BL01</b> - INT 2F - SilverNET - GET RUNTIME PARAMETER</a><br />
<a href="#2F4E53BL02"><b>2F4E53BL02</b> - INT 2F - SilverNET - SET RUNTIME PARAMETERS</a><br />
<a href="#2F5100"><b>2F5100</b> - INT 2F U - ODIHLP.EXE - INSTALLATION CHECK</a><br />
<a href="#2F5200"><b>2F5200</b> - INT 2F - JAM.SYS v1.10+ - "GetVersion" - INSTALLATION CHECK</a><br />
<a href="#2F5201"><b>2F5201</b> - INT 2F - JAM.SYS v1.10+ - "GetInfo" - GET COMPRESSED DRIVE INFORMATION</a><br />
<a href="#2F5202"><b>2F5202</b> - INT 2F - JAM.SYS v1.10+ - "Attach" - MOUNT COMPRESSED DRIVE</a><br />
<a href="#2F5203"><b>2F5203</b> - INT 2F - JAM.SYS v1.10+ - "Detach" - UNMOUNT COMPRESSED DRIVE</a><br />
<a href="#2F5204"><b>2F5204</b> - INT 2F - JAM.SYS v1.10+ - "Lock" - LOCK COMPRESSED DRIVE</a><br />
<a href="#2F5205"><b>2F5205</b> - INT 2F - JAM.SYS v1.10+ - "UnLock" - UNLOCK COMPRESSED DRIVE</a><br />
<a href="#2F5206"><b>2F5206</b> - INT 2F - JAM.SYS v1.10+ - "Read" - PHYSICAL READ DATA FROM JAM ARCHIVE</a><br />
<a href="#2F5207"><b>2F5207</b> - INT 2F - JAM.SYS v1.10+ - "Write" - PHYSICAL WRITE DATA TO JAM ARCHIVE</a><br />
<a href="#2F53"><b>2F53</b> - INT 2F U - POWER.EXE - APM event broadcasting???</a><br />
<a href="#2F530B"><b>2F530B</b> - INT 2F U - ??? (MOUSEPWR.COM, others) - ???</a><br />
<a href="#2F5400"><b>2F5400</b> - INT 2F U - POWER.EXE - INSTALLATION CHECK</a><br />
<a href="#2F5401"><b>2F5401</b> - INT 2F U - POWER.EXE - GET/SET POWER STATUS</a><br />
<a href="#2F5402"><b>2F5402</b> - INT 2F U - POWER.EXE - GET/SET IDLE DETECTION STRATEGY</a><br />
<a href="#2F5403"><b>2F5403</b> - INT 2F U - POWER.EXE - GET/SET ADVANCED POWER MANAGEMENT SETTING</a><br />
<a href="#2F5453"><b>2F5453</b> - INT 2F - TesSeRact RAM-RESIDENT PROGRAM INTERFACE</a><br />
<a href="#2F5480"><b>2F5480</b> - INT 2F U - POWER.EXE - GET/SET ???</a><br />
<a href="#2F5481"><b>2F5481</b> - INT 2F U - POWER.EXE - GET STATISTICS</a><br />
<a href="#2F5482"><b>2F5482</b> - INT 2F U - POWER.EXE - GET/SET APM POLLING FREQUENCY</a><br />
<a href="#2F548F"><b>2F548F</b> - INT 2F U - POWER.EXE - GET/SET ???</a><br />
<a href="#2F5500"><b>2F5500</b> - INT 2F U - DOS 5+ - COMMAND.COM INTERFACE</a><br />
<a href="#2F5501"><b>2F5501</b> - INT 2F U - DOS 5+ - ROM COMMAND.COM INTERFACE</a><br />
<a href="#2F5600"><b>2F5600</b> - INT 2F - INTERLNK - INSTALLATION CHECK</a><br />
<a href="#2F5601"><b>2F5601</b> - INT 2F - INTERLNK - CHECK IF REDIRECTED DRIVE</a><br />
<a href="#2F5602"><b>2F5602</b> - INT 2F - INTERLNK - CHECK IF PORT IN USE</a><br />
<a href="#2F5700"><b>2F5700</b> - INT 2F U - IOMEGA DRIVERS - INSTALLATION CHECK</a><br />
<a href="#2F5701"><b>2F5701</b> - INT 2F U - IOMEGA DRIVERS - SECONDARY INSTALLATION CHECK</a><br />
<a href="#2F5710"><b>2F5710</b> - INT 2F U - IOMEGA DRIVERS - GET DRIVER INFORMATION???</a><br />
<a href="#2F5711"><b>2F5711</b> - INT 2F U - IOMEGA DRIVERS - LOCK MEDIA IN DRIVE</a><br />
<a href="#2F5712"><b>2F5712</b> - INT 2F U - IOMEGA DRIVERS - UNLOCK MEDIA IN DRIVE / EJECT</a><br />
<a href="#2F5758BX4858"><b>2F5758BX4858</b> - INT 2F U - Helix Multimedia Cloaking - CACHECLK - INSTALLATION CHECK</a><br />
<a href="#2F5D00"><b>2F5D00</b> - INT 2F U - PCMCIA - AWARD PCDISK - GET INFO FROM DRIVER ???</a><br />
<a href="#2F5D01"><b>2F5D01</b> - INT 2F U - PCMCIA - AWARD PCDISK - PUT INFO INTO DRIVER ???</a><br />
<a href="#2F60FFDL00"><b>2F60FFDL00</b> - INT 2F U - IPLAY v1.00b - INSTALLATION CHECK</a><br />
<a href="#2F60FFDL01"><b>2F60FFDL01</b> - INT 2F U - IPLAY v1.00b - GET DATA SEGMENT</a><br />
<a href="#2F6282"><b>2F6282</b> - INT 2F U - PC Tools v7.0+ VDEFEND, VSAFE, VWATCH, DATAMON - SET ??? ADDRESS</a><br />
<a href="#2F6284BX0000"><b>2F6284BX0000</b> - INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT	- INSTALLATION CHECK</a><br />
<a href="#2F6284BX0001"><b>2F6284BX0001</b> - INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT - GET ???</a><br />
<a href="#2F6284BX0002"><b>2F6284BX0002</b> - INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT - GET OPTIONS</a><br />
<a href="#2F6284BX0003"><b>2F6284BX0003</b> - INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT - SET OPTION??? FLAGS</a><br />
<a href="#2F6284BX0004"><b>2F6284BX0004</b> - INT 2F U - PC Tools v8 DATAMON, v9+ DPROTECT - ???</a><br />
<a href="#2F6400"><b>2F6400</b> - INT 2F - SCRNSAV2.COM - INSTALLATION CHECK</a><br />
<a href="#2F7000"><b>2F7000</b> - INT 2F - License Service API - INSTALLATION CHECK</a><br />
<a href="#2F7001"><b>2F7001</b> - INT 2F - License Service API - REQUEST LICENSE</a><br />
<a href="#2F7002"><b>2F7002</b> - INT 2F - License Service API - RELEASE LICENSE</a><br />
<a href="#2F7003"><b>2F7003</b> - INT 2F - License Service API - UPDATE</a><br />
<a href="#2F7004"><b>2F7004</b> - INT 2F - License Service API - GET ERROR</a><br />
<a href="#2F7005"><b>2F7005</b> - INT 2F - License Service API - QUERY LICENSE</a><br />
<a href="#2F7041BX4B70"><b>2F7041BX4B70</b> - INT 2F U - HP 200LX - KEY200 - INSTALLATION CHECK</a><br />
<a href="#2F7200"><b>2F7200</b> - INT 2F - SRDISK v1.30+ - INSTALLATION CHECK</a><br />
<a href="#2F7201"><b>2F7201</b> - INT 2F - SRDISK v2.02 - GET CODE/DATA SEGMENT</a><br />
<a href="#2F7A00"><b>2F7A00</b> - INT 2F - Novell NetWare - LOW-LEVEL API (IPX) INSTALLATION CHECK</a><br />
<a href="#2F7A10"><b>2F7A10</b> - INT 2F U - Novell NetWare - TBMI v1.1+ - GET TBMI STATUS</a><br />
<a href="#2F7A11"><b>2F7A11</b> - INT 2F U - Novell NetWare - TBMI v1.1+ - GET INT2F HANDLERS</a><br />
<a href="#2F7A12"><b>2F7A12</b> - INT 2F U - Novell NetWare - TBMI v1.1+ - GET INT64 HANDLERS</a><br />
<a href="#2F7A13"><b>2F7A13</b> - INT 2F U - Novell NetWare - TBMI v1.1+ - GET INT7A HANDLERS</a><br />
<a href="#2F7A14"><b>2F7A14</b> - INT 2F U - Novell NetWare - TBMI v1.1+ - GET STATISTICS</a><br />
<a href="#2F7A15"><b>2F7A15</b> - INT 2F OU - Novell NetWare - TBMI v1.1 only - RESET ???</a><br />
<a href="#2F7A16"><b>2F7A16</b> - INT 2F OU - Novell NetWare - TBMI v1.1 only - ???</a><br />
<a href="#2F7A17"><b>2F7A17</b> - INT 2F OU - Novell NetWare - TBMI v1.1 only - ???</a><br />
<a href="#2F7A18"><b>2F7A18</b> - INT 2F U - Novell NetWare - TASKID v1.0 - INSTALLATION CHECK</a><br />
<a href="#2F7A19"><b>2F7A19</b> - INT 2F U - Novell NetWare - TASKID v1.0 - GET INT 08 HANDLERS</a><br />
<a href="#2F7A1A"><b>2F7A1A</b> - INT 2F U - Novell NetWare - TASKID v1.0 - GET INT 2F HANDLERS</a><br />
<a href="#2F7A1B"><b>2F7A1B</b> - INT 2F U - Novell NetWare - TASKID v1.0 - GET DIAGNOSTICS INFORMATION</a><br />
<a href="#2F7A1C"><b>2F7A1C</b> - INT 2F U - Novell NetWare - TBMI v1.1+ - ???</a><br />
<a href="#2F7A1D"><b>2F7A1D</b> - INT 2F U - Novell NetWare - TBMI v1.1+ - ???</a><br />
<a href="#2F7A1E"><b>2F7A1E</b> - INT 2F U - Novell NetWare - TBMI v1.1+ - ???</a><br />
<a href="#2F7A20BX0000"><b>2F7A20BX0000</b> - INT 2F - Novell NetWare - Adv NetWare 4.0 DOS Requester - GET VLM CALL ADDRESS</a><br />
<a href="#2F7A20BX0001"><b>2F7A20BX0001</b> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM CallA ADDRESS</a><br />
<a href="#2F7A20BX0002"><b>2F7A20BX0002</b> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM MULTIPLEX ADDRESS</a><br />
<a href="#2F7A20BX0003"><b>2F7A20BX0003</b> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM PARSE API ADDRESS</a><br />
<a href="#2F7A20BX0004"><b>2F7A20BX0004</b> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM MULTICAST CALLOUT</a><br />
<a href="#2F7A20BX0005"><b>2F7A20BX0005</b> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM INT 24 ADDRESS</a><br />
<a href="#2F7A20BX0006"><b>2F7A20BX0006</b> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT</a><br />
<a href="#2F7A20BX0007"><b>2F7A20BX0007</b> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT</a><br />
<a href="#2F7A20BX0008"><b>2F7A20BX0008</b> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT</a><br />
<a href="#2F7A20BX0080"><b>2F7A20BX0080</b> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT</a><br />
<a href="#2F7A20BX0081"><b>2F7A20BX0081</b> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT</a><br />
<a href="#2F7A20BX0082"><b>2F7A20BX0082</b> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT</a><br />
<a href="#2F7A21"><b>2F7A21</b> - INT 2F C - Novell NetWare - DOS Requester - BROADCAST CALLBACK</a><br />
<a href="#2F7A22"><b>2F7A22</b> - INT 2F C - Novell NetWare - DOS Requester - BROADCAST/SFT3 INFORM</a><br />
<a href="#2F7A2F"><b>2F7A2F</b> - INT 2F - Novell NetWare - IPXODI v2.12 - GET GNMA SUPPORT</a><br />
<a href="#2F7A2FBX0EDC"><b>2F7A2FBX0EDC</b> - INT 2F U - Personal NetWare - HRMIB - UNINSTALL</a><br />
<a href="#2F7A40"><b>2F7A40</b> - INT 2F - Novell NetWare - TCP/IP Protocol Stack - INSTALLATION CHECK</a><br />
<a href="#2F7A41"><b>2F7A41</b> - INT 2F U - Novell NetWare - TCP/IP Protocol Stack - WINDOWS SUPPORT???</a><br />
<a href="#2F7A42"><b>2F7A42</b> - INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - GET ??? ENTRY POINT</a><br />
<a href="#2F7A43"><b>2F7A43</b> - INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - GET ???</a><br />
<a href="#2F7A44"><b>2F7A44</b> - INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - SET ???</a><br />
<a href="#2F7A4C"><b>2F7A4C</b> - INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - GET ???</a><br />
<a href="#2F7A4DBX0001"><b>2F7A4DBX0001</b> - INT 2F U - Novell NetWare - ???</a><br />
<a href="#2F7A4E"><b>2F7A4E</b> - INT 2F U - Novell LAN Workplace for DOS - RARPD.EXE - INSTALLATION CHECK</a><br />
<a href="#2F7A4F"><b>2F7A4F</b> - INT 2F U - Novell LAN Workplace for DOS - RARPD.EXE - UNINSTALL</a><br />
<a href="#2F7A4FBX0001"><b>2F7A4FBX0001</b> - INT 2F U - Novell NetWare - SNMP.EXE - INSTALLATION CHECK</a><br />
<a href="#2F7A4FBX0002"><b>2F7A4FBX0002</b> - INT 2F U - Novell NetWare - SNMP.EXE - ???</a><br />
<a href="#2F7A80"><b>2F7A80</b> - INT 2F C - Novell NetWare - SHELL 3.01d BROADCAST - ABNORMAL EXIT</a><br />
<a href="#2F7A81"><b>2F7A81</b> - INT 2F C - Novell NetWare - SHELL 3.01d BROADCAST - SET SHELL INT 21 HANDLER</a><br />
<a href="#2F7A85"><b>2F7A85</b> - INT 2F C - Novell NetWare - shell 3.01 - BROADCAST INFORM</a><br />
<a href="#2F7A90"><b>2F7A90</b> - INT 2F U - Novell NetWare - NETBIOS.EXE 3+ - INSTALLATION CHECK</a><br />
<a href="#2F7AA0"><b>2F7AA0</b> - INT 2F U - Personal NetWare - HRMIB - ???</a><br />
<a href="#2F7AC1"><b>2F7AC1</b> - INT 2F - LAN HiJack - LHR - DISABLE???</a><br />
<a href="#2F7AC2"><b>2F7AC2</b> - INT 2F - LAN HiJack - LHR - SYNCHRONIZE SHIFT STATES???</a><br />
<a href="#2F7AC3"><b>2F7AC3</b> - INT 2F - LAN HiJack - LHR - CLEAR ??? FLAG</a><br />
<a href="#2F7AC8"><b>2F7AC8</b> - INT 2F - LAN HiJack - LHR - ENABLE FUNCTIONS</a><br />
<a href="#2F7AC9"><b>2F7AC9</b> - INT 2F - LAN HiJack - LHR - DISABLE FUNCTIONS</a><br />
<a href="#2F7ACA"><b>2F7ACA</b> - INT 2F - LAN HiJack - LHJ - ???</a><br />
<a href="#2F7ACB"><b>2F7ACB</b> - INT 2F - LAN HiJack - LHJ - ???</a><br />
<a href="#2F7ACC"><b>2F7ACC</b> - INT 2F - LAN HiJack - LHJ - ???</a><br />
<a href="#2F7ACFBX0000"><b>2F7ACFBX0000</b> - INT 2F - LAN HiJack - LHR - INSTALLATION CHECK</a><br />
<a href="#2F7AF0"><b>2F7AF0</b> - INT 2F - Novell NetWare - DOSNP.EXE v1.30G - INSTALLATION CHECK</a><br />
<a href="#2F7AF1"><b>2F7AF1</b> - INT 2F - Novell NetWare - Access Server Driver - INSTALLATION CHECK</a><br />
<a href="#2F7AFE"><b>2F7AFE</b> - INT 2F U - Novell NetWare - DOSNP.EXE - INSTALLATION CHECK</a><br />
<a href="#2F7AFFBX0000"><b>2F7AFFBX0000</b> - INT 2F - Novell NetWare - TBMI v1.1+ - INSTALLATION CHECK / Windows SUPPORT</a><br />
<a href="#2F7AFFBX0001"><b>2F7AFFBX0001</b> - INT 2F - Novell NetWare - TBMI v1.1+, shell v3.01d - INSTALLATION CHECK???</a><br />
<a href="#2F7F00"><b>2F7F00</b> - INT 2F - Jim Harper's CD-ROM redirector SCSI driver - INSTALLATION CHECK</a><br />
<a href="#2F7F00_0"><b>2F7F00</b> - INT 2F - PRINDIR v9.0 - INSTALLATION CHECK</a><br />
<a href="#2F7F01"><b>2F7F01</b> - INT 2F - Jim Harper's CD-ROM redirector SCSI driver - DO COMMAND</a><br />
<a href="#2F7F01_0"><b>2F7F01</b> - INT 2F - PRINDIR v9.0 - SET CAPTURE DEVICE</a><br />
<a href="#2F7F02"><b>2F7F02</b> - INT 2F - Jim Harper's CD-ROM redirector SCSI driver - DO RESET</a><br />
<a href="#2F7F02_0"><b>2F7F02</b> - INT 2F - PRINDIR v9.0 - SET DESTINATION DEVICE</a><br />
<a href="#2F7F03"><b>2F7F03</b> - INT 2F - Jim Harper's CD-ROM redirector SCSI driver - UNINSTALL</a><br />
<a href="#2F7F03_0"><b>2F7F03</b> - INT 2F - PRINDIR v9.0 - SET CAPTURE FILENAME</a><br />
<a href="#2F7F04"><b>2F7F04</b> - INT 2F - PRINDIR v9.0 - SET LOCK FILENAME</a><br />
<a href="#2F7F05"><b>2F7F05</b> - INT 2F - PRINDIR v9.0 - DUMP CAPTURE BUFFER</a><br />
<a href="#2F7F06"><b>2F7F06</b> - INT 2F - PRINDIR v9.0 - SET NORMAL TEXT COLOR</a><br />
<a href="#2F7F07"><b>2F7F07</b> - INT 2F - PRINDIR v9.0 - SET HIGHLIGHT TEXT COLOR</a><br />
<a href="#2F7F08"><b>2F7F08</b> - INT 2F - PRINDIR v9.0 - SET POPUP HOTKEY</a><br />
<a href="#2F7F09"><b>2F7F09</b> - INT 2F - PRINDIR v9.0 - SET BYTE COUNTER DISPLAY</a><br />
<a href="#2F7F0A"><b>2F7F0A</b> - INT 2F - PRINDIR v9.0 - SET FLUSH DELAY</a><br />
<a href="#2F7F0B"><b>2F7F0B</b> - INT 2F - PRINDIR v9.0 - SET MINIMUM DUMP SIZE</a><br />
<a href="#2F7F0C"><b>2F7F0C</b> - INT 2F - PRINDIR v9.0 - SET ECHO STATE</a><br />
<a href="#2F7F0D"><b>2F7F0D</b> - INT 2F - PRINDIR v9.0 - SHOW POPUP PARAMETER MENU</a><br />
<a href="#2F7F0E"><b>2F7F0E</b> - INT 2F - PRINDIR v9.0 - SUBMIT BYTE TO CURRENT DESTINATION DEVICE</a><br />
<a href="#2F7F24"><b>2F7F24</b> - INT 2F - Multiplex - ???</a><br />
<a href="#2F7F26"><b>2F7F26</b> - INT 2F - Multiplex - ???</a><br />
<a href="#2F8000"><b>2F8000</b> - INT 2F - EASY-NET - INSTALLATION CHECK</a><br />
<a href="#2F8000_0"><b>2F8000</b> - INT 2F - Nanosoft, Inc. TurboNET server - INSTALLATION CHECK</a><br />
<a href="#2F8000_1"><b>2F8000</b> - INT 2F - CS_TSR specification - TSR INSTALLATION CHECK</a><br />
<a href="#2F8000DX0000"><b>2F8000DX0000</b> - INT 2F - FaxBIOS interface - INSTALLATION CHECK</a><br />
<a href="#2F8001"><b>2F8001</b> - INT 2F - Nanosoft, Inc. TurboNET server - ???</a><br />
<a href="#2F8001_0"><b>2F8001</b> - INT 2F - CS_TSR specification - GET HANDLE (TSR-SPECIFIC INSTALLATION CHECK)</a><br />
<a href="#2F8002"><b>2F8002</b> - INT 2F - CS_TSR specification - GET PROCESS BLOCK BY PROCESS HANDLE</a><br />
<a href="#2F8003"><b>2F8003</b> - INT 2F - CS_TSR specification - CUSTOM SUBFUNCTION</a><br />
<a href="#2F80FB"><b>2F80FB</b> - INT 2F - FaxBIOS interface - COMMAND SUBMISSION</a><br />
<a href="#2F8100"><b>2F8100</b> - INT 2F U - Nanosoft, Inc. TurboNET redirector - INSTALLATION CHECK</a><br />
<a href="#2F8101"><b>2F8101</b> - INT 2F U - Nanosoft, Inc. TurboNET redirector - ???</a><br />
<a href="#2F8102"><b>2F8102</b> - INT 2F U - Nanosoft, Inc. TurboNET redirector - ???</a><br />
<a href="#2F8103"><b>2F8103</b> - INT 2F U - Nanosoft, Inc. TurboNET redirector - GET MACHINE NAME???</a><br />
<a href="#2F8104"><b>2F8104</b> - INT 2F U - Nanosoft, Inc. TurboNET redirector - ???</a><br />
<a href="#2F8105"><b>2F8105</b> - INT 2F U - Nanosoft, Inc. TurboNET redirector - ???</a><br />
<a href="#2F8200"><b>2F8200</b> - INT 2F - RESPLAY - SAMPLE/PLAYBACK</a><br />
<a href="#2F8200_0"><b>2F8200</b> - INT 2F U - Nanosoft, Inc. CAPDOS - INSTALLATION CHECK</a><br />
<a href="#2F8201"><b>2F8201</b> - INT 2F - RESPLAY - INSTALLATION CHECK</a><br />
<a href="#2F8201_0"><b>2F8201</b> - INT 2F - Nanosoft, Inc. CAPDOS - CLEAR QUEUE</a><br />
<a href="#2F8202"><b>2F8202</b> - INT 2F - RESPLAY - UNINSTALL</a><br />
<a href="#2F8202_0"><b>2F8202</b> - INT 2F - Nanosoft, Inc. CAPDOS - START COLLECTION</a><br />
<a href="#2F8203"><b>2F8203</b> - INT 2F - Nanosoft, Inc. CAPDOS - STOP COLLECTION</a><br />
<a href="#2F8204"><b>2F8204</b> - INT 2F - Nanosoft, Inc. CAPDOS - GET QUEUE PARAMETERS</a><br />
<a href="#2F8205"><b>2F8205</b> - INT 2F - Nanosoft, Inc. CAPDOS - GET QUEUE ITEM</a><br />
<a href="#2F8210"><b>2F8210</b> - INT 2F - RESPLAY - INITIALIZE</a><br />
<a href="#2F8220"><b>2F8220</b> - INT 2F - MODRES - PLAY MODULE</a><br />
<a href="#2F8221"><b>2F8221</b> - INT 2F - MODRES - INSTALLATION CHECK</a><br />
<a href="#2F8222"><b>2F8222</b> - INT 2F - MODRES - UNINSTALL</a><br />
<a href="#2F8223"><b>2F8223</b> - INT 2F - MODRES - PLAY SAMPLE</a><br />
<a href="#2F8224"><b>2F8224</b> - INT 2F - MODRES - ???</a><br />
<a href="#2F8225"><b>2F8225</b> - INT 2F - MODRES v2.00+ - GET LOCATION IN MOD</a><br />
<a href="#2F8226"><b>2F8226</b> - INT 2F - MODRES v2.00+ - STOP PLAYING</a><br />
<a href="#2F8227"><b>2F8227</b> - INT 2F - MODRES - CONFIGURE</a><br />
<a href="#2F86"><b>2F86</b> - INT 2F U - ???</a><br />
<a href="#2F8900"><b>2F8900</b> - INT 2F - WHOA!.COM - INSTALLATION CHECK</a><br />
<a href="#2F8901"><b>2F8901</b> - INT 2F - WHOA!.COM - UNINSTALL</a><br />
<a href="#2F8902"><b>2F8902</b> - INT 2F - WHOA!.COM - SET DELAY COUNT</a><br />
<a href="#2F9000"><b>2F9000</b> - INT 2F U - RAID - INSTALLATION CHECK</a><br />
<a href="#2F9001"><b>2F9001</b> - INT 2F U - RAID - GET ???</a><br />
<a href="#2F9002"><b>2F9002</b> - INT 2F U - RAID - GET RESIDENT SEGMENT</a><br />
<a href="#2F9003"><b>2F9003</b> - INT 2F U - RAID - UNINSTALL</a><br />
<a href="#2F9004"><b>2F9004</b> - INT 2F U - RAID - GET ???</a><br />
<a href="#2F92"><b>2F92</b> - INT 2F - Network Courier E-Mail - API</a><br />
<a href="#2F9200"><b>2F9200</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - BUG</a><br />
<a href="#2F9201"><b>2F9201</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - CHECK IF MAPPED DRIVE</a><br />
<a href="#2F9202"><b>2F9202</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - UNINSTALL</a><br />
<a href="#2F9203"><b>2F9203</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET VERSION</a><br />
<a href="#2F9204"><b>2F9204</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - INSTALLATION CHECK</a><br />
<a href="#2F9205"><b>2F9205</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - SET ???</a><br />
<a href="#2F9206"><b>2F9206</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F9207"><b>2F9207</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???</a><br />
<a href="#2F9208"><b>2F9208</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F9209"><b>2F9209</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F920A"><b>2F920A</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F920B"><b>2F920B</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - SET DRIVE MAPPING</a><br />
<a href="#2F920C"><b>2F920C</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F920D"><b>2F920D</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET DRIVE TYPE</a><br />
<a href="#2F920E"><b>2F920E</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - SET LPT MAPPING</a><br />
<a href="#2F920F"><b>2F920F</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???</a><br />
<a href="#2F9210"><b>2F9210</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F9211"><b>2F9211</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???</a><br />
<a href="#2F9212"><b>2F9212</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - CRITICAL SECTION???</a><br />
<a href="#2F9213"><b>2F9213</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F9214"><b>2F9214</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???</a><br />
<a href="#2F9215"><b>2F9215</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???</a><br />
<a href="#2F9216"><b>2F9216</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F9217"><b>2F9217</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F9218"><b>2F9218</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET LPT TYPE???</a><br />
<a href="#2F9219"><b>2F9219</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F921A"><b>2F921A</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F921B"><b>2F921B</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F921C"><b>2F921C</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F921D"><b>2F921D</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???</a><br />
<a href="#2F921E"><b>2F921E</b> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???</a><br />
<a href="#2F93"><b>2F93</b> - INT 2F - InnerMission v1.7+ - INSTALLATION CHECK</a><br />
<a href="#2F9400"><b>2F9400</b> - INT 2F - MICRO.EXE - INSTALLATION CHECK</a><br />
<a href="#2F9401"><b>2F9401</b> - INT 2F - MICRO.EXE - SET ??? FLAG</a><br />
<a href="#2F9402"><b>2F9402</b> - INT 2F - MICRO.EXE - ???</a><br />
<a href="#2F9403"><b>2F9403</b> - INT 2F - MICRO.EXE - SET ??? FLAG</a><br />
<a href="#2F9404"><b>2F9404</b> - INT 2F - MICRO.EXE - CLEAR ??? FLAG</a><br />
<a href="#2F96C7"><b>2F96C7</b> - INT 2F U - STRETCH - INSTALLATION CHECK</a><br />
<a href="#2F97"><b>2F97</b> - INT 2F U - Micro Focus COBOL v3.1.31 internal - ???</a><br />
<a href="#2F98"><b>2F98</b> - INT 2F U - Micro Focus COBOL v3.1.31 internal - ???</a><br />
<a href="#2F9800"><b>2F9800</b> - INT 2F U - S3RMDRV.SYS - INSTALLATION CHECK / VERSION CHECK</a><br />
<a href="#2F9803"><b>2F9803</b> - INT 2F U - S3RMDRV.SYS - COPY ??? INTO USER BUFFER</a><br />
<a href="#2F99"><b>2F99</b> - INT 2F U - Micro Focus COBOL v3.1.31 internal - ???</a><br />
<a href="#2F9900"><b>2F9900</b> - INT 2F U - DOS Navigator II - INSTALLATION CHECK</a><br />
<a href="#2F9901"><b>2F9901</b> - INT 2F U - DOS Navigator II - RETURN POINTER TO COMMAND LINE</a><br />
<a href="#2F9902"><b>2F9902</b> - INT 2F U - DOS Navigator II - SET 'TRUE' EXIT CODE OF DN.PRG</a><br />
<a href="#2F9903"><b>2F9903</b> - INT 2F U - DOS Navigator II - SPECIFY HOW TO EXECUTE COMMANDS</a><br />
<a href="#2F9904"><b>2F9904</b> - INT 2F U - DOS Navigator II v1.49 - SET ???</a><br />
<a href="#2F9905"><b>2F9905</b> - INT 2F U - DOS Navigator II v1.49 - GET ???</a><br />
<a href="#2F9906"><b>2F9906</b> - INT 2F U - DOS Navigator II v1.49 - GET ???</a><br />
<a href="#2F9A"><b>2F9A</b> - INT 2F U - Micro Focus COBOL v3.1.31 internal - ???</a><br />
<a href="#2F9C"><b>2F9C</b> - INT 2F - Network Courier E-Mail OPERATOR.EXE - API</a><br />
<a href="#2F9E00"><b>2F9E00</b> - INT 2F U - INTMON v2.1 - INSTALLATION CHECK</a><br />
<a href="#2F9E01"><b>2F9E01</b> - INT 2F U - INTMON v2.1 - RESET</a><br />
<a href="#2F9E02"><b>2F9E02</b> - INT 2F U - INTMON v2.1 - DISPLAY CPU REGISTERS???</a><br />
<a href="#2F9E03"><b>2F9E03</b> - INT 2F U - INTMON v2.1 - HOOK INTERRUPT???</a><br />
<a href="#2F9F00"><b>2F9F00</b> - INT 2F U - INTCFG v2.1 - INSTALLATION CHECK</a><br />
<a href="#2F9F01"><b>2F9F01</b> - INT 2F U - INTCFG v2.1 - ???</a><br />
<a href="#2F9F30"><b>2F9F30</b> - INT 2F U - INTCFG v2.1 - GET ???</a><br />
<a href="#2F9F49"><b>2F9F49</b> - INT 2F U - INTCFG v2.1 - UNINSTALL</a><br />
<a href="#2FA1--BX0081"><b>2FA1--BX0081</b> - INT 2F - Ergo DOS extenders - INSTALLATION CHECK</a><br />
<a href="#2FA189"><b>2FA189</b> - INT 2F U - Biologic HRAMDEV.SYS - API</a><br />
<a href="#2FA4E0"><b>2FA4E0</b> - INT 2F - Futurus Team - INSTALLATION CHECK</a><br />
<a href="#2FA900"><b>2FA900</b> - INT 2F - METZTSR.COM - INSTALLATION CHECK</a><br />
<a href="#2FA901"><b>2FA901</b> - INT 2F - METZTSR.COM - GET TIME OF LAST KEYBOARD ACTIVITY</a><br />
<a href="#2FA902"><b>2FA902</b> - INT 2F - METZTSR.COM - SET METZ Ctrl-Alt-Del FLAG</a><br />
<a href="#2FA903"><b>2FA903</b> - INT 2F - METZTSR.COM - GET METZ Ctrl-Alt-Del FLAG</a><br />
<a href="#2FAA"><b>2FAA</b> - INT 2F - Player's Tool 3.996b+ - UNINSTALL</a><br />
<a href="#2FAA00"><b>2FAA00</b> - INT 2F - VIDCLOCK.COM - INSTALLATION CHECK</a><br />
<a href="#2FAB"><b>2FAB</b> - INT 2F - Player's Tool 3.996b+ - INSTALLATION CHECK</a><br />
<a href="#2FAB00"><b>2FAB00</b> - INT 2F - Btrieve Multi-User - INSTALLATION CHECK</a><br />
<a href="#2FAB00_0"><b>2FAB00</b> - INT 2F - SRSoft MODAL PC v2+ - INSTALLATION CHECK / GET VERSION</a><br />
<a href="#2FAB01"><b>2FAB01</b> - INT 2F - Btrieve Multi-User - EXECUTE Btrieve OPERATION</a><br />
<a href="#2FAB01_0"><b>2FAB01</b> - INT 2F - SRSoft MODAL PC v2+ - GET PROCESS RUN PARAMETER</a><br />
<a href="#2FAB02"><b>2FAB02</b> - INT 2F - Btrieve Multi-User - GET NEW PROCESS ID</a><br />
<a href="#2FAB02_0"><b>2FAB02</b> - INT 2F - SRSoft MODAL PC v2+ - SET PROCESS EXIT CODE</a><br />
<a href="#2FAB03"><b>2FAB03</b> - INT 2F - SRSoft MODAL PC v2+ - ALLOCATE COMMON MEMORY</a><br />
<a href="#2FAB04"><b>2FAB04</b> - INT 2F - SRSoft MODAL PC v2+ - GET ALL COMMON VARIABLES AND SEMAPHORES</a><br />
<a href="#2FAB05"><b>2FAB05</b> - INT 2F - SRSoft MODAL PC v2+ - SET ALL COMMON VARIABLES AND SEMAPHORES</a><br />
<a href="#2FAB06"><b>2FAB06</b> - INT 2F - SRSoft MODAL PC v2+ - GET A COMMON VARIABLE OR SEMAPHORE</a><br />
<a href="#2FAB07"><b>2FAB07</b> - INT 2F - SRSoft MODAL PC v2+ - SET A COMMON VARIABLE OR SEMAPHORE</a><br />
<a href="#2FAC"><b>2FAC</b> - INT 2F u - Player's Tool 3.996b+ - POP UP</a><br />
<a href="#2FAC00"><b>2FAC00</b> - INT 2F - DOS 4.01+ GRAPHICS.COM - INSTALLATION CHECK</a><br />
<a href="#2FAC00DI1092"><b>2FAC00DI1092</b> - INT 2F - QRIP/TSR - GIVE CPU TO QRIP</a><br />
<a href="#2FAC01DI1092"><b>2FAC01DI1092</b> - INT 2F - QRIP/TSR - CHANGE INTERNAL FLAGS</a><br />
<a href="#2FAC02DI1092"><b>2FAC02DI1092</b> - INT 2F - QRIP/TSR - TURN OFF GRAPHICS SCREEN</a><br />
<a href="#2FAC03DI1092"><b>2FAC03DI1092</b> - INT 2F - QRIP/TSR - TURN ON GRAPHICS SCREEN</a><br />
<a href="#2FAC04DI1092"><b>2FAC04DI1092</b> - INT 2F - QRIP/TSR - OUTPUT STRING THROUGH QRIP</a><br />
<a href="#2FAC05DI1092"><b>2FAC05DI1092</b> - INT 2F - QRIP/TSR - OUTPUT NULL-TERMINATED STRING THROUGH QRIP</a><br />
<a href="#2FAC06DI1092"><b>2FAC06DI1092</b> - INT 2F - QRIP/TSR - RECEIVE CHARACTERS FROM QRIP</a><br />
<a href="#2FAC07DI1092"><b>2FAC07DI1092</b> - INT 2F - QRIP/TSR - GET FONT DIRECTORY</a><br />
<a href="#2FAC08DI1092"><b>2FAC08DI1092</b> - INT 2F - QRIP/TSR - GET ICON DIRECTORY</a><br />
<a href="#2FAC09DI1092"><b>2FAC09DI1092</b> - INT 2F - QRIP/TSR - OUTPUT STRING THROUGH QRIP</a><br />
<a href="#2FAC0ADI1092"><b>2FAC0ADI1092</b> - INT 2F - QRIP/TSR - OUTPUT NULL-TERMINATED STRING THROUGH QRIP</a><br />
<a href="#2FAC0BDI1092"><b>2FAC0BDI1092</b> - INT 2F - QRIP/TSR - EXECUTE RIP "END SCENE" COMMAND</a><br />
<a href="#2FAC0CDI1092"><b>2FAC0CDI1092</b> - INT 2F - QRIP/TSR - GET STRING TO BE SENT TO BBS</a><br />
<a href="#2FAC0DDI1092"><b>2FAC0DDI1092</b> - INT 2F - QRIP/TSR - SET PROTECTED SCREEN AREA</a><br />
<a href="#2FAC0EDI1092"><b>2FAC0EDI1092</b> - INT 2F - QRIP/TSR - WRITE ASCIZ STRING IN PROTECTED AREA</a><br />
<a href="#2FAC0FDI1092"><b>2FAC0FDI1092</b> - INT 2F - QRIP/TSR - SCROLL PROTECTED AREA</a><br />
<a href="#2FAC10DI1092"><b>2FAC10DI1092</b> - INT 2F - QRIP/TSR - SET OUTPUT COLOR FOR PROTECTED AREA</a><br />
<a href="#2FAC11DI1092"><b>2FAC11DI1092</b> - INT 2F - QRIP/TSR - CONVERT PROTECTED AREA TO ENTIRE SCREEN</a><br />
<a href="#2FAC12DI1092"><b>2FAC12DI1092</b> - INT 2F - QRIP/TSR - BEGIN POPUP-WINDOW MODE</a><br />
<a href="#2FAC13DI1092"><b>2FAC13DI1092</b> - INT 2F - QRIP/TSR - END POPUP-WINDOW MODE</a><br />
<a href="#2FAC14DI1092"><b>2FAC14DI1092</b> - INT 2F - QRIP/TSR - SAVE GRAPHICS SCREEN AND SWITCH TO TEXT MODE</a><br />
<a href="#2FAC15DI1092"><b>2FAC15DI1092</b> - INT 2F - QRIP/TSR - RESTORE GRAPHICS SCREEN</a><br />
<a href="#2FAC16DI1092"><b>2FAC16DI1092</b> - INT 2F - QRIP/TSR - REPORT MODE CHANGE TO QRIP</a><br />
<a href="#2FAC17DI1092"><b>2FAC17DI1092</b> - INT 2F - QRIP/TSR - CALL (EXECUTE) A RIP FILE</a><br />
<a href="#2FAC18DI1092"><b>2FAC18DI1092</b> - INT 2F - QRIP/TSR - SEND USER KEY TO QRIP</a><br />
<a href="#2FAC19DI1092"><b>2FAC19DI1092</b> - INT 2F - QRIP/TSR - HANGUP</a><br />
<a href="#2FAC1ADI1092"><b>2FAC1ADI1092</b> - INT 2F - QRIP/TSR - GET RIP_ENTER_BLOCK_MODE INFORMATION</a><br />
<a href="#2FAC1BDI1092"><b>2FAC1BDI1092</b> - INT 2F - QRIP/TSR - SET SYSTEM FONT SIZE</a><br />
<a href="#2FACF0DI1092"><b>2FACF0DI1092</b> - INT 2F - QRIP/TSR - INSTALLATION CHECK</a><br />
<a href="#2FACFFDI1092"><b>2FACFFDI1092</b> - INT 2F - QRIP/TSR - UNINSTALL</a><br />
<a href="#2FAD00"><b>2FAD00</b> - INT 2F U - DOS 3.3+ DISPLAY.SYS internal - INSTALLATION CHECK</a><br />
<a href="#2FAD00_0"><b>2FAD00</b> - INT 2F U - DR DOS 3.41-5.0, Novell DOS 7 KEYB - INSTALLATION CHECK</a><br />
<a href="#2FAD01"><b>2FAD01</b> - INT 2F U - DOS 3.3+ DISPLAY.SYS internal - SET ACTIVE CODE PAGE</a><br />
<a href="#2FAD01_0"><b>2FAD01</b> - INT 2F U - DR DOS 3.41,5.0 KEYB - GET CONFIGURATION</a><br />
<a href="#2FAD01_1"><b>2FAD01</b> - INT 2F U - Novell DOS 7 KEYB - GET/SET??? CONFIGURATION</a><br />
<a href="#2FAD02"><b>2FAD02</b> - INT 2F U - DOS 3.3+ DISPLAY.SYS internal - GET ACTIVE CODE PAGE</a><br />
<a href="#2FAD02_0"><b>2FAD02</b> - INT 2F U - Novell DOS 7 KEYB - ???</a><br />
<a href="#2FAD03"><b>2FAD03</b> - INT 2F U - DOS 3.3+ DISPLAY.SYS internal - GET CODE PAGE INFORMATION</a><br />
<a href="#2FAD04"><b>2FAD04</b> - INT 2F U - DOS 4.x only DISPLAY.SYS internal - ???</a><br />
<a href="#2FAD10"><b>2FAD10</b> - INT 2F U - DOS 4.x DISPLAY.SYS internal - INSTALLATION CHECK???</a><br />
<a href="#2FAD10_0"><b>2FAD10</b> - INT 2F U - DOS 5+ DISPLAY.SYS internal - ???</a><br />
<a href="#2FAD40"><b>2FAD40</b> - INT 2F - DOS 4.0+ - ???</a><br />
<a href="#2FAD41"><b>2FAD41</b> - INT 2F - Arabic/Hebrew DOS 5.0???+ - GET CURRENT FONTPAGE</a><br />
<a href="#2FAD42"><b>2FAD42</b> - INT 2F - Arabic/Hebrew DOS 5.0???+ SET CURRENT FONTPAGE</a><br />
<a href="#2FAD43"><b>2FAD43</b> - INT 2F - Arabic/Hebrew DOS 5.0???+ - GET FONTPAGE STATUS???</a><br />
<a href="#2FAD80"><b>2FAD80</b> - INT 2F u - MS-DOS 3.3+ KEYB.COM internal - INSTALLATION CHECK</a><br />
<a href="#2FAD80_0"><b>2FAD80</b> - INT 2F u - Novell DOS 7 KEYB.COM - INSTALLATION CHECK</a><br />
<a href="#2FAD81"><b>2FAD81</b> - INT 2F - DOS 3.3+ KEYB.COM - SET KEYBOARD CODE PAGE</a><br />
<a href="#2FAD82"><b>2FAD82</b> - INT 2F - DOS 3.3+ KEYB.COM - SET KEYBOARD MAPPING</a><br />
<a href="#2FAD83"><b>2FAD83</b> - INT 2F - DOS 5+ KEYB.COM - GET KEYBOARD MAPPING</a><br />
<a href="#2FAD84"><b>2FAD84</b> - INT 2F - PC DOS 5.0+ KEYB.COM - SET KEYBOARD SUB-MAPPING</a><br />
<a href="#2FAD85"><b>2FAD85</b> - INT 2F - PC DOS 5.0+ KEYB.COM - GET KEYBOARD SUB-MAPPING</a><br />
<a href="#2FADC1"><b>2FADC1</b> - INT 2F U - DOS 4.0+ SELECT - DISPLAY FORMAT DISK PROMPT</a><br />
<a href="#2FAE00"><b>2FAE00</b> - INT 2F U - DOS 3.3+ internal - INSTALLABLE COMMAND - INSTALLATION CHECK</a><br />
<a href="#2FAE01"><b>2FAE01</b> - INT 2F U - DOS 3.3+ internal - INSTALLABLE COMMAND - EXECUTE</a><br />
<a href="#2FAF00"><b>2FAF00</b> - INT 2F - WinDOS v2.11 - INSTALLATION CHECK</a><br />
<a href="#2FAF00_0"><b>2FAF00</b> - INT 2F U - ???</a><br />
<a href="#2FAF01"><b>2FAF01</b> - INT 2F - WinDOS v2.11 - TURN ON ONLINE MODE</a><br />
<a href="#2FAF02"><b>2FAF02</b> - INT 2F - WinDOS v2.11 - TURN OFF ONLINE MODE</a><br />
<a href="#2FAF02_0"><b>2FAF02</b> - INT 2F U - ???</a><br />
<a href="#2FAF03"><b>2FAF03</b> - INT 2F - WinDOS v2.11 - TURN VIDMEM ON</a><br />
<a href="#2FAF03_0"><b>2FAF03</b> - INT 2F U - ???</a><br />
<a href="#2FAF04"><b>2FAF04</b> - INT 2F - WinDOS v2.11 - TURN VIDMEM OFF</a><br />
<a href="#2FAF04_0"><b>2FAF04</b> - INT 2F U - ???</a><br />
<a href="#2FAF05"><b>2FAF05</b> - INT 2F - WinDOS v2.11 - GET VIDMEM STATE</a><br />
<a href="#2FAF05_0"><b>2FAF05</b> - INT 2F U - ???</a><br />
<a href="#2FAF06"><b>2FAF06</b> - INT 2F - WinDOS v2.11 - MAKE PROGRAM UNBREAKABLE</a><br />
<a href="#2FAF07"><b>2FAF07</b> - INT 2F - WinDOS v2.11 - SIGNAL FATAL OVERLAY FAULT</a><br />
<a href="#2FAF08"><b>2FAF08</b> - INT 2F - WinDOS v2.11 - SIGNAL RECOVERABLE OVERLAY FAULT</a><br />
<a href="#2FAF09"><b>2FAF09</b> - INT 2F - WinDOS v2.11 - GET TERMINATED PSP</a><br />
<a href="#2FAF0A"><b>2FAF0A</b> - INT 2F - WinDOS v2.11 - GET MAIN SHELL PSP</a><br />
<a href="#2FAF0B"><b>2FAF0B</b> - INT 2F - WinDOS v2.11 - SIGNAL FATAL ERROR</a><br />
<a href="#2FAF0C"><b>2FAF0C</b> - INT 2F - WinDOS v2.11 - GET OTHER MAIN SHELL PARAMETERS</a><br />
<a href="#2FAF0D"><b>2FAF0D</b> - INT 2F - WinDOS v2.11 - GET CURRENT PARAMETER</a><br />
<a href="#2FAF0E"><b>2FAF0E</b> - INT 2F - WinDOS v2.11 - SET CURRENT PARAMETER BYTE VALUE</a><br />
<a href="#2FAF0F"><b>2FAF0F</b> - INT 2F - WinDOS v2.11 - GET HISTORY SEGMENT</a><br />
<a href="#2FAF10"><b>2FAF10</b> - INT 2F - WinDOS v2.11 - SET HISTORY SEGMENT</a><br />
<a href="#2FAF11"><b>2FAF11</b> - INT 2F - WinDOS v2.11 - FREE XMS BLOCKS</a><br />
<a href="#2FAF12"><b>2FAF12</b> - INT 2F - WinDOS v2.11 - SET XMS IDENTIFICATION VALUE</a><br />
<a href="#2FAF12_0"><b>2FAF12</b> - INT 2F U - ???</a><br />
<a href="#2FAF13"><b>2FAF13</b> - INT 2F - WinDOS v2.11 - SET ASSIGN VALUE</a><br />
<a href="#2FAF13_0"><b>2FAF13</b> - INT 2F U - ???</a><br />
<a href="#2FAF14"><b>2FAF14</b> - INT 2F - WinDOS v2.11 - GET ASSIGN VALUE</a><br />
<a href="#2FAF15"><b>2FAF15</b> - INT 2F - WinDOS v2.11 - SIGNAL STACK ERROR</a><br />
<a href="#2FAF16"><b>2FAF16</b> - INT 2F - WinDOS v2.11 - GET SIMPLE TRUENAME</a><br />
<a href="#2FAF17"><b>2FAF17</b> - INT 2F - WinDOS v2.11 - QUERY FOR NEW CURRENT DRIVE</a><br />
<a href="#2FAF18"><b>2FAF18</b> - INT 2F - WinDOS v2.11 - SET CTRL-C/CTRL-BREAK DISABLE FLAG</a><br />
<a href="#2FAF19"><b>2FAF19</b> - INT 2F - WinDOS v2.11 - SET HEAD SETTLE FLAG</a><br />
<a href="#2FAF1A"><b>2FAF1A</b> - INT 2F - WinDOS v2.11 - SEARCH FOR NON-FRAGMENTED DISK AREA</a><br />
<a href="#2FAF30"><b>2FAF30</b> - INT 2F U - ???</a><br />
<a href="#2FAFDE"><b>2FAFDE</b> - INT 2F - Disk-Emu - INSTALLATION CHECK / GET VERSION</a><br />
<a href="#2FB000"><b>2FB000</b> - INT 2F - DOS 3.3+ GRAFTABL.COM - INSTALLATION CHECK</a><br />
<a href="#2FB001"><b>2FB001</b> - INT 2F - DOS 3.3+ GRAFTABL.COM - GET GRAPHICS FONT TABLE</a><br />
<a href="#2FB400"><b>2FB400</b> - INT 2F - IBM PC3270 EMULATION PROG v3 - INSTALLATION CHECK</a><br />
<a href="#2FB401"><b>2FB401</b> - INT 2F - IBM PC3270 EMULATION PROG v3 - GET HOST BUFFER ADDRESS</a><br />
<a href="#2FB402"><b>2FB402</b> - INT 2F - IBM PC3270 EMULATION PROG v3 - ???</a><br />
<a href="#2FB403"><b>2FB403</b> - INT 2F - IBM PC3270 EMULATION PROG v3 - ???</a><br />
<a href="#2FB404"><b>2FB404</b> - INT 2F - IBM PC3270 EMULATION PROG v3 - ???</a><br />
<a href="#2FB405"><b>2FB405</b> - INT 2F - IBM PC3270 EMULATION PROG v3 - ???</a><br />
<a href="#2FB700"><b>2FB700</b> - INT 2F - APPEND - INSTALLATION CHECK</a><br />
<a href="#2FB701"><b>2FB701</b> - INT 2F U - APPEND v3.21 only - GET APPEND PATH</a><br />
<a href="#2FB702"><b>2FB702</b> - INT 2F - APPEND - GET VERSION</a><br />
<a href="#2FB703"><b>2FB703</b> - INT 2F U - DOS 3.3, DOS 5.0 APPEND - HOOK INT 21</a><br />
<a href="#2FB704"><b>2FB704</b> - INT 2F - DOS 3.3+ APPEND - GET APPEND PATH</a><br />
<a href="#2FB706"><b>2FB706</b> - INT 2F - DOS 4.0+ APPEND - GET APPEND FUNCTION STATE</a><br />
<a href="#2FB707"><b>2FB707</b> - INT 2F - DOS 4.0+ APPEND - SET APPEND FUNCTION STATE</a><br />
<a href="#2FB710"><b>2FB710</b> - INT 2F U - DOS 3.3+ APPEND - GET VERSION INFO</a><br />
<a href="#2FB711"><b>2FB711</b> - INT 2F - DOS 4.0+ APPEND - SET RETURN FOUND NAME STATE</a><br />
<a href="#2FB800"><b>2FB800</b> - INT 2F - NETWORK - INSTALLATION CHECK</a><br />
<a href="#2FB800CXF041"><b>2FB800CXF041</b> - INT 2F - 10NET - INSTALLATION CHECK</a><br />
<a href="#2FB803"><b>2FB803</b> - INT 2F - NETWORK - GET NETWORK EVENT POST HANDLER</a><br />
<a href="#2FB804"><b>2FB804</b> - INT 2F - NETWORK - SET NETWORK EVENT POST HANDLER</a><br />
<a href="#2FB807"><b>2FB807</b> - INT 2F - NETWORK - GET NetBIOS NAME NUMBER OF MACHINE NAME</a><br />
<a href="#2FB808"><b>2FB808</b> - INT 2F U - NETWORK - RELINK KEYBOARD HANDLER</a><br />
<a href="#2FB809"><b>2FB809</b> - INT 2F - NETWORK - LANtastic, NetWare Lite - GET VERSION</a><br />
<a href="#2FB809_0"><b>2FB809</b> - INT 2F - NETWORK - PC LAN Program, Microsoft Networking - GET VERSION</a><br />
<a href="#2FB80A"><b>2FB80A</b> - INT 2F u - PC Network 1.00 - ???</a><br />
<a href="#2FB80E"><b>2FB80E</b> - INT 2F U - DOS LAN Requester - GET XSI2 ADDRESS / DATA</a><br />
<a href="#2FB80F"><b>2FB80F</b> - INT 2F - DOS LAN Requester - GET START PARAMETERS</a><br />
<a href="#2FB900"><b>2FB900</b> - INT 2F - PC Network RECEIVER.COM - INSTALLATION CHECK</a><br />
<a href="#2FB901"><b>2FB901</b> - INT 2F - PC Network RECEIVER.COM - GET RECEIVER.COM INT 2F HANDLER ADDRESS</a><br />
<a href="#2FB903"><b>2FB903</b> - INT 2F - PC Network RECEIVER.COM - GET RECEIVER.COM POST ADDRESS</a><br />
<a href="#2FB904"><b>2FB904</b> - INT 2F - PC Network RECEIVER.COM - SET RECEIVER.COM POST ADDRESS</a><br />
<a href="#2FB905"><b>2FB905</b> - INT 2F - PC Network RECEIVER.COM - GET FILENAME</a><br />
<a href="#2FB906"><b>2FB906</b> - INT 2F - PC Network RECEIVER.COM - SET FILENAME</a><br />
<a href="#2FB908"><b>2FB908</b> - INT 2F - PC Network RECEIVER.COM - UNLINK KEYBOARD HANDLER</a><br />
<a href="#2FBB00BX0000"><b>2FBB00BX0000</b> - INT 2F - CATC USB4DOS Host Controller - INSTALLATION CHECK</a><br />
<a href="#2FBB00BX0001"><b>2FBB00BX0001</b> - INT 2F - CATC USB4DOS Host Controller - GET ???</a><br />
<a href="#2FBB00BX0002"><b>2FBB00BX0002</b> - INT 2F - CATC USB4DOS Host Controller - EXECUTE USB REQUEST</a><br />
<a href="#2FBB00BX0003"><b>2FBB00BX0003</b> - INT 2F - CATC USB4DOS Host Controller - ??? (POLLS VARIOUS I/O PORTS)</a><br />
<a href="#2FBB00"><b>2FBB00</b> - INT 2F - CATC USB4DOS Host Controller - INVALID FUNCTION</a><br />
<a href="#2FBC00"><b>2FBC00</b> - INT 2F - Windows 3.0, DOS 5+ EGA.SYS - INSTALLATION CHECK</a><br />
<a href="#2FBC00BL00"><b>2FBC00BL00</b> - INT 2F - CATC USB4DOS Device Manager - INSTALLATION CHECK</a><br />
<a href="#2FBC00BL01"><b>2FBC00BL01</b> - INT 2F - CATC USB4DOS Device Manager - REGISTER DEVICE</a><br />
<a href="#2FBC00BL02"><b>2FBC00BL02</b> - INT 2F - CATC USB4DOS Device Manager - UNLOAD DEVICE</a><br />
<a href="#2FBC00BL03"><b>2FBC00BL03</b> - INT 2F - CATC USB4DOS Device Manager - HUB DEVICE ATTACHED</a><br />
<a href="#2FBC00BL04"><b>2FBC00BL04</b> - INT 2F - CATC USB4DOS Device Manager - HUB DEVICE DETACHED</a><br />
<a href="#2FBC00BX3F3F"><b>2FBC00BX3F3F</b> - INT 2F - MediaVision MVSOUND.SYS - INSTALLATION CHECK</a><br />
<a href="#2FBC01"><b>2FBC01</b> - INT 2F - MediaVision MVSOUND.SYS - GET VERSION</a><br />
<a href="#2FBC02"><b>2FBC02</b> - INT 2F - MediaVision MVSOUND.SYS - GET STATE TABLE POINTER</a><br />
<a href="#2FBC03"><b>2FBC03</b> - INT 2F - MediaVision MVSOUND.SYS - GET FUNCTION TABLE POINTER</a><br />
<a href="#2FBC04"><b>2FBC04</b> - INT 2F - MediaVision MVSOUND.SYS - GET DMA AND IRQ CHANNELS</a><br />
<a href="#2FBC06"><b>2FBC06</b> - INT 2F U - MS Windows 3.0, DOS 5+ EGA.SYS - GET VERSION INFO</a><br />
<a href="#2FBC06_0"><b>2FBC06</b> - INT 2F - MediaVision MVSOUND.SYS - GET STATUS STRING</a><br />
<a href="#2FBC0B"><b>2FBC0B</b> - INT 2F - MediaVision MVSOUND.SYS - GET EXECUTABLE PATH</a><br />
<a href="#2FBC0E"><b>2FBC0E</b> - INT 2F - MediaVision MVSOUND.SYS - RE-INITIALIZE INT 09 HANDLER</a><br />
<a href="#2FBE00"><b>2FBE00</b> - INT 2F - REDVIEW - INSTALLATION CHECK</a><br />
<a href="#2FBF00"><b>2FBF00</b> - INT 2F - PC LAN PROGRAM REDIRIFS.EXE internal - INSTALLATION CHECK</a><br />
<a href="#2FBF01"><b>2FBF01</b> - INT 2F U - PC LAN PROGRAM REDIRIFS.EXE internal - ???</a><br />
<a href="#2FBF80"><b>2FBF80</b> - INT 2F - PC LAN PROG REDIR.SYS internal - SET REDIRIFS ENTRY POINT</a><br />
<a href="#2FC0"><b>2FC0</b> - INT 2F - METZ XpressFax Hardware TSR (CLASS2) - API</a><br />
<a href="#2FC000"><b>2FC000</b> - INT 2F - Novell ODI Link Support Layer (LSL.COM) - INSTALLATION CHECK</a><br />
<a href="#2FC000_0"><b>2FC000</b> - INT 2F - Novell NetWare Event Service Layer (NESL) 1.0 - INSTALLATION CHECK</a><br />
<a href="#2FC000_1"><b>2FC000</b> - INT 2F - Novell NetWare Connect NETWARN - INSTALLATION CHECK</a><br />
<a href="#2FC000_2"><b>2FC000</b> - INT 2F - FN32 32 character filename utilities - INSTALLATION CHECK</a><br />
<a href="#2FC000_3"><b>2FC000</b> - INT 2F - QMR - INSTALLATION CHECK</a><br />
<a href="#2FC000_4"><b>2FC000</b> - INT 2F - VGAsave v1.93 - INSTALLATION CHECK</a><br />
<a href="#2FC000_5"><b>2FC000</b> - INT 2F - AD-DOS - INSTALLATION CHECK</a><br />
<a href="#2FC000_6"><b>2FC000</b> - INT 2F U - WANG_ER.COM - INSTALLATION CHECK</a><br />
<a href="#2FC000_7"><b>2FC000</b> - INT 2F O - ASPIHOOK.SYS - INSTALLATION CHECK</a><br />
<a href="#2FC000_8"><b>2FC000</b> - INT 2F - PMEASURE.EXE - INSTALLATION CHECK</a><br />
<a href="#2FC000_9"><b>2FC000</b> - INT 2F - PERSONAL MEASURE - HOOK MODULE INSTALLATION CHECK</a><br />
<a href="#2FC000_10"><b>2FC000</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - INSTALLATION CHECK</a><br />
<a href="#2FC000_11"><b>2FC000</b> - INT 2F - Frank Kintrup TSR Utilities - INSTALLATION CHECK</a><br />
<a href="#2FC000_12"><b>2FC000</b> - INT 2F U - HP 100LX/200LX - PUSHKEYS - INSTALLATION CHECK</a><br />
<a href="#2FC000_13"><b>2FC000</b> - INT 2F - DIMWIT - INSTALLATION CHECK</a><br />
<a href="#2FC000BX444B"><b>2FC000BX444B</b> - INT 2F - METZ XpressFax Hardware TSR (CLASS2) - INSTALLATION CHECK</a><br />
<a href="#2FC000_14"><b>2FC000</b> - INT 2F U - TSENGP.COM - INSTALLATION CHECK</a><br />
<a href="#2FC000_15"><b>2FC000</b> - INT 2F U - LapLink RemoteAccess (LLRA) - INSTALLATION CHECK</a><br />
<a href="#2FC001"><b>2FC001</b> - INT 2F - QMR - REQUEST HARDWARE RESET</a><br />
<a href="#2FC001_0"><b>2FC001</b> - INT 2F - DIMWIT - GET CONFIGURATION DATA</a><br />
<a href="#2FC001ES0000"><b>2FC001ES0000</b> - INT 2F - AD-DOS - GET RESIDENT CODE SEGMENT</a><br />
<a href="#2FC001_1"><b>2FC001</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ENTRY POINTS</a><br />
<a href="#2FC001_2"><b>2FC001</b> - INT 2F - Frank Kintrup TSR Utilities - CLOCK - DISABLE DISPLAY UPDATE</a><br />
<a href="#2FC001CX03FB"><b>2FC001CX03FB</b> - INT 2F U - HP 100LX/200LX - PUSHKEYS - INTERNAL - UNINSTALL</a><br />
<a href="#2FC001_3"><b>2FC001</b> - INT 2F - PERSONAL MEASURE - PASS PARAMETERS TO HOOK MODULE(S)</a><br />
<a href="#2FC002"><b>2FC002</b> - INT 2F - AD-DOS - CHECK FOR NEW INPUT</a><br />
<a href="#2FC002_0"><b>2FC002</b> - INT 2F - QMR - DISABLE QMR</a><br />
<a href="#2FC002_1"><b>2FC002</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET BUFFER SIZE</a><br />
<a href="#2FC002_2"><b>2FC002</b> - INT 2F - Frank Kintrup TSR Utilities - CLOCK - ENABLE DISPLAY UPDATE</a><br />
<a href="#2FC002_3"><b>2FC002</b> - INT 2F U - LapLink RemoteAccess (LLRA) - Core - ???</a><br />
<a href="#2FC003"><b>2FC003</b> - INT 2F - AD-DOS - SET MINUTES TO WAIT</a><br />
<a href="#2FC003_0"><b>2FC003</b> - INT 2F - QMR - ENABLE QMR</a><br />
<a href="#2FC003_1"><b>2FC003</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ??? FLAG</a><br />
<a href="#2FC004"><b>2FC004</b> - INT 2F - AD-DOS - GET MINUTES TO WAIT</a><br />
<a href="#2FC004_0"><b>2FC004</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - CLEAR ??? FLAG</a><br />
<a href="#2FC005"><b>2FC005</b> - INT 2F - AD-DOS - SET BLANKER STATUS</a><br />
<a href="#2FC005_0"><b>2FC005</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???</a><br />
<a href="#2FC006"><b>2FC006</b> - INT 2F - AD-DOS - GET BLANKER STATUS</a><br />
<a href="#2FC006_0"><b>2FC006</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???</a><br />
<a href="#2FC007"><b>2FC007</b> - INT 2F - AD-DOS - SET HOT KEY</a><br />
<a href="#2FC007_0"><b>2FC007</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???</a><br />
<a href="#2FC008"><b>2FC008</b> - INT 2F - AD-DOS - GET CURRENT HOT KEY</a><br />
<a href="#2FC008_0"><b>2FC008</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - CLEAR ??? FLAG</a><br />
<a href="#2FC009"><b>2FC009</b> - INT 2F - AD-DOS - UNBLANK MONITOR</a><br />
<a href="#2FC009_0"><b>2FC009</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ??? FLAG</a><br />
<a href="#2FC00A"><b>2FC00A</b> - INT 2F - AD-DOS - ???</a><br />
<a href="#2FC00A_0"><b>2FC00A</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???</a><br />
<a href="#2FC00B"><b>2FC00B</b> - INT 2F - AD-DOS - ???</a><br />
<a href="#2FC00B_0"><b>2FC00B</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - NOP</a><br />
<a href="#2FC00C"><b>2FC00C</b> - INT 2F - AD-DOS - SET ??? INTERNAL FLAG TO 01h</a><br />
<a href="#2FC00C_0"><b>2FC00C</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???</a><br />
<a href="#2FC00D"><b>2FC00D</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ???</a><br />
<a href="#2FC00E"><b>2FC00E</b> - INT 2F - AD-DOS - SET PASSWORD STATUS</a><br />
<a href="#2FC00E_0"><b>2FC00E</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - INSTALL ???</a><br />
<a href="#2FC00F"><b>2FC00F</b> - INT 2F - AD-DOS - GET PASSWORD STATUS</a><br />
<a href="#2FC00F_0"><b>2FC00F</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - REMOVE ???</a><br />
<a href="#2FC010"><b>2FC010</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???</a><br />
<a href="#2FC011"><b>2FC011</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???</a><br />
<a href="#2FC012"><b>2FC012</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???</a><br />
<a href="#2FC013"><b>2FC013</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???</a><br />
<a href="#2FC014"><b>2FC014</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???</a><br />
<a href="#2FC015"><b>2FC015</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???</a><br />
<a href="#2FC016"><b>2FC016</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - INCREMENT ???</a><br />
<a href="#2FC017"><b>2FC017</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - DECREMENT ???</a><br />
<a href="#2FC018"><b>2FC018</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???</a><br />
<a href="#2FC019"><b>2FC019</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???</a><br />
<a href="#2FC01A"><b>2FC01A</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - CLEAR ??? FLAG</a><br />
<a href="#2FC01B"><b>2FC01B</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ??? FLAG</a><br />
<a href="#2FC01C"><b>2FC01C</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???</a><br />
<a href="#2FC01D"><b>2FC01D</b> - INT 2F U - PrintCache v3.1 PCACHE.EXE - NOP</a><br />
<a href="#2FC020"><b>2FC020</b> - INT 2F - AD-DOS - GET AND RESET VxD API STATUS</a><br />
<a href="#2FC04E"><b>2FC04E</b> - INT 2F - Explosiv v2.00+ - NON-TSR EXECUTING CHECK</a><br />
<a href="#2FC050"><b>2FC050</b> - INT 2F - Explosiv v2.00+ - INSTALLATION CHECK</a><br />
<a href="#2FC052"><b>2FC052</b> - INT 2F - Explosiv v2.00+ - UNINSTALL</a><br />
<a href="#2FC054"><b>2FC054</b> - INT 2F - Explosiv v2.x - GET ANIMATION DELAY FACTOR</a><br />
<a href="#2FC054_0"><b>2FC054</b> - INT 2F - Explosiv v3.0+ - UPDATE PARAMETERS</a><br />
<a href="#2FC055"><b>2FC055</b> - INT 2F - Explosiv v2.x - SET BLANKING INTERVAL</a><br />
<a href="#2FC056"><b>2FC056</b> - INT 2F - Explosiv v2.x - SET ANIMATION DISPLAY TYPE</a><br />
<a href="#2FC056_0"><b>2FC056</b> - INT 2F - Explosiv v3.0+ - ENABLE/DISABLE EXPLOSIV</a><br />
<a href="#2FC057"><b>2FC057</b> - INT 2F - Explosiv v2.x - SET ANIMATION DELAY FACTOR</a><br />
<a href="#2FC058"><b>2FC058</b> - INT 2F - Explosiv v2.x - SET ANIMATION PARAMETER</a><br />
<a href="#2FC058_0"><b>2FC058</b> - INT 2F - Explosiv v3.0+ - LOAD NEW ANIMATION DISPLAY CODE</a><br />
<a href="#2FC059"><b>2FC059</b> - INT 2F - Explosiv v2.x - DISABLE EXPLOSIV</a><br />
<a href="#2FC05A"><b>2FC05A</b> - INT 2F u - Explosiv v2.x - ENABLE EXPLOSIV</a><br />
<a href="#2FC05B"><b>2FC05B</b> - INT 2F - Explosiv v2.x - CHANGE ANIMATION DISPLAY</a><br />
<a href="#2FC05C"><b>2FC05C</b> - INT 2F - Explosiv v2.x - SET INT 10 CHECKING</a><br />
<a href="#2FC080"><b>2FC080</b> - INT 2F U - AMI IAM.SYS - INSTALL ??? CALLBACK</a><br />
<a href="#2FC081"><b>2FC081</b> - INT 2F U - AMI IAM.SYS - CLEAR ???</a><br />
<a href="#2FC0AE"><b>2FC0AE</b> - INT 2F U - HP 100LX/200LX - PUSHKEYS - INSTALLATION CHECK</a><br />
<a href="#2FC0AF"><b>2FC0AF</b> - INT 2F U - HP 100LX/200LX - PUSHKEYS - INTERNAL - GET BUFFER ADDRESS</a><br />
<a href="#2FC100"><b>2FC100</b> - INT 2F U - Personal NetWare - STPIPX v1.00 - INSTALLATION CHECK</a><br />
<a href="#2FC101"><b>2FC101</b> - INT 2F U - Personal NetWare - STPIPX v1.00 - UNINSTALL</a><br />
<a href="#2FC205"><b>2FC205</b> - INT 2F U - LapLink RemoteAccess (LLRA) - Redirector - ???</a><br />
<a href="#2FC2F0"><b>2FC2F0</b> - INT 2F U - LapLink RemoteAccess (LLRA) - Redirector - ???</a><br />
<a href="#2FC2F1"><b>2FC2F1</b> - INT 2F U - LapLink RemoteAccess (LLRA) - Redirector - ???</a><br />
<a href="#2FC300"><b>2FC300</b> - INT 2F - SETWPR.COM - INSTALLATION CHECK</a><br />
<a href="#2FC300DX0000"><b>2FC300DX0000</b> - INT 2F U - SpaceManager - INSTALLATION CHECK</a><br />
<a href="#2FC300BX4F53"><b>2FC300BX4F53</b> - INT 2F U - SpaceManager - INSTALLATION VERIFICATION</a><br />
<a href="#2FC301"><b>2FC301</b> - INT 2F U - SpaceManager - ???</a><br />
<a href="#2FC301_0"><b>2FC301</b> - INT 2F U - LapLink RemoteAccess (LLRA) - Compression - ???</a><br />
<a href="#2FC302"><b>2FC302</b> - INT 2F U - SpaceManager - ENABLE PROGRAM</a><br />
<a href="#2FC302_0"><b>2FC302</b> - INT 2F - SETWPR.COM - SET WRITE-PROTECTION STATE</a><br />
<a href="#2FC303"><b>2FC303</b> - INT 2F U - SpaceManager - DISABLE PROGRAM</a><br />
<a href="#2FC304"><b>2FC304</b> - INT 2F U - SpaceManager - GET PER-DRIVE ENABLEMENT TABLE</a><br />
<a href="#2FC305DX9003"><b>2FC305DX9003</b> - INT 2F U - SpaceManager - FORTUNE.EXE - NOP</a><br />
<a href="#2FC305"><b>2FC305</b> - INT 2F U - SpaceManager - ???</a><br />
<a href="#2FC306"><b>2FC306</b> - INT 2F U - SpaceManager - CHECK WHETHER PROGRAM ENABLED</a><br />
<a href="#2FC307DX9001"><b>2FC307DX9001</b> - INT 2F U - SpaceManager - SELECTC - ???</a><br />
<a href="#2FC308DX9001"><b>2FC308DX9001</b> - INT 2F U - SpaceManager - SELECTC - ???</a><br />
<a href="#2FC3F0"><b>2FC3F0</b> - INT 2F U - LapLink RemoteAccess (LLRA) - Compression - ???</a><br />
<a href="#2FC3F1"><b>2FC3F1</b> - INT 2F U - LapLink RemoteAccess (LLRA) - Compression - ???</a><br />
<a href="#2FC500"><b>2FC500</b> - INT 2F - PC-DOS Econet v1.05 - INSTALLATION CHECK</a><br />
<a href="#2FC501"><b>2FC501</b> - INT 2F - PC-DOS Econet v1.05 - RESET BOARD AND DRIVER</a><br />
<a href="#2FC502"><b>2FC502</b> - INT 2F - PC-DOS Econet v1.05 - PERFORM NETWORK OPERATION</a><br />
<a href="#2FC503"><b>2FC503</b> - INT 2F - PC-DOS Econet v1.05 - ADD EVENT HANDLER</a><br />
<a href="#2FC504"><b>2FC504</b> - INT 2F - PC-DOS Econet v1.05 - REMOVE EVENT HANDLER</a><br />
<a href="#2FC505"><b>2FC505</b> - INT 2F - PC-DOS Econet v1.05 - SET DEFAULT EVENT ACTION</a><br />
<a href="#2FC506"><b>2FC506</b> - INT 2F - PC-DOS Econet v1.05 - SET INDIVIDUAL EVENT ACTION</a><br />
<a href="#2FC507"><b>2FC507</b> - INT 2F - PC-DOS Econet v1.05 - TEST/CLEAR EVENT STATUS</a><br />
<a href="#2FC508"><b>2FC508</b> - INT 2F - PC-DOS Econet v1.05 - ENABLE/DISABLE EVENT SCHEDULER</a><br />
<a href="#2FC64CBX5553"><b>2FC64CBX5553</b> - INT 2F U - Smart Prompt - INSTALLATION CHECK</a><br />
<a href="#2FC700CX434C"><b>2FC700CX434C</b> - INT 2F u - COLAP - INSTALLATION CHECK</a><br />
<a href="#2FC900BP0000"><b>2FC900BP0000</b> - INT 2F U - ThunderByte??? - INSTALLATION CHECK</a><br />
<a href="#2FC987"><b>2FC987</b> - INT 2F U - ThunderByte??? - DISINFECT FILE???</a><br />
<a href="#2FC9FD"><b>2FC9FD</b> - INT 2F - ThunderByte TBLOG - WRITE STRING TO LOG</a><br />
<a href="#2FC9FF"><b>2FC9FF</b> - INT 2F C - StackMan - INSTALLATION BROADCAST</a><br />
<a href="#2FCA"><b>2FCA</b> - INT 2F - FAXPLUS - FAX TSR</a><br />
<a href="#2FCA00BX5442"><b>2FCA00BX5442</b> - INT 2F - TBSCANX - INSTALLATION CHECK</a><br />
<a href="#2FCA01"><b>2FCA01</b> - INT 2F - TBSCANX - GET STATUS</a><br />
<a href="#2FCA02"><b>2FCA02</b> - INT 2F - TBSCANX - SET STATE</a><br />
<a href="#2FCA03"><b>2FCA03</b> - INT 2F - TBSCANX - SCAN BUFFER</a><br />
<a href="#2FCA04"><b>2FCA04</b> - INT 2F - TBSCANX - SCAN FILE</a><br />
<a href="#2FCAFEBX0000"><b>2FCAFEBX0000</b> - INT 2F U - THELP v3.0 - INSTALLATION CHECK</a><br />
<a href="#2FCB00"><b>2FCB00</b> - INT 2F - Communicating Applications Specification - INSTALLATION CHECK</a><br />
<a href="#2FCB00BX4D53"><b>2FCB00BX4D53</b> - INT 2F - METZ XpressFax CASMGR - INSTALLATION CHECK</a><br />
<a href="#2FCB01"><b>2FCB01</b> - INT 2F - Communicating Applications Specification - SUBMIT A TASK</a><br />
<a href="#2FCB02"><b>2FCB02</b> - INT 2F - Communicating Applications Specification - ABORT CURRENT EVENT</a><br />
<a href="#2FCB05"><b>2FCB05</b> - INT 2F - Communicating Applications Specification - FIND FIRST QUEUE ENTRY</a><br />
<a href="#2FCB06"><b>2FCB06</b> - INT 2F - Communicating Applications Specification - FIND NEXT QUEUE ENTRY</a><br />
<a href="#2FCB07"><b>2FCB07</b> - INT 2F - Communicating Applications Specification - OPEN FILE</a><br />
<a href="#2FCB08"><b>2FCB08</b> - INT 2F - Communicating Applications Specification - DELETE FILE</a><br />
<a href="#2FCB09"><b>2FCB09</b> - INT 2F - Communicating Applications Specification - DELETE ALL FILES IN Q</a><br />
<a href="#2FCB0A"><b>2FCB0A</b> - INT 2F - Communicating Applications Specification - GET EVENT DATE</a><br />
<a href="#2FCB0B"><b>2FCB0B</b> - INT 2F - Communicating Applications Specification - SET TASK DATE</a><br />
<a href="#2FCB0C"><b>2FCB0C</b> - INT 2F - Communicating Applications Specification - GET EVENT TIME</a><br />
<a href="#2FCB0D"><b>2FCB0D</b> - INT 2F - Communicating Applications Specification - SET TASK TIME</a><br />
<a href="#2FCB0E"><b>2FCB0E</b> - INT 2F - Communicating Applications Specification - GET EXTERNAL DATA BLOCK</a><br />
<a href="#2FCB0F"><b>2FCB0F</b> - INT 2F - Communicating Applications Specification - GET/SET AUTORECEIVE</a><br />
<a href="#2FCB10"><b>2FCB10</b> - INT 2F - Communicating Applications Specification - GET CURRENT EVENT STATUS</a><br />
<a href="#2FCB11"><b>2FCB11</b> - INT 2F - Communicating Applications Specification - GET QUEUE STATUS</a><br />
<a href="#2FCB11DL03"><b>2FCB11DL03</b> - INT 2F - Communicating Applications Spec v1.2+ - GET NUMBER OF SEND EVENTS</a><br />
<a href="#2FCB11DL04"><b>2FCB11DL04</b> - INT 2F - Communicating Applications Spec v1.2+ - GET NUMBER OF RECEIVE EVENTS</a><br />
<a href="#2FCB12"><b>2FCB12</b> - INT 2F - Communicating Applications Specification - GET HARDWARE STATUS</a><br />
<a href="#2FCB13DL00"><b>2FCB13DL00</b> - INT 2F - Communicating Applications Specification - GET DIAGNOSTICS RESULTS</a><br />
<a href="#2FCB13DL01"><b>2FCB13DL01</b> - INT 2F - Communicating Applications Specification - START DIAGNOSTICS</a><br />
<a href="#2FCB14"><b>2FCB14</b> - INT 2F - Communicating Applications Specification - MOVE RECEIVED FILE</a><br />
<a href="#2FCB15"><b>2FCB15</b> - INT 2F - Communicating Applications Specification - SUBMIT FILE TO SEND</a><br />
<a href="#2FCB16BX1234"><b>2FCB16BX1234</b> - INT 2F - Communicating Applications Spec v1.2+ - UNLOAD RESIDENT MANAGER</a><br />
<a href="#2FCB17"><b>2FCB17</b> - INT 2F - Communicating Applications Spec v1.2+ - SET COVER PAGE STATUS</a><br />
<a href="#2FCB80"><b>2FCB80</b> - INT 2F - Intel SatisFAXtion CASMGR - ???</a><br />
<a href="#2FCB81"><b>2FCB81</b> - INT 2F - Intel SatisFAXtion CASMGR - ???</a><br />
<a href="#2FCB82"><b>2FCB82</b> - INT 2F - Intel SatisFAXtion CASMGR - ???</a><br />
<a href="#2FCBDCBL56"><b>2FCBDCBL56</b> - INT 2F - Comwave Microfax Specification - GET STATUS ARRAY</a><br />
<a href="#2FCBDDBL56"><b>2FCBDDBL56</b> - INT 2F - Comwave Microfax Specification - COMMAND SUBMISSION</a><br />
<a href="#2FCC--SI5453"><b>2FCC--SI5453</b> - INT 2F U - PC-Kwik Programs - API</a><br />
<a href="#2FCC00"><b>2FCC00</b> - INT 2F - Tsoft NFSDRVR - INSTALLATION CHECK</a><br />
<a href="#2FCC01"><b>2FCC01</b> - INT 2F - Tsoft NFSDRVR - ???</a><br />
<a href="#2FCC02"><b>2FCC02</b> - INT 2F - Tsoft NFSDRVR - ???</a><br />
<a href="#2FCC03"><b>2FCC03</b> - INT 2F - Tsoft NFSDRVR - ???</a><br />
<a href="#2FCC04"><b>2FCC04</b> - INT 2F - Tsoft NFSDRVR - ???</a><br />
<a href="#2FCC05"><b>2FCC05</b> - INT 2F - Tsoft NFSDRVR - ???</a><br />
<a href="#2FCC06"><b>2FCC06</b> - INT 2F - Tsoft NFSDRVR - ???</a><br />
<a href="#2FCD00"><b>2FCD00</b> - INT 2F - Intel Image Processing Interface - INSTALLATION CHECK</a><br />
<a href="#2FCD00_0"><b>2FCD00</b> - INT 2F - LaserPort Interface - INSTALLATION CHECK</a><br />
<a href="#2FCD00_1"><b>2FCD00</b> - INT 2F - SWELL.EXE - INSTALLATION CHECK</a><br />
<a href="#2FCD00BX464F"><b>2FCD00BX464F</b> - INT 2F - Forte/Gravis ULTRAMID - INSTALLATION CHECK</a><br />
<a href="#2FCD00DX4957"><b>2FCD00DX4957</b> - INT 2F R - InterWave Game API - INSTALLATION CHECK</a><br />
<a href="#2FCD01"><b>2FCD01</b> - INT 2F - Intel Image Processing Interface - SET DEVICE NAME</a><br />
<a href="#2FCD01_0"><b>2FCD01</b> - INT 2F - SWELL.EXE - SUSPEND ONCE</a><br />
<a href="#2FCD01BX0000"><b>2FCD01BX0000</b> - INT 2F R - InterWave Game API - GET NUMBER OF INTERWAVE PROGRAMS / PROGRAM ID</a><br />
<a href="#2FCD02"><b>2FCD02</b> - INT 2F - Intel Image Processing Interface - GET VERSION NUMBER</a><br />
<a href="#2FCD02_0"><b>2FCD02</b> - INT 2F - SWELL.EXE - SUSPEND</a><br />
<a href="#2FCD02_1"><b>2FCD02</b> - INT 2F R - InterWave Game API - GET PROGRAM STATUS AND INFORMATION</a><br />
<a href="#2FCD03"><b>2FCD03</b> - INT 2F - Intel Image Processing Interface - SELECT SCAN LINE</a><br />
<a href="#2FCD03_0"><b>2FCD03</b> - INT 2F - SWELL.EXE - ACTIVATE</a><br />
<a href="#2FCD03_1"><b>2FCD03</b> - INT 2F R - InterWave Game API - SUSPEND PROGRAM</a><br />
<a href="#2FCD04"><b>2FCD04</b> - INT 2F - Intel Image Processing Interface - MOVE BITMAP TO SCANLINE</a><br />
<a href="#2FCD04_0"><b>2FCD04</b> - INT 2F - SWELL.EXE - TURN OFF VERBOSE MODE</a><br />
<a href="#2FCD04_1"><b>2FCD04</b> - INT 2F R - InterWave Game API - WAKE PROGRAM</a><br />
<a href="#2FCD05"><b>2FCD05</b> - INT 2F - Intel Image Processing Interface - PRINT PAGE</a><br />
<a href="#2FCD05_0"><b>2FCD05</b> - INT 2F - SWELL.EXE - TURN ON VERBOSE MODE</a><br />
<a href="#2FCD05_1"><b>2FCD05</b> - INT 2F R - InterWave Game API - UNINSTALL RESIDENT DEVICE DRIVER</a><br />
<a href="#2FCD06"><b>2FCD06</b> - INT 2F - Intel Image Processing Interface - CLEAR PAGE</a><br />
<a href="#2FCD06_0"><b>2FCD06</b> - INT 2F - SWELL.EXE - UNINSTALL</a><br />
<a href="#2FCD07"><b>2FCD07</b> - INT 2F - Intel Image Processing Interface - reserved</a><br />
<a href="#2FCD07_0"><b>2FCD07</b> - INT 2F - SWELL.EXE - GET INFO</a><br />
<a href="#2FCD08"><b>2FCD08</b> - INT 2F - Intel Image Processing Interface - SCREEN IMAGE</a><br />
<a href="#2FCD08_0"><b>2FCD08</b> - INT 2F - SWELL.EXE - UNUSED</a><br />
<a href="#2FCD09"><b>2FCD09</b> - INT 2F - Intel Image Processing Interface - LOAD SCREEN</a><br />
<a href="#2FCD09_0"><b>2FCD09</b> - INT 2F - SWELL.EXE - TURN OFF "BORLAND SUPPORT"</a><br />
<a href="#2FCD0A"><b>2FCD0A</b> - INT 2F - Intel Image Processing Interface - LOAD PALETTE</a><br />
<a href="#2FCD0A_0"><b>2FCD0A</b> - INT 2F - SWELL.EXE - TURN ON "BORLAND SUPPORT"</a><br />
<a href="#2FCD0F"><b>2FCD0F</b> - INT 2F - LaserPort Interface - EXECUTE FUNCTION</a><br />
<a href="#2FCD21"><b>2FCD21</b> - INT 2F R - InterWave Game API - OPEN GAME DEVICE</a><br />
<a href="#2FCD22"><b>2FCD22</b> - INT 2F R - InterWave Game API - CLOSE GAME DEVICE</a><br />
<a href="#2FCD80"><b>2FCD80</b> - INT 2F RC - InterWave Game API - MIXER SETTINGS CHANGED BROADCAST</a><br />
<a href="#2FCF00"><b>2FCF00</b> - INT 2F - TEMPLEXX 1.0 - INSTALLATION CHECK</a><br />
<a href="#2FD000"><b>2FD000</b> - INT 2F C - MDEBUG display driver - GET DRIVER STATUS</a><br />
<a href="#2FD000_0"><b>2FD000</b> - INT 2F - ZWmous - INSTALLATION CHECK</a><br />
<a href="#2FD000_1"><b>2FD000</b> - INT 2F - Lotus CD/Networker - INSTALLATION CHECK</a><br />
<a href="#2FD001"><b>2FD001</b> - INT 2F C - MDEBUG display driver - INITIALIZE DRIVER</a><br />
<a href="#2FD002"><b>2FD002</b> - INT 2F C - MDEBUG display driver - SAVE GRAPHIC DATA</a><br />
<a href="#2FD002BX4D44"><b>2FD002BX4D44</b> - INT 2F - Multiplex - Lotus CD/Networker GET DATA AREA</a><br />
<a href="#2FD003"><b>2FD003</b> - INT 2F C - MDEBUG display driver - RESTORE GRAPHIC DATA</a><br />
<a href="#2FD004"><b>2FD004</b> - INT 2F - MDEBUG display driver - SHOW SAVED DATA</a><br />
<a href="#2FD005"><b>2FD005</b> - INT 2F - MDEBUG display driver - SWITCH BACK TO TEXT SCREEN</a><br />
<a href="#2FD0"><b>2FD0</b> - INT 2F - MDEBUG display driver - RESERVED FUNCTION NUMBERS</a><br />
<a href="#2FD0_0"><b>2FD0</b> - INT 2F - MDEBUG display driver - USER DEFINED FUNCTION NUMBERS</a><br />
<a href="#2FD100"><b>2FD100</b> - INT 2F C - MDEBUG command driver - GET STATUS</a><br />
<a href="#2FD101"><b>2FD101</b> - INT 2F - MDEBUG command driver - INITIALIZE DRIVER</a><br />
<a href="#2FD102"><b>2FD102</b> - INT 2F - MDEBUG command driver - EXECUTE INTERPRETER COMMAND</a><br />
<a href="#2FD103"><b>2FD103</b> - INT 2F - MDEBUG command driver - EXECUTE KEY IN THE MONITOR</a><br />
<a href="#2FD104"><b>2FD104</b> - INT 2F - MDEBUG command driver - EXECUTE KEY IN THE INTERPRETER</a><br />
<a href="#2FD1"><b>2FD1</b> - INT 2F - MDEBUG command driver - RESERVED FUNCTIONS</a><br />
<a href="#2FD110"><b>2FD110</b> - INT 2F - MDEBUG command driver - GET ADDRESS OF THE OLD INT 2F</a><br />
<a href="#2FD111"><b>2FD111</b> - INT 2F - MDEBUG command driver - START DRIVER</a><br />
<a href="#2FD112"><b>2FD112</b> - INT 2F - MDEBUG command driver - END DRIVER</a><br />
<a href="#2FD1_0"><b>2FD1</b> - INT 2F - MDEBUG command driver - RESERVED FUNCTIONS</a><br />
<a href="#2FD1_1"><b>2FD1</b> - INT 2F - MDEBUG command driver - USER DEFINED FUNCTIONS</a><br />
<a href="#2FD200"><b>2FD200</b> - INT 2F - PCL-838.EXE - INSTALLATION CHECK</a><br />
<a href="#2FD200BX5144"><b>2FD200BX5144</b> - INT 2F - Quarterdeck RPCI - INSTALLATION CHECK</a><br />
<a href="#2FD201"><b>2FD201</b> - INT 2F - PCL-838.EXE - UNINSTALL</a><br />
<a href="#2FD201BX4849"><b>2FD201BX4849</b> - INT 2F - Quarterdeck RPCI - GET QD HIMEM PRESENCE</a><br />
<a href="#2FD201BX4849_0"><b>2FD201BX4849</b> - INT 2F - Quarterdeck RPCI - QEMM/QRAM v5.0+ - GET HIRAM MEMORY CHAIN</a><br />
<a href="#2FD201BX4D41"><b>2FD201BX4D41</b> - INT 2F U - Quarterdeck RPCI - MANIFEST v1.0+ - INSTALLATION CHECK</a><br />
<a href="#2FD201BX4D45"><b>2FD201BX4D45</b> - INT 2F U - Quarterdeck RPCI - DVDOS4GX.DVR - ???</a><br />
<a href="#2FD201BX5145"><b>2FD201BX5145</b> - INT 2F - Quarterdeck RPCI - QEMM v5.0+ - INSTALLATION CHECK</a><br />
<a href="#2FD201BX5649"><b>2FD201BX5649</b> - INT 2F u - Quarterdeck RPCI - VIDRAM v5.0+ - INSTALLATION CHECK</a><br />
<a href="#2FD202"><b>2FD202</b> - INT 2F - PCL-838.EXE - EXECUTE PCL838 COMMANDS</a><br />
<a href="#2FD300BX4562"><b>2FD300BX4562</b> - INT 2F U - TeleReplica - INSTALLATION CHECK</a><br />
<a href="#2FD3CB"><b>2FD3CB</b> - INT 2F U - LapLink Quick Connect v6 - API</a><br />
<a href="#2FD3D3BH00"><b>2FD3D3BH00</b> - INT 2F - KDRIVE v2.x - INSTALLATION CHECK</a><br />
<a href="#2FD44D"><b>2FD44D</b> - INT 2F - 4DOS.COM v2.1+ - API</a><br />
<a href="#2FD44E"><b>2FD44E</b> - INT 2F C - 4DOS v3.0+ - AWAITING USER INPUT</a><br />
<a href="#2FD44FBX0000"><b>2FD44FBX0000</b> - INT 2F - 4DOS v4.0+ - KSTACK.COM - INSTALLATION CHECK</a><br />
<a href="#2FD44FBX0001"><b>2FD44FBX0001</b> - INT 2F - 4DOS v4.0+ - KSTACK.COM - PLACE KEYSTROKES INTO KEYSTACK</a><br />
<a href="#2FD600"><b>2FD600</b> - INT 2F - HEART.COM - INSTALLATION CHECK</a><br />
<a href="#2FD600_0"><b>2FD600</b> - INT 2F U - VEDIT VSWAP - INSTALLATION CHECK</a><br />
<a href="#2FD601"><b>2FD601</b> - INT 2F U - VEDIT VSWAP - ???</a><br />
<a href="#2FD602"><b>2FD602</b> - INT 2F U - VEDIT VSWAP - EXEC PROGRAM WITH SWAP</a><br />
<a href="#2FD701BX0000"><b>2FD701BX0000</b> - INT 2F - Banyan VINES v4+ - GET BANV INTERRUPT NUMBER</a><br />
<a href="#2FD702"><b>2FD702</b> - INT 2F U - Banyan VINES v4+ - PCPRINT interface</a><br />
<a href="#2FD703"><b>2FD703</b> - INT 2F U - Banyan VINES v4+ - MAIL interface</a><br />
<a href="#2FD704"><b>2FD704</b> - INT 2F U - Banyan VINES v4+ - Streettalk Directory Assistance interface</a><br />
<a href="#2FD800"><b>2FD800</b> - INT 2F U - Novell NetWare Lite - CLIENT.EXE - INSTALLATION CHECK</a><br />
<a href="#2FD856"><b>2FD856</b> - INT 2F U - Novell NetWare Lite v1.1 - SERVER - "VNWLSERV_INIT" - GET ???</a><br />
<a href="#2FD880"><b>2FD880</b> - INT 2F U - Novell NetWare Lite v1.0+ - SERVER - INSTALLATION CHECK</a><br />
<a href="#2FD8C0"><b>2FD8C0</b> - INT 2F U - Novell NLCACHE,NWCACHE - INSTALLATION CHECK</a><br />
<a href="#2FDA00"><b>2FDA00</b> - INT 2F - ZyXEL ZFAX v1.x - INSTALLATION CHECK</a><br />
<a href="#2FDA01"><b>2FDA01</b> - INT 2F - ZyXEL ZFAX v1.x - UNINSTALL</a><br />
<a href="#2FDA02"><b>2FDA02</b> - INT 2F - ZyXEL ZFAX v.1x - DISABLE</a><br />
<a href="#2FDA03"><b>2FDA03</b> - INT 2F - ZyXEL ZFAX v1.x - ENABLE</a><br />
<a href="#2FDA55"><b>2FDA55</b> - INT 2F U - TRAP.COM - INSTALLATION CHECK</a><br />
<a href="#2FDAB2"><b>2FDAB2</b> - INT 2F U - Beame&Whiteside BWSNMP - INSTALLATION CHECK</a><br />
<a href="#2FDB00"><b>2FDB00</b> - INT 2F - ZyXEL ZFAX v2+ - INSTALLATION CHECK</a><br />
<a href="#2FDB00_0"><b>2FDB00</b> - INT 2F U - WINGO.COM - INSTALLATION CHECK</a><br />
<a href="#2FDB01"><b>2FDB01</b> - INT 2F - ZyXEL ZFAX v2+ - UNINSTALL</a><br />
<a href="#2FDB01_0"><b>2FDB01</b> - INT 2F U - WINGO.COM - SET CALLBACK FUNCTION POINTER</a><br />
<a href="#2FDB02"><b>2FDB02</b> - INT 2F - ZyXEL ZFAX v2.x - DISABLE</a><br />
<a href="#2FDB02_0"><b>2FDB02</b> - INT 2F U - WINGO.COM - RESET CALLBACK FUNCTION POINTER</a><br />
<a href="#2FDB03"><b>2FDB03</b> - INT 2F - ZyXEL ZFAX v2.x - ENABLE</a><br />
<a href="#2FDB03_0"><b>2FDB03</b> - INT 2F U - WINGO.COM - SET ??? FLAG</a><br />
<a href="#2FDB04"><b>2FDB04</b> - INT 2F U - WINGO.COM - RESET ??? FLAG</a><br />
<a href="#2FDB05"><b>2FDB05</b> - INT 2F U - WINGO.COM - GET ??? FLAG</a><br />
<a href="#2FDB06"><b>2FDB06</b> - INT 2F U - WINGO.COM - CALL CALLBACK FUNCTION</a><br />
<a href="#2FDB10"><b>2FDB10</b> - INT 2F - ZyXEL ZFAX v3+ - EXECUTE ZFAX MAIN MENU</a><br />
<a href="#2FDB11"><b>2FDB11</b> - INT 2F - ZyXEL ZFAX v3+ - SEND FAX</a><br />
<a href="#2FDB12"><b>2FDB12</b> - INT 2F - ZyXEL ZFAX v3+ - PRINT FAX</a><br />
<a href="#2FDB13"><b>2FDB13</b> - INT 2F - ZyXEL ZFAX v3+ - CONVERT FAX</a><br />
<a href="#2FDB14"><b>2FDB14</b> - INT 2F - ZyXEL ZFAX v3+ - VIEW FAX</a><br />
<a href="#2FDB15"><b>2FDB15</b> - INT 2F - ZyXEL ZFAX v4.01 - SEND FAX WITH LOGO AND SIGNATURE</a><br />
<a href="#2FDB16"><b>2FDB16</b> - INT 2F - ZyXEL ZFAX v4.01 - QUOTE PREVIOUS STATUS</a><br />
<a href="#2FDB17"><b>2FDB17</b> - INT 2F - ZyXEL ZFAX v4.01 - BEGIN RECEIVING INCOMING CALL</a><br />
<a href="#2FDB18"><b>2FDB18</b> - INT 2F - ZyXEL ZFAX v4.01 - SCHEDULE CALL</a><br />
<a href="#2FDB20"><b>2FDB20</b> - INT 2F - ZyXEL ZFAX v3+ - POLL FAX</a><br />
<a href="#2FDB21"><b>2FDB21</b> - INT 2F - ZyXEL ZFAX v3+ - SEND VOICE</a><br />
<a href="#2FDB22"><b>2FDB22</b> - INT 2F - ZyXEL ZFAX v3+ - CONVERT VOICE FILE</a><br />
<a href="#2FDB23"><b>2FDB23</b> - INT 2F - ZyXEL ZFAX v3+ - RECORD VOICE FILE</a><br />
<a href="#2FDB24"><b>2FDB24</b> - INT 2F - ZyXEL ZFAX v3+ - PLAY VOICE FILE</a><br />
<a href="#2FDB25"><b>2FDB25</b> - INT 2F - ZyXEL ZFAX v3+ - ANSWER MODEM WITH VOICE SYSTEM</a><br />
<a href="#2FDB26"><b>2FDB26</b> - INT 2F - ZyXEL ZFAX v3+ - DIAL PHONE</a><br />
<a href="#2FDB27"><b>2FDB27</b> - INT 2F - ZyXEL ZFAX v3+ - RECEIVE FAX - ANSWER MODEM AND SET TO FAX MODE</a><br />
<a href="#2FDB28"><b>2FDB28</b> - INT 2F - ZyXEL ZFAX v3+ - RECEIVE FAX DATA - ANSWER MODEM IN MULTI-AUDIO MODE</a><br />
<a href="#2FDB40"><b>2FDB40</b> - INT 2F - ZyXEL ZFAX v3+ - INTERNAL TERMINAL</a><br />
<a href="#2FDB41"><b>2FDB41</b> - INT 2F - ZyXEL ZFAX v3+ - SEND DATA - DIAL NUMBER AND UPLOAD FILE WITH ZMODEM</a><br />
<a href="#2FDC00"><b>2FDC00</b> - INT 2F - GOLD.COM - INSTALLATION CHECK</a><br />
<a href="#2FDC01"><b>2FDC01</b> - INT 2F - GOLD.COM - GET STATE</a><br />
<a href="#2FDC02"><b>2FDC02</b> - INT 2F - GOLD.COM - SET STATE</a><br />
<a href="#2FDD"><b>2FDD</b> - INT 2F - CappaCom programs - API</a><br />
<a href="#2FDD_0"><b>2FDD</b> - INT 2F - MIXFIX.EXE - API</a><br />
<a href="#2FDD--BX7844"><b>2FDD--BX7844</b> - INT 2F - xDISK v3.32+ - INSTALLATION CHECK</a><br />
<a href="#2FDE00BL00"><b>2FDE00BL00</b> - INT 2F U - Novell Netware - RPRINTER, NPRINTER - INSTALLATION CHECK</a><br />
<a href="#2FDE00BX4456"><b>2FDE00BX4456</b> - INT 2F - DESQview v2.26+ External Device Interface - INSTALLATION CHECK</a><br />
<a href="#2FDE01"><b>2FDE01</b> - INT 2F - DESQview v2.26+ External Device Interface - DRIVER CUSTOM SUBFUNCTION</a><br />
<a href="#2FDE01BX4450"><b>2FDE01BX4450</b> - INT 2F U - Quarterdeck QDPMI.SYS v1.0 - INSTALLATION CHECK</a><br />
<a href="#2FDE01BX5242"><b>2FDE01BX5242</b> - INT 2F - DESQview v2.26+ XDI - CUSTOM SUBFUNCTION, Ralf Brown's XDI drivers</a><br />
<a href="#2FDE01BX7474"><b>2FDE01BX7474</b> - INT 2F - DESQview v2.26+ XDI - CUSTOM SUBFUNCTION, DVTXDI.COM</a><br />
<a href="#2FDE01BX7575"><b>2FDE01BX7575</b> - INT 2F - DESQview v2.26+ XDI - CUSTOM SUBFUNCTION, DVSIXDI.COM</a><br />
<a href="#2FDE01BXFFFE"><b>2FDE01BXFFFE</b> - INT 2F U - DESQview v2.26+ XDI - DVXMS.DVR - ???</a><br />
<a href="#2FDE02"><b>2FDE02</b> - INT 2F C - DESQview v2.26+ External Dev Interface - DV INITIALIZATION COMPLETE</a><br />
<a href="#2FDE03"><b>2FDE03</b> - INT 2F C - DESQview v2.26+ External Dev Interface - DV TERMINATION</a><br />
<a href="#2FDE04"><b>2FDE04</b> - INT 2F C - DESQview v2.26+ External Dev Interface - ADD PROCESS</a><br />
<a href="#2FDE05"><b>2FDE05</b> - INT 2F C - DESQview v2.26+ External Dev Interface - REMOVE PROCESS</a><br />
<a href="#2FDE06"><b>2FDE06</b> - INT 2F C - DESQview v2.26+ External Dev Interface - CREATE TASK</a><br />
<a href="#2FDE07"><b>2FDE07</b> - INT 2F C - DESQview v2.26+ External Dev Interface - TERMINATE TASK</a><br />
<a href="#2FDE08"><b>2FDE08</b> - INT 2F C - DESQview v2.26+ External Dev Interface - SAVE STATE</a><br />
<a href="#2FDE09"><b>2FDE09</b> - INT 2F C - DESQview v2.26+ External Dev Interface - RESTORE STATE</a><br />
<a href="#2FDE0A"><b>2FDE0A</b> - INT 2F C - DESQview v2.26+ External Dev Interface - CHANGE KEYBOARD FOCUS</a><br />
<a href="#2FDE0B"><b>2FDE0B</b> - INT 2F C - DESQview v2.26+ External Dev Interface - DVP PROCESSING COMPLETE</a><br />
<a href="#2FDE0C"><b>2FDE0C</b> - INT 2F C - DESQview v2.26+ External Dev Interface - SWAP OUT PROCESS</a><br />
<a href="#2FDE0D"><b>2FDE0D</b> - INT 2F C - DESQview v2.26+ External Dev Interface - SWAP IN PROCESS</a><br />
<a href="#2FDE0E"><b>2FDE0E</b> - INT 2F C - DESQview v2.26+ External Dev Interface - DVP START FAILED</a><br />
<a href="#2FDE0F"><b>2FDE0F</b> - INT 2F C - DESQview v2.50+ External Dev Interface - INITIALIZE DV</a><br />
<a href="#2FDE10"><b>2FDE10</b> - INT 2F C - DESQview v2.50+ External Dev Interface - FREE TASK</a><br />
<a href="#2FDF00"><b>2FDF00</b> - INT 2F - HyperWare programs - INSTALLATION CHECK</a><br />
<a href="#2FDF00BX5445"><b>2FDF00BX5445</b> - INT 2F U - Quarterdeck TELTSR.COM - INSTALLATION CHECK</a><br />
<a href="#2FDF01BX0000"><b>2FDF01BX0000</b> - INT 2F U - MSG.COM - INSTALLATION CHECK</a><br />
<a href="#2FDF01BX4448"><b>2FDF01BX4448</b> - INT 2F - HyperDisk v4.50+ - GET CURRENT CACHE STATE</a><br />
<a href="#2FDF01"><b>2FDF01</b> - INT 2F U - Quarterdeck TELTSR.COM - CLOSE CONNECTION</a><br />
<a href="#2FDF02BX4448"><b>2FDF02BX4448</b> - INT 2F - HyperDisk v4.50+ - SET CACHE STATE</a><br />
<a href="#2FDF02"><b>2FDF02</b> - INT 2F U - Quarterdeck TELTSR.COM - OPEN CONNECTION</a><br />
<a href="#2FE000"><b>2FE000</b> - INT 2F - SETDRVER.COM v2.10+ - INSTALLATION CHECK</a><br />
<a href="#2FE000_0"><b>2FE000</b> - INT 2F - KAOSHIDE - INSTALLATION CHECK</a><br />
<a href="#2FE000DX4D50"><b>2FE000DX4D50</b> - INT 2F - FREEVER v1.0+ - INSTALLATION CHECK</a><br />
<a href="#2FE000DX5354"><b>2FE000DX5354</b> - INT 2F - StuffIt v3.21+ - INSTALLATION CHECK</a><br />
<a href="#2FE001"><b>2FE001</b> - INT 2F - SETDRVER.COM v2.10+ - GET SETDRVER VERSION</a><br />
<a href="#2FE002"><b>2FE002</b> - INT 2F - SETDRVER.COM v2.10+ - GET ORIGINAL DOS VERSION INFO</a><br />
<a href="#2FE003"><b>2FE003</b> - INT 2F - SETDRVER.COM v2.10+ - RESET INTERNAL VARIABLES</a><br />
<a href="#2FE004"><b>2FE004</b> - INT 2F - SETDRVER.COM v2.10+ - ENABLE TSR</a><br />
<a href="#2FE005"><b>2FE005</b> - INT 2F - SETDRVER.COM v2.10+ - DISABLE TSR</a><br />
<a href="#2FE006"><b>2FE006</b> - INT 2F - SETDRVER.COM v2.10+ - GET TSR STATUS</a><br />
<a href="#2FE007"><b>2FE007</b> - INT 2F - SETDRVER.COM v2.10+ - GET TaskMAX STATUS AT INSTALLATION</a><br />
<a href="#2FE0"><b>2FE0</b> - INT 2F - SETDRVER.COM - RESERVED FOR FUTURE USE</a><br />
<a href="#2FE100"><b>2FE100</b> - INT 2F - Phantom2 v1.1+ - INSTALLATION CHECK</a><br />
<a href="#2FE101"><b>2FE101</b> - INT 2F - Phantom2 v1.1+ - FUNCTION REQUEST</a><br />
<a href="#2FE102"><b>2FE102</b> - INT 2F - Phantom2 v1.1+ - UNINSTALL</a><br />
<a href="#2FE103"><b>2FE103</b> - INT 2F - Phantom2 v2.8 - SET ??? FLAG</a><br />
<a href="#2FE200"><b>2FE200</b> - INT 2F - SecureDevice - LOGIN TO DRIVE</a><br />
<a href="#2FE201"><b>2FE201</b> - INT 2F - SecureDevice - GET INFORMATION</a><br />
<a href="#2FE203"><b>2FE203</b> - INT 2F - SecureDevice - DESTROY PASSWORD (LOGOUT FROM DRIVE)</a><br />
<a href="#2FE209DX0000"><b>2FE209DX0000</b> - INT 2F - SecureDevice - INSTALLATION CHECK</a><br />
<a href="#2FE300"><b>2FE300</b> - INT 2F - ANARKEY.COM - INSTALLATION CHECK</a><br />
<a href="#2FE300_0"><b>2FE300</b> - INT 2F - Blank - INSTALLATION CHECK</a><br />
<a href="#2FE301"><b>2FE301</b> - INT 2F U - ANARKEY.COM v2+ - GET ???</a><br />
<a href="#2FE302"><b>2FE302</b> - INT 2F U - ANARKEY.COM v3+ - ???</a><br />
<a href="#2FE303"><b>2FE303</b> - INT 2F U - ANARKEY.COM v3+ - ANARKMD API</a><br />
<a href="#2FE304"><b>2FE304</b> - INT 2F U - ANARKEY.COM v2+ - ???</a><br />
<a href="#2FE305"><b>2FE305</b> - INT 2F U - ANARKEY.COM v3+ - ENABLE/SUSPEND ANARKEY</a><br />
<a href="#2FE306"><b>2FE306</b> - INT 2F U - ANARKEY.COM v4.0 - GET ???</a><br />
<a href="#2FE307"><b>2FE307</b> - INT 2F U - ANARKEY.COM v4.0 - GET ???</a><br />
<a href="#2FE337"><b>2FE337</b> - INT 2F - INT16.COM - INSTALLATION CHECK</a><br />
<a href="#2FE44D"><b>2FE44D</b> - INT 2F - NDOS - API</a><br />
<a href="#2FE44E"><b>2FE44E</b> - INT 2F C - NDOS - AWAITING USER INPUT</a><br />
<a href="#2FE44FBX0000"><b>2FE44FBX0000</b> - INT 2F - NDOS v4.0+ - KSTACK.COM - INSTALLATION CHECK</a><br />
<a href="#2FE44FBX0001"><b>2FE44FBX0001</b> - INT 2F - NDOS v4.0+ - KSTACK.COM - PLACE KEYSTROKES INTO KEYSTACK</a><br />
<a href="#2FE600CL30"><b>2FE600CL30</b> - INT 2F - Virtual 486 - INSTALLATION CHECK</a><br />
<a href="#2FE700BX4158"><b>2FE700BX4158</b> - INT 2F - Multiplex - ??? - INSTALLATION CHECK???</a><br />
<a href="#2FE77EBX0000"><b>2FE77EBX0000</b> - INT 2F - CTDEMN - INSTALLATION CHECK</a><br />
<a href="#2FED00"><b>2FED00</b> - INT 2F - Phar Lap DOS EXTENDERS - INSTALLATION CHECK</a><br />
<a href="#2FED03"><b>2FED03</b> - INT 2F R - Phar Lap 386/DOS-Extender v4.1 - GET EXTENDER ENTRY POINT</a><br />
<a href="#2FED10BL05"><b>2FED10BL05</b> - INT 2F - Pharlap DOS Extender - ???</a><br />
<a href="#2FED11BL05"><b>2FED11BL05</b> - INT 2F - Pharlap DOS Extender - FATAL EXIT TO REAL MODE ???</a><br />
<a href="#2FED58"><b>2FED58</b> - INT 2F U - K5.COM - INSTALLATION CHECK</a><br />
<a href="#2FED80"><b>2FED80</b> - INT 2F - Phar Lap 286|DOS Extender Lite v2.5 - ???</a><br />
<a href="#2FEDC8BX0000"><b>2FEDC8BX0000</b> - INT 2F - Novell DOS 7+ - SECURITY.BIN - INSTALLATION CHECK</a><br />
<a href="#2FEE00"><b>2FEE00</b> - INT 2F - GRIDLOC.EXE - INSTALLATION CHECK</a><br />
<a href="#2FEE00_0"><b>2FEE00</b> - INT 2F - XVIEW - INSTALLATION CHECK</a><br />
<a href="#2FEE00_1"><b>2FEE00</b> - INT 2F - WEB v4.02 - INSTALLATION CHECK</a><br />
<a href="#2FEE01"><b>2FEE01</b> - INT 2F - XVIEW - POP UP GIVING TOPIC SEARCH KEYWORD</a><br />
<a href="#2FEE02"><b>2FEE02</b> - INT 2F - XVIEW - POP UP GIVING A PAGE NUMBER</a><br />
<a href="#2FEE03"><b>2FEE03</b> - INT 2F - XVIEW - POP UP GIVING FILENAME AND SEARCH TOPIC OR PAGE NUMBER</a><br />
<a href="#2FEE04"><b>2FEE04</b> - INT 2F - XVIEW - POP UP AND READ SCREEN FOR SEARCH TOPIC KEYWORD</a><br />
<a href="#2FEE05"><b>2FEE05</b> - INT 2F - XVIEW - POP UP TO MOST-RECENTLY VIEWED PAGE</a><br />
<a href="#2FEE06"><b>2FEE06</b> - INT 2F - XVIEW - WAIT FOR POP-DOWN AND GET EXIT CODE</a><br />
<a href="#2FEE"><b>2FEE</b> - INT 2F - WEB v4.02 - WEB MODULE INSTALLATION CHECK</a><br />
<a href="#2FEEF0"><b>2FEEF0</b> - INT 2F - WEB v4.02 - WEB GENERAL NOTIFICATION</a><br />
<a href="#2FF000"><b>2FF000</b> - INT 2F U - 4MAP - INSTALLATION CHECK</a><br />
<a href="#2FF001"><b>2FF001</b> - INT 2F U - 4MAP - GET KEY MAPPINGS</a><br />
<a href="#2FF002"><b>2FF002</b> - INT 2F U - 4MAP - INSERT CHARACTER INTO ???</a><br />
<a href="#2FF003"><b>2FF003</b> - INT 2F U - 4MAP - INSERT CHARACTER INTO ???</a><br />
<a href="#2FF1"><b>2FF1</b> - INT 2F U - MIN-MEM v2.11 - INSTALLATION CHECK</a><br />
<a href="#2FF100"><b>2FF100</b> - INT 2F - DOS EXTENDER INSTALLATION CHECK</a><br />
<a href="#2FF1_0"><b>2FF1</b> - INT 2F U - RTKernel v4.0 - INSTALLATION CHECK</a><br />
<a href="#2FF200"><b>2FF200</b> - INT 2F - WINX - INSTALLATION CHECK</a><br />
<a href="#2FF201"><b>2FF201</b> - INT 2F - WINX - RETURN ADDRESS OF SERVER BUFFER</a><br />
<a href="#2FF202"><b>2FF202</b> - INT 2F - WINX - SET SERVER'S WORKING DIRECTORY</a><br />
<a href="#2FF203"><b>2FF203</b> - INT 2F - WINX - EXECUTE COMMAND</a><br />
<a href="#2FF400"><b>2FF400</b> - INT 2F - FINDIRQ.COM - INSTALLATION CHECK</a><br />
<a href="#2FF400_0"><b>2FF400</b> - INT 2F - PowerLAN - INSTALLATION CHECK???</a><br />
<a href="#2FF401"><b>2FF401</b> - INT 2F - PowerLAN - GET VERSION</a><br />
<a href="#2FF401CX5121"><b>2FF401CX5121</b> - INT 2F - FINDIRQ.COM - GET HOOKED INTERRUPTS</a><br />
<a href="#2FF483"><b>2FF483</b> - INT 2F - PowerLAN - ???</a><br />
<a href="#2FF700"><b>2FF700</b> - INT 2F - AUTOPARK.COM - INSTALLATION CHECK</a><br />
<a href="#2FF701"><b>2FF701</b> - INT 2F - AUTOPARK.COM - SET PARKING DELAY</a><br />
<a href="#2FF800CX4455"><b>2FF800CX4455</b> - INT 2F U - SuperStor PRO 2XON.COM - INSTALLATION CHECK</a><br />
<a href="#2FF801CX4455"><b>2FF801CX4455</b> - INT 2F U - SuperStor PRO 2XON.COM - UNINSTALL</a><br />
<a href="#2FFA00"><b>2FFA00</b> - INT 2F - Multiplex - ??? - INSTALLATION CHECK???</a><br />
<a href="#2FFA00_0"><b>2FFA00</b> - INT 2F - Multiplex - ??? - INSTALLATION CHECK???</a><br />
<a href="#2FFB"><b>2FFB</b> - INT 2F - Multiplex - RESERVED BY BORLAND INTERNATIONAL</a><br />
<a href="#2FFB_0"><b>2FFB</b> - INT 2F U - Conner Backup Exec AUTORES - API</a><br />
<a href="#2FFB00"><b>2FFB00</b> - INT 2F U - AutoBraille v1.1A - INSTALLATION CHECK</a><br />
<a href="#2FFB00_0"><b>2FFB00</b> - INT 2F U - Jot-It! v1.50 - INSTALLATION CHECK</a><br />
<a href="#2FFB01"><b>2FFB01</b> - INT 2F U - AutoBraille v1.1A - ???</a><br />
<a href="#2FFB01_0"><b>2FFB01</b> - INT 2F U - Jot-It! v1.50 - GET USER NAME</a><br />
<a href="#2FFB02"><b>2FFB02</b> - INT 2F U - AutoBraille v1.1A - ???</a><br />
<a href="#2FFB02_0"><b>2FFB02</b> - INT 2F U - Jot-It! v1.50 - GET MESSAGE DIRECTORY</a><br />
<a href="#2FFB03"><b>2FFB03</b> - INT 2F U - AutoBraille v1.1A - GET NEXT ???</a><br />
<a href="#2FFB03_0"><b>2FFB03</b> - INT 2F U - Jot-It! v1.50 - UNINSTALL</a><br />
<a href="#2FFB_1"><b>2FFB</b> - INT 2F U - AutoBraille v1.1A - SET ???</a><br />
<a href="#2FFB_2"><b>2FFB</b> - INT 2F U - AutoBraille v1.1A - SET ???</a><br />
<a href="#2FFB_3"><b>2FFB</b> - INT 2F U - AutoBraille v1.1A - SET ???</a><br />
<a href="#2FFB20"><b>2FFB20</b> - INT 2F U - AutoBraille v1.1A - SET ??? FLAGS</a><br />
<a href="#2FFB21"><b>2FFB21</b> - INT 2F U - AutoBraille v1.1A - CLEAR ??? FLAGS</a><br />
<a href="#2FFB22"><b>2FFB22</b> - INT 2F U - AutoBraille v1.1A - SET ???</a><br />
<a href="#2FFB28"><b>2FFB28</b> - INT 2F U - AutoBraille v1.1A - ???</a><br />
<a href="#2FFB29"><b>2FFB29</b> - INT 2F U - AutoBraille v1.1A - ???</a><br />
<a href="#2FFB_4"><b>2FFB</b> - INT 2F U - AutoBraille v1.1A - SET ???</a><br />
<a href="#2FFB35"><b>2FFB35</b> - INT 2F U - AutoBraille v1.1A - SET ???</a><br />
<a href="#2FFB36"><b>2FFB36</b> - INT 2F U - AutoBraille v1.1A - SET ???</a><br />
<a href="#2FFB37"><b>2FFB37</b> - INT 2F U - AutoBraille v1.1A - SET ???</a><br />
<a href="#2FFB42BX0001"><b>2FFB42BX0001</b> - INT 2F PU - Borland C++ DPMILOAD.EXE - INSTALLATION CHECK???</a><br />
<a href="#2FFB42BX0002"><b>2FFB42BX0002</b> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ALLOCATE MEMORY</a><br />
<a href="#2FFB42BX0002_0"><b>2FFB42BX0002</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ALLOCATE MEMORY</a><br />
<a href="#2FFB42BX0003"><b>2FFB42BX0003</b> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET AVAILABLE MEMORY</a><br />
<a href="#2FFB42BX0004"><b>2FFB42BX0004</b> - INT 2F PU - Borland C++ DPMILOAD.EXE - LOAD PROTECTED-MODE EXECUTABLE???</a><br />
<a href="#2FFB42BX0005"><b>2FFB42BX0005</b> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NAME</a><br />
<a href="#2FFB42BX0006"><b>2FFB42BX0006</b> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NUMBER</a><br />
<a href="#2FFB42BX0007"><b>2FFB42BX0007</b> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0007_0"><b>2FFB42BX0007</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0008"><b>2FFB42BX0008</b> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - FREE MEMORY BLOCK</a><br />
<a href="#2FFB42BX0008_0"><b>2FFB42BX0008</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE MEMORY BLOCK</a><br />
<a href="#2FFB42BX0009"><b>2FFB42BX0009</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - RESIZE MEMORY BLOCK</a><br />
<a href="#2FFB42BX000A"><b>2FFB42BX000A</b> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INIT DPMI HOST AND SPAWN SUBSHELL</a><br />
<a href="#2FFB42BX000B"><b>2FFB42BX000B</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - UNUSED</a><br />
<a href="#2FFB42BX000C"><b>2FFB42BX000C</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE DESCRIPTORS FOR MEMORY BLOCK???</a><br />
<a href="#2FFB42BX000D"><b>2FFB42BX000D</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SIMULATE REAL MODE INTERRUPT</a><br />
<a href="#2FFB42BX000E"><b>2FFB42BX000E</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???</a><br />
<a href="#2FFB42BX000F"><b>2FFB42BX000F</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - REALLOCATE LDT DESCRPS TO MEMBLK???</a><br />
<a href="#2FFB42BX0010"><b>2FFB42BX0010</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SEGMENT TO SELECTOR</a><br />
<a href="#2FFB42BX0011"><b>2FFB42BX0011</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0012"><b>2FFB42BX0012</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0013"><b>2FFB42BX0013</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0014"><b>2FFB42BX0014</b> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INSTALLATION CHECK</a><br />
<a href="#2FFB42BX0015"><b>2FFB42BX0015</b> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - UNINSTALL</a><br />
<a href="#2FFB42BX0016"><b>2FFB42BX0016</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???</a><br />
<a href="#2FFB42BX0017"><b>2FFB42BX0017</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0018"><b>2FFB42BX0018</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET ???</a><br />
<a href="#2FFB42BX0019"><b>2FFB42BX0019</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX001A"><b>2FFB42BX001A</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX001B"><b>2FFB42BX001B</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX001C"><b>2FFB42BX001C</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX001D"><b>2FFB42BX001D</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???</a><br />
<a href="#2FFB42BX001E"><b>2FFB42BX001E</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX001F"><b>2FFB42BX001F</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???</a><br />
<a href="#2FFB42BX0020"><b>2FFB42BX0020</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION???</a><br />
<a href="#2FFB42BX0021"><b>2FFB42BX0021</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROCESSOR EXCEPTION HANDLER VECT</a><br />
<a href="#2FFB42BX0022"><b>2FFB42BX0022</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROCESSOR EXCEPTION HANDLER VECT</a><br />
<a href="#2FFB42BX0023"><b>2FFB42BX0023</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SELECTOR TO SEGMENT NUMBER</a><br />
<a href="#2FFB42BX0024"><b>2FFB42BX0024</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROTECTED-MODE INTERRUPT VECTOR</a><br />
<a href="#2FFB42BX0025"><b>2FFB42BX0025</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROTECTED-MODE INTERRUPT VECTOR</a><br />
<a href="#2FFB42BX0026"><b>2FFB42BX0026</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0027"><b>2FFB42BX0027</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???</a><br />
<a href="#2FFB42BX0080"><b>2FFB42BX0080</b> - INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE</a><br />
<a href="#2FFB42BX0081"><b>2FFB42BX0081</b> - INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE</a><br />
<a href="#2FFB42BX1001"><b>2FFB42BX1001</b> - INT 2F U - Borland RTM.EXE 1.0 - INSTALLATION CHECK???</a><br />
<a href="#2FFB42BX1002"><b>2FFB42BX1002</b> - INT 2F U - Borland RTM.EXE 1.0 - EXECUTE COMPILED PROGRAM</a><br />
<a href="#2FFB42BX1003"><b>2FFB42BX1003</b> - INT 2F U - Borland RTM.EXE 1.0 - ???</a><br />
<a href="#2FFB43"><b>2FFB43</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION</a><br />
<a href="#2FFB43BX0100"><b>2FFB43BX0100</b> - INT 2F PU - Borland TDX - INSTALLATION CHECK</a><br />
<a href="#2FFB64"><b>2FFB64</b> - INT 2F U - AutoBraille v1.1A - GET ???</a><br />
<a href="#2FFBA1BX0081"><b>2FFBA1BX0081</b> - INT 2F U - TKERNEL (Borland DOS extender) - INSTALLATION CHECK</a><br />
<a href="#2FFBA1BX0082"><b>2FFBA1BX0082</b> - INT 2F U - TKERNEL (Borland DOS extender) - GET ENTRY POINT</a><br />
<a href="#2FFBA1BX0084"><b>2FFBA1BX0084</b> - INT 2F U - TKERNEL (Borland DOS extender) - UNINSTALL</a><br />
<a href="#2FFBFBES0000"><b>2FFBFBES0000</b> - INT 2F U - SoundBlaster speech driver - INSTALLATION CHECK</a><br />
<a href="#2FFD12"><b>2FFD12</b> - INT 2F - KS/KEYSTKCT.EXE - INSTALLATION CHECK</a><br />
<a href="#2FFE00BX4454"><b>2FFE00BX4454</b> - INT 2F - PC-NFS ??? - INSTALLATION CHECK</a><br />
<a href="#2FFE00BX4454_0"><b>2FFE00BX4454</b> - INT 2F - PC-NFS ??? - INSTALLATION CHECK</a><br />
<a href="#2FFE00DI4E55"><b>2FFE00DI4E55</b> - INT 2F U - NORTON UTILITIES 5.0+ TSRs - INSTALLATION CHECK/STATUS REPORT</a><br />
<a href="#2FFE00DX474F"><b>2FFE00DX474F</b> - INT 2F - GO! v3.22+ - API</a><br />
<a href="#2FFE01DI4E55"><b>2FFE01DI4E55</b> - INT 2F U - NORTON UTILITIES 5.0+ TSRs - ENABLE</a><br />
<a href="#2FFE02DI4E55"><b>2FFE02DI4E55</b> - INT 2F U - NORTON UTILITIES 5.0+ TSRs - DISABLE</a><br />
<a href="#2FFE03DI4E55"><b>2FFE03DI4E55</b> - INT 2F U - NORTON UTILITIES 5.0+ TSRs - FLUSH BUFFERS</a><br />
<a href="#2FFE04DI4E55"><b>2FFE04DI4E55</b> - INT 2F U - NORTON UTILITIES 5.0+ DISKMON, FILESAVE / EP - internal - ???</a><br />
<a href="#2FFE05DI4E55"><b>2FFE05DI4E55</b> - INT 2F U - NORTON UTILITIES 5.0+ DISKMON, FILESAVE / EP - internal - ???</a><br />
<a href="#2FFE08"><b>2FFE08</b> - INT 2F - PC-NFS ??? - GET ???</a><br />
<a href="#2FFE10DI4E55"><b>2FFE10DI4E55</b> - INT 2F U - NORTON UTILITIES 6.0 NCACHE - REBOOT</a><br />
<a href="#2FFEEF"><b>2FFEEF</b> - INT 2F - RTS Control TSR - INSTALLATION CHECK</a><br />
<a href="#2FFF00"><b>2FFF00</b> - INT 2F - Topware Network Operating System - INSTALLATION CHECK</a><br />
<a href="#2FFF01"><b>2FFF01</b> - INT 2F - Topware Network Operating System - GET VERSION</a><br />
<a href="#2FFF02"><b>2FFF02</b> - INT 2F - TopWare Network OS v5.10+ - GET TopNet VERSION STRING</a><br />
<a href="#2FFF10"><b>2FFF10</b> - INT 2F - TopWare Network OS v5.10+ - TopTerm - INSTALLATION CHECK</a><br />
<a href="#2FFF11"><b>2FFF11</b> - INT 2F - TopWare Network OS v5.10+ - TopTerm - ENABLE KEYBOARD SERVICE</a><br />
<a href="#2FFF12"><b>2FFF12</b> - INT 2F - TopWare Network OS v5.10+ - TopTerm - DISABLE KEYBOARD SERVICE</a><br />
<a href="#2FFF13"><b>2FFF13</b> - INT 2F - TopWare Network OS v5.10+ - TopTerm - SET INSTALLATION FLAG</a><br />
<a href="#2FFF14"><b>2FFF14</b> - INT 2F - TopWare Network OS v5.10+ - START BACKGROUND RECEIVE VIDEO DATA</a><br />
<a href="#2FFF15"><b>2FFF15</b> - INT 2F - TopWare Network OS v5.10+ - END BACKGROUND RECEIVE VIDEO DATA</a><br />
<a href="#2FFF16"><b>2FFF16</b> - INT 2F - TopWare Network OS v5.10+ - SET CONTROL NUMBER OF "SHOW" SCREEN</a><br />
<a href="#2FFF18"><b>2FFF18</b> - INT 2F - TopWare Network OS v5.10+ - SEND FULL SCREEN OF DATA FOR TopShow</a><br />
<a href="#2FFF23"><b>2FFF23</b> - INT 2F - TopWare Network OS v5.10+ - CLOSE SPOOL FILES AND START PRINTING</a><br />
<a href="#2FFF27"><b>2FFF27</b> - INT 2F - TopWare Network OS v5.10+ - GET "SHOW" TYPE</a><br />

<hr />

<a href="#2F" name="2F"><b>2F</b></a> - INT 2F - Multiplex - NOTES<br />
<pre>
INT 2F - Multiplex - NOTES
	AH = identifier of program which is to handle the interrupt
	   00h-3Fh reserved for IBM (for DOS)
	   40h-7Fh reserved for Microsoft (for DOS)
	   80h-B7h reserved for IBM
	   B8h-BFh reserved for networks
	   C0h-FFh reserved for applications
	AL is the function code
   This is a general mechanism for verifying the presence of a TSR and
   communicating with it.  When searching for a free identifier code for AH
   using the installation check (AL=00h), the calling program should set
   BX/CX/DX to 0000h and must not depend on any registers other than CS:IP
   and SS:SP to be valid on return, since numerous programs now use additional
   registers on input and/or output for the installation check.
Notes:	Since the multiplex chain is growing so long, and beginning to
	  experience multiplex number collisions, I have proposed an alternate
	  multiplex interrupt on INT 2D.  If you decide to use the alternate
	  multiplex, please let me know.
	DOS and some other programs return values in the flags register, so
	  any TSR which chains by calling the previous handler rather than
	  jumping to it should ensure that the returned flags are preserved
	  and passed back to the original caller
SeeAlso: INT 2D"ALTERNATE MULTIPLEX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F_0" name="2F_0"><b>2F</b></a> - INT 2F - BMB Compuscience Canada Utilities Interface - INSTALLATION CHECK<br />
<pre>
INT 2F - BMB Compuscience Canada Utilities Interface - INSTALLATION CHECK
	AH = xx (dynamically assigned based upon a search for a multiplex
		 number which doesn't answer installed)
	AL = 00h installation check
	ES:DI = EBEBh:BEBEh
Return: AL = 00h not installed
	     01h not installed, not OK to install
	     FFh installed; if ES:DI was EBEBh:BEBEh on entry, ES:DI will point
		 to a string of the form 'MMMMPPPPPPPPvNNNN' where MMMM is a
		 short form of the manufacturer's name, PPPPPPPP is a product
		 name and NNNN is the product's version number

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F_1" name="2F_1"><b>2F</b></a> - INT 2F - Ross Wentworth's Turbo Pascal POPUP LIBRARY<br />
<pre>
INT 2F - Ross Wentworth's Turbo Pascal POPUP LIBRARY
	AH = programmer-selected multiplex number
	AL = function
	    00h installation check
		Return: AL = FFh if installed
	    01h get TSR interrupt vectors
		Return: DX:AX -&gt; vector table (see #02587)
	    02h get TSR code segment
		Return: AX = code segment for all interrupt handlers
	    03h call user exit routine and release TSR's memory
	    04h get signature string
		Return: DX:AX -&gt; counted string containing signature
	    05h get TSR's INT 2F handler
		Return: DX:AX -&gt; INT 2F handler
	    06h enable/disable TSR
		BL = new state (00h disabled, 01h enabled)
	    07h activate TSR (popup if not disabled)
	    08h get hotkeys
		BL = which hotkey (00h = hotkey 1, 01h = hotkey 2)
		Return: AX = hotkey (AH = keyflags, AL = scancode)
	    09h set hotkey
		BL = which hotkey (00h = hotkey 1, 01h = hotkey 2)
		CX = new hotkey (CH = keyflags, CL = scancode)
	    0Ah-1Fh reserved
Index:	installation check;Ross Wentworth POPUP library
Index:	hotkeys;Ross Wentworth POPUP library

Format of POPUP vector table entry:
Offset	Size	Description	(Table 02587)
 00h	BYTE	vector number (00h = end of table)
 01h	DWORD	original vector
 05h	WORD	offset of interrupt handler in TSR's code segment

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F_2" name="2F_2"><b>2F</b></a> - INT 2F - CiriSOFT Spanish University of Valladolid TSR's Interface<br />
<pre>
INT 2F - CiriSOFT Spanish University of Valladolid TSR's Interface
	AH = xx (dynamically assigned based upon a search for a multiplex
		 number from C0h to FFh which doesn't answer installed)
	AL = 00h installation check
	ES:DI = 1492h:1992h
Return: AL = 00h not installed
	     01h not installed, not OK to install
	     FFh installed; and if ES:DI was 1492h:1992h on entry, ES:DI will
		   point to author_name_ver table (see #02588)
	AH = FFh
Note:	this interface permits advanced communication with TSRs: it is possible
	  to make a generic uninstall utility, advanced TSR relocator programs
	  in order to fit fragmented memory areas, etc.
See also: INT 2D"AMIS",INT 2F"Compuscience"
Index:	installation check;CiriSOFT TSR interface
Index:	uninstall;CiriSOFT TSR interface

Format of CiriSOFT author_name_ver table:
Offset	Size	Description	(Table 02588)
 -16	WORD	segment of the start of the resident TSR code (CS in programs
		  with PSP, XMS upper memory segment if installed as UMB...)
 -14	WORD	offset of the start of the resident TSR code (frequently 100h
		  in *.COM programs and 0 in upper memory TSR's).
 -12	WORD	memory used by TSR (in paragraphs). Knowing the memory area
		  used by TSR is possible to determine if hooked vectors are
		  still pointing it (and if it is safe to uninstall).
 -10	BYTE	characteristics byte (see #02589)
 -9	BYTE	number of multiplex entry used (redefinition available). Note
		  that the TSR must use THIS variable in it's INT 2Fh handler.
 -8	WORD	offset to vector_area table (see #02590)
 -6	WORD	offset to extra_area table (see #02591,#02589 [bit 7])
 -4   4 BYTEs	signature string "*##*"
 00h	var	"AUTHOR:PROGRAM_NAME:VERSION",0	 (variable length, this area
		  is used in order to determine if the TSR is already resident
		  and it's version code; the ':' char is used as delimiter)

Bitfields for CiriSOFT characteristics byte:
Bit(s)	Description	(Table 02589)
 0-2	type
	000 normal program (with PSP)
	001 upper XMS memory block (needed HIMEM.SYS function to free memory
	      when uninstalling)
	010 device driver (*.SYS)
	011 device driver in EXE format
	1xx others (reserved)
 3-6	reserved
 7	set if extra_table defined and supported (see #02591)
SeeAlso: #02588

Format of CiriSOFT vector_area table:
Offset	Size	Description	(Table 02590)
 -1	BYTE	number of vectors intercepted by TSR
 00h	BYTE	first vector number
 01h	DWORD	first vector pointer before installing the TSR
 05h	BYTE	second vector number
 06h	DWORD	second vector pointer before installing the TSR
 0Ah	...	(and so on)
Note:	the TSR must use these variables to invoke the previous interrupt
	  handler routines
SeeAlso: #02588

Format of extra_area table (needed only to improve relocation feature):
Offset	Size	Description	(Table 02591)
 00h	WORD	offset to external_ctrl table (see #02592)
		0000h if not supported
 02h	WORD	reserved for future use (0)
SeeAlso: #02588

Format of CiriSOFT external_ctrl table:
Offset	Size	Description	(Table 02592)
 00h	BYTE	bit 0: TSR is relocatable (no absolute segment references)
 01h	WORD	offset to a variable which can activate/inhibit the TSR
 ---And if bit 0 in offset 00h is off:
 03h	DWORD	pointer to ASCIZ pathname for executable file which supports
		  /SR parameter (silent installation & inhibit)
 07h	DWORD	pointer to first variable to initialize on the copy reloaded
		  from the previous TSR still resident
 0Bh	DWORD	pointer to last variable (all variables packed in one block)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F00" name="2F00"><b>2F00</b></a> - INT 2F U - DOS 2.x only PRINT.COM - SUBMIT FILE FOR PRINTING<br />
<pre>
INT 2F U - DOS 2.x only PRINT.COM - SUBMIT FILE FOR PRINTING
	AH = 00h
	DS:DX -&gt; opened FCB (see #01345 at INT 21/AX=0Fh)
Return: AH = number of files currently in print queue
	AL = status
	    00h file successfully added
	    01h queue is full
	ES:BX -&gt; print queue (10 FCBs; first byte of FFh indicates unused)
	ES:DX -&gt; currently-printing FCB (if DX=FFFFh, none printing)
Notes:	DOS 2.x PRINT.COM does not chain to previous INT 2F handler
	values in AH other than 00h or 01h cause PRINT to return the number of
	  files in the queue in AH
SeeAlso: AH=01h"PRINT",AX=0102h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F00_0" name="2F00_0"><b>2F00</b></a> - INT 2F U - PSPRINT - PRINT JOB CONTROL<br />
<pre>
INT 2F U - PSPRINT - PRINT JOB CONTROL
	AH = 00h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0080" name="2F0080"><b>2F0080</b></a> - INT 2F - DOS 3.1+ PRINT - GIVE PRINT A TIME SLICE<br />
<pre>
INT 2F - DOS 3.1+ PRINT - GIVE PRINT A TIME SLICE
	AX = 0080h
Return: after PRINT executes
Notes:	PRINT returns AL=01h if AH=00h but AL is not 80h on entry
	this function is not supported by the Novell DOS 7 PRINT.COM

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F00D8" name="2F00D8"><b>2F00D8</b></a> - INT 2F - Personal NetWare - VLM - ???<br />
<pre>
INT 2F - Personal NetWare - VLM - ???
	AX = 00D8h
	???
Return: ???
Note:	hooked by one of the .VLMs loaded by VLM.EXE v1.10, but apparently a
	  NOP

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F01" name="2F01"><b>2F01</b></a> - INT 2F U - DOS 2.x only PRINT.COM - REMOVE FILE FROM PRINT QUEUE<br />
<pre>
INT 2F U - DOS 2.x only PRINT.COM - REMOVE FILE FROM PRINT QUEUE
	AH = 01h
	DS:DX -&gt; FCB (see #01345 at INT 21/AH=0Fh) for file to be canceled
Return: AH = number of files currently in print queue
	AL = 00h (successful)
	ES:BX -&gt; print queue (10 FCBs; first byte of FFh indicates unused)
	ES:DX -&gt; currently-printing FCB (if DX=FFFFh, none printing)
Notes:	DOS 2.x PRINT.COM does not chain to previous INT 2F handler
	values in AH other than 00h or 01h cause PRINT to return the number of
	  files in the queue in AH
SeeAlso: AH=00h"PRINT.COM",AX=0103h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0100" name="2F0100"><b>2F0100</b></a> - INT 2F - DOS 3.0+ PRINT - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS 3.0+ PRINT - INSTALLATION CHECK
	AX = 0100h
Return: AL = status
	    00h not installed
	    01h not installed, but not OK to install
	    FFh installed
		AH = 00h (Novell DOS 7)
SeeAlso: AX=0101h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0100SI20D6" name="2F0100SI20D6"><b>2F0100SI20D6</b></a> - INT 2F U - PrintCache 3.1 PRINT.COM - INSTALLATION CHECK<br />
<pre>
INT 2F U - PrintCache 3.1 PRINT.COM - INSTALLATION CHECK
	AX = 0100h
	SI = 20D6h
	DI = 8761h
Return: AX = 00FFh if installed
	DI = 0001h if PrintCache's PRINT.COM installed and magic values match
	    SI = resident code segment
Program: PrintCache PRINT.COM is a DOS PRINT replacement included in
	  LaserTools' PrintCache memory/disk-based print spooler package
Note:	if either of SI or DI differ from the indicated magic values, only AX
	  will be modified on return, for compatibility with DOS PRINT
SeeAlso: AX=0101h/SI=20D6h,AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0101" name="2F0101"><b>2F0101</b></a> - INT 2F - DOS 3.0+ PRINT - SUBMIT FILE FOR PRINTING<br />
<pre>
INT 2F - DOS 3.0+ PRINT - SUBMIT FILE FOR PRINTING
	AX = 0101h
	DS:DX -&gt; submit packet (see #02593)
Return: CF clear if successful
	    AL = status
		01h added to queue
		9Eh now printing
	CF set on error
	    AX = error code (see #02594,#01680 at INT 21/AH=59h/BX=0000h)
SeeAlso: AX=0102h

Format of PRINT submit packet:
Offset	Size	Description	(Table 02593)
 00h	BYTE	level (must be 00h)
 01h	DWORD	pointer to ASCIZ filename (no wildcards)

(Table 02594)
Values for PRINT error code:
 0001h	invalid function
 0002h	file not found
 0003h	path not found
 0004h	out of file handles
 0005h	access denied
 0008h	print queue full
 0009h	spooler busy
 000Ch	name too long
 000Fh	invalid drive

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0101SI20D6" name="2F0101SI20D6"><b>2F0101SI20D6</b></a> - INT 2F U - PrintCache v3.1 PRINT.COM - SUBMIT FILE FOR PRINTING<br />
<pre>
INT 2F U - PrintCache v3.1 PRINT.COM - SUBMIT FILE FOR PRINTING
	AX = 0101h
	SI = 20D6h
	DI = 8761h
	DS:DX -&gt; submit packet (see #02593)
	CL = print options
	    bit 4: use default options
Return: CF clear if successful
	    AL = status
		01h added to queue
		9Eh now printing
	CF set on error
	    AX = error code (see #02594)
Program: PrintCache PRINT.COM is a DOS PRINT replacement included in
	  LaserTools' PrintCache memory/disk-based print spooler package
Note:	if either SI or DI differs from the indicated magic values on entry,
	  PrintCache will use the default print options for the file for
	  compatibility with DOS PRINT
SeeAlso: AX=0100h/SI=20D6h,AX=0101h,AH=00h"PRINT",AX=0107h"PrintCache"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0102" name="2F0102"><b>2F0102</b></a> - INT 2F - DOS 3.0+ PRINT - REMOVE FILE FROM PRINT QUEUE<br />
<pre>
INT 2F - DOS 3.0+ PRINT - REMOVE FILE FROM PRINT QUEUE
	AX = 0102h
	DS:DX -&gt; ASCIZ filename (wildcards allowed)
Return: CF clear if successful
	CF set on error
	    AX = error code (see #02594)
SeeAlso: AX=0101h,AX=0103h,AH=01h"PRINT"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0103" name="2F0103"><b>2F0103</b></a> - INT 2F - DOS 3.0+ PRINT - CANCEL ALL FILES IN PRINT QUEUE<br />
<pre>
INT 2F - DOS 3.0+ PRINT - CANCEL ALL FILES IN PRINT QUEUE
	AX = 0103h
Return: CF clear if successful
	CF set on error
	    AX = error code (see #02594)
SeeAlso: AX=0102h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0104" name="2F0104"><b>2F0104</b></a> - INT 2F - DOS 3.0+ PRINT - FREEZE PRINT QUEUE TO READ JOB STATUS<br />
<pre>
INT 2F - DOS 3.0+ PRINT - FREEZE PRINT QUEUE TO READ JOB STATUS
	AX = 0104h
Return: CF clear if successful
	    DX = error count since status last read
	    DS:SI -&gt; print queue
	CF set on error
	    AX = error code (see #02594)
Desc:	get the list of print jobs, temporarily suspending PRINT's activities
	  to avoid changing the list while it is being examined
Notes:	the print queue is an array of 64-byte ASCIZ filenames terminated by
	  an empty filename; the first name is the file currently being printed
	printing is stopped until AX=0105h is called to prevent the queue
	  from changing while the filenames are being read
SeeAlso: AX=0101h,AX=0105h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0105" name="2F0105"><b>2F0105</b></a> - INT 2F - DOS 3.0+ PRINT - RESTART PRINT QUEUE AFTER STATUS READ<br />
<pre>
INT 2F - DOS 3.0+ PRINT - RESTART PRINT QUEUE AFTER STATUS READ
	AX = 0105h
Return: CF clear if successful
	CF set on error
	    AX = error code (see #02594)
Desc:	restart PRINT's activities once an application finishes examining the
	  print queue
SeeAlso: AX=0104h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0106" name="2F0106"><b>2F0106</b></a> - INT 2F - DOS 3.3+ PRINT - GET PRINTER DEVICE<br />
<pre>
INT 2F - DOS 3.3+ PRINT - GET PRINTER DEVICE
	AX = 0106h
Return: CF set if files in print queue
	    AX = error code 0008h (queue full)
	    DS:SI -&gt; device driver header (see #01646)
	CF clear if print queue empty
	    AX = 0000h
Desc:	determine which device, if any, PRINT is currently using for output
Notes:	undocumented prior to the release of MS-DOS 5.0
	this function can be used to allow a program to avoid printing to the
	  printer on which PRINT is currently performing output
SeeAlso: AX=0104h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0107" name="2F0107"><b>2F0107</b></a> - INT 2F U - PrintCache v3.1 PRINT.COM - SET TRAILING FORM FEEDS<br />
<pre>
INT 2F U - PrintCache v3.1 PRINT.COM - SET TRAILING FORM FEEDS
	AX = 0107h
	CL bit 0: output form feed between print jobs
Return: AL destroyed
SeeAlso: AX=0100h/SI=20D6h,AX=0101h/SI=20D6h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0200" name="2F0200"><b>2F0200</b></a> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - INSTALLATION CHECK<br />
<pre>
INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - INSTALLATION CHECK
	AX = 0200h
Return: AL = FFh if installed
Desc:	determine whether the PC LAN Program redirector is installed
SeeAlso: AX=0201h,AX=0203h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0201" name="2F0201"><b>2F0201</b></a> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???<br />
<pre>
INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???
	AX = 0201h
Return: nothing???
Notes:	this function is called by the DOS 3.3+ PRINT.COM
	AX=0202h appears to be the opposite function
	these functions are supposedly used to signal opening and closing of
	  printers
SeeAlso: AX=0202h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0202" name="2F0202"><b>2F0202</b></a> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???<br />
<pre>
INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???
	AX = 0202h
	???
Return: nothing???
Notes:	this function is called by the DOS 3.3+ PRINT.COM
	these functions are supposedly used to signal opening and closing of
	  printers
SeeAlso: AX=0201h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0203" name="2F0203"><b>2F0203</b></a> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???<br />
<pre>
INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???
	AX = 0203h
Return: nothing???
Notes:	this function is called by the DOS 3.3+ PRINT.COM
	AX=0204h appears to be the opposite function
	these functions are supposedly used to signal opening and closing of
	  printers
SeeAlso: AX=0200h,AX=0204h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0204" name="2F0204"><b>2F0204</b></a> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???<br />
<pre>
INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???
	AX = 0204h
	???
Return: nothing???
Notes:	this function is called by the DOS 3.3+ PRINT.COM
	AX=0203h appears to be the opposite function
	these functions are supposedly used to signal opening and closing of
	  printers
SeeAlso: AX=0200h,AX=0203h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F_3" name="2F_3"><b>2F</b></a> - INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???<br />
<pre>
INT 2F U - PC LAN PROGRAM REDIR/REDIRIFS internal - ???
	AX = 02xxh
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0500" name="2F0500"><b>2F0500</b></a> - INT 2F U - DOS 3.0+ CRITICAL ERROR HANDLER - INSTALLATION CHECK<br />
<pre>
INT 2F U - DOS 3.0+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
	AX = 0500h
Return: AL = status
	    00h not installed, OK to install
	    01h not installed, can't install
	    FFh installed
	BX destroyed (MSCDEX v2.21-2.25)
	CF clear (MSCDEX v2.21-2.25)
Desc:	determine whether a critical error message override is installed
Note:	this set of functions allows a user program to partially or completely
	  override the default critical error handler's message in COMMAND.COM
SeeAlso: AH=05h,INT 24

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F05" name="2F05"><b>2F05</b></a> - INT 2F CU - DOS 3.0+ CRITICAL ERROR HANDLER - EXPAND ERROR INTO STRING<br />
<pre>
INT 2F CU - DOS 3.0+ CRITICAL ERROR HANDLER - EXPAND ERROR INTO STRING
	AH = 05h
---DOS 3.x---
	AL = extended error code (not zero)
---DOS 4.0+ ---
	AL = error type
	    01h DOS extended error code
	    02h parameter error
	BX = error code
Return: CF clear if successful
	    ES:DI -&gt; ASCIZ error message (read-only)
	    AL = completion state
		00h message requires completion with device name, drive, etc.
		01h message is complete as returned
	CF set if error code can't be converted to string
	    AX,DI,ES destroyed
	other flags corrupted
Notes:	called at start of COMMAND.COM's default critical error handler if
	  installed by a user program, allowing partial or complete overriding
	  of the default error messages
	subfunction 02h is called by many DOS 4 external programs
	DR DOS's COMMAND.COM appends additional info ("0 files copied") to the
	  returned string
SeeAlso: AX=0500h,AX=122Eh,INT 24

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0600" name="2F0600"><b>2F0600</b></a> - INT 2F - DOS 3.0+ ASSIGN - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS 3.0+ ASSIGN - INSTALLATION CHECK
	AX = 0600h
Return: AL = status
	    00h not installed
	    01h not installed, but not OK to install
	    FFh installed
Notes:	ASSIGN is not a TSR in DR DOS 5.0; it is internally replaced by SUBST
	  (see INT 21/AH=52h)
	undocumented prior to the release of DOS 5.0
SeeAlso: AX=0601h,INT 21/AH=52h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0601" name="2F0601"><b>2F0601</b></a> - INT 2F U - DOS 3.0+ ASSIGN - GET DRIVE ASSIGNMENT TABLE<br />
<pre>
INT 2F U - DOS 3.0+ ASSIGN - GET DRIVE ASSIGNMENT TABLE
	AX = 0601h
Return: ES = segment of ASSIGN work area and assignment table
Note:	the 26 bytes starting at ES:0103h specify which drive each of A: to Z:
	  is mapped to.	 Initially set to 01h 02h 03h....
SeeAlso: AX=0600h,AX=AF14h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0800" name="2F0800"><b>2F0800</b></a> - INT 2F U - DRIVER.SYS support - INSTALLATION CHECK<br />
<pre>
INT 2F U - DRIVER.SYS support - INSTALLATION CHECK
	AX = 0800h
Return: AL = status
	    00h not installed, OK to install
	    01h not installed, not OK to install
	    FFh installed
Desc:	determine whether the internal support code used by DRIVER.SYS is
	  present; it is always present in DOS 3.2+
Note:	supported by DR DOS 5.0 and Novell DOS 7

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0801" name="2F0801"><b>2F0801</b></a> - INT 2F U - DRIVER.SYS support - ADD NEW BLOCK DEVICE<br />
<pre>
INT 2F U - DRIVER.SYS support - ADD NEW BLOCK DEVICE
	AX = 0801h
	DS:DI -&gt; drive data table (see #02601,#02602,#02603)
Return: AX,BX,SI,ES destroyed
Notes:	moves down internal list of drive data tables, copying and modifying
	  the drive description flags word for tables referencing same physical
	  drive
	the data table is appended to the chain of tables
	supported by DR DOS 5.0 and Novell DOS 7
SeeAlso: AX=0803h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0802" name="2F0802"><b>2F0802</b></a> - INT 2F U - DRIVER.SYS support - EXECUTE DEVICE DRIVER REQUEST<br />
<pre>
INT 2F U - DRIVER.SYS support - EXECUTE DEVICE DRIVER REQUEST
	AX = 0802h
	ES:BX -&gt; device driver request header (see #02597)
Return: request header updated as per requested operation
	STACK:	WORD	original flags from INT call (left by RETF in device
			  driver, at least in DOS 5.0-6.22)
Notes:	supported by DR DOS 5.0
	DOS 3.2 executes this function on any AL value from 02h through F7h;
	  DOS 4.0+ executes this function on AL=02h and AL=04h-F7h
	the command codes (see #02595) and structures described below apply
	  to all drivers which support the appropriate commands; this call is
	  just one of a number of ways in which a device driver request may
	  be invoked
	supported by Novell DOS 7
SeeAlso: AX=0800h,AX=0801h,AX=0803h,AX=1510h,INT 21/AH=52h,INT 21/AH=99h
SeeAlso: INT 21/AH=9Ah

(Table 02595)
Values for device driver command code:
 00h (0)  INIT
 01h (1)  MEDIA CHECK (block devices)
 02h (2)  BUILD BPB (block devices)
 03h (3)  IOCTL INPUT
 04h (4)  INPUT
 05h (5)  NONDESTRUCTIVE INPUT, NO WAIT (character devices)
 06h (6)  INPUT STATUS (character devices)
 07h (7)  INPUT FLUSH (character devices)
 08h (8)  OUTPUT
 09h (9)  OUTPUT WITH VERIFY
 0Ah (10) OUTPUT STATUS (character devices)
 0Bh (11) OUTPUT FLUSH (character devices)
 0Ch (12) IOCTL OUTPUT
 0Dh (13) (DOS 3.0+) DEVICE OPEN
 0Eh (14) (DOS 3.0+) DEVICE CLOSE
 0Fh (15) (DOS 3.0+) REMOVABLE MEDIA (block devices)
 10h (16) (DOS 3.0+) OUTPUT UNTIL BUSY (character devices)
 11h (17) (European MS-DOS 4.0) STOP OUTPUT (console screen drivers only)
 12h (18) (European MS-DOS 4.0) RESTART OUTPUT (console screen drivers only)
 13h (19) (DOS 3.2+) GENERIC IOCTL
 14h (20) (DOS 4.0, KKCFUNC) DEVICE RESTORE (character device)
 15h (21) (European MS-DOS 4.0) RESET UNCERTAIN MEDIA FLAG
 16h (22) (DOS 4.0) unknown???
 17h (23) (DOS 3.2+) GET LOGICAL DEVICE
 18h (24) (DOS 3.2+) SET LOGICAL DEVICE
 19h (25) (DOS 5.0+) CHECK GENERIC IOCTL SUPPORT
 80h (128)(CD-ROM,DRFAT32) READ LONG
 81h (129)(CD-ROM) reserved
 82h (130)(CD-ROM,DRFAT32) READ LONG PREFETCH
 83h (131)(CD-ROM,DRFAT32) SEEK
 84h (132)(CD-ROM) PLAY AUDIO
 85h (133)(CD-ROM) STOP AUDIO
 86h (134)(CD-ROM,DRFAT32) WRITE LONG
 87h (135)(CD-ROM,DRFAT32) WRITE LONG VERIFY
 88h (136)(CD-ROM) RESUME AUDIO

Bitfields for device request status:
Bit(s)	Description	(Table 02596)
 15	error
 14-11	reserved
 10	??? set by DOS kernel on entry to some driver calls
 9	busy
 8	done (may be clear on return under European MS-DOS 4.0)
 7-0	error code if bit 15 set (see #02598)

Format of device driver request header:
Offset	Size	Description	(Table 02597)
 00h	BYTE	length of request header
 01h	BYTE	subunit within device driver
 02h	BYTE	command code (see #02595)
 03h	WORD	status (filled in by device driver) (see #02596)
---DOS---
 05h  4 BYTEs	reserved (unused in DOS 2.x and 3.x)
 09h	DWORD	(European MS-DOS 4.0 only) pointer to next request header in
			  device's request queue
		(other versions) reserved (unused in DOS 2.x and 3.x)
---STARLITE architecture---
 05h	DWORD	pointer to next request header
 09h  4 BYTEs	reserved
---command code 00h---
 0Dh	BYTE	(ret) number of units
 0Eh	DWORD	(call) pointer to DOS device helper function (see #02599)
			  (European MS-DOS 4.0 only)
		(call) pointer past end of memory available to driver (DOS 5+)
		(ret) address of first free byte following driver
 12h	DWORD	(call) pointer to commandline arguments
		(ret) pointer to BPB array (block drivers) or
			  0000h:0000h (character drivers)
 16h	BYTE	(DOS 3.0+) drive number for first unit of block driver (0=A)
   ---European MS-DOS 4.0---
 17h	DWORD	pointer to function to save registers on stack
   ---DOS 5+ ---
 17h	WORD	(ret) error-message flag
		0001h MS-DOS should display error msg on init failure
---command code 01h---
 0Dh	BYTE	media descriptor
 0Eh	BYTE	(ret) media status
		00h don't know
		01h media has not changed
		FFh media has been changed
 0Fh	DWORD	(ret, DOS 3.0+) pointer to previous volume ID if the
		  OPEN/CLOSE/RM bit in device header is set and disk changed
		Note:	some drives (or controllers???) forget the change line
			  status if another drive is accessed afterwards. The
			  DOS IO.SYS layer takes care of this by not relying
			  on the reported change line status when the change 
			  line is not active and a different drive is accessed,
			  instead it reports "don't know" to the DOS kernel.
---command code 02h---
 0Dh	BYTE	media descriptor
 0Eh	DWORD	transfer address
		-&gt; scratch sector if NON-IBM FORMAT bit in device header set
		-&gt; first FAT sector otherwise
 12h	DWORD	pointer to BPB (set by driver) (see #01663 at INT 21/AH=53h)
---command codes 03h,0Ch---
		  (see also INT 21/AX=4402h"DOS 2+",INT 21/AX=4403h"DOS")
 0Dh	BYTE	media descriptor (block devices only)
 0Eh	DWORD	transfer address
 12h	WORD	(call) number of bytes to read/write
		(ret) actual number of bytes read or written
---command codes 04h,08h,09h (except Compaq DOS 3.31, DR DOS 6)---
 0Dh	BYTE	media descriptor (block devices only)
 0Eh	DWORD	transfer address
 12h	WORD	byte count (character devices) or sector count (block devices)
 14h	WORD	starting sector number (block devices only)
 16h	DWORD	(DOS 3.0+) pointer to volume ID if error 0Fh returned
 1Ah	DWORD	(DOS 4.0+) 32-bit starting sector number (block devices with
		  device attribute word bit 1 set only) if starting sector
		  number above is FFFFh (see INT 21/AH=52h)
---command codes 04h,08h,09h (Compaq DOS 3.31, DR DOS 6)---
 0Dh	BYTE	media descriptor (block devices only)
 0Eh	DWORD	transfer address
 12h	WORD	byte count (character devices) or sector count (block devices)
 14h	DWORD	32-bit starting sector number (block devices only)
	Note:	to reliably determine which variant of the request block for
		  functions 04h,08h,09h has been passed to the driver, check
		  the length field as well as the word at offset 14h.  If the
		  length is 1Eh and 14h=FFFFh, use the DWORD at 1Ah as the
		  starting sector number; if the length is 18h, use the DWORD
		  at 14h; otherwise, use the WORD at 14h.
---command code 05h---
 0Dh	BYTE	byte read from device if BUSY bit clear on return
---command codes 06h,07h,0Ah,0Bh,0Dh,0Eh,0Fh---
 no further fields
---command code 10h---
 0Dh	BYTE	unused
 0Eh	DWORD	transfer address
 12h	WORD	(call) number of bytes to write
		(ret) actual number of bytes written
---command codes 11h,12h---
 0Dh	BYTE	reserved
---command code 14h---
 no further fields
	Note:	This is at least true for KKCFUNC.SYS' "device restore".
		  KKCFUNC.SYS checks that INT 2Fh in the IVT still points
		  to KKCFUNC's own INT 2Fh entry point.	 In this case it
		  restores the original INT 2Fh vector, as recorded at device
		  init, into the IVT.
	SeeAlso: INT 2F/AH=4Dh
---command code 15h---
 no further fields
---command codes 13h,19h---
 0Dh	BYTE	category code
		00h-7Fh reserved for Microsoft
		00h unknown
		01h COMn: (serial) (DOS 3.3+)
		02h reserved for terminal control
		03h CON (DOS 3.3+)
		04h reserved for keyboard control
		05h LPTn:
		07h mouse (European MS-DOS 4.0)
		08h disk
		48h FAT32 disk control (MS-DOS 7.10+)
		80h-FFh reserved for OEM/user-defined
		9Eh (STARLITE) Media Access Control driver
		EDh (DR PalmDOS) login security
		SeeAlso: #01558
 0Eh	BYTE	function code
		00h (STARLITE) MAC Bind request
 0Fh	WORD	copy of DS at time of IOCTL call (apparently unused in DOS 3.3)
		SI contents (European MS-DOS 4.0)
 11h	WORD	offset of device driver header (see #01646)
		DI contents (European MS-DOS 4.0)
 13h	DWORD	pointer to parameter block from INT 21/AX=440Ch or AX=440Dh
---command codes 80h,82h---
 0Dh	BYTE	addressing mode
		00h HSG (default)
		01h Phillips/Sony Red Book
 0Eh	DWORD	transfer address (ignored for command 82h)
 12h	WORD	number of sectors to read
		(if 0 for command 82h, request is an advisory seek)
 14h	DWORD	starting sector number
		logical sector number in HSG mode
		frame/second/minute/unused in Red Book mode
		(HSG sector = minute * 4500 + second * 75 + frame - 150)
 18h	BYTE	data read mode
		00h cooked (2048 bytes per frame)
		01h raw (2352 bytes per frame, including EDC/ECC)
 19h	BYTE	interleave size (number of sectors stored consecutively)
 1Ah	BYTE	interleave skip factor
		(number of sectors between consecutive portions)
---command code 83h---
 0Dh	BYTE	addressing mode
		00h HSG (default)
		01h Phillips/Sony Red Book
 0Eh	DWORD	transfer address (ignored)
 12h	WORD	number of sectors to read (ignored)
 14h	DWORD	starting sector number (see also above)
---command code 84h---
 0Dh	BYTE	addressing mode
		00h HSG (default)
		01h Phillips/Sony Red Book
 0Eh	DWORD	starting sector number (see also above)
 12h	DWORD	number of sectors to play
---command codes 85h,88h---
 no further fields
---command codes 86h,87h---
 0Dh	BYTE	addressing mode
		00h HSG (default)
		01h Phillips/Sony Red Book
 0Eh	DWORD	transfer address (ignored in write mode 0)
 12h	WORD	number of sectors to write
 14h	DWORD	starting sector number (also see above)
 18h	BYTE	write mode
		00h mode 0 (write all zeros)
		01h mode 1 (default) (2048 bytes per sector)
		02h mode 2 form 1 (2048 bytes per sector)
		03h mode 2 form 2 (2336 bytes per sector)
 19h	BYTE	interleave size (number of sectors stored consecutively)
 1Ah	BYTE	interleave skip factor
		(number of sectors between consecutive portions)

(Table 02598)
Values for device driver error code:
 00h	write-protect violation
 01h	unknown unit
 02h	drive not ready
 03h	unknown command
 04h	CRC error
 05h	bad drive request structure length
 06h	seek error
 07h	unknown media
 08h	sector not found
 09h	printer out of paper
 0Ah	write fault
 0Bh	read fault
 0Ch	general failure
 0Dh	reserved
 0Eh	(CD-ROM) media unavailable
 0Fh	invalid disk change

(Table 02599)
Call European MS-DOS 4.0 device helper function with:
	DL = function
	    00h "SchedClock" called on each timer tick
		AL = tick interval in milliseconds
	    01h "DevDone" device I/O complete
		ES:BX -&gt; request header
		Note:	must update status word first; may be called from
			  an interrupt handler
	    02h "PullRequest" pull next request from queue
		DS:SI -&gt; DWORD pointer to start of device's request queue
		Return: ZF clear if pending request
			    ES:BX -&gt; request header
			ZF set if no more requests
	    03h "PullParticular" remove specific request from queue
		DS:SI -&gt; DWORD pointer to start of device's request queue
		ES:BX -&gt; request header
		Return: ZF set if request header not found
	    04h "PushRequest" push the request onto the queue
		DS:SI -&gt; DWORD pointer to start of device's request queue
		ES:BX -&gt; request header
		interrupts disabled
	    05h "ConsInputFilter" keyboard input check
		AX = character (high byte 00h if PC ASCII character)
		Return: ZF set if character should be discarded
			ZF clear if character should be handled normally
		Note:	called by keyboard interrupt handler so DOS can scan
			  for special input characters
	    06h "SortRequest" push request in sorted order by starting sector
		DS:SI -&gt; DWORD pointer to start of device's request queue
		ES:BX -&gt; request header
		interrupts disabled
	    07h "SigEvent" send signal on keyboard event
		AH = event identifier
		Return: AL,FLAGS destroyed
	    09h "ProcBlock" block on event
		AX:BX = event identifier (typically a pointer)
		CX = timeout in ms or 0000h for never
		DH = interruptable flag (nonzero if pause may be interrupted)
		interrupts disabled
		Return: after corresponding ProcRun call
			CF clear if event wakeup, set if unusual wakeup
			ZF set if timeout wakeup, clear if interrupted
			AL = wakeup code, nonzero if unusual wakeup
			interrupts enabled
			BX,CX,DX destroyed
		Note:	block process and schedules another to run
	    0Ah "ProcRun" unblock process
		AX:BX = event identifier (typically a pointer)
		Return: AX = number of processes awakened
			ZF set if no processes awakened
			BX,CX,DX destroyed
	    0Bh "QueueInit" initialize/clear character queue
		DS:BX -&gt; character queue structure (see #02600)
		Note:	the queue size field must be set before calling
	    0Dh "QueueWrite" put a character in the queue
		DS:BX -&gt; character queue (see #02600)
		AL = character to append to end of queue
		Return: ZF set if queue is full
			ZF clear if character stored
	    0Eh "QueueRead" get a character from the queue
		DS:BX -&gt; character queue (see #02600)
		Return: ZF set if queue is empty
			ZF clear if characters in queue
			    AL = first character in queue
	    10h "GetDOSVar" return pointer to DOS variable
		AL = index of variable
		    03h current process ID
		BX = index into variable if AL specifies an array
		CX = expected length of variable
		Return: CF clear if successful
			    DX:AX -&gt; variable
			CF set on error
			    AX,DX destroyed
			BX,CX destroyed
		Note:	the variables may not be modified
	    14h "Yield" yield CPU if higher-priority task ready to run
		Return: FLAGS destroyed
	    1Bh "CritEnter" begin system critical section
		DS:BX -&gt; semaphore (6 BYTEs, initialized to zero)
		Return: AX,BX,CX,DX destroyed
	    1Ch "CritLeave" end system critical section
		DS:BX -&gt; semaphore (6 BYTEs, initialized to zero)
		Return: AX,BX,CX,DX destroyed
		Note:	must be called in the context of the process which
			  called CritEnter on the semaphore
Note:	the DWORD pointing at the request queue must be allocated by the driver
	  and initialized to 0000h:0000h.  It always points at the next request
	  to be executed

Format of European MS-DOS 4.0 character queue:
Offset	Size	Description	(Table 02600)
 00h	WORD	size of queue in bytes
 02h	WORD	index of next character out
 04h	WORD	count of characters in the queue
 06h  N BYTEs	queue buffer

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F0803" name="2F0803"><b>2F0803</b></a> - INT 2F U - DOS 4.0+ DRIVER.SYS support - GET DRIVE DATA TABLE LIST<br />
<pre>
INT 2F U - DOS 4.0+ DRIVER.SYS support - GET DRIVE DATA TABLE LIST
	AX = 0803h
Return: DS:DI -&gt; first drive data table in list (see #02601,#02602,#02603)
Note:	not available under DR DOS 5.0, but supported by Novell DOS 7 (using
	  the MS-DOS 4+ data table format)
SeeAlso: AX=0801h

Format of DOS 3.30 drive data table:
Offset	Size	Description	(Table 02601)
 00h	DWORD	pointer to next table (offset FFFFh if last table)
 04h	BYTE	physical unit number (for INT 13)
 05h	BYTE	logical drive number (0=A:)
 06h 19 BYTEs	BIOS Parameter Block (see also INT 21/AH=53h)
		Offset	Size	Description
		 00h	WORD	bytes per sector
		 02h	BYTE	sectors per cluster, FFh if unknown
		 03h	WORD	number of reserved sectors
		 05h	BYTE	number of FATs
		 06h	WORD	number of root dir entries
		 08h	WORD	total sectors
		 0Ah	BYTE	media descriptor, 00h if unknown
		 0Bh	WORD	sectors per FAT
		 0Dh	WORD	sectors per track
		 0Fh	WORD	number of heads
		 11h	WORD	number of hidden sectors
 19h	BYTE	flags
		bit 6: 16-bit FAT instead of 12-bit FAT
 1Ah	WORD	number of DEVICE OPEN calls without corresponding DEVICE CLOSE
 1Ch 11 BYTEs	volume label or "NO NAME    " if none (always "NO NAME" for
		  fixed media)
 27h	BYTE	terminating null for volume label???
 28h	BYTE	device type (see #01561 at INT 21/AX=440Dh"DOS 3.2+")
 29h	WORD	bit flags describing drive (see #02604)
 2Bh	WORD	number of cylinders
 2Dh 19 BYTEs	BIOS Parameter Block for highest capacity supported
 40h  3 BYTEs	???
 43h  9 BYTEs	filesystem type???, default = "NO NAME	"
		(apparently only MS-DOS 3.30 fixed media, nulls for removable
		  media and PC-DOS 3.30)
 4Ch	BYTE	least-significant byte of last-accessed cylinder number
---removable media---
 4Dh	DWORD	time of last access in clock ticks (FFFFFFFFh if never)
---fixed media---
 4Dh	WORD	partition (FFFFh = primary, 0001h = extended)
 4Fh	WORD	absolute cylinder number of partition's start on physical
		  drive (always FFFFh if primary partition)
SeeAlso: #02602,#02603

Format of COMPAQ DOS 3.31 drive data table:
Offset	Size	Description	(Table 02602)
 00h	DWORD	pointer to next table (offset FFFFh if last table)
 04h	BYTE	physical unit number (for INT 13)
 05h	BYTE	logical drive number (0=A:)
 06h 25 BYTEs	BIOS Parameter Block (see #02603)
 1Fh  6 BYTEs	reserved fields from BPB above???
 25h	BYTE	flags
		bit 6: 16-bit FAT instead of 12-bit FAT
		bit 5: large volume???
 26h	WORD	device-open count???
 28h 11 BYTEs	volume label or "NO NAME    " if none (always "NO NAME" for
		  fixed media)
 33h	BYTE	terminating null for volume label
 34h	BYTE	device type (see #01561 at INT 21/AX=440Dh"DOS 3.2+")
 35h	WORD	bit flags describing drive (see #02604)
 37h	WORD	number of cylinders
 39h 25 BYTEs	BIOS parameter block for highest capacity drive supports
 52h  6 BYTEs	??? apparently always zeros
 58h	BYTE	least-significant byte of last-accessed cylinder number
---removable media---
 59h	DWORD	time of last access in clock ticks (FFFFFFFFh if never)
---fixed media---
 59h	WORD	partition (FFFFh = primary, 0001h = extended)
 5Bh	WORD	absolute cylinder number of partition's start on physical
		  drive (always FFFFh if primary partition)
SeeAlso: #02601,#02603

Format of DOS 4.0-7.0 drive data table:
Offset	Size	Description	(Table 02603)
 00h	DWORD	pointer to next table (offset FFFFh if last table)
 04h	BYTE	physical unit number (for INT 13)
 05h	BYTE	logical drive number (0=A:)
 06h 25 BYTEs	BIOS Parameter Block (see also INT 21/AH=53h)
		Offset	Size	Description
		 00h	WORD	bytes per sector
		 02h	BYTE	sectors per cluster, FFh if unknown
		 03h	WORD	number of reserved sectors
		 05h	BYTE	number of FATs
		 06h	WORD	number of root dir entries
		 08h	WORD	total sectors (refer to offset 15h if zero)
		 0Ah	BYTE	media descriptor, 00h if unknown
		 0Bh	WORD	sectors per FAT
		 0Dh	WORD	sectors per track
		 0Fh	WORD	number of heads
		 11h	DWORD	number of hidden sectors
		 15h	DWORD	total sectors if WORD at 08h is zero
 1Fh	BYTE	flags
		bit 6: 16-bit FAT instead of 12-bit
		bit 7: unsupportable disk (all accesses will return Not Ready)
 20h	WORD	device-open count
 22h	BYTE	device type (see #01561 at INT 21/AX=440Dh"DOS 3.2+")
 23h	WORD	bit flags describing drive (see #02604)
 25h	WORD	number of cylinders (for partition only, if hard disk)
 27h 25 BYTEs	BIOS Parameter Block for default (highest) capacity supported
 40h  6 BYTEs	reserved (part of BPB above)
 46h	BYTE	last track accessed
---removable media---
 47h	DWORD	time of last access in clock ticks (FFFFFFFFh if never)
---fixed media---
 47h	WORD	partition (FFFFh = primary, 0001h = extended)
		always 0001h for DOS 5+
 49h	WORD	absolute cylinder number of partition's start on physical drive
		(FFFFh if primary partition in DOS 4.x)
------
 4Bh 11 BYTEs	volume label or "NO NAME    " if none (apparently taken from
		  extended boot record rather than root directory)
 56h	BYTE	terminating null for volume label
 57h	DWORD	serial number
 5Bh  8 BYTEs	filesystem type ("FAT12	  " or "FAT16	")
 63h	BYTE	terminating null for filesystem type
SeeAlso: #02601,#02602

Bitfields for flags describing drive:
Bit(s)	Description	(Table 02604)
 0	fixed media
 1	door lock ("changeline") supported
 2	current BPB locked
 3	all sectors in a track are the same size
 4	physical drive has multiple logical units
 5	current logical drive for shared physical drive
 6	disk change detected
 7	device parameters were changed (set DASD before formatting)
	(see #01560 at INT 21/AX=440Dh"DOS 3.2+")
 8	disk reformatted (BPB of current media was changed)
 9	access flag (fixed media only, disables reads and writes)
	(see #01566 at INT 21/AX=440Dh"DOS 3.2+")

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1000" name="2F1000"><b>2F1000</b></a> - INT 2F - SHARE - INSTALLATION CHECK<br />
<pre>
INT 2F - SHARE - INSTALLATION CHECK
	AX = 1000h
Return: AL = status
	    00h not installed, OK to install
	    01h not installed, not OK to install
	    FFh installed
Notes:	supported by OS/2 v1.3+ compatibility box, which always returns AL=FFh
	if DOS 4.01 SHARE was automatically loaded, file sharing is in an
	  inactive state (due to the undocumented /NC flag used by the autoload
	  code) until this call is made
	DR DOS 5.0 SHARE 1.00 only checks for AH=10h and in this case does not
	  chain to a previous handler, DR DOS 6.0 SHARE 1.02+ properly chains
	  for any values other than AX=1000h and the private FDOS hook
	  AX=1001h.  However, under DR PalmDOS and Novell DOS 7+, the
	  SHARE 2.00+ only tests for the AX=1000h install check, since it no
	  longer uses AX=1001h to hook into the system.
	DOS 5+ chains to the previous handler if AL &lt;&gt; 00h on entry
	Windows Enhanced mode hooks this call and reports that SHARE is
	  installed even when it is not
BUGS:	values of AL other than 00h put DOS 3.x SHARE into an infinite loop
	  (08E9: OR  AL,AL
	   08EB: JNZ 08EB) &lt;- the buggy instruction (DOS 3.3)
	values of AL other than described here put PC-DOS 4.00 into the same
	  loop (the buggy instructions are the same)
SeeAlso: AX=1080h,INT 21/AH=52h,INT 21/AX=4457h/DX=FFFFh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1001" name="2F1001"><b>2F1001</b></a> - INT 2F U - DR DOS 6.0+ FDOS EXTENSIONS - INSTALL FDOS HOOK (SHARE / DELWATCH)<br />
<pre>
INT 2F U - DR DOS 6.0+ FDOS EXTENSIONS - INSTALL FDOS HOOK (SHARE / DELWATCH)
	AX = 1001h
	DX:BX -&gt; new FDOS stub entry function
Return: nothing
Notes:	the default handler for the pointer set by this call under DELWATCH
	  simply returns with CF set
	In Digital Research terminology FDOS is the part of the BDOS kernel
	  (IBMDOS.COM) responsible for the file system and related tasks, and
	  its functionality is also used by the BDOS kernel itself. However,
	  for reasons of performance and code size, it uses direct calling.
	This interrupt allows external components like SHARE file locking or
	  DELWATCH delete tracking software to hook into the internal backdoor
	  INT 2F/AH=10h/AL&lt;=09h chain in the kernel, so that they can actually
	  allows the kernel to ensure that several conditions are met when
	  passing control to these registered components including proper
	  maintaining A20, re-enterancy, or critical section mutexing
	  (e.g. getting the disk sub-system queue "MXdisk").
	The default handler in the BDOS just sets the carry flag and returns.
	Currently known clients to this shared interface are DR DOS 6.0
	  SHARE 1.xx, DR DOS 6.0+ DELWATCH 1.00+, which both chain onto
	  the same call far address, and the version of AddStor's SuperStor
	  which is bundled with DR DOS 6.0
	However, the DR PalmDOS, and Novell DOS 7 - DR-DOS 7.03 SHARE 2.00-2.05
	  do not use this function to hook into the system. Instead they fix up
	  the share stubs directly. DR PalmDOS SHARE 2.00 uses the stubs at
	  Table !!! INT 21/AH=52h, while Novell DOS 7 - DR-DOS 7.03
	  SHARE 2.01-2.05 use the private set of share stubs at Table !!! at
	  INT 21/AX=4458h).  Future releases may possibly again fix up the
	  share stubs at INT 21/AH=52h.
SeeAlso: AX=1000h,AX=F800h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1002CHFF" name="2F1002CHFF"><b>2F1002CHFF</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - READ BUFFERS<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - READ BUFFERS
	AX = 1002h
	CH = FFh (pre-read required)
	CL = buffer type (here FAT, DIR, or DATA, see below)
	AH:DX = 24 bit sector number
Return:	ES:SI -&gt; buffer control block
Notes:	This private function is called internally by the OS kernel to
	  ask the FDOS to find the corresponding buffer.  By using the
	  INT 2F/AX=1001h FDOS hook, the call can be intercepted by external
	  system components such as the DELWATCH TSR.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=1003h,AX=1008h,AX=1009h,AX=10FEh

Bitfields for Novell DOS 7 FDOS buffer type:
Bit(s)	Description	(Table 04099)
 7	remote (on a network drive)
 6	dirty (modified)
 3	data sector
 2	directory sector
 1	FAT sector

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1003" name="2F1003"><b>2F1003</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - FLUSH BUFFERS<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - FLUSH BUFFERS
	AX = 1003h
	BL = drive???
	BH = buffer type to flush (BF_ISFAT+BF_ISDIR+BF_ISDATA)
Return: nothing???
Notes:	This private function is called internally by the OS kernel to
	  ask the FDOS to flush all buffer.  By using the INT 2F/AX=1001h FDOS
	  hook, the call can be intercepted by external system components such
	  as the DELWATCH TSR.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=1004h,AX=10FEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1004" name="2F1004"><b>2F1004</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - FREE FAT CHAIN<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - FREE FAT CHAIN
	AX = 1004h
	BX = first block to release on current drive
Return: nothing
Notes:	This private function is called internally by the OS kernel to
	  ask the FDOS to release the FAT chain.  By using the INT 2F/AX=1001h
	  FDOS hook, the call can be intercepted by external system components
	  such as the DELWATCH TSR.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=1005h,AX=10FEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1005" name="2F1005"><b>2F1005</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - ALLOCATE CLUSTER<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - ALLOCATE CLUSTER
	AX = 1005h
	BX = block from which to start search (e.g. current end of file)
	    0000h = start of disk
Return: AX or BX??? = allocated cluster (already marked as End of Chain)
	    or 0000h if none available
Notes:	This private function is called internally by the OS kernel to
	  ask the FDOS to allocate disk space.  By using the
	  INT 2F/AX=1001h FDOS hook, the call can be intercepted by external
	  system components such as the DELWATCH TSR.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=1004h,AX=1007h,AX=10FEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1006" name="2F1006"><b>2F1006</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - NEXT CLUSTER / READ FAT???<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - NEXT CLUSTER / READ FAT???
	AX = 1006h
	BX = current cluster number
Return:	AX or BX??? = next cluster in chain
Notes:	This private function is called internally by the OS kernel to
	  ask the FDOS to get the next cluster in a file.  By using the
	  INT 2F/AX=1001h FDOS hook, the call can be intercepted by external
	  system components such as the DELWATCH TSR.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=1005h,AX=1007h,AX=10FEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1007" name="2F1007"><b>2F1007</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - UPDATE FAT ENTRY / WRITE FAT???<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - UPDATE FAT ENTRY / WRITE FAT???
	AX = 1007h
	BX = FAT entry to change
	DX = new value
Return:	nothing
Notes:	This private function is called internally by the OS kernel to
	  ask the FDOS to update the FAT.  By using the INT 2F/AX=1001h FDOS
	  hook, the call can be intercepted by external system components such
	  as the DELWATCH TSR.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=1005h,AX=1006h,AX=1008h,AX=10FEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1008" name="2F1008"><b>2F1008</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - FIXUP CHECKSUMS / DIR UPDATE???<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - FIXUP CHECKSUMS / DIR UPDATE???
	AX = 1008h
	BX = segment of directory buffer
	CX = cluster to fixup (0 = root)
	DI = directory entry index (truncated to cluster if subdirectory)
	BX:SI -&gt; directory entry (single entry for hashing)
Return:	nothing
Notes:	This private function is called internally by the OS kernel to
	  ask the FDOS to fixup hashing/checksums.  By using the
	  INT 2F/AX=1001h FDOS hook, the call can be intercepted by external
	  system components such as the DELWATCH TSR.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=1007h,AX=1009h,AX=10FEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1009" name="2F1009"><b>2F1009</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - DIRECTORY BUFFER INFO<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - DIRECTORY BUFFER INFO
	AX = 1009h
Return: ES:DI -&gt; 128-byte directory record buffer
	ES:SI -&gt; directory BCB structure (see #04101)
Notes:	This private function is called internally by the OS kernel.  By using
	  the INT 2F/AX=1001h FDOS hook, the call can be intercepted by
	  external system components such as the DELWATCH TSR.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=10FEh

Format of Novell DOS 7+ FDOS directory BCB:
Offset	Size	Description	(Table 04101)
 00h	BYTE	drive (FFh = invalid)
 01h	BYTE	low byte of record number
 02h	BYTE	middle byte of record number
 03h	BYTE	high byte of record number

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1010CX0000" name="2F1010CX0000"><b>2F1010CX0000</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - SUPERSTOR - QUERY PHYS FREE SPACE<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - SUPERSTOR - QUERY PHYS FREE SPACE
	AX = 1010h
	CX = 0000h
Return: CX = free space
	    0000h if no physical space left on the drive
	    else there is still space available
Notes:	This private function is internally called by the FDOS part of the
	  OS kernel on "out of disk space" conditions.  It allows optimized
	  behaviour of DELWATCH delete tracking software in conjunction with
	  disk compression, and was implemented for SuperStor (but it would
	  also work with other disk compression if they hook this function).
	  If there truly is no physical space left on the drive, the FDOS asks
	  DELWATCH to purge files in its queue until enough space has been
	  freed, or there actually is no free disk space any more.
	By using the INT 2F/AX=1001h FDOS hook, the call can be intercepted by
	  external system components such as SuperStor, bundled with DR DOS
	  "Panther" and Novell DOS 7 BETAs.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=10FEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1020" name="2F1020"><b>2F1020</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - CREATE PASSWORD ENTRY<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - CREATE PASSWORD ENTRY
	AX = 1020h
	???
Return: ???
Notes:	This private function is called internally by the OS kernel to an
	  optional SECURITY TSR.  By using the INT 2F/AX=1001h FDOS hook, it
	  can be intercepted by external system components such as
	  Multiuser SECURITY, bundled with DR DOS "Panther" Beta 1.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=1021h,AX=1022h,AX=10FEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1021" name="2F1021"><b>2F1021</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - CHANGE PASSWORD ENTRY<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - CHANGE PASSWORD ENTRY
	AX = 1021h
	CL &gt; 05h ???
	BX -&gt; matching directory entry???
	AL = directory attributes???
Return: ???
	CF set on error (password change not allowed)
Notes:	This private function is called internally by the OS kernel to an
	  optional SECURITY TSR.  By using the INT 2F/AX=1001h FDOS hook, it
	  can be intercepted by external system components such as
	  Multiuser SECURITY, bundled with DR DOS "Panther" Beta 1.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=1020h,AX=1022h,AX=10FEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1022" name="2F1022"><b>2F1022</b></a> - INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - CHECK PASSWORD ENTRY<br />
<pre>
INT 2F CU - Novell DOS 7+ FDOS EXTENSIONS - CHECK PASSWORD ENTRY
	AX = 1022h
	???
Return: ???
Notes:	This private function is called internally by the OS kernel to an
	  optional SECURITY TSR.  By using the INT 2F/AX=1001h FDOS hook, it
	  can be intercepted by external system components such as
	  Multiuser SECURITY, bundled with DR DOS "Panther" Beta 1.
	This function must under no circumstances be called by applications!
SeeAlso: INT 2F/AX=1001h,AX=1020h,AX=1021h,AX=10FEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1040" name="2F1040"><b>2F1040</b></a> - INT 2F U - DOS 4 only SHARE internal - ???<br />
<pre>
INT 2F U - DOS 4 only SHARE internal - ???
	AX = 1040h
	???
Return: AL = FFh???
SeeAlso: AX=1000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1080" name="2F1080"><b>2F1080</b></a> - INT 2F U - DOS 4 only SHARE internal - TURN ON FILE SHARING CHECKS<br />
<pre>
INT 2F U - DOS 4 only SHARE internal - TURN ON FILE SHARING CHECKS
	AX = 1080h
Return: AL = status
	    F0h successful
	    FFh checking was already on
Note:	DOS 4.x SHARE has dual functions: FCB support for large (&gt;32M) media
	  and file sharing checks.  The undocumented commandline flag /NC can
	  be used to disable the sharing code.
SeeAlso: AX=1000h,AX=1081h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1081" name="2F1081"><b>2F1081</b></a> - INT 2F U - DOS 4 only SHARE internal - TURN OFF FILE SHARING CHECKS<br />
<pre>
INT 2F U - DOS 4 only SHARE internal - TURN OFF FILE SHARING CHECKS
	AX = 1081h
Return: AL = status
	    F0h successful
	    FFh checking was already off
Note:	(see AX=1080h)
SeeAlso: AX=1000h,AX=1080h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F10FE" name="2F10FE"><b>2F10FE</b></a> - INT 2F U - DR DOS 6.0+ DELWATCH.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F U - DR DOS 6.0+ DELWATCH.EXE - INSTALLATION CHECK
	AX = 10FEh
Return: AL = FFh if installed and active
	    AH = internal version number
	        10h for DR DOS 6.0 DELWATCH 1.0 / 1.1 (through 1993/03/19)
		20h for Novell DOS 7+ DELWATCH 2.0+
	    DX:BX -&gt; private entry point (see #02605)
Notes:	The DR DOS 6.0 DELWATCH 1.x used to store information about deleted
	  files in a hidden file named @DLWATCH.DAT, however the Novell DOS 7+
	  DELWATCH 2.0+ stores all the info in previously unused fields in
	  the files' directory entries. (See table !!! at INT 21h/11h for
	  details). This, however, now causes problems on systems also running
	  Windows 9x since Microsoft decided to use a rather similar but
	  incompatible method to store long filenames etc. in these entries.
	Running DELWATCH 2.x on a system which previously used DELWATCH 1.x,
	  the @DLWATCH.DAT file will be abandoned and converted to the new
	  method.
SeeAlso: #01352,INT 21/AX=4306h,INT 21/AX=5704h,INT 2F/AX=1001h

(Table 02605)
Call DELWATCH private entry point with:
	AH = function
	    00h (OS hook) installation check
		AL = 00h required for DELWATCH 1.x
		Return: CF clear
			AX = 0000h
			CX = 0004h (unsupported function)
	    01h (DELWATCH 1.x) New Disk
	        ???
	    01h (DELWATCH 2.0+) disable DELWATCH on drive
		AL = drive number (00h = A:)
		Return: AX = status (0000h if failed, FFFFh if successful)
	    02h (OS hook) Delete File
		AL = drive number (00h = A:)
		DX = directory cluster number (0000h for root directory)
		CX = directory entry number
		DS:BX -&gt; directory entry
		ES,DS must be valid selectors if called in protected mode
		Return: DS:BX -&gt; updated directory entry
			CF set if file is to be deleted by the OS
			CF clear if DELWATCH has placed the file in its queue
		Note:	deletes the directory entry
	    03h	(OS hook) Free Clusters
		AL = drive number (00h = A:)
		CX = number of clusters currently free (do not free if &gt; 1)
		DX = preferred 'search from cluster' (ignored by DELWATCH 2.0)
		Return: CF clear if clusters freed
			CF set if no clusters freed
			DX = new 'search from' cluster (one before first free)
	    04h (OS hook) free root directory entry
		AL = drive number (00h = A:)
		Return: CF set if no directory entry freed
	    05h (OS hook) return free space
		AL = drive number (00h = A:)
		CX = number of free clusters
		Return:	CX = updated number of free clusters
		Notes:	adds space used by "deleted" files to free space
			call is chained
	    06h enable DELWATCH on drive
		AL = drive number with bit 7 set (80h = A:, etc.)
			(DELWATCH 2.0+: set bit 6 for removable drives)
		BX = maximum files of same name in one directory to save
		CX = maximum files to save on this disk
		DS:DX -&gt; MEMDESC??? for drive data (see #04104)
		DS:SI -&gt; MEMDESC??? for DWLIST (see #04104)
		ES,DS must contain valid selectors if called in protected mode
		Return: AX = status
			    0000h failed
			    FFFFh successful
			CX = error code on failure (see #04102)
			    (0004h "wrong version" if AL &lt; 80h on entry)
	    07h (DELWATCH 1.x) disable DELWATCH on drive
		???
	    07h (DELWATCH 2.0+) (OS hook) new disk
		AL = drive (00h = A:, etc.)
		ES:BX -&gt; DOS DDSC structure
		CF set if not enabled
		Return: ???
	    08h set file extensions list
		AL = sense (00h exclude named extensions, 01h only named ext.)
		DS:BX -&gt; 31-byte ASCIZ extension list (three blank-padded bytes
			  per extension)
		Return: AX = FFFFh (successful)
	    09h	adjust pending delete space
		AL = drive number (00h = A:)
		CX = number of clusters being freed
		Return: AX = 0000h if drive not enabled
	    0Ah remove DELWATCH entry
		AL = drive number (00h = A:)
		DX = directory cluster number (0000h if root directory)
		CX = directory entry number
		BX:SI -&gt; filename
		ES,DS must contain valid selectors if called in protected mode
		Return: AX &gt; 0000h if entry found in DWLIST
	    0Bh enable NEWDISK
		Return: AX &gt; 0000h if successful (FFFFh for DELWATCH 2.0)
		see also function 0Dh
	    0Ch (DELWATCH 1.x) drive status
		AL = drive number (00h = A:, etc.)
		Return: AX = drive data segment, 0000h if not enabled
			CX = pending delete space, if drive enabled
	    0Ch (DELWATCH 2.0+) check if drive enabled
		AL = drive number with bit 7 set (80h = A:, etc.)
		DS:DX -&gt; MEMDESC for drive data (see #04104)
			(DX = 0000h if not required)
		DS:SI -&gt; MEMDESC for DWLIST (see #04104)
			(SI = 0000h if not required)
		ES,DS must contain valid selectors if called in protected mode
		Return: AX = drive status (see also #04103)
			    0000h disabled or error
				CX = error code (see #04102)
			    0001h drive enabled
				CX = pending delete space, FFFFh if NEWDISK
				      not yet called
	    0Dh disable NEWDISK
		BX = segment address of bitmap buffer
		Return: AX &gt; 0000h if successful (FFFFh for DELWATCH 2.0)
		see also function 0Bh
	    0Eh (DELWATCH 2.0+) (OS hook) purge file
		AL = drive number (00h = A:)
		DX = directory cluster number (0000h if root directory)
		CX = directory entry number
		Return: CF set if drive not enabled
			CF clear
			    AX = status
				0000h successfully purged
				else error code (see #04102)
	    0Fh (DELWATCH 2.0+) (OS hook) undelete file
		AL = drive number (00h = A:)
		DX = directory cluster number (0000h if root directory)
		CX = directory entry number
		Return: CF set if drive not enabled
			CF clear
			    AX = status
				0000h successfully undeleted
				else error code (see #04102)
Return: AX = 0000h, CX = 0001h (see #04102) if DELWATCH busy
	registers unchanged if AH &gt; 0Fh on entry
Notes:	functions marked "OS hook" must under no circumstances by called by
	  external applications, as this would bypass the serialization
	  performed by the kernel and cause problems at least in multitasking
	  environments.
	two functions have been swapped between DELWATCH 1.x and DELWATCH 2.0
	  to ensure that DELWATCH 1.x calls will not do anything under newer
	  versions of the OS; for the same reason, the drive number in AL
	  sometimes requires that bit 7 be set for DELWATCH 2.0+.
SeeAlso: AX=1001h,AX=1010h

(Table 04102)
Values for DELWATCH error codes:
 0001h	reentered (DELWATCH busy)
 0002h	not enabled
 0003h	not found
 0004h	wrong version of DELWATCH
 0005h	memory allocation
SeeAlso: #04103

(Table 04103)
Values for DELWATCH drive status:
 0000h	drive not enabled
 0001h	OK
 0002h	no bitmap
 0003h	zero files
 0004h	cross-linked files
SeeAlso: #04102

Format of DELWATCH MEMDESC structure:
Offset	Size	Description	(Table 04104)
 00h	BYTE	memory type
		01h protected mode (DPMS)
		02h XMS
		03h upper (high) memory
		04h low memory
 01h	DWORD	location
		(conventional memory) WORD: segment base address
		(XMS) WORD: XMS handle
		(DPMS) DWORD: DPMS memory 32-bit base address
 05h	DWORD	length in bytes
 09h	DWORD	allocation
		(conventional memory) WORD: memory block segment
		(XMS) WORD: XMS handle (same as location handle)
		(DPMS) DWORD: DPMS 32-bit handle

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F10FF" name="2F10FF"><b>2F10FF</b></a> - INT 2F U - DR DOS 5.0 - FIXUP SHARE STUB TABLE???<br />
<pre>
INT 2F U - DR DOS 5.0 - FIXUP SHARE STUB TABLE???
	AX = 10FFh
	ES:BX -&gt; new SHARE stub table to use???
Return: DS destroyed???
Notes:	Sets a pointer in the kernel. ES:BX points to a structure in SHARE's
	  segment, which presumeably contains a number (4 or 11???) of entries
	  of 5 bytes each and is probably part of some kind of share stub
	  dispatcher that gets fixed up by this call.
	This was seen called by DR DOS 5.0 SHARE 1.00 (when INT 2F/AX=1000h
	  revealed that SHARE was not installed) before it hooked INT 2Fh
	  via INT 21/AH=35h to provide its install check function. It preserved
	  the DS register before calling.
	However, the DR DOS 6.0+ SHARE 1.02+ uses INT 2F/AX=1001h to hook
	  into the OS, DR PalmDOS SHARE 2.00 directly fixes up the share stubs
	  in table !!! at INT 21h/52h, and Novell DOS 7 - DR-DOS 7.03
	  SHARE 2.01-2.05 maintains the private set of share stubs in
	  Table !!! at INT 21/AX=4458h).
	This function was probably used between 1990/02/09 and 1991/03/15.
SeeAlso: INT 2F/AX=1001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1100" name="2F1100"><b>2F1100</b></a> - INT 2F C - NETWORK REDIRECTOR - INSTALLATION CHECK<br />
<pre>
INT 2F C - NETWORK REDIRECTOR - INSTALLATION CHECK
	AX = 1100h
Return: AL = status
	    00h not installed, OK to install
	    01h not installed, not OK to install
	    FFh installed
		AH = product identifier (ad hoc by various manufacturers)
		    00h if PC Tools v8 DRIVEMAP
		    42h ('B') for Beame&Whiteside BWNFS v3.0a
		    6Eh ('n') for NetWare Lite v1.1 CLIENT
Notes:	this function is called by the DOS 3.1+ kernel
	in DOS 4.x only, the 11xx calls are all in IFSFUNC.EXE, not in the
	  PC LAN Program redirector; DOS 5+ moves the calls back into the
	  redirector
	the PC Network 1.00 redirector (renamed to PC LAN Program in 1.1-1.3)
	  only supports AL=00h-27h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1100SFDADA" name="2F1100SFDADA"><b>2F1100SFDADA</b></a> - INT 2F - MSCDEX (MS CD-ROM Extensions) - INSTALLATION CHECK<br />
<pre>
INT 2F - MSCDEX (MS CD-ROM Extensions) - INSTALLATION CHECK
	AX = 1100h subfn DADAh
	STACK: WORD DADAh
Return: AL = status
	    00h not installed, OK to install
		STACK unchanged
	    01h not installed, not OK to install
		STACK unchanged
	    FFh installed
		STACK: WORD	ADADh if MSCDEX installed
				DADBh if Lotus CD/Networker installed
Note:	although MSCDEX sets the stack word to ADADh on return, any value other
	  than DADAh is considered to mean that MSCDEX is already installed;
	  Lotus CD/Networker v4+ uses this feature to fool MSCDEX into
	  thinking it is already installed when it is in fact CD/Networker
	  that is installed
Index:	installation check;Lotus CD/Networker
Index:	Lotus CD/Networker;installation check

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1101" name="2F1101"><b>2F1101</b></a> - INT 2F CU - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
	AX = 1101h
	SS = DOS DS
	SDA first filename pointer -&gt; fully-qualified directory name
	SDA CDS pointer -&gt; current directory structure for drive with dir
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: AX=1103h,AX=1105h,INT 21/AH=3Ah,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1102" name="2F1102"><b>2F1102</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - REMOVE REMOTE DIRECTORY<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - REMOVE REMOTE DIRECTORY
	AX = 1102h
	SS = DOS DS
	SDA first filename pointer -&gt; fully-qualified directory name
	SDA CDS pointer -&gt; current directory structure for drive with dir
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
Note:	appears to be identical to AX=1101h; MS internal documentation calls
	  this function "SEQ_RMDIR"
SeeAlso: AX=1101h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1103" name="2F1103"><b>2F1103</b></a> - INT 2F CU - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
	AX = 1103h
	SS = DOS DS
	SDA first filename pointer -&gt; fully-qualified directory name
	SDA CDS pointer -&gt; current directory structure for drive with dir
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: AX=1101h,AX=1105h,INT 21/AH=39h,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1104" name="2F1104"><b>2F1104</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - MAKE REMOTE DIRECTORY<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - MAKE REMOTE DIRECTORY
	AX = 1104h
	SS = DOS DS
	SDA first filename pointer -&gt; fully-qualified directory name
	SDA CDS pointer -&gt; current directory structure for drive with dir
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
Note:	appears to be identical to AX=1103h
SeeAlso: AX=1103h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1105" name="2F1105"><b>2F1105</b></a> - INT 2F CU - NETWORK REDIRECTOR - CHDIR<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - CHDIR
	AX = 1105h
	SS = DOS DS
	SDA first filename pointer -&gt; fully-qualified directory name
	SDA CDS pointer -&gt; current directory structure for drive with dir
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    CDS updated with new path
Notes:	this function is called by the DOS 3.1+ kernel
	directory string in CDS should not have a terminating backslash unless
	  the current directory is the root
SeeAlso: AX=1101h,AX=1103h,INT 21/AH=3Bh,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1106" name="2F1106"><b>2F1106</b></a> - INT 2F CU - NETWORK REDIRECTOR - CLOSE REMOTE FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - CLOSE REMOTE FILE
	AX = 1106h
	ES:DI -&gt; filled-in SFT (assumed to point at SDA's current SFT field)
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    SFT updated (redirector must decrement open count, which may be
		  done with INT 2F/AX=1208h)
	ES:DI must be preserved
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: AX=1116h,AX=1201h,AX=1208h,AX=1227h,INT 21/AH=3Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1107" name="2F1107"><b>2F1107</b></a> - INT 2F CU - NETWORK REDIRECTOR - COMMIT REMOTE FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - COMMIT REMOTE FILE
	AX = 1107h
	ES:DI -&gt; filled-in SFT (assumed to point at SDA's current SFT field)
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    all buffers for file flushed
	    directory entry updated
	ES:DI must be preserved
Desc:	perform all the buffer flushing, directory updates, etc. that would be
	  performed on a file close, but do not decrement the SFT reference
	  count
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: INT 21/AH=68h,INT 21/AX=5D01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1108" name="2F1108"><b>2F1108</b></a> - INT 2F CU - NETWORK REDIRECTOR - READ FROM REMOTE FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - READ FROM REMOTE FILE
	AX = 1108h
	ES:DI -&gt; SFT
	    SFT DPB field -&gt; DPB of drive containing file
	CX = number of bytes
	SS = DOS DS
	SDA DTA field -&gt; user buffer
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    CX = number of bytes read (0000h = end of file)
	    SFT updated
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: AX=1109h,AX=1229h,INT 21/AH=3Fh"DOS",INT 21/AX=5D06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1109" name="2F1109"><b>2F1109</b></a> - INT 2F CU - NETWORK REDIRECTOR - WRITE TO REMOTE FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
	AX = 1109h
	ES:DI -&gt; SFT
	    SFT DPB field -&gt; DPB of drive containing file
	CX = number of bytes
	SS = DOS DS
	SDA DTA field -&gt; user buffer
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    CX = number of bytes written
	    SFT updated
Notes:	this function is called by the DOS 3.1+ kernel
	PrintCache v3.1 PCACHE.EXE intercepts this function for SFTs where
	  the Device Driver Header field points at PCACHE, but does not
	  intercept any other network redirector functions
SeeAlso: AX=1107h,AX=1108h,INT 21/AH=40h,INT 21/AX=5D06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F110A" name="2F110A"><b>2F110A</b></a> - INT 2F CU - NETWORK REDIRECTOR (DOS 3.x only) - LOCK REGION OF FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR (DOS 3.x only) - LOCK REGION OF FILE
	AX = 110Ah
	BX = file handle
	CX:DX = starting offset
	SI = high word of size
	STACK: WORD low word of size
	ES:DI -&gt; SFT
	    SFT DPB field -&gt; DPB of drive containing file
	SS = DOS DS
Return: CF set on error
	   AL = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	STACK unchanged
Notes:	this function is called by the DOS 3.10-3.31 kernel
	the redirector is expected to resolve lock conflicts
SeeAlso: AX=110Bh,INT 21/AH=5Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F110A_0" name="2F110A_0"><b>2F110A</b></a> - INT 2F CU - NETWORK REDIRECTOR (DOS 4.0+) - LOCK/UNLOCK REGION OF FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR (DOS 4.0+) - LOCK/UNLOCK REGION OF FILE
	AX = 110Ah
	BL = function
	    00h lock
	    01h unlock
	CX = number of lock/unlock parameters (0001h for DOS 4.0-6.1)
	DS:DX -&gt; parameter block (see #02606)
	ES:DI -&gt; SFT
	    SFT DPB field -&gt; DPB of drive containing file
	SS = DOS DS
Return: CF set on error
	   AL = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
Notes:	this function is called by the DOS 4.0+ kernel
	the redirector is expected to resolve lock conflicts
SeeAlso: AX=110Bh,INT 21/AH=5Ch

Format of parameter block entry [array, but currently limited to single entry]:
Offset	Size	Description	(Table 02606)
 00h	DWORD	start offset
 04h	DWORD	size of region

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F110B" name="2F110B"><b>2F110B</b></a> - INT 2F CU - NETWORK REDIRECTOR (DOS 3.x only) - UNLOCK REGION OF FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR (DOS 3.x only) - UNLOCK REGION OF FILE
	AX = 110Bh
	BX = file handle
	CX:DX = starting offset
	SI = high word of size
	STACK: WORD low word of size
	ES:DI -&gt; SFT for file
	    SFT DPB field -&gt; DPB of drive containing file
Return: CF set on error
	   AL = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	STACK unchanged
Note:	this function is called by the DOS 3.1-3.31 kernel; DOS 4.0+ calls
	  AX=110Ah instead
SeeAlso: AX=110Ah,INT 21/AH=5Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F110C" name="2F110C"><b>2F110C</b></a> - INT 2F CU - NETWORK REDIRECTOR - GET DISK INFORMATION<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - GET DISK INFORMATION
	AX = 110Ch
	ES:DI -&gt; current directory structure for desired drive
Return: CF clear if data valid
	    AL = sectors per cluster
	    AH = media ID byte
	    BX = total clusters
	    CX = bytes per sector
	    DX = number of available clusters
	CF set if data invalid
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: INT 21/AH=36h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F110D" name="2F110D"><b>2F110D</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - SET REMOTE FILE'S ATTRIBUTES<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - SET REMOTE FILE'S ATTRIBUTES
	AX = 110Dh
	SDA first filename pointer -&gt; name of file
	???
Return: ???
Note:	similar to AX=110Eh
SeeAlso: AX=110Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F110E" name="2F110E"><b>2F110E</b></a> - INT 2F CU - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
	AX = 110Eh
	SS = DOS DS
	SDA first filename pointer -&gt; fully-qualified name of file
	SDA CDS pointer -&gt; current directory structure for drive with file
	STACK: WORD new file attributes
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	STACK unchanged
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: AX=110Dh,AX=110Fh,INT 21/AX=4301h,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F110F" name="2F110F"><b>2F110F</b></a> - INT 2F CU - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES AND SIZE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES AND SIZE
	AX = 110Fh
	SS = DOS DS
	SDA first filename pointer -&gt; fully-qualified name of file
	SDA CDS pointer -&gt; current directory structure for drive with file
		(offset = FFFFh if null CDS [net direct request])
	SDA search attributes = mask of attributes which may be included in
		  search for file
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    AX = file attributes
	    BX:DI = file size
	    CX = time stamp of file
	    DX = date stamp of file
Notes:	this function is called by the DOS 3.1+ kernel
	wildcards and device names are not permitted
SeeAlso: AX=110Eh,INT 21/AX=4300h,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1110" name="2F1110"><b>2F1110</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - GET REMOTE FILE'S ATTRIBUTES AND SIZE<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - GET REMOTE FILE'S ATTRIBUTES AND SIZE
	AX = 1110h
	SDA first filename pointer -&gt; name of file
	???
Return: ???
Note:	appears to be similar to AX=110Fh
SeeAlso: AX=110Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1111" name="2F1111"><b>2F1111</b></a> - INT 2F CU - NETWORK REDIRECTOR - RENAME REMOTE FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - RENAME REMOTE FILE
	AX = 1111h
	SS = DS = DOS DS
	SDA first filename pointer = offset of fully-qualified old name
	SDA second filename pointer = offset of fully-qualified new name
	SDA CDS pointer -&gt; current directory structure for drive with file
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: AX=1112h,INT 21/AH=56h,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1112" name="2F1112"><b>2F1112</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - RENAME REMOTE FILE<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - RENAME REMOTE FILE
	AX = 1112h
	SS = DS = DOS DS
	SDA first filename pointer -&gt; name of file
	???
Return: ???
Note:	similar to AX=1111h
SeeAlso: AX=1111h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1113" name="2F1113"><b>2F1113</b></a> - INT 2F CU - NETWORK REDIRECTOR - DELETE REMOTE FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - DELETE REMOTE FILE
	AX = 1113h
	SS = DS = DOS DS
	SDA first filename pointer -&gt; fully-qualified filename in DOS DS
	SDA CDS pointer -&gt; current directory structure for drive with file
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
Notes:	this function is called by the DOS 3.1+ kernel
	the filespec may contain wildcards
SeeAlso: AX=1114h,INT 21/AH=41h,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1114" name="2F1114"><b>2F1114</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - DELETE REMOTE FILE<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - DELETE REMOTE FILE
	AX = 1114h
	SDA first filename pointer -&gt; name of file
	???
Return: ???
Note:	similar to AX=1113h
SeeAlso: AX=1113h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1115" name="2F1115"><b>2F1115</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - OPEN REMOTE FILE<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - OPEN REMOTE FILE
	AX = 1115h
	SS = DOS DS
	ES:DI -&gt; SFT ???
	???
Return: ???
Note:	similar to AX=1116h
SeeAlso: AX=1116h,AX=112Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1116" name="2F1116"><b>2F1116</b></a> - INT 2F CU - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
	AX = 1116h
	ES:DI -&gt; uninitialized SFT
	SS = DOS DS
	SDA first filename pointer -&gt; fully-qualified name of file to open
	STACK: WORD file access and sharing modes (see #01402 at INT 21/AH=3Dh)
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    SFT filled (except handle count, which DOS manages itself)
	STACK unchanged
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: AX=1106h,AX=1115h,AX=1117h,AX=1118h,AX=112Eh,INT 21/AH=3Dh
SeeAlso: INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1117" name="2F1117"><b>2F1117</b></a> - INT 2F CU - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
	AX = 1117h
	ES:DI -&gt; uninitialized SFT
	SS = DOS DS
	SDA first filename pointer -&gt; fully-qualified name of file to open
	SDA CDS pointer -&gt; current directory structure for drive with file
	STACK: WORD file creation mode
			low byte = file attributes (see #01401 at INT 21/AH=3Ch)
			high byte = 00h normal create, 01h create new file
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    SFT filled (except handle count, which DOS manages itself)
	STACK unchanged
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: AX=1106h,AX=1116h,AX=1118h,AX=112Eh,INT 21/AH=3Ch,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1118" name="2F1118"><b>2F1118</b></a> - INT 2F CU - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE WITHOUT CDS<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE WITHOUT CDS
	AX = 1118h
	ES:DI -&gt; uninitialized SFT
	SS = DOS DS
	SDA first filename pointer -&gt; fully-qualified name of file
	STACK: WORD file creation mode
			low byte = file attributes
			high byte = 00h normal create, 01h create new file
Return: ???
	STACK unchanged
Note:	this function is called by the DOS 3.1+ kernel when creating a file
	  on a drive for which the SDA CDS pointer has offset FFFFh
SeeAlso: AX=1106h,AX=1116h,AX=1117h,AX=112Eh,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1119" name="2F1119"><b>2F1119</b></a> - INT 2F CU - NETWORK REDIRECTOR - FIND FIRST FILE WITHOUT CDS<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - FIND FIRST FILE WITHOUT CDS
	AX = 1119h
	SS = DS = DOS DS
	[DTA] = uninitialized 21-byte findfirst search data
	      (see #01626 at INT 21/AH=4Eh)
	SDA first filename pointer -&gt; fully-qualified search template
	SDA search attribute = attribute mask for search
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    [DTA] = updated findfirst search data
		    (bit 7 of first byte must be set)
	    [DTA+15h] = standard directory entry for file (see #01352)
Notes:	this function is called by the DOS 3.1+ kernel
	DOS 4.x IFSFUNC returns CF set, AX=0003h
SeeAlso: AX=111Ah,AX=111Bh,INT 21/AH=1Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F111A" name="2F111A"><b>2F111A</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - FIND NEXT FILE WITHOUT CDS<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - FIND NEXT FILE WITHOUT CDS
	AX = 111Ah
	???
Return: CF set
	    AX = error code (03h for DOS 4.01 IFSFUNC)
Note:	use AX=111Ch for DOS 5+
SeeAlso: AX=1119h,AX=111Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F111B" name="2F111B"><b>2F111B</b></a> - INT 2F CU - NETWORK REDIRECTOR - FINDFIRST<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - FINDFIRST
	AX = 111Bh
	SS = DS = DOS DS
	[DTA] = uninitialized 21-byte findfirst search data
	      (see #01626 at INT 21/AH=4Eh)
	SDA first filename pointer -&gt; fully-qualified search template
	SDA CDS pointer -&gt; current directory structure for drive with file
	SDA search attribute = attribute mask for search
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    [DTA] = updated findfirst search data
		    (bit 7 of first byte must be set)
	    [DTA+15h] = standard directory entry for file (see #01352)
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: AX=1119h,AX=111Ch,INT 21/AH=1Ah,INT 21/AH=4Eh,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F111C" name="2F111C"><b>2F111C</b></a> - INT 2F CU - NETWORK REDIRECTOR - FINDNEXT<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - FINDNEXT
	AX = 111Ch
	SS = DS = DOS DS
	ES:DI -&gt; CDS
	ES:DI -&gt; DTA (MSDOS v5.0)
	[DTA] = 21-byte findfirst search data
	      (see #01626 at INT 21/AH=4Eh)
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    [DTA] = updated findfirst search data
		    (bit 7 of first byte must be set)
	    [DTA+15h] = standard directory entry for file (see #01352)
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: AX=1119h,AX=111Bh,INT 21/AH=1Ah,INT 21/AH=4Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F111D" name="2F111D"><b>2F111D</b></a> - INT 2F CU - NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS (ABORT)<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS (ABORT)
	AX = 111Dh
	SS = DOS DS
	SDA PSP segment field = PSP of terminating process
Return: nothing
Notes:	used when a process is aborted; the process being terminated is
	  indicated by the "sharing PSP" field in the SDA (offset 1Ah/1Ch)
	this function is called by the DOS 3.1+ kernel
	closes all FCBs opened by process
SeeAlso: INT 21/AX=5D04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F111E" name="2F111E"><b>2F111E</b></a> - INT 2F CU - NETWORK REDIRECTOR - DO REDIRECTION<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - DO REDIRECTION
	AX = 111Eh
	SS = DOS DS
	STACK: WORD function to execute
		5F00h  get redirection mode
			BL = type (03h printer, 04h disk)
			Return: BH = state (00h off, 01h on)
		5F01h  set redirection mode
			BL = type (03h printer, 04h disk)
			BH = state (00h off, 01h on)
		5F02h  get redirection list entry
			BX = redirection list index
			DS:SI -&gt; 16-byte local device name buffer
			ES:DI -&gt; 128-byte network name buffer
			Return: must set user's BX to device type and CX to
				stored parameter value, using AX=1218h to get
				stack frame address
		5F03h  redirect device
			BL = device type (see INT 21/AX=5F03h)
			CX = stored parameter value
			DS:SI -&gt; ASCIZ source device name
			ES:DI -&gt; destination ASCIZ network path + ASCIZ passwd
		5F04h  cancel redirection
			DS:SI -&gt; ASCIZ device name or network path
		5F05h  get redirection list extended entry
			BX = redirection list index
			DS:SI -&gt; buffer for ASCIZ source device name
			ES:DI -&gt; buffer for destination ASCIZ network path
			Return: BH = status flag
				BL = type (03h printer, 04h disk)
				CX = stored parameter value
				BP = NETBIOS local session number
		5F06h  similar to 5F05h???
Return: CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
	STACK unchanged
Notes:	this function is called by the DOS 3.1+ kernel on INT 21/AH=5Fh
	  (including LAN Manager calls)
	the PC Network 1.00 redirector does not support function 5F06h
SeeAlso: INT 21/AX=5F00h,INT 21/AX=5F01h,INT 21/AX=5F02h,INT 21/AX=5F03h
SeeAlso: INT 21/AX=5F04h,INT 21/AX=5F05h,INT 21/AX=5F06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F111F" name="2F111F"><b>2F111F</b></a> - INT 2F CU - NETWORK REDIRECTOR - PRINTER SETUP<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - PRINTER SETUP
	AX = 111Fh
	STACK: WORD function
		5E02h  set printer setup
		5E03h  get printer setup
		5E04h  set printer mode
		5E05h  get printer mode
Return: CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
	STACK unchanged
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: INT 21/AX=5E02h,INT 21/AX=5E03h,INT 21/AX=5E04h,INT 21/AX=5E05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1120" name="2F1120"><b>2F1120</b></a> - INT 2F CU - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
	AX = 1120h
	DS = DOS DS
	???
Return: CF clear (successful)
Notes:	this function is called by the DOS 3.1+ kernel
	uses CDS array pointer and LASTDRIVE= entries in DOS list of lists
SeeAlso: INT 21/AH=0Dh,INT 21/AX=5D01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1121" name="2F1121"><b>2F1121</b></a> - INT 2F CU - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
	AX = 1121h
	CX:DX = offset (in bytes) from end
	ES:DI -&gt; SFT
	    SFT DPB field -&gt; DPB of drive with file
	SS = DOS DS
Return: CF set on error
	    AL = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    DX:AX = new file position
Note:	this function is called by the DOS 3.1+ kernel, but only when seeking
	  from the end of a file opened with sharing modes set in such a
	  manner that another process is able to change the size of the file
	  while it is already open
SeeAlso: AX=1228h,INT 21/AH=42h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1122" name="2F1122"><b>2F1122</b></a> - INT 2F CU - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
	AX = 1122h
	SS = DOS DS
	DS = PSP of process about to terminate
Return: ???
Notes:	this function is called by the DOS 3.1+ kernel
	after calling this function, the kernel calls INT 2F/AX=111Dh
SeeAlso: AX=111Dh,INT 21/AH=4Ch,INT 60/DI=0601h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1123" name="2F1123"><b>2F1123</b></a> - INT 2F CU - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
	AX = 1123h
	DS:SI -&gt; ASCIZ filename to canonicalize
	ES:DI -&gt; 128-byte buffer for qualified name
Return: CF set if not resolved
Notes:	called by MS-DOS 3.1+ kernel, but not called by DR DOS 5.0 unless the
	  filename matches the name of a character device
	called first when DOS attempts to resolve a filename (unless inside an
	  AX=5D00h server call); if this fails, DOS resolves the name locally
SeeAlso: AX=1221h,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1124" name="2F1124"><b>2F1124</b></a> - INT 2F CU - NETWORK REDIRECTOR - TURN OFF REMOTE PRINTER<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - TURN OFF REMOTE PRINTER
	AX = 1124h
	ES:DI -&gt; SFT
	SS = DOS DS
	???
Return: CX = ???
Note:	this function is called by the DOS 3.1+ kernel if AX=1126h
	  returns CF set
SeeAlso: AX=1126h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1125" name="2F1125"><b>2F1125</b></a> - INT 2F CU - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
	AX = 1125h
	STACK: WORD subfunction
		5D07h get print stream state
			Return: DL = current state
		5D08h set print stream state
			DL = new state
		5D09h finish print job
Return: CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
	STACK unchanged
Note:	this function is called by the DOS 3.1+ kernel
SeeAlso: INT 21/AX=5D07h,INT 21/AX=5D08h,INT 21/AX=5D09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1126" name="2F1126"><b>2F1126</b></a> - INT 2F CU - NETWORK REDIRECTOR - REMOTE PRINTER ECHO ON/OFF<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR - REMOTE PRINTER ECHO ON/OFF
	AX = 1126h
	ES:DI -&gt; SFT for file handle 4???
	SS = DOS DS???
	???
Return: CF set on error
Notes:	this function is called by the DOS 3.1+ kernel
	called when print echoing (^P, ^PrtSc) changes state and STDPRN has
	  bit 11 of the device information word in the SFT set
SeeAlso: AX=1124h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1127" name="2F1127"><b>2F1127</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - UNUSED<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - UNUSED
	AX = 1127h
Return: CF set
	    AX = 0001h (invalid function) (see #01680 at INT 21/AH=59h/BX=0000h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1127BX4E57" name="2F1127BX4E57"><b>2F1127BX4E57</b></a> - INT 2F - NetWare 4.0 - REMOTE FILE COPY<br />
<pre>
INT 2F - NetWare 4.0 - REMOTE FILE COPY
	AX = 1127h
	BX = 4E57h ('NW') (signature identifying this as a NetWare call)
	SI = source file handle
	DI = destination file handle
	DX:CX = number of bytes to copy, starting at current file position
Return: CF clear if successful
	CF set on error
	    AX = error code (05h,06h,0Bh,11h,3Bh) (see #01680)
	DX:CX = number of bytes successfully copied (file position updated)
Notes:	this is the only call which may be made directly to the NetWare
	  redirector from an application
	COMMAND.COM's COPY and DOS's XCOPY reportedly call INT 21/AX=1127h in
	  order to speed up copies between files on the same network server;
	  if error code 11h (not same device) is returned, the copy is
	  performed in the usual manner.  However, no such calls appear to
	  be present in MS-DOS 6.22.
	From the DR DOS "Panther" BETA COMMAND.COM (1992/06/22) up to some of
	  the Novell DOS 7 COMMAND.COM updates (1994/09/12), the shell made
	  calls to INT 2F/AX=11F0h to attempt "remote server COPYing". However,
	  this was removed from later releases of the shell because it stopped
	  Performance Technologies' PowerLAN 3.1 working. (A successor of
	  the DR-DOS 7.03 COMMAND.COM may possibly reintroduce this remote
	  copy feature.	 Probably it would then try both INT 2F/AX=1127h and
	  INT 2F/AX=11F0h.)
SeeAlso: INT 2F/AX=11F0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1128" name="2F1128"><b>2F1128</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - UNUSED<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - UNUSED
	AX = 1128h
Return: CF set
	    AX = 0001h (invalid function) (see #01680 at INT 21/AH=59h/BX=0000h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1129" name="2F1129"><b>2F1129</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - UNUSED<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - UNUSED
	AX = 1129h
Return: CF set
	    AX = 0001h (invalid function) (see #01680 at INT 21/AH=59h/BX=0000h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F112A" name="2F112A"><b>2F112A</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - CLOSE ALL FILES FOR PROCESS<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - CLOSE ALL FILES FOR PROCESS
	AX = 112Ah
	DS = DOS DS
	???
Return: ???
Note:	does something to each IFS driver

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F112B" name="2F112B"><b>2F112B</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - GENERIC IOCTL<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - GENERIC IOCTL
	AX = 112Bh
	SS = DOS DS
	CX = function/category
	DS:DX -&gt; parameter block
	STACK: WORD value of AX on entry to INT 21 (440Ch or 440Dh)
	???
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
Note:	this function is called by the DOS 4.0 kernel

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F112C" name="2F112C"><b>2F112C</b></a> - INT 2F CU - NETWORK REDIRECTOR (DOS 4.0+) - "UPDATE_CB" - ???<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR (DOS 4.0+) - "UPDATE_CB" - ???
	AX = 112Ch
	SS = DOS DS
	SDA current SFT pointer -&gt; SFT for file
	???
Return: CF set on error
Note:	called by SHARE in DOS 5.0-6.0

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F112D" name="2F112D"><b>2F112D</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - EXTENDED ATTRIBUTES<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - EXTENDED ATTRIBUTES
	AX = 112Dh
	BL = subfunction (value of AL on INT 21)
	    02h get extended attributes
	    03h get extended attribute properties
	    04h set extended attributes
		Return: CF clear
	    else ???
		Return: CX = ??? (00h or 02h for DOS 4.01)
	ES:DI -&gt; SFT for file
	SS = DOS DS
Return: DS = DOS DS
Note:	this function is called by the DOS 4.0 kernel on INT 21/AX=5702h,
	  INT 21/AX=5703h, and INT 21/AX=5704h
SeeAlso: INT 21/AX=5702h,INT 21/AX=5703h,INT 21/AX=5704h,INT 21/AH=6Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F112E" name="2F112E"><b>2F112E</b></a> - INT 2F CU - NETWORK REDIRECTOR (DOS 4.0+) - EXTENDED OPEN/CREATE FILE<br />
<pre>
INT 2F CU - NETWORK REDIRECTOR (DOS 4.0+) - EXTENDED OPEN/CREATE FILE
	AX = 112Eh
	SS = DS = DOS DS
	ES:DI -&gt; uninitialized SFT for file
	STACK: WORD file attribute for created/truncated file
			low byte = file attributes
			high byte = 00h normal create/open, 01h create new file
	SDA first filename pointer -&gt; fully-qualified filename
	SDA extended file open action = action code
	      (see #01770 at INT 21/AX=6C00h)
	SDA extended file open mode = open mode for file (see INT 21/AX=6C00h)
Return: CF set on error
	    AX = error code
	CF clear if successful
	    CX = result code
		01h file opened
		02h file created
		03h file replaced (truncated)
	    SFT initialized (except handle count, which DOS manages itself)
Note:	this function is called by the DOS 4.0+ kernel
BUG:	this function is not called correctly under some DOS versions
	  (at least 5.0 and 6.2):
	    the file attribute on the stack is not correct if the action
	      code is 11h,
	    the result code in CX is not passed back to the application.
SeeAlso: AX=1115h,AX=1116h,AX=1117h,INT 21/AX=6C00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F112F" name="2F112F"><b>2F112F</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - IFS IOCTL<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - IFS IOCTL
	AX = 112Fh
	SS = DOS DS
	STACK: WORD function in low byte
		00h ???
		    DS:SI -&gt; Current Directory Structure???
		    CL = drive (1=A:)
		01h ???
		    DS:SI -&gt; ???
		    CL = file handle???
		02h ???
		    DS:SI -&gt; Current Directory Structure???
		    DI = ???
		    CX = drive (1=A:)
	???
Return: CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
Note:	this function is called by the DOS 4.0 kernel
SeeAlso: INT 21/AH=6Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1130" name="2F1130"><b>2F1130</b></a> - INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - GET IFSFUNC SEGMENT<br />
<pre>
INT 2F CU - IFSFUNC.EXE (DOS 4.x only) - GET IFSFUNC SEGMENT
	AX = 1130h
Return: ES = CS of resident IFSFUNC

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1180" name="2F1180"><b>2F1180</b></a> - INT 2F - LAN Manager Enhanced DOS Services - ???<br />
<pre>
INT 2F - LAN Manager Enhanced DOS Services - ???
	AX = 1180h
	???
Return: ???
SeeAlso: AX=1100h,AX=1181h,AX=118Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1181" name="2F1181"><b>2F1181</b></a> - INT 2F - LAN Manager Enhanced DOS Services - SET USER NAME???<br />
<pre>
INT 2F - LAN Manager Enhanced DOS Services - SET USER NAME???
	AX = 1181h
	???
Return: ???
SeeAlso: AX=1100h,AX=1180h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1182" name="2F1182"><b>2F1182</b></a> - INT 2F - LAN Manager Enhanced DOS Services - INSTALL SERVICE<br />
<pre>
INT 2F - LAN Manager Enhanced DOS Services - INSTALL SERVICE
	AX = 1182h
	???
Return: ???
SeeAlso: AX=1100h,AX=1180h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1184" name="2F1184"><b>2F1184</b></a> - INT 2F - LAN Manager Enhanced DOS - ???<br />
<pre>
INT 2F - LAN Manager Enhanced DOS - ???
	AX = 1184h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1186" name="2F1186"><b>2F1186</b></a> - INT 2F - LAN Manager Enhanced DOS - DosReadAsynchNmPipe<br />
<pre>
INT 2F - LAN Manager Enhanced DOS - DosReadAsynchNmPipe
	AX = 1186h
	DS:SI -&gt; stack frame (see #02607)
Return: CF clear if successful
	CF set if error
	    AX = error code
Note:	LAN Manager enhance mode adds features beyond the standard redirector
	  file/printer services
SeeAlso: AX=118Fh,AX=1190h,AX=1191h,INT 21/AX=5F39h

Format of LAN Manager DosReadAsynchNmPipe stack frame:
Offset	Size	Description	(Table 02607)
 00h	DWORD	-&gt; number of bytes read
 04h	WORD	size of buffer
 06h	DWORD	-&gt; buffer
 0Ah	DWORD	-&gt; return code
 0Eh	DWORD	function to call on completion as function( char far *buffer )
 12h	WORD	handle

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F118A" name="2F118A"><b>2F118A</b></a> - INT 2F - LAN Manager 2.0+ DOS Enhanced ENCRYPT.EXE - STREAM ENCRYPTION SERVICE<br />
<pre>
INT 2F - LAN Manager 2.0+ DOS Enhanced ENCRYPT.EXE - STREAM ENCRYPTION SERVICE
	AX = 118Ah
	BX = function (0000h or 0001h)
Return: CF clear if successful
	    AX = 1100h success
	CF set if error
	    AX = 0001h, etc.
SeeAlso: AX=1186h,AH=41h,AH=42h,AH=4Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F118B" name="2F118B"><b>2F118B</b></a> - INT 2F - LAN Manager Enhanced DOS - ???<br />
<pre>
INT 2F - LAN Manager Enhanced DOS - ???
	AX = 118Bh
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F118C" name="2F118C"><b>2F118C</b></a> - INT 2F - LAN Manager Enhanced DOS - ???<br />
<pre>
INT 2F - LAN Manager Enhanced DOS - ???
	AX = 118Ch
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F118E" name="2F118E"><b>2F118E</b></a> - INT 2F - LAN Manager Enhanced DOS - ???<br />
<pre>
INT 2F - LAN Manager Enhanced DOS - ???
	AX = 118Eh
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F118F" name="2F118F"><b>2F118F</b></a> - INT 2F - LAN Manager Enhanced DOS - DosWriteAsynchNmPipe<br />
<pre>
INT 2F - LAN Manager Enhanced DOS - DosWriteAsynchNmPipe
	AX = 118Fh
	DS:SI -&gt; stack frame (see #02608)
Return: CF clear if successful
	CF set if error
	    AX = error code
SeeAlso: AX=1186h,AX=1191h,INT 21/AX=5F3Ah

Format of LAN Manager DosReadAsynchNmPipe stack frame:
Offset	Size	Description	(Table 02608)
 00h	DWORD	-&gt; number of bytes read
 04h	WORD	Size of buffer
 06h	DWORD	-&gt; buffer
 0Ah	DWORD	-&gt; return code
 0Eh	DWORD	function to call on completion as function( char far *buffer )
 12h	WORD	handle

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1190" name="2F1190"><b>2F1190</b></a> - INT 2F - LAN Manager Enhanced DOS - DosReadAsynchNmPipe2<br />
<pre>
INT 2F - LAN Manager Enhanced DOS - DosReadAsynchNmPipe2
	AX = 1190h
	DS:SI -&gt; stack frame (see #02609)
Return: CF clear if successful
	CF set if error
	    AX = error code
SeeAlso: AX=1186h,AX=1191h

Format of LAN Manager DosReadAsynchNmPipe2 stack frame:
Offset	Size	Description	(Table 02609)
 00h	DWORD	-&gt; number of bytes read
 04h	WORD	size of buffer
 06h	DWORD	-&gt; buffer
 0Ah	DWORD	-&gt; return code
 0Eh	DWORD	function to call on completion as function( char far *buffer )
 12h	WORD	handle
 14h	DWORD	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1191" name="2F1191"><b>2F1191</b></a> - INT 2F - LAN Manager Enhanced DOS - DosWriteAsynchNmPipe2<br />
<pre>
INT 2F - LAN Manager Enhanced DOS - DosWriteAsynchNmPipe2
	AX = 1191h
	DS:SI -&gt; stack frame (see #02610)
Return: CF clear if successful
	CF set if error
	    AX = error code
SeeAlso: AX=118Fh,AX=1190h,INT 21/AX=5F3Ah

Format of LAN Manager DosReadAsynchNmPipe2 stack frame:
Offset	Size	Description	(Table 02610)
 00h	DWORD	-&gt; number of bytes read
 04h	WORD	size of buffer
 06h	DWORD	-&gt; buffer
 0Ah	DWORD	-&gt; return code
 0Eh	DWORD	function to call on completion as function( char far *buffer )
 12h	WORD	handle
 14h	DWORD	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F11F0" name="2F11F0"><b>2F11F0</b></a> - INT 2F - Novell ??? - REMOTE FILE COPY<br />
<pre>
INT 2F - Novell ??? - REMOTE FILE COPY
	AX = 11F0h
	SI = source file handle
	DI = destination file handle
	DX:CX = number of bytes to copy, starting at current file position
	CF cleared
Return: CF clear:
	    AX = 11F0h	"no network there"
	    AX &lt;&gt; 11F0h if successful
	CF set on error "the request could not be handled"
	    AX = error code (05h,06h,0Bh,11h,3Bh) (see #01680)
	DX:CX = number of bytes successfully copied (file position updated)
Notes:	From the DR DOS "Panther" BETA COMMAND.COM (1992/06/22) up to some of
	  the Novell DOS 7 COMMAND.COM updates (1994/09/12), the shell made
	  calls to INT 2F/AX=11F0h to attempt "remote server COPYing". However,
	  this was removed from later releases of the shell because it 
	  interfered with Performance Technologies' PowerLAN 3.1. (A successor
	  of the DR-DOS 7.03 COMMAND.COM may possibly reintroduce this remote
	  copy feature. Probably it would then try both INT 2F/AX=1127h and
	  INT 2F/AX=11F0h.)
SeeAlso: INT 2F/AX=1127h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1200" name="2F1200"><b>2F1200</b></a> - INT 2F U - DOS 3.0+ internal - INSTALLATION CHECK<br />
<pre>
INT 2F U - DOS 3.0+ internal - INSTALLATION CHECK
	AX = 1200h
Return: AL = FFh (for compatibility with other INT 2F functions)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1201" name="2F1201"><b>2F1201</b></a> - INT 2F U - DOS 3.0+ internal - CLOSE CURRENT FILE<br />
<pre>
INT 2F U - DOS 3.0+ internal - CLOSE CURRENT FILE
	AX = 1201h
	SS = DOS DS = DOS kernel data seg (must be using a DOS internal stack)
	SDA current SFT pointer -&gt; SFT of file to close
Return: CF set on error
	ES:DI -&gt; SFT for file
	CX undefined (new reference count of SFT in many versions)
	BX destroyed
SeeAlso: AX=1106h,AX=1227h,INT 21/AH=3Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1202" name="2F1202"><b>2F1202</b></a> - INT 2F U - DOS 3.0+ internal - GET INTERRUPT ADDRESS<br />
<pre>
INT 2F U - DOS 3.0+ internal - GET INTERRUPT ADDRESS
	AX = 1202h
	STACK: WORD vector number
Return: ES:BX -&gt; interrupt vector (DWORD containing handler's address)
	STACK unchanged

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1203" name="2F1203"><b>2F1203</b></a> - INT 2F U - DOS 3.0+ internal - GET DOS DATA SEGMENT<br />
<pre>
INT 2F U - DOS 3.0+ internal - GET DOS DATA SEGMENT
	AX = 1203h
Return: DS = data segment of IBMDOS.COM/MSDOS.SYS
Note:	for DOS prior to version 5.0, the data segment is the same as the code
	  segment

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1204" name="2F1204"><b>2F1204</b></a> - INT 2F U - DOS 3.0+ internal - NORMALIZE PATH SEPARATOR<br />
<pre>
INT 2F U - DOS 3.0+ internal - NORMALIZE PATH SEPARATOR
	AX = 1204h
	STACK: WORD character to normalize
Return: AL = normalized character (forward slash turned to backslash, all
		  others unchanged)
	ZF set if path separator
	STACK unchanged

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1205" name="2F1205"><b>2F1205</b></a> - INT 2F U - DOS 3.0+ internal - OUTPUT CHARACTER TO STANDARD OUTPUT<br />
<pre>
INT 2F U - DOS 3.0+ internal - OUTPUT CHARACTER TO STANDARD OUTPUT
	AX = 1205h
	STACK: WORD character to output
Return: STACK unchanged
Note:	can be called only from within DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1206" name="2F1206"><b>2F1206</b></a> - INT 2F U - DOS 3.0+ internal - INVOKE CRITICAL ERROR<br />
<pre>
INT 2F U - DOS 3.0+ internal - INVOKE CRITICAL ERROR
	AX = 1206h
	DI = error code
	BP:SI -&gt; device driver header (see #01646)
	SS = DOS DS (must be using a DOS internal stack)
	STACK: WORD value to be passed to INT 24 in AX
Return: AL = 0-3 for Abort, Retry, Ignore, Fail
	STACK unchanged
SeeAlso: INT 24

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1207" name="2F1207"><b>2F1207</b></a> - INT 2F U - DOS 3.0+ internal - MAKE DISK BUFFER MOST-RECENTLY USED<br />
<pre>
INT 2F U - DOS 3.0+ internal - MAKE DISK BUFFER MOST-RECENTLY USED
	AX = 1207h
	DS:DI -&gt; disk buffer
Return: nothing
Desc:	move the indicated buffer to the end of the disk buffer chain (least-
	  recently used is first); under DOS 3.3, the buffer is then moved to
	  the start of the disk buffer chain if it was marked unused
Notes:	can be called only from within DOS
	this function is nearly the same as AX=120Fh
SeeAlso: AX=120Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1208" name="2F1208"><b>2F1208</b></a> - INT 2F U - DOS 3.0+ internal - DECREMENT SFT REFERENCE COUNT<br />
<pre>
INT 2F U - DOS 3.0+ internal - DECREMENT SFT REFERENCE COUNT
	AX = 1208h
	ES:DI -&gt; SFT
Return: AX = original value of reference count
Notes:	if the reference count was 1, it is set to FFFFh ("busy", since 0
	  indicates that the SFT is not in use).  It is the caller's
	  responsibility to set the reference count to zero after cleaning up.
	used by network redirectors such as MSCDEX
SeeAlso: AX=1106h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1209" name="2F1209"><b>2F1209</b></a> - INT 2F U - DOS 3.0+ internal - FLUSH AND FREE DISK BUFFER<br />
<pre>
INT 2F U - DOS 3.0+ internal - FLUSH AND FREE DISK BUFFER
	AX = 1209h
	DS:DI -&gt; disk buffer
Return: disk buffer marked unused, contents written to disk if buffer dirty
Note:	can be called only from within DOS
SeeAlso: AX=120Eh,AX=1215h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F120A" name="2F120A"><b>2F120A</b></a> - INT 2F U - DOS 3.0+ internal - PERFORM CRITICAL ERROR INTERRUPT<br />
<pre>
INT 2F U - DOS 3.0+ internal - PERFORM CRITICAL ERROR INTERRUPT
	AX = 120Ah
	DS = SS = DOS DS (must be using a DOS internal stack)
	STACK: WORD extended error code
Return: AL = user response (0=ignore, 1=retry, 2=abort, 3=fail)
	CF clear if retry, set otherwise
	STACK unchanged
Notes:	can only be called during a DOS function call, as it uses various
	  fields in the SDA to set up the registers for the INT 24
	reportedly sets current DPB's first root directory sector to 1
SeeAlso: INT 24

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F120B" name="2F120B"><b>2F120B</b></a> - INT 2F U - DOS 3.0+ internal - SIGNAL SHARING VIOLATION TO USER<br />
<pre>
INT 2F U - DOS 3.0+ internal - SIGNAL SHARING VIOLATION TO USER
	AX = 120Bh
	ES:DI -&gt; system file table entry for previous open of file
	STACK: WORD extended error code (should be 20h--sharing violation)
Return: CF clear if operation should be retried
	CF set if operation should not be retried
	    AX = error code (20h) (see #01680 at INT 21/AH=59h/BX=0000h)
	STACK unchanged
Notes:	can only be called during a DOS function call
	should only be called if an attempt was made to open an already-open
	  file contrary to the sharing rules
	invokes INT 24 if SFT file opened via FCB or in compatibility mode with
	  inheritance allowed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F120C" name="2F120C"><b>2F120C</b></a> - INT 2F U - DOS 3.0+ internal - OPEN DEVICE AND SET SFT OWNER/MODE<br />
<pre>
INT 2F U - DOS 3.0+ internal - OPEN DEVICE AND SET SFT OWNER/MODE
	AX = 120Ch
	SDA current SFT pointer -&gt; SFT for file
	DS = DOS DS
	SS = DOS DS (must be using a DOS internal stack)
Return: ES, DI, AX destroyed
Notes:	invokes "device open" call on device driver for SFT
	changes owner of last-accessed SFT to calling process if it was opened
	  via FCB
	called by network redirectors such as MSCDEX

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F120D" name="2F120D"><b>2F120D</b></a> - INT 2F U - DOS 3.0+ internal - GET DATE AND TIME<br />
<pre>
INT 2F U - DOS 3.0+ internal - GET DATE AND TIME
	AX = 120Dh
	SS = DOS DS (must be using a DOS internal stack)
Return: AX = current date in packed format (see #01666 at INT 21/AX=5700h)
	DX = current time in packed format (see #01665 at INT 21/AX=5700h)
SeeAlso: INT 21/AH=2Ah,INT 21/AH=2Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F120E" name="2F120E"><b>2F120E</b></a> - INT 2F U - DOS 3.0+ internal - MARK ALL DISK BUFFERS UNREFERENCED<br />
<pre>
INT 2F U - DOS 3.0+ internal - MARK ALL DISK BUFFERS UNREFERENCED
	AX = 120Eh
	SS = DOS DS (must be using a DOS internal stack)
Return: DS:DI -&gt; first disk buffer
Notes:	clears "referenced" flag on all disk buffers
	in DOS 5+, this has become essentially a NOP, invoking the same code
	  used by AX=1224h (SHARING DELAY)
SeeAlso: AX=1209h,AX=1210h,INT 21/AH=0Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F120F" name="2F120F"><b>2F120F</b></a> - INT 2F U - DOS 3.0+ internal - MAKE BUFFER MOST RECENTLY USED<br />
<pre>
INT 2F U - DOS 3.0+ internal - MAKE BUFFER MOST RECENTLY USED
	AX = 120Fh
	DS:DI -&gt; disk buffer
	SS = DOS DS (must be using a DOS internal stack)
Return: DS:DI -&gt; next buffer in buffer list
Desc:	move the indicated buffer to the end of the disk buffer chain (least-
	  recently used is first); under DOS 3.3, the buffer is then moved to
	  the start of the disk buffer chain if it was marked unused
Note:	this function is the same as AX=1207h except that it returns a
	  pointer to the buffer following the specified buffer in the buffer
	  chain
SeeAlso: AX=1207h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1210" name="2F1210"><b>2F1210</b></a> - INT 2F U - DOS 3.0+ internal - FIND UNREFERENCED DISK BUFFER<br />
<pre>
INT 2F U - DOS 3.0+ internal - FIND UNREFERENCED DISK BUFFER
	AX = 1210h
	DS:DI -&gt; first disk buffer to check
Return: ZF clear if found
	    DS:DI -&gt; first unreferenced disk buffer
	ZF set if not found
Note:	in DOS 5+, this has become essentially a NOP, invoking the same code
	  used by AX=1224h (SHARING DELAY)
SeeAlso: AX=120Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1211" name="2F1211"><b>2F1211</b></a> - INT 2F U - DOS 3.0+ internal - NORMALIZE ASCIZ FILENAME<br />
<pre>
INT 2F U - DOS 3.0+ internal - NORMALIZE ASCIZ FILENAME
	AX = 1211h
	DS:SI -&gt; ASCIZ filename to normalize
	ES:DI -&gt; buffer for normalized filename
Return: destination buffer filled with uppercase filename, with slashes turned
	to backslashes
SeeAlso: AX=121Eh,AX=1221h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1212" name="2F1212"><b>2F1212</b></a> - INT 2F U - DOS 3.0+ internal - GET LENGTH OF ASCIZ STRING<br />
<pre>
INT 2F U - DOS 3.0+ internal - GET LENGTH OF ASCIZ STRING
	AX = 1212h
	ES:DI -&gt; ASCIZ string
Return: CX = length of string
SeeAlso: AX=1225h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1213" name="2F1213"><b>2F1213</b></a> - INT 2F U - DOS 3.0+ internal - UPPERCASE CHARACTER<br />
<pre>
INT 2F U - DOS 3.0+ internal - UPPERCASE CHARACTER
	AX = 1213h
	STACK: WORD character to convert to uppercase
Return: AL = uppercase character
	STACK unchanged

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1214" name="2F1214"><b>2F1214</b></a> - INT 2F U - DOS 3.0+ internal - COMPARE FAR POINTERS<br />
<pre>
INT 2F U - DOS 3.0+ internal - COMPARE FAR POINTERS
	AX = 1214h
	DS:SI = first pointer
	ES:DI = second pointer
Return: ZF set if pointers are equal, ZF clear if not equal
	CF clear if pointers equal, CF set if not

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1215" name="2F1215"><b>2F1215</b></a> - INT 2F U - DOS 3.0+ internal - FLUSH BUFFER<br />
<pre>
INT 2F U - DOS 3.0+ internal - FLUSH BUFFER
	AX = 1215h
	DS:DI -&gt; disk buffer
	SS = DOS DS (must be using a DOS internal stack)
	STACK: WORD drives for which to skip buffer
		ignore buffer if drive same as high byte, or bytes differ and
		  the buffer is for a drive OTHER than that given in low byte
Return: STACK unchanged
Note:	can be called only from within DOS
SeeAlso: AX=1209h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1216" name="2F1216"><b>2F1216</b></a> - INT 2F U - DOS 3.0+ internal - GET ADDRESS OF SYSTEM FILE TABLE ENTRY<br />
<pre>
INT 2F U - DOS 3.0+ internal - GET ADDRESS OF SYSTEM FILE TABLE ENTRY
	AX = 1216h
	BX = system file table entry number
Return: CF clear if successful
	    ES:DI -&gt; system file table entry
	    BX = relative entry number in system file table containing entry
	    AX destroyed
	CF set if BX greater than FILES=
Note:	supported by DR DOS 5+
SeeAlso: AX=1220h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1217" name="2F1217"><b>2F1217</b></a> - INT 2F U - DOS 3.0+ internal - GET CURRENT DIRECTORY STRUCTURE FOR DRIVE<br />
<pre>
INT 2F U - DOS 3.0+ internal - GET CURRENT DIRECTORY STRUCTURE FOR DRIVE
	AX = 1217h
	SS = DOS DS (must be using a DOS internal stack)
	STACK: WORD drive (0 = A:, 1 = B:, etc)
Return: CF set on error
	    (drive &gt; LASTDRIVE)
	CF clear if successful
	    DS:SI -&gt; current directory structure for specified drive
	STACK unchanged
SeeAlso: AX=1219h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1218" name="2F1218"><b>2F1218</b></a> - INT 2F U - DOS 3.0+ internal - GET CALLER'S REGISTERS<br />
<pre>
INT 2F U - DOS 3.0+ internal - GET CALLER'S REGISTERS
	AX = 1218h
Return: DS:SI -&gt; saved caller's AX,BX,CX,DX,SI,DI,BP,DS,ES (on stack)
Note:	only valid while within DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1219" name="2F1219"><b>2F1219</b></a> - INT 2F U - DOS 3.0+ internal - SET DRIVE???<br />
<pre>
INT 2F U - DOS 3.0+ internal - SET DRIVE???
	AX = 1219h
	SS = DOS DS (must be using a DOS internal stack)
	STACK: WORD drive (0 = default, 1 = A:, etc)
Return: ???
	STACK unchanged
Notes:	calls AX=1217h
	builds a current directory structure if inside server call
	  (INT 21/AX=5D00h)
SeeAlso: AX=1217h,AX=121Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F121A" name="2F121A"><b>2F121A</b></a> - INT 2F U - DOS 3.0+ internal - GET FILE'S DRIVE<br />
<pre>
INT 2F U - DOS 3.0+ internal - GET FILE'S DRIVE
	AX = 121Ah
	DS:SI -&gt; filename
Return: AL = drive (0 = default, 1 = A:, etc, FFh = invalid)
	DS:SI -&gt; filename without leading X: (if present)
SeeAlso: INT 21/AH=19h,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F121B" name="2F121B"><b>2F121B</b></a> - INT 2F U - DOS 3.0+ internal - SET YEAR/LENGTH OF FEBRUARY<br />
<pre>
INT 2F U - DOS 3.0+ internal - SET YEAR/LENGTH OF FEBRUARY
	AX = 121Bh
	CL = year - 1980
Return: AL = number of days in February
Note:	requires DS to be set to the DOS data segment
SeeAlso: INT 21/AH=2Bh"DATE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F121C" name="2F121C"><b>2F121C</b></a> - INT 2F U - DOS 3.0+ internal - CHECKSUM MEMORY<br />
<pre>
INT 2F U - DOS 3.0+ internal - CHECKSUM MEMORY
	AX = 121Ch
	DS:SI -&gt; start of memory to checksum
	CX = number of bytes
	DX = initial checksum
	SS = DOS DS (must be using a DOS internal stack)
Return: AX, CX destroyed
	DX = checksum
	DS:SI -&gt; first byte after checksummed range
Notes:	used by DOS to determine day count since 1980/1/1 given a date
	supported by DR DOS 5.0+
SeeAlso: AX=121Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F121D" name="2F121D"><b>2F121D</b></a> - INT 2F U - DOS 3.0+ internal - SUM MEMORY<br />
<pre>
INT 2F U - DOS 3.0+ internal - SUM MEMORY
	AX = 121Dh
	DS:SI -&gt; memory to add up
	CX = 0000h
	DX = limit
Return: AL = byte which exceeded limit
	CX = number of bytes before limit exceeded
	DX = remainder after adding first CX bytes
	DS:SI -&gt; byte beyond the one which exceeded the limit
Notes:	used by DOS to determine year or month given day count since 1980/1/1
	supported by DR DOS 5.0+
SeeAlso: AX=121Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F121E" name="2F121E"><b>2F121E</b></a> - INT 2F U - DOS 3.0+ internal - COMPARE FILENAMES<br />
<pre>
INT 2F U - DOS 3.0+ internal - COMPARE FILENAMES
	AX = 121Eh
	DS:SI -&gt; first ASCIZ filename
	ES:DI -&gt; second ASCIZ filename
Return: ZF set if filenames equivalent, ZF clear if not
Note:	supported by DR DOS 5.0+
SeeAlso: AX=1211h,AX=1221h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F121F" name="2F121F"><b>2F121F</b></a> - INT 2F U - DOS 3.0+ internal - BUILD CURRENT DIRECTORY STRUCTURE<br />
<pre>
INT 2F U - DOS 3.0+ internal - BUILD CURRENT DIRECTORY STRUCTURE
	AX = 121Fh
	SS = DOS DS (must be using a DOS internal stack)
	STACK: WORD drive letter
Return: ES:DI -&gt; current directory structure (will be overwritten by next call)
	STACK unchanged

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1220" name="2F1220"><b>2F1220</b></a> - INT 2F U - DOS 3.0+ internal - GET JOB FILE TABLE ENTRY<br />
<pre>
INT 2F U - DOS 3.0+ internal - GET JOB FILE TABLE ENTRY
	AX = 1220h
	BX = file handle
Return: CF set on error
	    AL = 6 (invalid file handle)
	CF clear if successful
	    ES:DI -&gt; JFT entry for file handle in current process
Notes:	the byte pointed at by ES:DI contains the number of the SFT for the
	  file handle, or FFh if the handle is not open
	supported by DR DOS 5.0+
SeeAlso: AX=1216h,AX=1229h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1221" name="2F1221"><b>2F1221</b></a> - INT 2F U - DOS 3.0+ internal - CANONICALIZE FILE NAME<br />
<pre>
INT 2F U - DOS 3.0+ internal - CANONICALIZE FILE NAME
	AX = 1221h
	DS:SI -&gt; file name to be fully qualified
	ES:DI -&gt; 128-byte buffer for resulting canonical file name
	SS = DOS DS (must be using a DOS internal stack)
Return: (see INT 21/AH=60h)
Note:	identical to INT 21/AH=60h
SeeAlso: AX=1123h,INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1222" name="2F1222"><b>2F1222</b></a> - INT 2F U - DOS 3.0+ internal - SET EXTENDED ERROR INFO<br />
<pre>
INT 2F U - DOS 3.0+ internal - SET EXTENDED ERROR INFO
	AX = 1222h
	SS = DOS data segment
	SS:SI -&gt; 4-byte records
		BYTE	error code, FFh = last record
		BYTE	error class, FFh = don't change
		BYTE	suggested action, FFh = don't change
		BYTE	error locus, FFh = don't change
	SDA error code set
Return: SI destroyed
	SDA error class, error locus, and suggested action fields set
Note:	can be called only from within DOS
SeeAlso: AX=122Dh,INT 21/AH=59h/BX=0000h,INT 21/AX=5D0Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1223" name="2F1223"><b>2F1223</b></a> - INT 2F U - DOS 3.0+ internal - CHECK IF CHARACTER DEVICE<br />
<pre>
INT 2F U - DOS 3.0+ internal - CHECK IF CHARACTER DEVICE
	AX = 1223h
	DS = DOS DS
	SS = DOS DS (must be using a DOS internal stack)
	SDA+218h (DOS 3.10-3.30) = eight-character blank-padded name
	SDA+22Bh (DOS 4.0-6.0) = eight-character blank-padded name
	SDA file attribute field set
	direction flag clear (i.e. CLD)
Return: CF set if no character device by that name found
	CF clear if found
	    BH bits 4-0 copied from low byte of device attribute word
	    BH bit 5 set, bits 7-6 clear
Notes:	can only be called from within DOS
	the check is skipped (always says "not device") if the volume ID bit
	  of the file attribute field is set on entry
SeeAlso: INT 21/AX=5D06h,INT 21/AX=5D0Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1224" name="2F1224"><b>2F1224</b></a> - INT 2F U - DOS 3.0+ internal - SHARING RETRY DELAY<br />
<pre>
INT 2F U - DOS 3.0+ internal - SHARING RETRY DELAY
	AX = 1224h
	SS = DOS DS (must be using a DOS internal stack)
Return: after delay set by INT 21/AX=440Bh, unless in server call
	  (INT 21/AX=5D00h)
Note:	delay is dependent on the processor speed, and is skipped entirely if
	  inside a server call
SeeAlso: INT 21/AX=440Bh,INT 21/AH=52h,INT 62/AX=0097h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1225" name="2F1225"><b>2F1225</b></a> - INT 2F U - DOS 3.0+ internal - GET LENGTH OF ASCIZ STRING<br />
<pre>
INT 2F U - DOS 3.0+ internal - GET LENGTH OF ASCIZ STRING
	AX = 1225h
	DS:SI -&gt; ASCIZ string
Return: CX = length of string
Note:	supported by DR DOS 5.0+
SeeAlso: AX=1212h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1226" name="2F1226"><b>2F1226</b></a> - INT 2F U - DOS 3.3+ internal - OPEN FILE<br />
<pre>
INT 2F U - DOS 3.3+ internal - OPEN FILE
	AX = 1226h
	CL = access mode
	DS:DX -&gt; ASCIZ filename
	SS = DOS DS (must be using a DOS internal stack)
Return: CF set on error
	    AL = error code (see #01680 at INT 21/AH=59h/BX=0000h)
	CF clear if successful
	    AX = file handle
Notes:	can only be called from within DOS
	equivalent to INT 21/AH=3Dh
	used by NLSFUNC to access COUNTRY.SYS when invoked by the DOS kernel
SeeAlso: AX=1227h,INT 21/AH=3Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1227" name="2F1227"><b>2F1227</b></a> - INT 2F U - DOS 3.3+ internal - CLOSE FILE<br />
<pre>
INT 2F U - DOS 3.3+ internal - CLOSE FILE
	AX = 1227h
	BX = file handle
	SS = DOS DS (must be using a DOS internal stack)
Return: CF set on error
	    AL = 06h invalid file handle
	CF clear if successful
Notes:	can only be called from within DOS
	equivalent to INT 21/AH=3Eh
	used by NLSFUNC to access COUNTRY.SYS when invoked by the DOS kernel
SeeAlso: AX=1106h,AX=1201h,AX=1226h,INT 21/AH=3Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1228BP4200" name="2F1228BP4200"><b>2F1228BP4200</b></a> - INT 2F U - DOS 3.3+ internal - MOVE FILE POINTER<br />
<pre>
INT 2F U - DOS 3.3+ internal - MOVE FILE POINTER
	AX = 1228h
	BP = 4200h, 4201h, 4202h (see INT 21/AH=42h)
	BX = file handle
	CX:DX = offset in bytes
	SS = DOS DS (must be using a DOS internal stack)
Return: as for INT 21/AH=42h
Notes:	equivalent to INT 21/AH=42h, but may only be called from inside a DOS
	  function call
	sets user stack frame pointer to dummy buffer, moves BP to AX, performs
	  LSEEK, and restores frame pointer
	used by NLSFUNC to access COUNTRY.SYS when invoked by the DOS kernel
SeeAlso: INT 21/AH=42h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1229" name="2F1229"><b>2F1229</b></a> - INT 2F U - DOS 3.3+ internal - READ FROM FILE<br />
<pre>
INT 2F U - DOS 3.3+ internal - READ FROM FILE
	AX = 1229h
	BX = file handle
	CX = number of bytes to read
	DS:DX -&gt; buffer
	SS = DOS DS (must be using a DOS internal stack)
Return: as for INT 21/AH=3Fh"DOS"
Notes:	equivalent to INT 21/AH=3Fh, but may only be called when already inside
	  a DOS function call
	used by NLSFUNC to access COUNTRY.SYS when invoked by the DOS kernel
SeeAlso: AX=1226h,INT 21/AH=3Fh"DOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F122A" name="2F122A"><b>2F122A</b></a> - INT 2F U - DOS 3.3+ internal - SET FASTOPEN ENTRY POINT<br />
<pre>
INT 2F U - DOS 3.3+ internal - SET FASTOPEN ENTRY POINT
	AX = 122Ah
	BX = entry point to set (0001h or 0002h)
	DS:SI -&gt; FASTOPEN entry point (see #02611,#02612)
		(entry point not set if SI = FFFFh for DOS 4.0+)
Return: CF set if specified entry point already set
Notes:	entry point in BX is ignored under DOS 3.30
	both entry points set to same handler by DOS 4.01
	DOS 5.0 and 6.0 only set entry point 1

(Table 02611)
Values DOS 3.30+ FASTOPEN entry point is called with:
	AL = 01h  Lookup
	    CX = ??? seems to be offset
	    DI = ??? seems to be offset
	    SI = offset in DOS DS of filename
	AL = 02h  insert file into FASTOPEN cache
	AL = 03h  delete file from FASTOPEN cache
	    SI = offset in DOS DS of filename
	AL = 04h  purge FASTOPEN cache
	    AH = subfunction (00h,01h,02h)
	    ES:DI -&gt; ???
	    CX = ??? (subfunctions 01h and 02h only)
Returns: CF set on error or not installed
Note: function 03h calls function 01h first
SeeAlso: #02612,#02613

(Table 02612)
Values PC-DOS 4.01 FASTOPEN is additionally called with:
	AL = 04h ???
	    AH = 03h
	    ???
	AL = 05h ???
	AL = 0Bh ???
	AL = 0Ch ???
	AL = 0Dh ???
	AL = 0Eh ???
	AL = 0Fh ???
	AL = 10h ???
SeeAlso: #02611,#02613

(Table 02613)
Values MS-DOS 5.0-6.0 FASTOPEN is additionally called with:
	AL = 04h  purge FASTOPEN cache
	    AH = 03h
	    ???
	AL = 05h ???
	    DL = drive (00h = A:)
	    ???
	AL = 06h ???
	    ???
SeeAlso: #02611,#02612

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F122B" name="2F122B"><b>2F122B</b></a> - INT 2F U - DOS 3.3+ internal - IOCTL<br />
<pre>
INT 2F U - DOS 3.3+ internal - IOCTL
	AX = 122Bh
	BP = 44xxh
	SS = DOS DS (must be using a DOS internal stack)
	additional registers as appropriate for INT 21/AX=44xxh
Return: as for INT 21/AH=44h
Notes:	equivalent to INT 21/AH=44h, but may only be called when already inside
	  a DOS function call
	sets user stack frame pointer to dummy buffer, moves BP to AX, performs
	  IOCTL, and restores frame pointer
	used by NLSFUNC in accessing COUNTRY.SYS when invoked by the DOS kernel
SeeAlso: INT 21/AH=44h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F122C" name="2F122C"><b>2F122C</b></a> - INT 2F U - DOS 3.3+ internal - GET DEVICE CHAIN<br />
<pre>
INT 2F U - DOS 3.3+ internal - GET DEVICE CHAIN
	AX = 122Ch
Return: BX:AX -&gt; header of second device driver (NUL is first) in driver chain
Note:	although this function exists in DR DOS 5.0 and Novell DOS 7, it
	  always returns 0000h:0000h prior to Novell DOS 7 Update 15
SeeAlso: INT 21/AH=52h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F122D" name="2F122D"><b>2F122D</b></a> - INT 2F U - DOS 3.3+ internal - GET EXTENDED ERROR CODE<br />
<pre>
INT 2F U - DOS 3.3+ internal - GET EXTENDED ERROR CODE
	AX = 122Dh
	SS = DOS DS
Return: AX = current extended error code
SeeAlso: AX=1222h,INT 21/AH=59h/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F122E" name="2F122E"><b>2F122E</b></a> - INT 2F U - DOS 4.0+ internal - GET OR SET ERROR TABLE ADDRESSES<br />
<pre>
INT 2F U - DOS 4.0+ internal - GET OR SET ERROR TABLE ADDRESSES
	AX = 122Eh
	DL = subfunction
	    00h get standard DOS error table (see #02614)
		Return: ES:DI -&gt; error table
				 (DOS 4: errors 00h-12h,50h-5Bh)
				 (DOS 5: errors 00h-26h,4Fh,51h-59h)
	    01h set standard DOS error table
		ES:DI -&gt; error table
	    02h get parameter error table (errors 00h-0Ah)
		Return: ES:DI -&gt; error table
	    03h set parameter error table
		ES:DI -&gt; error table
	    04h get critical/SHARE error table (errors 13h-2Bh)
		Return: ES:DI -&gt; error table
	    05h set critical/SHARE error table
		ES:DI -&gt; error table
	    06h get ??? error table
		Return: ES:DI -&gt; error table or 0000h:0000h
	    07h set ??? error table
		ES:DI -&gt; error table
	    08h get error message retriever (see #02615)
		Return: ES:DI -&gt; FAR procedure to fetch error message
	    09h set ??? error table
		ES:DI -&gt; error table
Notes:	if the returned segment on a "get" is 0001h, then the offset specifies
	  the offset of the error message table within COMMAND.COM, and the
	  procedure returned by DL=08h should be called
	DOS 5+ COMMAND.COM does not allow setting any of the addresses (calls
	  with DL odd are ignored); they are always returned with segment 0001h
	for DOS 5.0, the standard and critical/SHARE error tables are combined
	  into a single error table
SeeAlso: AX=0500h,INT 21/AH=59h/BX=0000h

Format of DOS 4.x error table:
Offset	Size	Description	(Table 02614)
 00h	BYTE	FFh
 01h  2 BYTEs	04h,00h (DOS version???)
 03h	BYTE	number of error headers following
 04h 2N WORDs	table of all error headers for table
		Offset	Size	Description
		 00h	WORD	error message number
		 02h	WORD	offset of error message from start of header
				error messages are count byte followed by msg
Note:	DOS 5 error tables consist of one word per error number; each word
	  contains either the offset of a counted string or 0000h

(Table 02615)
Call error retrieval function with:
	AX = error number (see #02616)
	DI = offset of error table
Return: ES:DI -&gt; error message (counted string)
Notes:	this function needs to access COMMAND.COM if the messages were not
	  loaded into memory permanently with /MSG; the caller should assume
	  that the returned message will be overwritten by the next call of
	  the function
	supported by DR DOS 5.0

(Table 02616)
Values for parameter errors:
 01h	Too many parameters
 02h	Required Parameter missing
 03h	Invalid switch
 04h	Invalid keyword
 06h	Parameter value not in allowed range
 07h	Parameter value not allowed
 08h	Parameter value not allowed
 09h	Parameter format not correct
 0Ah	Invalid parameter
 0Bh	Invalid parameter combination

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F122F" name="2F122F"><b>2F122F</b></a> - INT 2F U - DOS 4.x internal - SET DOS VERSION NUMBER TO RETURN<br />
<pre>
INT 2F U - DOS 4.x internal - SET DOS VERSION NUMBER TO RETURN
	AX = 122Fh
	DX = DOS version number (0000h = return true DOS version)
Notes:	not available under DR DOS 5.0 or 6.0, or Novell DOS 7
	supported by FREEVER.COM, a freeware DOS version faking TSR by Matthias
	  Paul
SeeAlso: INT 21/AH=30h,INT 21/AX=3306h,INT 2F/AX=E000h"SETDRVER"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1230" name="2F1230"><b>2F1230</b></a> - INT 2F U - Windows95 - FIND SFT ENTRY IN INTERNAL FILE TABLES<br />
<pre>
INT 2F U - Windows95 - FIND SFT ENTRY IN INTERNAL FILE TABLES
	AX = 1230h
	ES:DI -&gt; SFT entry
Return: CF clear if SFT found in internal table
	CF set if SFT not in any internal file table
	    AX = 0000h
	    SI:CX = 32-bit starting cluster number for directory
	    DX = directory entry number
	    BX = index into new file system table
Notes:	the new file system table from which the return values are taken is
	  reported to be statically allocated with 20 entries, and used only
	  for FCB calls
	this function is not supported by DR-DOS 7.03 or earlier, by S/DOS 1.0,
	  or by PTS-DOS 6.51
BUG:	Win95-OSR2 is reported to have a bug that can potentially corrupt
	  memory if SFT tables are "arranged poorly"
SeeAlso: AX=1231h,AX=1200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1231" name="2F1231"><b>2F1231</b></a> - INT 2F U - Windows95 - SET/CLEAR "REPORT WINDOWS TO DOS PROGRAMS" FLAG<br />
<pre>
INT 2F U - Windows95 - SET/CLEAR "REPORT WINDOWS TO DOS PROGRAMS" FLAG
	AX = 1231h
	DL = function
	    00h set byte after "IsWIN386" to 01h
	    01h set "IsWIN386" bit 1
	    02h clear "IsWIN386" bit 1
	    else
		Return:	CF set
			AX = 0001h
Return: CF clear
	AX = 0000h
Note:	this function is not supported by DR-DOS 7.03 or earlier, by S/DOS 1.0,
	  or by PTS-DOS 6.51
BUG:	Windows98 will crash the system if DL&gt;02h on entry due to an off-by-1
	  conditional jump; if the jump were correct, the function would return
	  CF set/AX=0001h as for Windows95
SeeAlso: AX=1230h,AX=1200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1250" name="2F1250"><b>2F1250</b></a> - INT 2F U - PTS-DOS - SET MACHINE ID<br />
<pre>
INT 2F U - PTS-DOS - SET MACHINE ID
	AX = 1250h
	???
Return: ???
Note:	This is known to be supported by Paragon Technology Systems PTS-DOS
	  sometime before 6.51, but is known not to be supported by S/DOS 1.0
	  (which derived from PTS-DOS 6.51)
SeeAlso: AX=1251h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1251" name="2F1251"><b>2F1251</b></a> - INT 2F U - PTS-DOS - GET MACHINE ID<br />
<pre>
INT 2F U - PTS-DOS - GET MACHINE ID
	AX = 1251h
	???
Return: ???
Note:	This is known to be supported by Paragon Technology Systems PTS-DOS
	  sometime before 6.51, but is known not to be supported by S/DOS 1.0
	  (which derived from PTS-DOS 6.51)
SeeAlso: AX=1250h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1252" name="2F1252"><b>2F1252</b></a> - INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - SET SFT INCREMENT<br />
<pre>
INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - SET SFT INCREMENT
	AX = 1252h
	BX = new SFT increment
Return: ???
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0 and probably was also supported
	  in earlier releases.
SeeAlso: AX=1253h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1253" name="2F1253"><b>2F1253</b></a> - INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - GET SFT INCREMENT<br />
<pre>
INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - GET SFT INCREMENT
	AX = 1253h
Return: BX = current SFT increment
	AX = ???
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0 and probably was also supported
	  in earlier releases.
SeeAlso: AX=1252h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1260" name="2F1260"><b>2F1260</b></a> - INT 2F C - PTS-DOS 6.51, S/DOS 1.0+ - "EMPTY" (RESERVED FOR INPUT STRING)<br />
<pre>
INT 2F C - PTS-DOS 6.51, S/DOS 1.0+ - "EMPTY" (RESERVED FOR INPUT STRING)
	AX = 1260h
	ES:DI -&gt; string buffer (see getstr)
	DL = extended keystroke code or FFh if ENTER
Return: AX = 0000h (default handler in the kernel)
	CF set if action done, all registers preserved
Notes:	This function is known to be handled by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also handled
	  in earlier releases.
	The default handler in the kernel justs XORs AX,AX and returns.
	This is reserved to be invoked in input string

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1261" name="2F1261"><b>2F1261</b></a> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET FIRST UMB<br />
<pre>
INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET FIRST UMB
	AX = 1261h
Return: AX = address of first UMB or 1 if invalid function.
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also supported
	  in earlier releases.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1262" name="2F1262"><b>2F1262</b></a> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET DOS COLOR<br />
<pre>
INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET DOS COLOR
	AX = 1262h
Return: AL = current video attribute used by DOS functions
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also supported
	  in earlier releases.
SeeAlso: AX=1263h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1263" name="2F1263"><b>2F1263</b></a> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - SET DOS COLOR<br />
<pre>
INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - SET DOS COLOR
	AX = 1263h
	DL = new video attribute to be used by DOS functions
Return: ???
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also supported
	  in earlier releases.
SeeAlso: AX=1262h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1270" name="2F1270"><b>2F1270</b></a> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - "SYSBELL" - EMIT A BEEP<br />
<pre>
INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - "SYSBELL" - EMIT A BEEP
	AX = 1270h
Return: ???
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also supported
	  in earlier releases.
SeeAlso: AX=1271h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1271" name="2F1271"><b>2F1271</b></a> - INT 2F C - PTS-DOS, S/DOS - RESERVED FOR BEEP<br />
<pre>
INT 2F C - PTS-DOS, S/DOS - RESERVED FOR BEEP
	AX = 1271h
Return: ???
Note:	According to the Paragon Technology Systems S/DOS 1.0 sources,
	  which derived from PTS-DOS 6.51, this is reserved for a "BEEP"
	  function. However, S/DOS 1.0 does not handle this function by
	  itself.
SeeAlso: AX=1270h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12F0" name="2F12F0"><b>2F12F0</b></a> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - BACKDOOR INTERCEPT INT 2Fh CHAIN<br />
<pre>
INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - BACKDOOR INTERCEPT INT 2Fh CHAIN
	AX = 12F0h
	CX:DX -&gt; user INT 2F handler
	CF set
Return: CF clear if successful
	    CX:DX -&gt; previous INT 2F handler
	CF set on error
Notes:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also supported
	  in earlier releases.  It is handled from within the kernel's
	  INT 2Fh dispatcher.
	Resident system extensions should call INT 2Fh/12F0h to intercept
	  the INT 2Fh chain. The main idea of this call is to allow them to
	  be moved to the HMA and intercept INT 2Fh without querying A20 state
	  and without interception of the INT2Fh vector. This is why the
	  "Chain2F" variable must be instanced by placing it to the SDA.
	On chain entry of the far procedure, CF must be set.  All registers
	  except for AX, BP, and DS remain unchanged. If a handler cannot
	  process the call, it must set CF and do a far jump to the previous
	  one in the chain in order to indicate an error.  If CF is still set
	  on exit, the call will be ignored.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12F1" name="2F12F1"><b>2F12F1</b></a> - INT 2F - PTS-DOS, S/DOS - RESERVED<br />
<pre>
INT 2F - PTS-DOS, S/DOS - RESERVED
	AX = 12F1h-12FFh
Return: ???
Note:	According to the Paragon Technology Systems S/DOS 1.0 sources,
	  which derived from PTS-DOS 6.51, these functions are reserved for
	  future use. However, S/DOS 1.0 does not make use of them itself.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL00" name="2F12FFBL00"><b>2F12FFBL00</b></a> - INT 2F - FreeDOS - FDAK-DDT - INSTALLATION CHECK / STATUS CHECK<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - INSTALLATION CHECK / STATUS CHECK
	AX = 12FFh
	BL = 00h
Return: AL = DDh if installed
	    BH = state (00h disabled, nonzero enabled)
	    BL = readonly flag (00h writable, nonzero read-only)
Program: FDAK-DDT is the FreeDOS Alternative Kernel Device Drivers Testing
	  release by Yury A. Semenov
SeeAlso: AX=12FFh/BL=07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL01" name="2F12FFBL01"><b>2F12FFBL01</b></a> - INT 2F - FreeDOS - FDAK-DDT - ENABLE FDAK DRIVERS<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - ENABLE FDAK DRIVERS
	AX = 12FFh
	BL = 01h
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL02" name="2F12FFBL02"><b>2F12FFBL02</b></a> - INT 2F - FreeDOS - FDAK-DDT - DISABLE FDAK DRIVERS<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - DISABLE FDAK DRIVERS
	AX = 12FFh
	BL = 02h
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL03" name="2F12FFBL03"><b>2F12FFBL03</b></a> - INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-ONLY<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-ONLY
	AX = 12FFh
	BL = 03h
	???
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL04" name="2F12FFBL04"><b>2F12FFBL04</b></a> - INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-WRITE<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-WRITE
	AX = 12FFh
	BL = 04h
	???
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL05" name="2F12FFBL05"><b>2F12FFBL05</b></a> - INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR ON<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR ON
	AX = 12FFh
	BL = 05h
Note:	not yet implemented as of January 1996
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL06" name="2F12FFBL06"><b>2F12FFBL06</b></a> - INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR OFF<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR OFF
	AX = 12FFh
	BL = 06h
Note:	not yet implemented as of January 1996
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL07" name="2F12FFBL07"><b>2F12FFBL07</b></a> - INT 2F - FreeDOS - FDAK-DDT - UNINSTALL<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - UNINSTALL
	AX = 12FFh
	BL = 07h
Return: ES = segment of FDAK memory block
Note:	the caller must free the memory block returned in ES
	  (via INT 21/AH=49h)
SeeAlso: AX=12FFh/BL=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0000" name="2F12FFBX0000"><b>2F12FFBX0000</b></a> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BDOS<br />
<pre>
INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BDOS
	AX = 12FFh
	BX = 0000h
Return: AX = 0000h if supported
	DX = size of the BDOS in paragraphs
	Flags trashed
	ES,CL destroyed (DR PalmDOS)
Note:	This API is provided by IBMBIO.COM for the initialization phase
	  of drivers loaded via DEVICE=/HIDEVICE=/DEVICEHIGH= directives and
	  is only available during these short time intervals.  It is called
	  by DR DOS 6.0 EMM386.SYS and Novell DOS 7+ EMM386.EXE to query the
	  size of the BDOS kernel (the resident code of IBMDOS.COM).
SeeAlso: AX=12FFh/BX=0001h,AX=12FFh/BX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0001" name="2F12FFBX0001"><b>2F12FFBX0001</b></a> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BDOS<br />
<pre>
INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BDOS
	AX = 12FFh
	BX = 0001h
	CX = 0000h (DR PalmDOS)
	DX = segment to relocate to (FFFFh for HMA)
Return: AX = 0000h if supported
	Flags trashed
	BX,CX,DX,DI,SI,DS,ES destroyed (DR PalmDOS)
Notes:	This API is provided by IBMBIO.COM for the initialization phase
	  of drivers loaded via DEVICE=/HIDEVICE=/DEVICEHIGH= directives and
	  is only available during these short time intervals.  It is initiated
	  by DR DOS 6.0 EMM386.SYS and Novell DOS 7+ EMM386.EXE to relocate
	  the BDOS kernel (e.g. into the HMA).
	This call is also issued by DR PalmDOS IBMBIO.COM which explicitly
	  clears CX.
	Under Novell DOS 7+ the actual relocation takes place at a later
	  stage, but under DR PalmDOS the BDOS is relocated immediately.
SeeAlso: AX=12FFh/BX=0000h,AX=12FFh/BX=0003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0002" name="2F12FFBX0002"><b>2F12FFBX0002</b></a> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BIOS<br />
<pre>
INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BIOS
	AX = 12FFh
	BX = 0002h
Return: AX = 0000h if supported
	DX = size of the DOS BIOS in paragraphs
	CL and flags trashed
Note:	This API is provided by IBMBIO.COM for the initialization phase
	  of drivers loaded via DEVICE=/HIDEVICE=/DEVICEHIGH= directives and
	  is only available during these short time intervals. It is called
	  by DR DOS 6.0 EMM386.SYS and Novell DOS 7 EMM386.EXE to query the
	  size of the DOS BIOS (the resident code of IBMBIO.COM).
SeeAlso: AX=12FFh/BX=0000h,AX=12FFh/BX=0003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0003" name="2F12FFBX0003"><b>2F12FFBX0003</b></a> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BIOS<br />
<pre>
INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BIOS
	AX = 12FFh
	BX = 0003h
	CX = 0000h (DR PalmDOS)
	DX = segment to relocate to (FFFFh for HMA)
Return: AX = 0000h if supported
	Flags trashed
Notes:	This API is provided by IBMBIO.COM for the initialization phase
	  is only available during these short time intervals.  It is initiated
	  by DR DOS 6.0 EMM386.SYS and Novell DOS 7 EMM386.EXE to relocate the
	  resident part of the DOS BIOS.  The actual relocation takes place at
	  a later stage.
	This call is also issued by DR PalmDOS IBMBIO.COM which explicitly
	  clears CX.
SeeAlso: AX=12FFh/BX=0001h,AX=12FFh/BX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0005" name="2F12FFBX0005"><b>2F12FFBX0005</b></a> - INT 2F U - DR DOS 6.0+ - BOOT PHASE BROADCASTS FOR MEMORYMAX/RPLOADER/SECURITY<br />
<pre>
INT 2F U - DR DOS 6.0+ - BOOT PHASE BROADCASTS FOR MEMORYMAX/RPLOADER/SECURITY
	AX = 12FFh
	BX = 0005h
	CX = 0000h
	DX = function
	    0000h MemoryMAX cleanup broadcast
	    0001h RPLOADER broadcast
	    !!! details to follow
Note:	called at three separate points inside IBMBIO.COM

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0006" name="2F12FFBX0006"><b>2F12FFBX0006</b></a> - INT 2F U - DR DOS 6+, Novell DOS 7+ - EMM386.EXE - VIDEO MEMORY SPACE CONTROL<br />
<pre>
INT 2F U - DR DOS 6+, Novell DOS 7+ - EMM386.EXE - VIDEO MEMORY SPACE CONTROL
	AX = 12FFh
	BX = 0006h
	DX = 0000h
	CX = function
	    0000h get status of video memory space (MEMMAX /V)
	    0001h map memory into video memory space (MEMMAX +V)
	    0002h unmap memory from video memory space (MEMMAX -V)
Return: CF clear if successful
	    AX = 0000h (successful)
	    BX = segment of reserved video RAM
	    CX = segment of used video RAM
	    DX = segment of first upper MCB
Notes:	this functionality is provided by EMM386, and partially supported by
	  HIDOS.SYS
	BL specifies which program handles the call, BH is the function number
BUG:	4DOS 5.51(a) often hangs the system (reported to be reproducable), if
	  MEMMAX +V is issued from the 4DOS prompt.  To avoid this, one should
	  temporary load COMMAND.COM followed by MEMMAX +v , starting the
	  application, MEMMAX -v and EXIT.  4DOS 5.5c does not show this
	  phenomena on the same systems where 5.51a hangs.
SeeAlso: AX=D201h/BX=4849h

(Table 04105)
Values for DR DOS memory space control error code:
 00h	successful
 80h	video memory already unmapped
 81h	video memory already mapped
 82h	no video memory reserved (/VIDEO not specified)
 83h	video memory in use (graphics mode or non-standard text mode)
 84h	mapped video memory contains allocated arena(s)
 85h	hardware error
 86h	driver requires protected mode but is permanently in real mode
	  ("EMM386 OFF")

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0007" name="2F12FFBX0007"><b>2F12FFBX0007</b></a> - INT 2F U - Novell DOS 7 - SCRIPT.EXE - GET ???<br />
<pre>
INT 2F U - Novell DOS 7 - SCRIPT.EXE - GET ???
	AX = 12FFh
	BX = 0007h
	CX = 0000h
Return: CF clear if installed
	    AX = 0000h
	    BX = ??? (4426h)
	    CX = ??? (0068h)
	    DX = PSP segment of resident code???
	    SI = ??? (4AFAh)
	    ES = resident code segment

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0009" name="2F12FFBX0009"><b>2F12FFBX0009</b></a> - INT 2F - DR DOS 6.0+ IBMBIO.COM - REGISTER ROOT OF UPPER MEMORY LINK<br />
<pre>
INT 2F - DR DOS 6.0+ IBMBIO.COM - REGISTER ROOT OF UPPER MEMORY LINK
	AX = 12FFh
	BX = 0009h
	DX = new value for root segment of upper memory link
Return: AX = 0000h if supported
	ES:BX modified
Notes:	the DX value is stored at offset 66h in SYSVARS (see INT 21h/AH=52h)
	  and offset 18h in the Novell DOS 7 internal variable table
	  (see INT 21/AX=4458h)
	This API is provided by IBMBIO.COM for the initialization phase
	  of drivers loaded via DEVICE=/HIDEVICE=/DEVICEHIGH= directives and
	  is only available during these short time intervals.  It is probably
	  initiated by the Novell DOS 7+ EMM386.EXE.
	this function has apparently been supported since DR DOS 6.0 "Buxton"
	  of 1991/03/19
	for Novell DOS 7, ES:BX points at the internal variable table DRDAT,
	  but this may change in future releases

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0106" name="2F12FFBX0106"><b>2F12FFBX0106</b></a> - INT 2F U - Novell DOS 7+ - MEMORYMAX INSTALLATION CHECK<br />
<pre>
INT 2F U - Novell DOS 7+ - MEMORYMAX INSTALLATION CHECK
	AX = 12FFh
	BX = 0106h
Return: CF clear if successful
	    AX = 0000h (successful)
	    BX = EDC0h (signature "European Development Centre")
	    CL = memory manager variant
		00h if HIMEM.SYS present
		01h if EMMXMA.SYS present
		02h if EMM386.EXE present (DPMI/VCPI disabled)
		03h if multitasking EMM386.EXE present (DPMI/VCPI loaded)
	    CH = ??? (00h)
	    DX = binary driver version, DH is major, DL is minor
	    ES = segment of EMM386 device driver header (low-memory stub)
	CF set on error
	    AX = 0001h
Notes:	BL specifies which program handles the call, BH is the function number
	if the word at ES:0012h is nonzero, if contains the offset within
	  segment ES of the CEMM-compatible entry point (see #02617)
	if no other program has hooked INT 67, an alternate installation
	  check is to test for the string
	  "NOVELL EXPANDED MEMORY MANAGER 386" at offset 14h in the INT 67
	  handler's segment; the word immediately preceding this string
	  contains the offset of the API entry point if it is nonzero
Index:	entry point;Novell EMM386

(Table 02617)
Call Novell EMM386.EXE entry point with:
	AH = 00h get memory manager's status???
	    ???
	AH = 01h set memory manager's status???
	    ???
	AH = 02h Weitek coprocessor support???
	    AL = subfunction???
	more functions???
SeeAlso: #01513 at INT 21/AX=4402h/SF=02h,#03666 at INT 67/AX=FFA5h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0206" name="2F12FFBX0206"><b>2F12FFBX0206</b></a> - INT 2F - Novell DOS 7+ - MEMORYMAX GET PAGE TABLE ENTRY<br />
<pre>
INT 2F - Novell DOS 7+ - MEMORYMAX GET PAGE TABLE ENTRY
	AX = 12FFh
	BX = 0206h
	ESI = linear address
Return: CF clear if successful
	    AX = 0000h (successful)
	    CX = 0000h
	    EDI = page table entry
	CF set on error
	    AX = function status
		0000h function supported
		    CX error code
		       80h if linear address has no mapping
	        0001h (AX &gt; 0) function not supported
		    CX undefined
Note:	This function is supported by Novell DOS 7+ EMM386.EXE 3.0+ and
	  possibly by HIMEM.SYS 2.3+.
SeeAlso: AX=12FFh/BX=0306h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0306" name="2F12FFBX0306"><b>2F12FFBX0306</b></a> - INT 2F - Novell DOS 7+ - MEMORYMAX SET PAGE TABLE ENTRY<br />
<pre>
INT 2F - Novell DOS 7+ - MEMORYMAX SET PAGE TABLE ENTRY
	AX = 12FFh
	BX = 0306h
	ESI = linear address
	EDI = page table entry
Return: CF clear if successful
	    AX = 0000h (successful)
	    CX = 0000h
	CF set on error
	    AX = function status
		0000h function supported
		    CX error code
		       80h if linear address has no mapping
	        0001h (AX &gt; 0) function not supported
		    CX undefined
Note:	This function is supported by Novell DOS 7+ EMM386.EXE 3.0+ and
	  possibly by HIMEM.SYS 2.3+.
SeeAlso: AX=12FFh/BX=0206h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0406" name="2F12FFBX0406"><b>2F12FFBX0406</b></a> - INT 2F - Novell DOS 7+ - MEMORYMAX CREATE ACCESS KEY<br />
<pre>
INT 2F - Novell DOS 7+ - MEMORYMAX CREATE ACCESS KEY
	AX = 12FFh
	BX = 0406h
Return: CF clear if successful
	    AX = 0000h (successful)
	    CX = 0000h
	    SI:DI = access key
	CF set on error
	    AX = function status
		0000h function supported
		    CX error code
		       80h if access key already exists
	        0001h (AX &gt; 0) function not supported
		    CX undefined
Note:	This function is supported by Novell DOS 7+ EMM386.EXE 3.0+ and
	  possibly by HIMEM.SYS 2.3+.
SeeAlso: AX=12FFh/BX=0506h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0506" name="2F12FFBX0506"><b>2F12FFBX0506</b></a> - INT 2F - Novell DOS 7+ - MEMORYMAX DESTROY ACCESS KEY<br />
<pre>
INT 2F - Novell DOS 7+ - MEMORYMAX DESTROY ACCESS KEY
	AX = 12FFh
	BX = 0506h
	SI:DI = access key
Return: CF clear if successful
	    AX = 0000h (successful)
	    CX = 0000h
	CF set on error
	    AX = function status
		0000h function supported
		    CX error code
		       80h if invalid access key
		       81h if no access key exists
	        0001h (AX &gt; 0) function not supported
		    CX undefined
Note:	This function is supported by Novell DOS 7+ EMM386.EXE 3.0+ and
	  possibly by HIMEM.SYS 2.3+.
SeeAlso: AX=12FFh/BX=0406h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL06_0" name="2F12FFBL06_0"><b>2F12FFBL06</b></a> - INT 2F U - Novell DOS 7 - EMM386.EXE - ???<br />
<pre>
INT 2F U - Novell DOS 7 - EMM386.EXE - ???
	AX = 12FFh
	BL = 06h
	BH = function (06h-09h)
	???
Return: CF clear if successful
	CF set on error
	    AX = function status
		0000h function supported
		    CX error code
	        0001h (AX &gt; 0) function not supported
		    CX undefined

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0EDC" name="2F12FFBX0EDC"><b>2F12FFBX0EDC</b></a> - INT 2F U - Novell DOS 7 - EMM386.EXE - CHECK IF MULTITASKING SUPPORT LOADED???<br />
<pre>
INT 2F U - Novell DOS 7 - EMM386.EXE - CHECK IF MULTITASKING SUPPORT LOADED???
	AX = 12FFh
	BX = 0EDCh ('EDC' = Novell European Development Center)
Return: AX = 0000h if ??? loaded
	    CF clear
	    BX = 0000h
Notes:	called by Novell DOS 7 TaskMgr
	if this function returns with AX=0000h, then the code necessary to
	  support the API on INT 2F/AX=2780h is loaded and that API becomes
	  available for use
	because the request is handled on the initial trap to the memory
	  manager caused by INT instructions, this function must be invoked
	  with an actual INT 2F instruction instead of some simulation such
	  as a far call to the address in the interrupt vector table
SeeAlso: AX=2780h/CL=01h,AX=2780h/CL=02h,AX=2780h/CL=03h,AX=2780h/CL=04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F13" name="2F13"><b>2F13</b></a> - INT 2F U - DOS 3.2+ - SET DISK INTERRUPT HANDLER<br />
<pre>
INT 2F U - DOS 3.2+ - SET DISK INTERRUPT HANDLER
	AH = 13h
	DS:DX -&gt; interrupt handler disk driver calls on read/write
	ES:BX = address to restore INT 13 to on system halt (exit from root
		 shell) or warm boot (INT 19)
Return: DS:DX set by previous invocation of this function
	ES:BX set by previous invocation of this function
Notes:	IO.SYS hooks INT 13 and inserts one or more filters ahead of the
	  original INT 13 handler.  The first is for disk change detection
	  on floppy drives, the second is for tracking formatting calls and
	  correcting DMA boundary errors, the third is for working around
	  problems in a particular version of IBM's ROM BIOS
	before the first call, ES:BX points at the original BIOS INT 13; DS:DX
	  also points there unless IO.SYS has installed a special filter for
	  hard disk reads (on systems with model byte FCh and BIOS date
	  "01/10/84" only), in which case it points at the special filter
	most DOS 3.2+ disk access is via the vector in DS:DX, although a few
	  functions are still invoked via an INT 13 instruction
	during Windows 3.1 startup this function seems to be used to
	  temporarily point DOS to a dummy handler in WDCTRL.386 which always
	  halts the system with a fatal error message.	If DS hasn't changed
	  on return from the function, Windows will display the error message
	  "Invalid DOS version".
	this is a dangerous security loophole for any virus-monitoring software
	  which does not trap this call ("INT13", "Nomenklatura", and many
	  Bulgarian viruses are known to use it to get the original ROM entry
	  point)
	the preloadable Novell DOS 7+ SECURITY.BIN driver $SECURE$ traps
	  this call.
BUG:	Novell DOS 7 IBMBIO.COM before 1995-05-08 trashed AX on return from
	  this function. VGACOPY by Thomas Mnkemeier's VGA Software GmbH
	  crashed due to this.	Later releases of Novell DOS 7 preserved the
	  contents of the AX register.
SeeAlso: INT 13/AH=01h,INT 19,INT 9D"VIRUS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F13_0" name="2F13_0"><b>2F13</b></a> - INT 2F U - MS-NET - ???<br />
<pre>
INT 2F U - MS-NET - ???
	AH = 13h
	???
Return: ???
Note:	supposedly used to move (or control the movement of) NCBs

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1400" name="2F1400"><b>2F1400</b></a> - INT 2F C - NLSFUNC.COM - INSTALLATION CHECK<br />
<pre>
INT 2F C - NLSFUNC.COM - INSTALLATION CHECK
	AX = 1400h
	BX &lt;&gt; 0EDCh
Return: AL = status
	    00h not installed, OK to install
	    01h not installed, not OK to install
	    FFh installed
Notes:	this function is called by the DOS v3.3+ kernel
	supported by OS/2 v1.3+ compatibility box, which always returns AL=FFh
	supported by DR DOS 5.0+ NLSFUNC v3.0+
	documented for MS-DOS 5+, but undocumented in prior versions
	DR DOS 5.0+ NLSFUNC 3.00+ returns CF set and AX=0001h, if AL was not
	  00h, FEh, or FFh on entry.
SeeAlso: AX=1400h/BX=0EDCh,AX=1401h"NLSFUNC",AX=1402h"NLSFUNC"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1400BX0EDC" name="2F1400BX0EDC"><b>2F1400BX0EDC</b></a> - INT 2Fh - DR-DOS NLSFUNC 4.01+ - ENHANCED INSTALLATION CHECK<br />
<pre>
INT 2Fh - DR-DOS NLSFUNC 4.01+ - ENHANCED INSTALLATION CHECK
	AX = 1400h
	BX = 0EDCh
Return: AL = status
	    00h not installed, OK to install
	    01h not installed, not OK to install
		  (for example under a multitasker)
	    FFh installed
		ES:DI -&gt; version signature ("4.01$".."4.04$" for 4.01..4.04)
	flags may be destroyed
Program: NLSFUNC 4.01+ is currently an independent project under
	  development by Matthias Paul. It is not yet publically available,
	  but as NLSFUNC 4.00 did, it will probably become available with
	  future DR-DOS releases.
Notes:	If BX &lt;&gt; 0EDCh on entry, DR-DOS NLSFUNC 4.01+ performs the standard
	  installation check (INT 2F/AX=1400h), and does not change ES:DI.
	DR DOS 5.0+ NLSFUNC 3.00+ returns CF set and AX=0001h, if AL was not
	  00h, FEh, or FFh on entry.
	NLSFUNC 4.01+ will use the ES:DI enhancement to check the driver
	  version and calculate displacements into the resident driver for
	  runtime updates of internal structures like the local NLS database
	  filespec, etc.
	If the returned ES points into the HMA (ES=FFFEh) care should be taken
	  to actually access the HMA while checking the version signature and
	  updating resident data (mutex with local A20 enable/disable).
	While previous issues of NLSFUNC installed under a multitasker,
	  DR-DOS NLSFUNC 4.01+ will actually adapt to work properly in this
	  environment.
SeeAlso: AX=1400h"NLSFUNC.COM",AX=14FEh,AX=14FFh,INT 21/AH=65h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1400_0" name="2F1400_0"><b>2F1400</b></a> - INT 2F - European MS-DOS 4.0 POPUP - "CheckPu" - INSTALLATION CHECK<br />
<pre>
INT 2F - European MS-DOS 4.0 POPUP - "CheckPu" - INSTALLATION CHECK
	AX = 1400h
Return: AX = FFFFh if installed
	    BX = maximum memory required to save screen and keyboard info
	CF clear if successful
	CF set on error
	    AX = error code
		0002h invalid function
		0004h unknown error
Note:	the POPUP interface is used by background programs (see INT 21/AH=80h)
	  to communicate with the user
SeeAlso: AX=1401h"POPUP",AX=1402h"POPUP",AX=1403h"POPUP"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1401" name="2F1401"><b>2F1401</b></a> - INT 2F CU - NLSFUNC.COM - CHANGE CODE PAGE<br />
<pre>
INT 2F CU - NLSFUNC.COM - CHANGE CODE PAGE
	AX = 1401h
	DS:SI -&gt; internal code page structure (see #02618)
	BX = new code page (see #01757 at INT 21/AX=6602h)
	DX = country code???
Return: AL = status
	     00h successful
	     else DOS error code
Note:	this function is called by the DOS v3.3+ kernel
SeeAlso: AX=1400h"NLSFUNC",AX=1402h"NLSFUNC",INT 21/AH=66h

Format of DOS 3.30 internal code page structure:
Offset	Size	Description	(Table 02618)
 00h  8 BYTEs	???
 08h 64 BYTEs	name of country information file (see #02619)
 48h	WORD	system code page (see #01757 at INT 21/AX=6602h)
 4Ah	WORD	number of supported subfunctions
 4Ch  5 BYTEs	data to return for INT 21/AX=6502h
 51h  5 BYTEs	data to return for INT 21/AX=6504h
 56h  5 BYTEs	data to return for INT 21/AX=6505h
 5Bh  5 BYTEs	data to return for INT 21/AX=6506h
 60h 41 BYTEs	data to return for INT 21/AX=6501h

Format of MS-DOS/PC-DOS/OS2/WinNT/PTS-DOS COUNTRY.SYS file:
Offset	Size	Description	(Table 02619)
 00h	BYTE	ID tag (FFh)
 01h  7 BYTEs	ASCII "COUNTRY"
 08h  8 BYTEs	??? (00h)
 10h	BYTE	??? (01h)
 11h	BYTE	??? (00h)
 12h	BYTE	??? (01h)
 13h	DWORD	offset of first entry in file (see #02620)
SeeAlso: #02623

Format of MS-DOS/PC-DOS/OS2/WinNT/PTS-DOS COUNTRY.SYS entry:
Offset	Size	Description	(Table 02620)
 00h	WORD	number of country-codepage entries following
 02h		N Country-Codepage entries:
		Offset	Size	Description
		 00h	WORD	length of entry, not counting this word (000Ch)
		 02h	WORD	country ID
		 04h	WORD	codepage ID
		 06h	WORD	??? (0000h)
		 08h	WORD	??? (0000h)
		 0Ah	DWORD	offset of country-subfunction-header in file
				  (see #02621)
Notes:	multiple codepages for a country are stored consecutively
	PTS/DOS places a copyright string immediately following this structure,
	  though a copyright at the end of the file is preferable
SeeAlso: #02619

Format of MS-DOS/PC-DOS/OS2/WinNT/PTS-DOS COUNTRY.SYS country-subfunc header:
Offset	Size	Description	(Table 02621)
 00h	WORD	number of subfunction entries following
 02h		N subfunction entries
		Offset	Size	Description
		 00h	WORD	length of subfunction entry, not counting this
				  word (usually 06h)
		 02h	WORD	subfunction ID
				(value passed to INT 21/AH=65h in AL)
		 04h	DWORD	offset within file of subfunction data entry
				  (see #02622)
SeeAlso: #02620

Format of MS-DOS/PC-DOS/OS2/WinNT/PTS-DOS COUNTRY.SYS country-subfunc data::
Offset	Size	Description	(Table 02622)
 00h	BYTE	ID-tag (FFh)
 01h  7 BYTEs	table-type signature (blank-padded)
		"CTYINFO"	general country info (subfn 01h)
		"UCASE	"	uppercase table (subfn 02h)
		"LCASE	"	lowercase table (subfn 03h) (DOS 6.2_)
		"FUCASE "	filename uppercase table (subfn 04h)
		"FCHAR	"	filename terminator table (subfn 05h)
		"COLLATE"	collating sequence (subfn 06h)
		"DBCS	"	double-byte character table (subfn 07h)
 08h	WORD	length of following table in bytes
		(if 0000h for DBCS table, there will still be a word of 0000h)
---country info (01h)---
 0Ah	WORD	country ID (see #01400 at AH=38h)
 0Ch	WORD	code page (see #01757)
 0Eh 34 BYTEs	country-dependent info (see #01399 at AH=38h)
---uppercase table (02h)---
 0Ah 128 BYTEs	uppercase equivalents (if any) of chars 80h to FFh
---lowercase table (03h)---
 0Ah 256 BYTEs	lowercase equivalents (if any) of chars 00h to FFh
---filename uppercase table (04h)---
 0Ah 128 BYTEs	uppercase equivalents (if any) of chars 80h to FFh
---filename terminator table (05h)---
 0Ah	BYTE	??? (01h for MS-DOS 3.30-6.00)
 0Bh	BYTE	lowest permissible character value for filename
 0Ch	BYTE	highest permissible character value for filename
 0Dh	BYTE	??? (00h for MS-DOS 3.30-6.00)
 0Eh	BYTE	first excluded character in range \ all characters in this
 0Fh	BYTE	last excluded character in range  / range are illegal
 10h	BYTE	??? (02h for MS-DOS 3.30-6.00)
 11h	BYTE	number of illegal (terminator) characters
 12h  N BYTEs	characters which terminate a filename:	."/\[]:|&lt;&gt;+=;,
---collating sequence (06h)---
 0Ah 256 BYTEs	values used to sort characters 00h to FFh
---DBCS table (07h)---
 0Ah 2N BYTEs	start/end for N lead byte ranges
	WORD	0000h	(end of table)
SeeAlso: #02621,#01750,#01751,#01753,#01754,#01755,#01756

Format of DR DOS/Novell DOS/OpenDOS COUNTRY.SYS file:
Offset	Size	Description	(Table 02623)
 00h 126 BYTEs	copyright notice (terminated with Ctrl-Z; NUL-padded)
		the copyright notice starts with the signature
		"COUNTRY.SYS Rx.xx" where "x.xx" indicates the file format
		revision, which is checked by the OS (revision is 2.00 for
		DR DOS 3.41 and 2.01 for all newer versions of DR DOS,
		Novell DOS, and OpenDOS)
 7Eh	WORD	signature of file format revision
		0EDCh = 2.00 (DR DOS 3.41)
		EDC1h = 2.01 (all newer versions)
 80h	var	country pointer records (see #02624)
		(packed array of variable-size records)
SeeAlso: #02619

Format of DR DOS/Novell DOS/OpenDOS COUNTRY.SYS country pointer record::
Offset	Size	Description	(Table 02624)
 00h	WORD	country code (0000h if end of array)
 02h	WORD	code page (see #01757)
 04h	WORD	??? (0000h)
 06h  7	WORDs	offsets in file for INT 21/AH=65h subfunctions 01h to 07h, or
		  0000h if no table for that subfunction
 14h	var	country information
Notes:	the end-of-file marker is a country pointer record filled entirely with
	  zeros
	the data at which the pointers point is in the same format as the
	  tables returned by INT 21/AH=65h, except that the general-info
	  table for subfunction 01h does not contain the length word at the
	  beginning
SeeAlso: #02623

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1401_0" name="2F1401_0"><b>2F1401</b></a> - INT 2F - European MS-DOS 4.0 POPUP - "PostPu" - OPEN/CLOSE POPUP SCREEN<br />
<pre>
INT 2F - European MS-DOS 4.0 POPUP - "PostPu" - OPEN/CLOSE POPUP SCREEN
	AX = 1401h
	DL = function (00h open, 01h close)
	DH = wait flag
	    00h block until screen opens
	    01h return error if screen is not available
	    02h urgent--always open screen immediately
Return: CF clear if successful
	    BX = amount of memory needed to save screen and keyboard info,
		0000h if default save location can be used (only if DH was 02h)
	CF set on error
Note:	the application using the screen is frozen until the popup screen is
	  closed
SeeAlso: AX=1400h"POPUP",AX=1402h"POPUP",AX=1403h"POPUP"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1402" name="2F1402"><b>2F1402</b></a> - INT 2F CU - NLSFUNC.COM - GET EXTENDED COUNTRY INFO<br />
<pre>
INT 2F CU - NLSFUNC.COM - GET EXTENDED COUNTRY INFO
	AX = 1402h
	BP = subfunction (same as AL for INT 21/AH=65h)
	BX = code page (see #01757 at INT 21/AX=6602h)
	DX = country code (see #01400 at INT 21/AH=38h)
	DS:SI -&gt; internal code page structure (see #02618)
	ES:DI -&gt; user buffer
	CX = size of user buffer
Return: AL = status
	    00h successful
	    else DOS error code
Notes:	this function is called by the DOS v3.3+ kernel on INT 21/AH=65h
	code page structure apparently only needed for COUNTRY.SYS pathname
SeeAlso: AX=1401h"NLSFUNC",AX=1403h"NLSFUNC",AX=1404h,INT 21/AH=65h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1402_0" name="2F1402_0"><b>2F1402</b></a> - INT 2F - European MS-DOS 4.0 POPUP - "SavePu" - SAVE POPUP SCREEN<br />
<pre>
INT 2F - European MS-DOS 4.0 POPUP - "SavePu" - SAVE POPUP SCREEN
	AX = 1402h
	ES:DI -&gt; save buffer (0000h:0000h for default buffer in POPUP)
Return: CF clear if successful
	CF set on error
	    AX = error code (see #02625)
SeeAlso: AX=1400h"POPUP",AX=1401h"POPUP",AX=1403h"POPUP"

(Table 02625)
Values for POPUP error code:
 0001h	process does not own screen
 0004h	unknown error
 0005h	invalid pointer

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1403" name="2F1403"><b>2F1403</b></a> - INT 2F CU - NLSFUNC.COM - SET CODE PAGE<br />
<pre>
INT 2F CU - NLSFUNC.COM - SET CODE PAGE
	AX = 1403h
	DS:SI -&gt; internal code page structure (see #02618)
	BX = code page (see #01757 at INT 21/AX=6602h)
	DX = country code (see #01400 at INT 21/AH=38h)
Return: AL = status
	     ???
Note:	this function is called by the DOS v3.3+ kernel on INT 21/AH=38h
SeeAlso: AX=1402h"NLSFUNC",AX=1404h,INT 21/AH=38h"SET"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1403_0" name="2F1403_0"><b>2F1403</b></a> - INT 2F - European MS-DOS 4.0 POPUP - "RestorePu" - RESTORE SCREEN<br />
<pre>
INT 2F - European MS-DOS 4.0 POPUP - "RestorePu" - RESTORE SCREEN
	AX = 1403h
	ES:DI -&gt; buffer containing saved screen
		(0000h:0000h for default buffer in POPUP)
Return: CF clear if successful
	CF set on error
	    AX = error code (see #02625)
SeeAlso: AX=1400h"POPUP",AX=1401h"POPUP",AX=1402h"POPUP"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1404" name="2F1404"><b>2F1404</b></a> - INT 2F CU - NLSFUNC.COM - GET COUNTRY INFO<br />
<pre>
INT 2F CU - NLSFUNC.COM - GET COUNTRY INFO
	AX = 1404h
	BX = code page (see #01757 at INT 21/AX=6602h)
	DX = country code (see #01400 at INT 21/AH=38h)
	DS:SI -&gt; internal code page structure (see #02618)
	ES:DI -&gt; user buffer
Return: AL = status
	     ???
Notes:	this function is called by the DOS v3.3+ kernel on INT 21/AH=38h
	code page structure apparently only needed for COUNTRY.SYS pathname
SeeAlso: AX=1402h,AX=1403h,INT 21/AH=38h"GET"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F14FE" name="2F14FE"><b>2F14FE</b></a> - INT 2F U - DR DOS 5.0 NLSFUNC - GET EXTENDED COUNTRY INFORMATION<br />
<pre>
INT 2F U - DR DOS 5.0 NLSFUNC - GET EXTENDED COUNTRY INFORMATION
	AX = 14FEh
	BX = code page (FFFFh=global code page) (see #01757 at INT 21/AX=6602h)
	DX = country ID (FFFFh=current country) (see #01400 at INT 21/AH=38h)
	ES:DI -&gt; country information buffer
	CL = info ID
	    01h get general internationalization info
	    02h get pointer to uppercase table
	    04h get pointer to filename uppercase table
	    05h get pointer to filename terminator table
	    06h get pointer to collating sequence table
	    07h get pointer to Double-Byte Character Set table
	CF set (used to return error if not installed)
Return: CF clear if successful
	    DS:SI -&gt; requested information
	CF set on error
Notes:	DR DOS 5.0 NLSFUNC returns CF set and AX=0001h if AL was not 00h, FEh,
	  or FFh on entry.
	the DR DOS kernel calls this function on INT 21/AX=6501h
	the value in CL is not range-checked by the DR DOS 5.0 NLSFUNC
SeeAlso: #02626,AX=14FFh,INT 21/AH=65h

Format of DR DOS COUNTRY.SYS file:
Offset	Size	Description	(Table 02626)
 00h 126 BYTEs	copyright notice (terminated with Ctrl-Z, padded with NULs)
 7Eh	WORD	signature EDC1h
 80h	var	country pointer records
	Offset	Size	Description
	 00h	WORD	country code (0000h if end of array)
	 02h	WORD	code page (see #01757 at INT 21/AX=6602h)
	 04h	WORD	??? (0000h)
	 06h  7 WORDs	offsets in file for data tables for subfunctions
			  01h-07h
 var	var	country information

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F14FF" name="2F14FF"><b>2F14FF</b></a> - INT 2F U - DR DOS 5.0+ NLSFUNC - PREPARE CODE PAGE<br />
<pre>
INT 2F U - DR DOS 5.0+ NLSFUNC - PREPARE CODE PAGE
	AX = 14FFh
	BX = code page (see #01757 at INT 21/AX=6602h)
Return: AX = ???
	ZF set if AX=0000h
Notes:	DR DOS 5.0 NLSFUNC returns CF set and AX=0001h if AL was not 00h, FEh,
	  or FFh on entry.
	passes codepage preparation request to each character device supporting
	  the generic IOCTL call
BUG:	DR DOS 5.0 NLSFUNC 3.00 - Novell DOS 7 NLSFUNC 3.03, and OpenDOS 7.01 -
	  DR-OpenDOS 7.02 NLSFUNC 3.02 requires DF cleared on entry, otherwise
	  the system may crash.  However, since this function is called only by
	  the BDOS, the problem never actually occurs.  DR-DOS 7.02/7.03
	  NLSFUNC 4.00+ always clears DF by itself.
SeeAlso: AX=1400h/BX=0EDCh,AX=14FEh,INT 21/AX=440Ch,INT 21/AX=6602h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1500" name="2F1500"><b>2F1500</b></a> - INT 2F - DOS 4.00 GRAPHICS.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS 4.00 GRAPHICS.COM - INSTALLATION CHECK
	AX = 1500h
Return: AX = FFFFh
	ES:DI -&gt; ??? (graphics data?)
Note:	this installation check conflicts with the CD-ROM Extensions
	  installation check; moved to AX=AC00h in later versions
SeeAlso: AX=AC00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1500BX0000" name="2F1500BX0000"><b>2F1500BX0000</b></a> - INT 2F - CD-ROM - INSTALLATION CHECK<br />
<pre>
INT 2F - CD-ROM - INSTALLATION CHECK
	AX = 1500h
	BX = 0000h
Return: BX = number of CD-ROM drive letters used
	CX = starting drive letter (0=A:)
	AX = 15FFh (Novell DOS 7 NWCDEX only!)
Notes:	this installation check DOES NOT follow the format used by other
	  software
	this installation check conflicts with the DOS 4.00 GRAPHICS.COM
	  installation check
BUG:	this function may return an incorrect starting drive letter when
	  INTERLNK is installed
SeeAlso: AX=150Ch,AX=15FFh,INT 2F/AX=D000h"Lotus"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1500CH90" name="2F1500CH90"><b>2F1500CH90</b></a> - INT 2F U - CDBLITZ v2.11 - INSTALLATION CHECK<br />
<pre>
INT 2F U - CDBLITZ v2.11 - INSTALLATION CHECK
	AX = 1500h
	CH = 90h (function number)
	BX = 1234h (magic value for CDBLITZ)
Return: CX = 1234h if installed
	    CF clear
	    DX = BCD version number (DH = major, DL = minor)
Program: CDBLITZ is a CD-ROM cache by Blitz 'n' Software, Inc.
SeeAlso: AX=1500h/CH=99h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1500CH91" name="2F1500CH91"><b>2F1500CH91</b></a> - INT 2F U - CDBLITZ v2.11 - GET STATISTICS<br />
<pre>
INT 2F U - CDBLITZ v2.11 - GET STATISTICS
	AX = 1500h
	CH = 91h (function number)
	BX = 1234h (magic value for CDBLITZ)
Return: CF clear
	ES:BX -&gt; statistics record (see #02627)
SeeAlso: AX=1500h/CH=90h,AX=1500h/CH=97h

Format of CDBLITZ statistics record:
Offset	Size	Description	(Table 02627)
 00h	WORD	cache mode (see also AX=1500h/CH=94h)
		0001h 'min', 0002h 'max'
 02h	DWORD	number of read calls???
 06h	DWORD	total number of sectors read
 0Ah	DWORD	unused??? (zero)
 0Eh	DWORD	number of cache hit sectors
 12h	WORD	cache size in KB
 14h	WORD	unused??? (zero)
 16h	WORD	cache state (0000h disabled, 0001h enabled)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1500CH92" name="2F1500CH92"><b>2F1500CH92</b></a> - INT 2F U - CDBLITZ v2.11 - ENABLE CACHE<br />
<pre>
INT 2F U - CDBLITZ v2.11 - ENABLE CACHE
	AX = 1500h
	CH = 92h (function number)
	BX = 1234h (magic value for CDBLITZ)
Return: CF clear
SeeAlso: AX=1500h/CH=90h,AX=1500h/CH=93h,AX=1500h/CH=94h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1500CH93" name="2F1500CH93"><b>2F1500CH93</b></a> - INT 2F U - CDBLITZ v2.11 - DISABLE CACHE<br />
<pre>
INT 2F U - CDBLITZ v2.11 - DISABLE CACHE
	AX = 1500h
	CH = 93h (function number)
	BX = 1234h (magic value for CDBLITZ)
Return: CF clear
SeeAlso: AX=1500h/CH=90h,AX=1500h/CH=92h,AX=1500h/CH=95h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1500CH94" name="2F1500CH94"><b>2F1500CH94</b></a> - INT 2F U - CDBLITZ v2.11 - SET 'MAX' MODE (CACHE BOTH DIRECTORIES AND DATA)<br />
<pre>
INT 2F U - CDBLITZ v2.11 - SET 'MAX' MODE (CACHE BOTH DIRECTORIES AND DATA)
	AX = 1500h
	CH = 94h (function number)
	BX = 1234h (magic value for CDBLITZ)
Return: CF clear
SeeAlso: AX=1500h/CH=90h,AX=1500h/CH=92h,AX=1500h/CH=95h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1500CH95" name="2F1500CH95"><b>2F1500CH95</b></a> - INT 2F U - CDBLITZ v2.11 - SET 'MIN' MODE (CACHE ONLY DIRECTORY ENTRIES)<br />
<pre>
INT 2F U - CDBLITZ v2.11 - SET 'MIN' MODE (CACHE ONLY DIRECTORY ENTRIES)
	AX = 1500h
	CH = 95h (function number)
	BX = 1234h (magic value for CDBLITZ)
Return: CF clear
SeeAlso: AX=1500h/CH=90h,AX=1500h/CH=94h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1500CH96" name="2F1500CH96"><b>2F1500CH96</b></a> - INT 2F U - CDBLITZ v2.11 - FLUSH CACHE<br />
<pre>
INT 2F U - CDBLITZ v2.11 - FLUSH CACHE
	AX = 1500h
	CH = 96h (function number)
	BX = 1234h (magic value for CDBLITZ)
Return: CF clear
Note:	this function resets the counts for number of sectors read and number
	  of cache hits, but no other values in the statistics record
	  (see #02627)
SeeAlso: AX=1500h/CH=90h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1500CH97" name="2F1500CH97"><b>2F1500CH97</b></a> - INT 2F U - CDBLITZ v2.11 - GET CACHE STATISTICS<br />
<pre>
INT 2F U - CDBLITZ v2.11 - GET CACHE STATISTICS
	AX = 1500h
	CH = 97h (function number)
	BX = 1234h (magic value for CDBLITZ)
Return: CF clear
	AL = cache mode (01h 'min', 02h 'max') (see also AX=1500h/CH=94h)
	AH = cache state (00h disabled, 01h enabled)
	BX = cache size in KB
	DX:CX = total number of reads
	DI:SI = number of cache hits
SeeAlso: AX=1500h/CH=90h,AX=1500h/CH=91h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1500CH99" name="2F1500CH99"><b>2F1500CH99</b></a> - INT 2F U - CDBLITZ v2.11 - UNINSTALL<br />
<pre>
INT 2F U - CDBLITZ v2.11 - UNINSTALL
	AX = 1500h
	CH = 99h (function number)
	BX = 1234h (magic value for CDBLITZ)
Return: CF clear
	???
Program: CDBLITZ is a CD-ROM cache by Blitz 'n' Software, Inc.
SeeAlso: AX=1500h/CH=90h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1501" name="2F1501"><b>2F1501</b></a> - INT 2F - CD-ROM - GET DRIVE DEVICE LIST<br />
<pre>
INT 2F - CD-ROM - GET DRIVE DEVICE LIST
	AX = 1501h
	ES:BX -&gt; buffer to hold drive letter list (5 bytes per drive letter)
Return: buffer filled, for each drive letter
	  BYTE	subunit number in driver
	  DWORD address of device driver header (see #01646)
Note:	reportedly returns AX=0000h and an invalid address under Windows95;
	  other reports say it works fine
SeeAlso: AX=1510h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1502" name="2F1502"><b>2F1502</b></a> - INT 2F - CD-ROM - GET COPYRIGHT FILE NAME<br />
<pre>
INT 2F - CD-ROM - GET COPYRIGHT FILE NAME
	AX = 1502h
	ES:BX -&gt; 38-byte buffer for name of copyright file
	CX = drive number (0=A:)
Return: CF set if drive is not a CD-ROM drive
	    AX = 000Fh (invalid drive)
	CF clear if successful
SeeAlso: AX=1503h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1503" name="2F1503"><b>2F1503</b></a> - INT 2F - CD-ROM - GET ABSTRACT FILE NAME<br />
<pre>
INT 2F - CD-ROM - GET ABSTRACT FILE NAME
	AX = 1503h
	ES:BX -&gt; 38-byte buffer for name of abstract file
	CX = drive number (0=A:)
Return: CF set if drive is not a CD-ROM drive
	    AX = 000Fh (invalid drive)
	CF clear if successful
SeeAlso: AX=1502h,AX=1504h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1504" name="2F1504"><b>2F1504</b></a> - INT 2F - CD-ROM - GET BIBLIOGRAPHIC DOC FILE NAME<br />
<pre>
INT 2F - CD-ROM - GET BIBLIOGRAPHIC DOC FILE NAME
	AX = 1504h
	ES:BX -&gt; 38-byte buffer for name of bibliographic documentation file
	CX = drive number (0=A:)
Return: CF set if drive is not a CD-ROM drive
	    AX = 000Fh (invalid drive)
	CF clear if successful
SeeAlso: AX=1502h,AX=1503h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1505" name="2F1505"><b>2F1505</b></a> - INT 2F - CD-ROM - READ VTOC<br />
<pre>
INT 2F - CD-ROM - READ VTOC
	AX = 1505h
	ES:BX -&gt; 2048-byte buffer
	CX = drive number (0=A:)
	DX = sector index (0=first volume descriptor,1=second,...)
Return: CF set on error
	    AX = error code (15=invalid drive,21=not ready)
	CF clear if successful
	    AX = volume descriptor type (1=standard,FFh=terminator,0=other)
Note:	This function was not supported by Novell DOS 7 NWCDEX prior to the
	  08/16/94 update

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1506" name="2F1506"><b>2F1506</b></a> - INT 2F - CD-ROM - TURN DEBUGGING ON<br />
<pre>
INT 2F - CD-ROM - TURN DEBUGGING ON
	AX = 1506h
	BX = debugging function to enable
Note:	reserved for development
SeeAlso: AX=1507h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1507" name="2F1507"><b>2F1507</b></a> - INT 2F - CD-ROM - TURN DEBUGGING OFF<br />
<pre>
INT 2F - CD-ROM - TURN DEBUGGING OFF
	AX = 1507h
	BX = debugging function to disable
Note:	reserved for development
SeeAlso: AX=1506h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1508" name="2F1508"><b>2F1508</b></a> - INT 2F - CD-ROM - ABSOLUTE DISK READ<br />
<pre>
INT 2F - CD-ROM - ABSOLUTE DISK READ
	AX = 1508h
	ES:BX -&gt; buffer
	CX = drive number (0=A:)
	SI:DI = starting sector number
	DX = number of sectors to read
Return: CF set on error
	    AL = error code (0Fh invalid drive,15h not ready)
	CF clear if successful
Note:	returns error 15h (not ready) under Windows95 if the starting sector
	  number is less than 10h
SeeAlso: AX=1509h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1509" name="2F1509"><b>2F1509</b></a> - INT 2F - CD-ROM - ABSOLUTE DISK WRITE<br />
<pre>
INT 2F - CD-ROM - ABSOLUTE DISK WRITE
	AX = 1509h
	ES:BX -&gt; buffer
	CX = drive number (0=A:)
	SI:DI = starting sector number
	DX = number of sectors to write
Note:	corresponds to INT 26h and is currently reserved and nonfunctional,
	  but could be implemented for CD-R and CD-RW drives
SeeAlso: AX=1508h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F150A" name="2F150A"><b>2F150A</b></a> - INT 2F - CD-ROM - RESERVED<br />
<pre>
INT 2F - CD-ROM - RESERVED
	AX = 150Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F150B" name="2F150B"><b>2F150B</b></a> - INT 2F - CD-ROM v2.00+ - DRIVE CHECK<br />
<pre>
INT 2F - CD-ROM v2.00+ - DRIVE CHECK
	AX = 150Bh
	CX = drive number (0=A:)
Return: BX = ADADh if MSCDEX.EXE installed
	    AX = support status
		0000h if drive not supported
		nonzero if supported
SeeAlso: AX=150Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F150CBX0000" name="2F150CBX0000"><b>2F150CBX0000</b></a> - INT 2F - CD-ROM v2.00+ - GET MSCDEX.EXE VERSION (GET VERSION)<br />
<pre>
INT 2F - CD-ROM v2.00+ - GET MSCDEX.EXE VERSION (GET VERSION)
	AX = 150Ch
	BX = 0000h
Return: BH = major version
	BL = minor version
Notes:	MSCDEX.EXE versions prior to 2.00 leave BX unchanged, thus BX should
	  be 0000h on entry
	Corel's CORELCDX.COM v1.01d returns 2.20, v1.12a returns 2.21
	Meridian Data's CDNETEX.EXE returns its own version number, e.g. 4.70
	J.M.A. Hall's CDEMU2.COM returns 2.10 (it is an MSCDEX emulator for
	  networked CD-ROM drives)
	Windows95 returns v2.95
	Novell DOS 7 NWCDEX.EXE returns the same version number reported in
	  its startup message
SeeAlso: AX=1500h"CD-ROM",AX=15FFh"CORELCDX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F150D" name="2F150D"><b>2F150D</b></a> - INT 2F - CD-ROM v2.00+ - GET CD-ROM DRIVE LETTERS<br />
<pre>
INT 2F - CD-ROM v2.00+ - GET CD-ROM DRIVE LETTERS
	AX = 150Dh
	ES:BX -&gt; buffer for drive letter list (1 byte per drive)
Return: buffer filled with drive numbers (0=A:).  Each byte corresponds
	to the drive in the same position for function 1501h
SeeAlso: AX=150Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F150E" name="2F150E"><b>2F150E</b></a> - INT 2F - CD-ROM v2.00+ - GET/SET VOLUME DESCRIPTOR PREFERENCE<br />
<pre>
INT 2F - CD-ROM v2.00+ - GET/SET VOLUME DESCRIPTOR PREFERENCE
	AX = 150Eh
	BX = subfunction
	    00h get preference
		DX = 0000h
		Return: DX = preference settings
	    01h set preference
		DH = volume descriptor preference
		    01h = primary volume descriptor
		    02h = supplementary volume descriptor
		DL = supplementary volume descriptor preference
		    01h = shift-Kanji
	CX = drive number (0=A:)
Return: CF set on error
	    AX = error code (15=invalid drive,1=invalid function)
	CF clear if successful

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F150F" name="2F150F"><b>2F150F</b></a> - INT 2F - CD-ROM v2.00+ - GET DIRECTORY ENTRY<br />
<pre>
INT 2F - CD-ROM v2.00+ - GET DIRECTORY ENTRY
	AX = 150Fh
	CL = drive number (0=A:)
	CH bit 0 = copy flag
		clear if direct copy
		set if copy to structure which removes ISO/High Sierra diffs
	ES:BX -&gt; ASCIZ path name
	SI:DI -&gt; buffer for directory entry (see #02628,#02629)
		must be 255 bytes for direct copy, 285 bytes for canonical
Return: CF set on error
	    AX = error code
	CF clear if successful
	    AX = disk format (0=High Sierra,1=ISO 9660)
Note:	this function was not supported by Novell DOS 7 NWCDEX prior to the
	  08/16/94 update

Format of CD-ROM directory entry (direct copy):
Offset	Size	Description	(Table 02628)
 00h	BYTE	length of directory entry
 01h	BYTE	length of XAR in Logical Block Numbers
 02h	DWORD	LBN of data, Intel (little-endian) format
 06h	DWORD	LBN of data, Motorola (big-endian) format
 0Ah	DWORD	length of file, Intel format
 0Eh	DWORD	length of file, Motorola format
---High Sierra---
 12h  6 BYTEs	date and time
 18h	BYTE	bit flags
 19h	BYTE	reserved
---ISO 9660---
 12h  7 BYTEs	date and time
		(seventh byte is offset from GMT in 15-minute increments)
 19h	BYTE	bit flags
---both formats---
 1Ah	BYTE	interleave size
 1Bh	BYTE	interleave skip factor
 1Ch	WORD	volume set sequence number, Intel format
 1Eh	WORD	volume set sequence number, Motorola format
 20h	BYTE	length of file name
 21h  N BYTEs	file name
	BYTE	(optional) padding if filename is odd length
      N BYTEs	system data
SeeAlso: #02629,#01352

Format of CD-ROM directory entry (canonicalized):
Offset	Size	Description	(Table 02629)
 00h	BYTE	length of XAR in Logical Block Numbers
 01h	DWORD	Logical Block Number of file start
 05h	WORD	size of disk in logical blocks
 07h	DWORD	file length in bytes
 0Bh  7 BYTEs	date and time
 12h	BYTE	bit flags
 13h	BYTE	interleave size
 14h	BYTE	interleave skip factor
 15h	WORD	volume set sequence number
 17h	BYTE	length of file name
 18h 38 BYTEs	ASCIZ filename
 3Eh	WORD	file version number
 40h	BYTE	number of bytes of system use data
 41h 220 BYTEs	system use data
SeeAlso: #02628

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1510" name="2F1510"><b>2F1510</b></a> - INT 2F - CD-ROM v2.10+ - SEND DEVICE DRIVER REQUEST<br />
<pre>
INT 2F - CD-ROM v2.10+ - SEND DEVICE DRIVER REQUEST
	AX = 1510h
	CX = CD-ROM drive letter (0 = A, 1 = B, etc)
	ES:BX -&gt; CD-ROM device driver request header (see #02597 at AX=0802h)
Return: CF clear if device driver has been called (check the request header's
	      status word to determine whether an error has occurred)
	    ES:BX request header updated
	CF set if device driver has not been called
	    AX = error code (000Fh = invalid drive, 0001h = invalid function)
	    ES:BX request header unchanged
Notes:	MSCDEX initializes the device driver request header's subunit field
	  based on the drive number specified in CX
	MSCDEX v2.21 through v2.25 (at least) return error code AX=0001h if
	  nested calls are attempted
BUGS:	Novell DOS 7 NWCDEX prior to the 12/13/94 update did not initialize
	  the subunit field
	Windows95 sets CF if CX isn't a CD-ROM drive but leaves CF unchanged
	  if the drive is in fact a CD-ROM
SeeAlso: AX=0802h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F15FFBX0000" name="2F15FFBX0000"><b>2F15FFBX0000</b></a> - INT 2F - CD-ROM - CORELCDX - INSTALLATION CHECK<br />
<pre>
INT 2F - CD-ROM - CORELCDX - INSTALLATION CHECK
	AX = 15FFh
	BX = 0000h
Return: BX = ABCDh if CORELCDX loaded
Note:	Corel's CORELCDX.COM is a replacement for MSCDEX.EXE; it also supports
	  the standard MSCDEX installation check calls AX=1500h and AX=150Ch
SeeAlso: AX=1500h"CD-ROM",AX=150Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1600" name="2F1600"><b>2F1600</b></a> - INT 2F - MS Windows - WINDOWS ENHANCED MODE INSTALLATION CHECK<br />
<pre>
INT 2F - MS Windows - WINDOWS ENHANCED MODE INSTALLATION CHECK
	AX = 1600h
Return: AL = status
	    00h neither Windows 3.x enhanced mode nor Windows/386 2.x running
	    01h Windows/386 2.x running
	    80h XMS version 1 driver installed (neither Windows 3.x enhanced
		  mode nor Windows/386 2.x running) (obsolete--see note)
	    FFh Windows/386 2.x running
	AL = anything else
	    AL = Windows major version number &gt;= 3
	    AH = Windows minor version number
Notes:	INT 2F/AH=16h comprises an API for non-Windows programs (DOS device
	  drivers, TSRs, and applications) to cooperate with multitasking
	  Windows/386 2.x and Windows 3.x and higher enhanced mode.
	certain calls are also supported in the Microsoft 80286 DOS extender in
	  Windows standard mode
	this function served as the installation check and AX=1610h served to
	  get the driver entry point for XMS version 1, which is now obsolete.
	  Use AX=4300h and AX=4310h instead
	Windows95 reports version 4.00, Windows95B reports version 4.03
SeeAlso: AX=160Ah,AX=1610h,AX=4300h,AX=4680h
Index:	installation check;XMS version 1

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1602" name="2F1602"><b>2F1602</b></a> - INT 2F - MS Windows/386 2.x - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows/386 2.x - GET API ENTRY POINT
	AX = 1602h
Return: ES:DI -&gt; Windows/386 2.x API procedure entry point
Notes:	this interface is supported in Windows 3.x and Windows95 only for 2.x
	  compatibility
	to get the current virtual machine (VM) ID in Windows/386 2.x:
	    AX = 0000h
	    ES:DI -&gt; return address
	    JUMP to address returned from INT 2F/AX=1602h
	After JUMP, at return address:
	    BX = current VM ID.
SeeAlso: AX=C020h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1603" name="2F1603"><b>2F1603</b></a> - INT 2F C - MS Windows/386 - GET INSTANCE DATA<br />
<pre>
INT 2F C - MS Windows/386 - GET INSTANCE DATA
	AX = 1603h
Return: AX = 5248h ('RH') if supported
	    DS:SI -&gt; Windows/386 instance data (see #02630)
Notes:	reportedly supported by RM Nimbus MS-DOS 3.3 kernel
	this function is called by DOSMGR when AX=1607h/BX=0015h is not
	  supported, as is the case in DOS versions prior to 5.0
	see Geoff Chappell's book _DOS_Internals_ for additional discussions of
	  this function, DOSMGR's behavior, and instancing in general
SeeAlso: AX=1607h/BX=0015h

Format of Windows/386 instance data:
Offset	Size	Description	(Table 02630)
 00h	WORD	segment of IO.SYS (0000h = default 0070h)
 02h	WORD	offset in IO.SYS of STACKS data structure (DOS 3.2x)
		0000h if not applicable
 04h	WORD	number of instance data entries (max 32)
 06h	Array of instance data entries
	Offset	Size	Description
	 00h	WORD	segment (0002h = DOS kernel)
	 02h	WORD	offset
	 04h	WORD	size

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1605" name="2F1605"><b>2F1605</b></a> - INT 2F C - MS Windows - WINDOWS ENHANCED MODE & 286 DOSX INIT BROADCAST<br />
<pre>
INT 2F C - MS Windows - WINDOWS ENHANCED MODE & 286 DOSX INIT BROADCAST
	AX = 1605h
	ES:BX = 0000h:0000h
	DS:SI = 0000h:0000h
	CX = 0000h
	DX = flags
	    bit 0 = 0 if Windows enhanced-mode initialization
	    bit 0 = 1 if Microsoft 286 DOS extender initialization
	    bits 1-15 reserved (undefined)
	DI = version number (major in upper byte, minor in lower)
Return: CX = 0000h if okay for Windows to load
	CX = FFFFh (other registers unchanged) if Windows 3.0 in standard mode
	CX &lt;&gt; 0 if Windows should not load
	ES:BX -&gt; startup info structure (see #02631)
	DS:SI -&gt; virtual86 mode enable/disable callback or 0000h:0000h
	      (see #02634)
Notes:	the Windows enhanced mode loader and Microsoft 286 DOS extender will
	  broadcast an INT 2F/AX=1605h call when initializing.	Any DOS device
	  driver or TSR can watch for this broadcast and return the appropriate
	  values.  If the driver or TSR returns CX &lt;&gt; 0, it is also its
	  responsibility to display an error message (however, Windows95 is
	  reported to load regardless of the returned CX).
	each handler must first chain to the prior INT 2F handler with
	  registers unchanged before processing the call
	if the handler requires local data on a per-VM basis, it must store the
	  returned ES:BX in the "next" field of a startup info structure and
	  return a pointer to that structure in ES:BX
	a single TSR may set the V86 mode enable/disable callback; if DS:SI is
	  already nonzero, the TSR must fail the initialization by setting CX
	  nonzero
	MSD checks for Windows 3.0 running in standard mode by testing whether
	  CX=FFFFh and other registers are unchanged on return
	Novell DOS v7.0 (Update 8 - Update 11) TASKMGR in multitasking mode
	  uses this broadcast, even if TASKMGR.INI sets WinPresent= to OFF
	Microsoft's EMM386.EXE for DOS 5+ when installed with the NOEMS option
	  changes its driver name from EMMQXXX0 to EMMXXXX0 while Windows is
	  active
SeeAlso: AX=1606h,AX=1608h,AX=4B05h

Format of Windows Startup Information Structure:
Offset	Size	Description	(Table 02631)
 00h  2 BYTEs	major, minor version of info structure
 02h	DWORD	pointer to next startup info structure or 0000h:0000h
 06h	DWORD	pointer to ASCIZ name of virtual device file or 0000h:0000h
 0Ah	DWORD	virtual device reference data (see #02633)
		(only used if above nonzero)
 0Eh	DWORD	pointer to instance data records (see #02632) or 0000h:0000h
---structure version &gt;= 4.0---
 12h	DWORD	pointer to optionally-instanced data records (see #02632)
		  or 0000h:0000h

Format of one Instance Item in array:
Offset	Size	Description	(Table 02632)
 00h	DWORD	address of instance data (end of array if 0000h:0000h)
 04h	WORD	size of instance data
SeeAlso: #02631

Format of Virtual Device Reference Data:
Offset	Size	Description	(Table 02633)
 00h	DWORD	physical address of ??? or 00000000h
 04h	DWORD	physical address of ??? table
 08h	DWORD	"DEST_PAGE" address to which pages must be mapped
 0Ch  N DWORDs	"SRC_PAGE" physical addresses of the pages
		00000000h = end of table
Note:	EMM386.EXE sets the first pointer to the start of the device driver
	  chain, the second pointer to a field of 40h bytes followed by a
	  16-bit offset to the end of the SRC_PAGE table, and DEST_PAGE to
	  the start segment of the UMB area
SeeAlso: #02631

(Table 02634)
Values Windows virtual mode enable/disable procedure is called with:
	AX = 0000h disable V86 mode
	AX = 0001h enable V86 mode
	interrupts disabled
Return: CF set on error
	CF clear if successful
	interrupts disabled
SeeAlso: #02631

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1606" name="2F1606"><b>2F1606</b></a> - INT 2F C - MS Windows - WINDOWS ENHANCED MODE & 286 DOSX EXIT BROADCAST<br />
<pre>
INT 2F C - MS Windows - WINDOWS ENHANCED MODE & 286 DOSX EXIT BROADCAST
	AX = 1606h
	DX = flags
	    bit 0 = 0 if Windows enhanced-mode exit
	    bit 0 = 1 if Microsoft 286 DOS extender exit
	    bits 1-15 reserved (undefined)
Notes:	if the init broadcast fails (AX=1605h returned CX &lt;&gt; 0), then this
	  broadcast will be issued immediately.
	this call will be issued in real mode
	Novell DOS v7.0 (Update 8 - Update 15) TASKMGR in multitasking mode
	  uses this broadcast, even if TASKMGR.INI sets WinPresent= to OFF
SeeAlso: AX=1605h,AX=1609h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607" name="2F1607"><b>2F1607</b></a> - INT 2F C - MS Windows - VIRTUAL DEVICE CALL OUT API<br />
<pre>
INT 2F C - MS Windows - VIRTUAL DEVICE CALL OUT API
	AX = 1607h
	BX = virtual device ID (see #02642)
	CX = (usually) callout subfunction
Return: (usually) AX,BX,CX,DX,ES contain results
Notes:	more of a convention than an API, this call specifies a standard
	  mechanism for Windows enhanced-mode virtual devices (VxD's) to talk
	  to DOS device drivers and TSRs
	see below for details on several virtual devices
SeeAlso: AX=1605h,AX=1607h/BX=000Ch,AX=1607h/BX=0014h,AX=1607h/BX=0015h
SeeAlso: AX=1607h/BX=0018h,AX=1684h"DEVICE API",AX=C020h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX0006" name="2F1607BX0006"><b>2F1607BX0006</b></a> - INT 2F C - MS Windows - "V86MMGR" VIRTUAL DEVICE API<br />
<pre>
INT 2F C - MS Windows - "V86MMGR" VIRTUAL DEVICE API
	AX = 1607h
	BX = 0006h (VxD identifier of "V86MMGR")
	CX = 0000h
Return: AX = status
	    0000h if local A20 state changed
	    1607h if A20 unchanged
	    other if global A20 state changed
SeeAlso: AX=1607h"CALL OUT API"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX000C" name="2F1607BX000C"><b>2F1607BX000C</b></a> - INT 2F C - MS Windows - "VMD" VIRTUAL MOUSE DEVICE API<br />
<pre>
INT 2F C - MS Windows - "VMD" VIRTUAL MOUSE DEVICE API
	AX = 1607h
	BX = 000Ch (VxD identifier of "VMD")
Return: CX = nonzero if mouse driver already virtualized
Note:	VMD (Virtual Mouse Driver) calls this and then checks whether CX is
	  nonzero; if yes, it will not automatically virtualize the mouse
	  driver.  This would be used if MOUSE.COM already virtualizes
	  itself using the Windows API.
SeeAlso: AX=1607h/BX=0014h,AX=1607h/BX=0015h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX000D" name="2F1607BX000D"><b>2F1607BX000D</b></a> - INT 2F C - MS Windows95 - "VKD" VIRTUAL DEVICE - ??? CALLOUT<br />
<pre>
INT 2F C - MS Windows95 - "VKD" VIRTUAL DEVICE - ??? CALLOUT
	AX = 1607h
	BX = 000Dh (VxD ID for VKD)
	???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX0010" name="2F1607BX0010"><b>2F1607BX0010</b></a> - INT 2F C - MS Windows 3.1 - "BLOCKDEV" VIRTUAL HARD DISK DEVICE API<br />
<pre>
INT 2F C - MS Windows 3.1 - "BLOCKDEV" VIRTUAL HARD DISK DEVICE API
	AX = 1607h
	BX = 0010h (VxD identifier of "BLOCKDEV")
	CX = function
	    0001h starting FastDisk compatibility tests
	    0002h ending FastDisk compatibility tests
	    0003h check if FastDisk installation allowed
		Return: CX = 0000h if allowed
Note:	this interface is called by the Windows FastDisk driver (such as
	  WDCTRL) when it thinks that the INT 13h handler immediately below
	  IO.SYS's INT 13h code is not in ROM; it should be supported by any
	  program which hooks itself underneath IO.SYS's INT 13h code with
	  INT 2F/AH=13h
SeeAlso: AX=1607h/BX=0014h,INT 2F/AH=13h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX0014" name="2F1607BX0014"><b>2F1607BX0014</b></a> - INT 2F C - MS Windows - "VNETBIOS" VIRTUAL DEVICE API<br />
<pre>
INT 2F C - MS Windows - "VNETBIOS" VIRTUAL DEVICE API
	AX = 1607h
	BX = 0014h (VxD identifier of "VNETBIOS")
Return: ES:DI -&gt; 128-byte table specifying VNETBIOS actions for each NetBIOS
		command code (see #02635)
Note:	VNETBIOS (Virtual NetBIOS) calls this function to determine whether
	  the NetBIOS has an extensions Windows should know about
SeeAlso: AX=1607h/BX=000Ch,AX=1607h/BX=0010h,AX=1607h/BX=0015h

(Table 02635)
Values for VNETBIOS action code:
 00h	"VN_Unknown" unknown command
 04h	"VN_No_Map"  no memory mapping necessary
 08h	"VN_Map_In"  input buffer is quickly used, so no global mapping needed
 0Ch	"VN_Map_In"  output buffer is quickly used, so no global mapping needed
 10h	"VN_Map_In_Out"	 buffer is quickly used, so no global mapping needed
 14h	"VN_Chain_Send"	 the chain-send command
 18h	"VN_Cancel"	special case for cancel command
 1Ch	"VN_Buffer_In"	buffer is incoming
 20h	"VN_Buffer_Out" buffer is outgoing
 24h	"VN_Buffer_In_Out" buffer used for both incoming and outgoing data

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX0015" name="2F1607BX0015"><b>2F1607BX0015</b></a> - INT 2F C - MS Windows - "DOSMGR" VIRTUAL DEVICE API<br />
<pre>
INT 2F C - MS Windows - "DOSMGR" VIRTUAL DEVICE API
	AX = 1607h
	BX = 0015h (VxD identifier of "DOSMGR")
	CX = function
	    0000h query instance processing
		DX = 0000h
		Return: CX = state
			    0000h not instanced
			    other instanced (DOS 5+ kernel returns 0001h)
				DX = segment of DOS drivers or 0000h for
					default of 0070h
				ES:BX -&gt; patch table (see #02637)
	    0001h set patches in DOS
		DX = bit mask of patch requests (see #02636)
		Return: AX = B97Ch
			BX = bit mask of patches applied (see #02636)
			DX = A2ABh
	    0002h remove patches in DOS (ignored by DOS 5.0 kernel)
		DX = bit mask of patch requests (see #02636)
		Return: CX = 0000h (DOS 5-6)
		Note:	return values are ignored by DOSMGR in Windows 3.1
	    0003h get size of DOS data structures
		DX = bit mask of request (only one bit can be set)
		    bit 0: Current Directory Structure size
		Return: if supported request:
			    AX = B97Ch
			    CX = size in bytes of requested structure
			    DX = A2ABh
			else:
			    CX = 0000h
			    all other registers preserved
	    0004h determine instanced data structures
		Return: AX = B97Ch if supported
			DX = A2ABh if supported (DOS 5+ kernel returns 0000h)
			BX = bit mask of instanced items
			    bit 0: CDS
			    bit 1: SFT
			    bit 2: device list
			    bit 3: DOS swappable data area
	    0005h get device driver size
		ES = segment of device driver
		Return: DX:AX = 0000h:0000h on error (not dev. driver segment)
			DX:AX = A2ABh:B97Ch if successful
			    BX:CX = size of device driver in bytes
Notes:	DOSMGR (DOS Manager) will check whether the OEM DOS/BIOS data has
	  been instanced via this API and will not perform its own default
	  instancing of the normal DOS/BIOS data if so; if this API is not
	  supported, DOSMGR will also try to access instancing data through
	  INT 2F/AX=1603h
	these functions are supported by the DOS 5+ kernel; DOSMGR contains
	  tables of instancing information for earlier versions of DOS
	see Geoff Chappell's book _DOS_Internals_ for additional discussions of
	  DOSMGR's behavior and instancing in general
SeeAlso: AX=1603h,AX=1605h,AX=1607h/BX=000Ch,AX=1607h/BX=0014h
SeeAlso: AX=1684h"DEVICE API"

Bitfields for DOSMGR patch requests:
Bit(s)	Description	(Table 02636)
 0	enable critical sections
 1	NOP setting/checking user ID
 2	turn INT 21/AH=3Fh on STDIN into polling loop
 3	trap stack fault in "SYSINIT" to WIN386
 4	BIOS patch to trap "Insert disk X:" to WIN386

Format of DOSMGR patch table:
Offset	Size	Description	(Table 02637)
 00h  2 BYTEs	DOS version (major, minor)
 02h	WORD	offset in DOS data segment of "SAVEDS"
 04h	WORD	offset in DOS data segment of "SAVEBX"
 06h	WORD	offset in DOS data segment of InDOS flag
 08h	WORD	offset in DOS data segment of User ID word
 0Ah	WORD	offset in DOS data segment of "CritPatch" table to enable
		  critical section calls (see INT 2A/AH=80h)
 0Ch	WORD	(DOS 5+ only) offset in DOS data segment of "UMB_HEAD",
		  containing segment of last MCB in conventional memory

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX0018" name="2F1607BX0018"><b>2F1607BX0018</b></a> - INT 2F C - MS Windows - "VMPoll" VIRTUAL DEVICE - IDLE CALLOUT<br />
<pre>
INT 2F C - MS Windows - "VMPoll" VIRTUAL DEVICE - IDLE CALLOUT
	AX = 1607h
	BX = 0018h (VMPoll VxD ID) (see #02642)
	CX = 0000h
Return: AX = status
	    0000h if timeslice used
	    nonzero if timeslice not needed
Note:	when VMPoll makes this callout, all virtual machines are idle, and any
	  interested TSR can use the opportunity to perform background
	  processing
SeeAlso: AX=1607h"CALL OUT API",AX=1689h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX0021" name="2F1607BX0021"><b>2F1607BX0021</b></a> - INT 2F C - MS Windows - "PageFile" VIRTUAL DEVICE - GET LOCK BYTE<br />
<pre>
INT 2F C - MS Windows - "PageFile" VIRTUAL DEVICE - GET LOCK BYTE
	AX = 1607h
	BX = 0021h (PageFile VxD ID)
	CX = 0000h
Return: AX = status
	    0000h success
		ES:DI -&gt; cache lock byte in disk cacher
	    other no disk cache or unsupported
Notes:	PageFile issues this call on real-mode initialization in order to allow
	  disk caches to provide it with a byte which it can use to temporarily
	  lock the disk cache; VMPOLL also issues this call, so it is made
	  twice each time Windows starts up
	if this call fails, PageFile falls back to other techniques for locking
	  the disk cache
SeeAlso: AX=1607h"CALL OUT API"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX002D" name="2F1607BX002D"><b>2F1607BX002D</b></a> - INT 2F C - MS Windows - "W32S" VIRTUAL DEVICE - ??? CALLOUT<br />
<pre>
INT 2F C - MS Windows - "W32S" VIRTUAL DEVICE - ??? CALLOUT
	AX = 1607h
	BX = 002Dh (VxD ID for W32S)
	???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX0040" name="2F1607BX0040"><b>2F1607BX0040</b></a> - INT 2F C - MS Windows - "IFSMgr" VIRTUAL DEVICE - ??? CALLOUT<br />
<pre>
INT 2F C - MS Windows - "IFSMgr" VIRTUAL DEVICE - ??? CALLOUT
	AX = 1607h
	BX = 0040h (VxD ID for IFSMgr)
	???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX0446" name="2F1607BX0446"><b>2F1607BX0446</b></a> - INT 2F C - MS Windows - "VADLIBD" VIRTUAL DEVICE - ??? CALLOUT<br />
<pre>
INT 2F C - MS Windows - "VADLIBD" VIRTUAL DEVICE - ??? CALLOUT
	AX = 1607h
	BX = 0446h (VxD ID for VADLIBD)
	???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX0484" name="2F1607BX0484"><b>2F1607BX0484</b></a> - INT 2F C - MS Windows - "IFSMgr" VIRTUAL DEVICE - ??? CALLOUT<br />
<pre>
INT 2F C - MS Windows - "IFSMgr" VIRTUAL DEVICE - ??? CALLOUT
	AX = 1607h
	BX = 0484h (VxD ID for IFSMgr)
	???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX0487" name="2F1607BX0487"><b>2F1607BX0487</b></a> - INT 2F C - MS Windows - "NWSUP" VIRTUAL DEVICE - ??? CALLOUT<br />
<pre>
INT 2F C - MS Windows - "NWSUP" VIRTUAL DEVICE - ??? CALLOUT
	AX = 1607h
	BX = 0487h (VxD ID for NWSUP)
	???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX22C0" name="2F1607BX22C0"><b>2F1607BX22C0</b></a> - INT 2F C - Rational Systems DOS/4GW - ???<br />
<pre>
INT 2F C - Rational Systems DOS/4GW - ???
	AX = 1607h
	BX = 22C0h
	???
Return: ???
SeeAlso: INT 15/AX=BF02h,INT 15/AX=BF04h,#02642

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX28A1" name="2F1607BX28A1"><b>2F1607BX28A1</b></a> - INT 2F C - MS Windows - "PharLap" VIRTUAL DEVICE - ??? CALLOUT<br />
<pre>
INT 2F C - MS Windows - "PharLap" VIRTUAL DEVICE - ??? CALLOUT
	AX = 1607h
	BX = 28A1h (VxD ID for PharLap)
	???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX7A5F" name="2F1607BX7A5F"><b>2F1607BX7A5F</b></a> - INT 2F C - MS Windows - "SIWVID" VIRTUAL DEVICE - ??? CALLOUT<br />
<pre>
INT 2F C - MS Windows - "SIWVID" VIRTUAL DEVICE - ??? CALLOUT
	AX = 1607h
	BX = 7A5Fh (VxD ID for SIWVID)
	???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1608" name="2F1608"><b>2F1608</b></a> - INT 2F C - MS Windows - WINDOWS ENHANCED MODE INIT COMPLETE BROADCAST<br />
<pre>
INT 2F C - MS Windows - WINDOWS ENHANCED MODE INIT COMPLETE BROADCAST
	AX = 1608h
Notes:	called after all installable devices have been initialized
	real-mode software may be called between the Windows enhanced-mode init
	  call (AX=1605h) and this call; the software must detect this
	  situation
SeeAlso: AX=1605h,AX=1609h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1609" name="2F1609"><b>2F1609</b></a> - INT 2F C - MS Windows - WINDOWS ENHANCED MODE BEGIN EXIT BROADCAST<br />
<pre>
INT 2F C - MS Windows - WINDOWS ENHANCED MODE BEGIN EXIT BROADCAST
	AX = 1609h
Note:	called at the beginning of a normal exit sequence; not made in the
	  event of a fatal system crash
SeeAlso: AX=1606h,AX=1608h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F160A" name="2F160A"><b>2F160A</b></a> - INT 2F - MS Windows 3.1 - IDENTIFY WINDOWS VERSION AND TYPE<br />
<pre>
INT 2F - MS Windows 3.1 - IDENTIFY WINDOWS VERSION AND TYPE
	AX = 160Ah
Return: AX = 0000h if call supported
	    BX = version (BH=major, BL=minor)
	    CX = mode (0002h = standard, 0003h = enhanced)
Note:	Windows95 reports version 4.00, Windows95B reports version 4.03
SeeAlso: AX=1600h,AX=4680h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F160B" name="2F160B"><b>2F160B</b></a> - INT 2F - MS Windows 3.1 - IDENTIFY TSRs<br />
<pre>
INT 2F - MS Windows 3.1 - IDENTIFY TSRs
	AX = 160Bh
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; TSR information structure (see #02638)
Desc:	this call allows Windows-aware TSRs to make themselves known to
	  Windows.
Note:	the TSR should first chain to the previous INT 2F handler, then
	  allocate a communication structure, place the returned ES:DI
	  pointer in the first field, and return a pointer to the new
	  structure
SeeAlso: AX=1605h,AX=160Ch,AX=4B01h,AX=4B05h

Format of TSR-to-Windows information structure:
Offset	Size	Description	(Table 02638)
 00h	DWORD	pointer to next structure
 04h	WORD	PSP segment
 06h	WORD	API version ID (0100h)
 08h	WORD	EXEC flags (how to load command specified by "exec_cmd")
		bit 0: "WINEXEC"
		bit 1: "LOADLIBRARY"
		bit 2: "OPENDRIVER"
 0Ah	WORD	"exec_cmd_show" (see #02639)
 0Ch	DWORD	"exec_cmd" pointer to command line to be executed
 10h  4 BYTEs	reserved (0)
 14h	DWORD	pointer to TSR ID block (see #02640)
 18h	DWORD	pointer to TSR data block or 0000h:0000h

(Table 02639)
Values for TSR information structure "exec_cmd_show":
 00h	HIDE
 01h	SHOWNORMAL
 02h	SHOWMINIMIZED
 03h	SHOWMAXIMIZED
 04h	SHOWNOACTIVE
 05h	SHOW
 06h	MINIMIZE
 07h	SHOWMINNOACTIVE
 08h	SHOWNA
 09h	RESTORE
Note:	this value is passed as the second parameter to the WinExec(),
	  LoadLibrary(), or OpenDriver() call used to execute a requested
	  command line
SeeAlso: #02638

Format of Norton Utilities 6.0 TSR ID block:
Offset	Size	Description	(Table 02640)
 00h	WORD	length of name string
 02h  N BYTEs	name of TSR's executable
SeeAlso: #02638

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F160C" name="2F160C"><b>2F160C</b></a> - INT 2F - MS Windows 3.1 - DETECT ROMs<br />
<pre>
INT 2F - MS Windows 3.1 - DETECT ROMs
	AX = 160Ch
	???
Return: ???
Note:	used by ROM Windows; appears to be a NOP under standard Windows95 and
	  Windows95B
SeeAlso: AX=160Bh,INT 21/AH=6Dh"ROM"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F160E" name="2F160E"><b>2F160E</b></a> - INT 2F U - MS-DOS 7 kernel - BOOT LOGO SUPPORT???<br />
<pre>
INT 2F U - MS-DOS 7 kernel - BOOT LOGO SUPPORT???
	AX = 160Eh
	BL = subfunction
	    00h get ???
		AX = state of flag manipulated by subfn 04h and 05h
		    0000h clear
		    FFFFh set
		DX = ??? (0000h)
	    01h link in INT 10h??? handlers
	    02h unlink INT 10h??? handlers
	    03h ???
	    04h set ??? flag
	    05h clear ??? flag
Return: AX = 0000h if supported
	    ???
SeeAlso: AX=160Fh,AX=1611h,AX=1614h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F160F" name="2F160F"><b>2F160F</b></a> - INT 2F U - MS-DOS 7 kernel - GET/SET ??? HANDLER<br />
<pre>
INT 2F U - MS-DOS 7 kernel - GET/SET ??? HANDLER
	AX = 160Fh
	BL = subfunction
	    00h get ??? handler
		Return: AX = 0000h if supported
			    CX:DX -&gt; handler to which control is passed after
				      ??? executes
			   = 160Fh inside a Windows 95B DOS box
	    01h set ??? handler
		CX:DX -&gt; new handler for ???
		Return: AX = 0000h if supported
Notes:	this function is not supported if ??? in the IO.SYS drivers portion of
	  the kernel is an IRET instruction (as is the case on my system)
	  rather than a FAR JMP
	the indicated handler seems to be related to INT 10 processing
SeeAlso: AX=160Eh,AX=1611h,AX=1614h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1610" name="2F1610"><b>2F1610</b></a> - INT 2F - XMS v1.x only - GET DRIVER ADDRESS<br />
<pre>
INT 2F - XMS v1.x only - GET DRIVER ADDRESS
	AX = 1610h
	details unavailable
Note:	this function and AX=1600h were only used in XMS version 1 and are now
	  obsolete.  Use AX=4300h and AX=4310h instead
SeeAlso: AX=1600h,AX=4310h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1611" name="2F1611"><b>2F1611</b></a> - INT 2F U - MS-DOS 7 kernel - GET SHELL PARAMETERS<br />
<pre>
INT 2F U - MS-DOS 7 kernel - GET SHELL PARAMETERS
	AX = 1611h
Return: AX = 0000h if supported
	    DS:DX -&gt; primary shell's executable name
	    DS:SI -&gt; prinary shell command line (counted string)
	    BH = ??? (00h)
	    BL = ??? (00h,40h)
Desc:	return the program name and commandline from the CONFIG.SYS SHELL=
	  statement
SeeAlso: AX=160Eh,AX=160Fh,AX=1612h,AX=4A33h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1612" name="2F1612"><b>2F1612</b></a> - INT 2F U - MS-DOS 7 kernel - GET ???<br />
<pre>
INT 2F U - MS-DOS 7 kernel - GET ???
	AX = 1612h
Return: AX = 0000h if supported
	    ES:BX -&gt; DOS 7 kernel data (see #02641)
Note:	called by VTD.VXD; one of the returned data items is a pointer to the
	  WORD in which the default CLOCK$ driver maintains its count of days
	  since 01jan1980
SeeAlso: AX=160Fh,AX=1611h,AX=1613h

Format of MS-DOS 7.x ??? kernel data:
Offset	Size	Description	(Table 02641)
 00h	WORD	structure revision??? (0001h)
 02h	DWORD	-&gt; ??? function (call with DS=high word of this field)
		the indicated function vectors through the INT 13 hook at
		  0070h:00B4h and then forces the A20 gate open
 06h	DWORD	-&gt; ??? function
 0Ah	WORD	DOS DS
 0Ch  8 BYTEs	zeros seen
 14h	DWORD	-&gt; ??? data
 18h	DWORD	-&gt; ??? data
	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1613" name="2F1613"><b>2F1613</b></a> - INT 2F - MS-DOS 7 kernel - GET SYSTEM.DAT (REGISTRY FILE) PATHNAME<br />
<pre>
INT 2F - MS-DOS 7 kernel - GET SYSTEM.DAT (REGISTRY FILE) PATHNAME
	AX = 1613h
	ES:DI -&gt; buffer for full ASCIZ pathname to Windows95 SYSTEM.DAT
	CX = buffer size in bytes
Return: AX = 0000h if supported
	    ES:DI buffer filled
	    CX = number of bytes copied into buffer
SeeAlso: AX=160Eh,AX=1611h,AX=1612h,AX=1614h,AX=1690h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1614" name="2F1614"><b>2F1614</b></a> - INT 2F U - MS-DOS 7 kernel - SET SYSTEM.DAT (REGISTRY FILE) PATHNAME<br />
<pre>
INT 2F U - MS-DOS 7 kernel - SET SYSTEM.DAT (REGISTRY FILE) PATHNAME
	AX = 1614h
	ES:DI -&gt; ASCIZ pathname to Windows95 SYSTEM.DAT
Return: AX = status
	    0000h if successful
	    1614h not supported
	    other: maximum length of pathname (004Eh for v4.00.950)
SeeAlso: AX=160Eh,AX=1611h,AX=1613h,AX=1690h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1615" name="2F1615"><b>2F1615</b></a> - INT 2F - Windows95 - SAVE32.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - Windows95 - SAVE32.COM - INSTALLATION CHECK
	AX = 1615h
Return: AX = 0000h if installed
	    BX = segment of resident code
Program: SAVE32.COM is a TSR included in the Windows95 distribution which
	  preserves the contents of 32-bit registers across invocations of
	  all of the hardware interrupt handlers (which, for some older BIOSes
	  and TSRs, do not properly preserve the high words of the 32-bit
	  registers)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1680" name="2F1680"><b>2F1680</b></a> - INT 2F - MS Windows, DPMI, various - RELEASE CURRENT VIRTUAL MACHINE TIME-SLICE<br />
<pre>
INT 2F - MS Windows, DPMI, various - RELEASE CURRENT VIRTUAL MACHINE TIME-SLICE
	AX = 1680h
Return: AL = status
	    00h if the call is supported
	    80h (unchanged) if the call is not supported
Notes:	programs can use this function in idle loops to enhance performance
	  under multitaskers; this call is supported by MS Windows 3+, DOS 5+,
	  DPMI 1.0+, and in OS/2 2.0+ for multitasking DOS applications
	does not block the program; it just gives up the remainder of the time
	  slice
	should not be used by Windows-specific programs
	when called very often without intermediate screen output under
	  MS Windows 3.x, the VM will go into an idle-state and will not
	  receive the next slice before 8 seconds have elapsed. This time can
	  be changed in SYSTEM.INI through "IdleVMWakeUpTime=&lt;seconds&gt;".
	  Setting it to zero results in a long wait.
	this function has no effect under OS/2 2.10-4.0 if the DOS box has an
	  "Idle Sensitivity" setting of 100
SeeAlso: AX=1689h,INT 15/AX=1000h,INT 15/AX=5305h,INT 21/AH=89h,INT 7A/BX=000Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1681" name="2F1681"><b>2F1681</b></a> - INT 2F - MS Windows 3+ - BEGIN CRITICAL SECTION<br />
<pre>
INT 2F - MS Windows 3+ - BEGIN CRITICAL SECTION
	AX = 1681h
Notes:	used to prevent a task switch from occurring
	should be followed by an INT 2F/AX=1682h call as soon as possible
	nested calls are allowed, and must be followed by an appropriate number
	  of "end critical section" calls
	not supported in Windows/386 2.x. Get INDOS flag with INT 21/AH=34h and
	  increment by hand.
SeeAlso: AX=1682h,INT 15/AX=101Bh,INT 21/AH=34h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1682" name="2F1682"><b>2F1682</b></a> - INT 2F - MS Windows 3+ - END CRITICAL SECTION<br />
<pre>
INT 2F - MS Windows 3+ - END CRITICAL SECTION
	AX = 1682h
Notes:	not supported in Windows/386 2.x.  Get InDOS flag with INT 21/AH=34h
	  and decrement by hand, taking care not to decrement InDOS flag
	  through zero
SeeAlso: AX=1681h,INT 15/AX=101Ch,INT 21/AH=34h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1683" name="2F1683"><b>2F1683</b></a> - INT 2F - MS Windows 3+ - GET CURRENT VIRTUAL MACHINE ID<br />
<pre>
INT 2F - MS Windows 3+ - GET CURRENT VIRTUAL MACHINE ID
	AX = 1683h
Return: BX = current virtual machine (VM) ID
Notes:	Windows itself currently runs in VM 1, but this can't be relied upon
	VM IDs are reused when VMs are destroyed
	an ID of 0 will never be returned
SeeAlso: AX=1684h"DEVICE API",AX=1685h,AX=168Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684" name="2F1684"><b>2F1684</b></a> - INT 2F - MS Windows - GET DEVICE API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - GET DEVICE API ENTRY POINT
	AX = 1684h
	BX = virtual device (VxD) ID (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point, or 0:0 if the VxD does not support an API
Note:	some Windows enhanced-mode virtual devices provide services that
	  applications can access.  For example, the Virtual Display Device
	  (VDD) provides an API used in turn by WINOLDAP.
SeeAlso: AX=1684h/BX=0001h,AX=1684h/BX=0015h,AX=1683h,AX=4011h,INT 20"Windows"

(Table 02642)
Values for MS Windows VxD ID:
Value	Name   CallOut V86 PM	Description
 0000h	ACT200L	     ?	?  ?	IrDA Infrared ActiSys framer VxD
 0000h	ACT220L	     ?	?  ?	IrDA Infrared ActiSys 220 framer VxD
 0000h	ADAPTEC	     ?	?  ?	IrDA Infrared Adaptec framer VxD
 0000h	AM1500T	     ?	N  N	(Win95)
 0000h	ATI	     ?	N  N	(Win95) ATI display driver
 0000h	ATIPPCAP     ?	N  Y	ATI Rage128-based video card
 0000h	CDFS	     ?	N  N
 0000h	CDTSD	     ?	N  N	(Win95) CD-ROM Type-Specific Driver
 0000h	CE2NDIS3     ?	N  N	(W4Wg)
 0000h	CENDIS	     ?	N  N	(W4Wg)
 0000h	CHIPS	     ?	N  N	(Win95) Chips&Tech display driver
 0000h	CIRRUS	     ?	N  N	(Win95) Cirrus display driver
 0000h	CTNDW	     ?	N  N	(W4Wg)
 0000h	CTVSD	     ?	N  N	(Win95) CD-ROM Vendor-Specific Driver
 0000h	CM2NDIS3     ?	N  N	(W4Wg)
 0000h	COMBUFF	     ?	N  N	(Win95)
 0000h	COMPAQ	     ?	N  N	(Win95) Compaq display driver
 0000h	CPQNDIS3     ?	N  N	(W4Wg)
 0000h	CRYSTAL	     ?	?  ?	IrDA Infrared Crystal framer VxD
 0000h	CWCENUM	     ?	N  N	(Win95SR2???)
 0000h	CWCSPUD3     ?	N  N	(Win95SR2???)
 0000h	DBKVSSD	     ?	N  N	(Win95) Databook PCMCIA socket services???
 0000h	DDOM95	     ?	N  N
 0000h	DECLAN	     ?	N  N	(W4Wg)
 0000h	DiskTSD	     ?	N  N	(Win95) hard-disk Type-Specific Driver
 0000h	DiskVSD	     ?	N  N	(Win95) hard-disk Vendor-Specific Driver
 0000h	DMICTVXD     ?	N  N
 0000h	DMMDVDX	     ?	N  N	Diamond MaximumDVD
 0000h	DRVSPACX     ?	N  N	(Win95)
 0000h	E30N3	     ?	N  N	(W4Wg)
 0000h	E31N3		N  N	(W4Wg)
 0000h	EE16		N  N	(W4Wg)
 0000h	EISA		N  N	(Win95)
 0000h	EL59X		N  N	(Win95)
 0000h	ELNK16		N  N	(W4Wg)
 0000h	ELNK3		N  N	(Win95)
 0000h	ELNKII		N  N	(W4Wg)
 0000h	ELNKMC		N  N	(W4Wg)
 0000h	ELPC3		N  N	(W4Wg)
 0000h	ENABLE2		N  N	(Win95)
 0000h	ENABLE4		N  N	(Win95)
 0000h	EPRO		N  N	(Win95)
 0000h	ES1488V		N  N	(Win95)
 0000h	ES1688V		N  N	(Win95)
 0000h	ES488V		N  N	(Win95)
 0000h	ES688V		N  N	(Win95)
 0000h	ESI		?  ?	IrDA Infrared ESI framer VxD
 0000h	FILEMON		N  N	DOS386 File Monitor
 0000h	FLS1MTD		N  N	(Win95) flash-memory driver???
 0000h	FLS2MTD		N  N	(Win95) flash-memory driver???
 0000h	HPEISA		N  N	(W4Wg)
 0000h	HPFEND		N  N	(W4Wg)
 0000h	HPISA		N  N	(W4Wg)
 0000h	HPMCA		N  N	(W4Wg)
 0000h	HSFLOP		N  N
 0000h	IBMTOK		N  N	(W4Wg)
 0000h	IBMTOK4		N  N	(Win95)
 0000h	IRCOMM		?  ?	IrDA Infrared Virtual COM/LPT driver
 0000h	IRLAMPEX	?  ?	IrDA Infrared Protocol VxD
 0000h	IRLAPFRM	?  ?	IrDA Infrared Virtual COM/LPT frame driver
 0000h	IRMATRAK	N  N	(W4Wg)
 0000h	JAVASUP		N  N	Internet Explorer JAVA support
 0000h	KEYREMAP	N  N	(Windows95 PowerToys) shift-key remapper
 0000h	LPT	     N	N  N	(Win4Workgroups 3.11) DOS386 LPT Device
 0000h	LPTENUM	     ?	N  N
 0000h	MONVSD	     ?	?  ?
 0000h	MGA	     ?	N  N	(Win95) Matrox MGA display driver
 0000h	MSMINI	     ?	N  N	(Win95)
 0000h	MSODISUP     N	N  N	(Win4Workgroups 3.11) MS ODI Support
 0000h	mvpas	     ?	N  N	(Win95) Pro Audio Spectrum driver
 0000h	NECATAPI     ?	N  N	(Win95)
 0000h	NICE	     ?	N  N	(Win95)
 0000h	NTI4CDR	     ?	Y  Y	NTI CD-R/CD-RW
 0000h	NV3	     ?	N  N	(Win95SR2)
 0000h	NWNBLINK     N	N  N	(Win4Workgroups 3.11) Netware NetBIOS
 0000h	OAK		N  N	(Win95) Oak Tech display driver
 0000h	OCTK32		N  N	(W4Wg)
 0000h	OTCETH		N  N	(W4Wg)
 0000h	PARALINK	N  N	(Win95)
 0000h	PARALLAX	?  ?	IrDA Infrared Parallax framer VxD
 0000h	PCNTN3		N  N	(W4Wg)
 0000h	PE3NDIS		N  N	(W4Wg)
 0000h	PPM		N  N	(Win95)
 0000h	PROTEON		N  N	(W4Wg)
 0000h	QEMMFix		N  N
 0000h	QIC117		N  N	(Win95) QIC-117 floppy-ctrl tape drive
 0000h	QPI		N  N	QEMM Programming Interface (see INT 67/AH=3Fh)
 0000h	RMM		N  N	Real-Mode Mapper for hw with real-mode drivers
 0000h	S3		N  N	(Win95) S3 display driver
 0000h	S3INFO		N  N
 0000h	S3MINI		N  N	S3 display driver
 0000h	SAGE		N  N	(Plus!) System Agent
 0000h	sage		N  N	(Plus! for Win95) System Agent
 0000h	scsi1hlp	N  N	(Win95)
 0000h	SERENUM		N  N
 0000h	SERIAL	     N	N  N	(Win4Workgroups 3.11) DOS386 Serial Device
 0000h	SERWAVE	     ?	N  N
 0000h	SETP3	     ?	N  N	(Win95) Silicon Ethernet Pocket Adapter
 0000h	SLMSDENM     ?	Y  Y	
 0000h	SMARTVSD     ?	N  N	(EZ-SMART???)
 0000h	SMC8000W     ?	N  N	(W4Wg)
 0000h	SMC80PC	     ?	N  N	(W4Wg)
 0000h	SMC8100W     ?	N  N	(W4Wg)
 0000h	SMC8232W     ?	N  N	(W4Wg)
 0000h	SMC9000	     ?	N  N	(W4Wg)
 0000h	SNIP	     ?	N  N	(W4Wg)
 0000h	SOCKET	     ?	N  N	(W4Wg)
 0000h	SOCKETSV     ?	N  N	(Win95)
 0000h	SPAP	     ?	Y  Y	(Win95)
 0000h	SPENDIS	     ?	N  N	(Win95)
 0000h	SRAMMTD	     ?	N  N	(Win95) flash-memory driver???
 0000h	STLTH64	     ?	N  N	Diamond Stealth64 driver
 0000h	STLTHMON     ?	N  N
 0000h	T20N3	     ?	N  N	(W4Wg)
 0000h	T30N3	     ?	N  N	(W4Wg)
 0000h	TCTOK	     ?	N  N	(W4Wg)
 0000h	TSENG	     ?	N  N	(Win95) Tseng Labs display driver
 0000h	UBNEI	     ?	N  N	(W4Wg)
 0000h	UNIMODEM     ?	?  ?	(Win95) Universal Modem Driver
 0000h	VDEF	     ?	N  N	(Win95)
 0000h	VGATEWAY     ?	N  Y	(Win95) dialin gateway
 0000h	VIDEO7	     ?	N  N	(Win95) Video7 display driver
 0000h	VRomD	     ?	N  N	(Win95)
 0000h	VStDspcD     ?	?  ?	Quarterdeck Stealth D*Space
 0000h	VXDMON	     ?	?  ?
 0000h	WD	     ?	N  N	(Win95)
 0000h	WINTOP	     ?	N  N	(Windows95 Power Toys)
 0000h	WSHTCP	     ?	N  N
 0000h	XGA	     ?	N  N	(Win95) XGA display driver
 0001h	VMM	     ?	N  N	Virtual Machine Manager
 0001h	VMM	     ?	Y  Y	Windows95 Virtual Machine Manager
 0002h	Debug	     ?	?  ?
 0003h	VPICD	     ?	Y  Y	Virtual Prog. Interrupt Controller (PIC) Device
 0004h	VDMAD	     ?	N  N	Virtual Direct Memory Access (DMA) Device
 0005h	VTD	     ?	Y  Y	Virtual Timer Device
 0006h	V86MMGR	     Y	N  N	(Windows3.x) Virtual 8086 Mode Device
 0006h	V86MMGR	     ?	N  Y	(Win95) Virtual 8068 Mode Device
 0007h	PageSwap     ?	N  N	Paging Device
 0008h	Parity	     ?	N  N	Parity-check trapper
 0009h	Reboot	     ?	N  Y	Ctrl-Alt-Del handler
 000Ah	VDD	     ?	N  Y	Virtual Display Device (GRABBER)
 000Bh	VSD	     ?	N  N	Virtual Sound Device
 000Ch	VMD	     Y	Y  Y	Virtual Mouse Device
 000Dh	VKD	     ?	N  Y	Virtual Keyboard Device
 000Eh	VCD	     ?	N  Y	Virtual COMM Device
 000Fh	VPD	     ?	N  Y	Virtual Printer Device
 0010h	VHD	     ?	?  ?	Virtual Hard Disk Device (Windows 3.0)
 0010h	BLOCKDEV     Y	N  N	Virtual Hard Disk Device (Windows 3.1)
 0010h	IOS	     N	N  N	(Win4Workgroups 3.11) DOS386 IOS Device
 0010h	IOS	     ?	Y  Y	Windows95 I/O Supervisor
 0011h	VMCPD	     ?	Y  Y	(Windows3.x) Virtual Math CoProcessor Device
 0011h	VMCPD	     ?	N  Y	(Win95) Virtual Math CoProcessor Device
 0012h	EBIOS	     ?	N  N	Reserve EBIOS page (e.g., on PS/2)
 0013h	BIOSXLAT     ?	N  N	Map ROM BIOS API between prot & V86 mode
 0014h	VNETBIOS     Y	N  N	Virtual NetBIOS Device
 0015h	DOSMGR	     Y	Y  N	DOS data instancing (see #02656)
 0016h	WINLOAD	     ?	?  ?
 0017h	SHELL	     ?	N  Y	(Windows3)
 0017h	SHELL	     ?	Y  Y	(Win95)
 0018h	VMPOLL	     Y	N  N
 0019h	VPROD	     ?	?  ?
 001Ah	DOSNET	     ?	N  N	assures network integrity across VMs
 001Ah	VNETWARE     ?	Y  Y	Novell NetWare DOSNET replacement
 001Bh	VFD	     ?	N  N	Virtual Floppy Device
 001Ch	VDD2	     ?	?  ?	Secondary display adapter
 001Ch	LoadHi	     ?	N  N	Netroom LoadHi Device (RMLODHI.VXD)
 001Ch	LoadHi	     ?	N  N	386MAX LoadHi Device (386MAX.VXD)
 001Ch	LoadHi	     ?	N  N	Win386 LoadHi Device (EMM386.EXE)
 001Dh	WINDEBUG     ?	N  Y
 001Dh	TDDebug	     ?	N  Y
 001Eh	TSRLoad	     ?	?  ?	TSR instance utility
 001Fh	BiosHook     ?	?  ?	BIOS interrupt hooker VxD
 0020h	Int13	     N	N  N
 0021h	PageFile     Y	N  Y	Paging File device
 0022h	SCSI	     ?	?  ?
 0022h	APIX	     ?	N  Y	(Win95)
 0023h	MCA_POS	     ?	?  ?	Microchannel Programmable Option Select
 0024h	SCSIFD	     ?	?  ?	SCSI FastDisk device
 0025h	VPEND	     ?	?  ?	Pen device
 0026h	APM	     ?	?  ?	Advanced Power Management
 0026h	VPOWERD	     ?	Y  Y	(Win95) power management
 0027h	VXDLDR	     N	Y  Y	(Win4Wg 3.11/Win95) VXD Loader
 0028h	NDIS	     N	Y  Y	(Win4Wg 3.11) Network Driver Interface Spec
 0029h	???
 002Ah	VWIN32	     ?	N  Y	(Win95)
 002Bh	VCOMM	     N	Y  Y	(Win4Workgroups 3.11) DOS386 VCOMM Device
 002Ch	SPOOLER	     ?	N  N	Windows95 print spooler
 002Dh	W32S	     Y	N  Y	WIN32s 32-bit extension to Windows API
 002Eh	???
 002Fh	???
 0030h	MACH32	     N	N  Y	ATI Mach32 video card
 0031h	NETBEUI	     N	N  N	(Win4Workgroups 3.11) NETBEUI
 0032h	SERVER	     N	Y  Y	(Win4Workgroups 3.11) Int21 File Server
 0032h	VSERVER	     ?	N  Y	(Win95) Int21 File Server
 0033h	CONFIGMG     ?	Y  Y	(Win95)
 0033h	EDOS	     ?	N  N	Windows DOS Box Enhancer by Mom's Software
 0034h	DWCFGMG.SYS  ?	Y  ?	DOS Plug-and-Play configuration manager
 0035h	SCSIPORT     ?	N  N	(Win95) virtualized access to SCSI adapter
 0036h	VFBACKUP     ?	Y  Y	(Win95)
 0037h	ENABLE	     ?	Y  Y	(Win95)
 0038h	VCOND	     ?	Y  Y	(Win95)
 0039h	???
 003Ah	VPMTD	     N	N  Y	(Win4Workgroups 3.11) IFAX Scheduler Device
 003Bh	DSVXD	     ?	Y  N	DoubleSpace VxD from MS-DOS v6.x
 003Ch	ISAPNP	     ?	N  N	(Win95)
 003Dh	BIOS	     ?	Y  Y	(Win95)
 003Eh	WSOCK	     ?	Y  Y	(Win95) WinSock
 003Fh	WSIPX	     ?	N  N	(Win95) IPX WinSock
 0040h	IFSMGR	     ?	N  N	(Win95)
 0041h	VCDFSD	     ?	N  N	(Win95) CD-ROM File System Driver (MSCDEX)
 0042h	MRCI2	     ?	N  N	(Win95) DriveSpace3
 0043h	PCI	     ?	N  N	(Win95)
 0048h	PERF	     ?	N  N	(Win95)
 004Ah	MTRR	     ?	N  N	(Win95SR2) PPro/P-II MTRR enumerator???
 004Bh	NTKERN	     ?	N  Y	(Win95SR2)
 0051h	ISAPNP	     ?	N  N	(Win95) ISA Plug-and-Play manager
 008Dh	ESDI_506     ?	N  N	(Win95) MFM/RLL/ESDI disk driver
 0090h	voltrack     ?	N  N	(Win95) Volume Tracker
 00FDh	FAKEIDE	     ?	N  N	(Chicago)
 0102h	CV1	     ?	N  N	Microsoft C/C++ 7.00+ CodeView for Windows
 011Fh	VFLATD	     ?	N  Y	(Win95)
 0200h	VIPX	     ?	Y  Y	NetWare Virtual IPX Driver
 0200h	VTEMPD	     ?	?  ?	dummy template driver by Ray Patch
 0201h	VNWLSERV     ?	N  N	NetWare Lite 1.1 Server (SERVER.EXE)
 0202h	WINICE	     ?	Y  Y	SoftICE/W
 0202h	SICE	     ?	Y  Y
 0203h	VCLIENT	     ?	N  Y	NetWare Lite 1.1+ Client
 0205h	VCAFT	     ?	N  N	Novell Virtual CAFT Driver (LANalyzer for Win)
 0205h	BCW	     ?	Y  Y	Nu-Mega Bounds Checker for Windows
 0206h	VTXRX	     ?	N  N	Novell Virtual TXRX Driver (LANalyzer for Win)
 0207h	DPMS	     N	Y  N	Novell DOS Protected Mode Services
 0234h	VCOMMUTE     ?	Y  Y	PC Tools Commute
 0442h	VTDAPI	     ?	N  Y	MMSys Win386 VTAPI Device
 0443h	???
 0444h	VADMAD	     ?	?  ?	Autoinitialize DMA (Windows 3.0)
 0445h	VSBD	     ?	Y  Y	WinResKit: Sound Blaster Device
 0446h	VADLIBD	     Y	Y  Y	MMSys Win386 AdLib Device (v3.x)
 0447h	???
 0448h	SETULTRA     ?	?  ?	Gravis UltraSound setup
 0449h	vjoyd	     ?	N  Y	(Win95) joystick
 044Ah	mmdevldr     ?	Y  Y	(Win95)
 044Bh	???
 044Ch	msmpu401     ?	N  N	(Win95) MPU-401 MIDI driver
 044Ch	cwdmidi	     ?	Y  Y	(Crystal???) MIDI driver
 044Dh	msopl	     ?	N  N	(Win95) OPL-3 (SoundBlaster FM) driver
 044Eh	mssblst	     ?	N  N	(Win95) SoundBlaster MIDI driver
 045Dh	VflatD	     ?	N  Y	dva.386, part of WIN32s
 045Eh	???
 045Fh	mssndsys     ?	?  ?	Microsoft Sound System audio driver
 045Fh	azt16	     ?	Y  Y	Aztech Sound Galaxy 16 audio driver
 0460h	UNIMODEM     ?	N  Y	Universal Modem driver
 0480h	VNetSup	     N	Y  Y	(Win4Workgrps 3.11) Virtual Network Support
 0481h	VRedir	     N	N  N	(Win4Workgroups 3.11) Redirector File System
 0481h	VREDIR	     ?	N  N	(Win95) Redirector File System driver
 0482h	VBrowse	     ?	Y  Y	Win386 Virtual Browser
 0482h	SNAPVXD	     ?	Y  Y	(Win95)
 0483h	VSHARE	     ?	N  N	(Win4Workgroups) Virtual SHARE
 0483h	VSHARE	     ?	Y  Y	(Win95) Virtual SHARE
 0484h	IFSMgr	     Y	N  Y	(Win4Wg 3.11) Installable File System Manager
 0485h	???			???
 0486h	VFAT	     N	Y  Y	(Win4Workgroups 3.11) Win386 HPFS Driver
 0487h	NWLINK	     ?	Y  Y	Win386 Virtual Packet Exchange Protocol
 0487h	NWSUP	     Y	N  N	NetWare Vnetbios shim
 0488h	VTDI	     ?	N  N	(Win95)
 0489h	VIP	     ?	Y  N	(Win95)
 0489h	FTCVIP	     ?	Y  Y	Frontier Technologies' VIP
 048Ah	VTCP	     ?	Y  ?
 048Ah	MSTCP	     ?	Y  N	(Win95) TCP stack
 048Ah	FTCTDI	     ?	Y  Y	Future Technologies' TCP stack
 048Bh	VCache	     N	Y  Y	(Win4Workgroups 3.11) Virtual File Cache
 048Bh	VCACHE	     ?	Y  Y	(Win95) disk cache
 048Ch	???			???
 048Dh	RASMAC	     ?	Y  Y	enhanced mode Win4Workgroups RASMAC device
 048Eh	NWREDIR	     ?	Y  Y	(Win95)
 048Fh	???			???
 0490h	???			???
 0491h	FILESEC	     ?	?  ?	(Win95) File Access Control Manager
 0492h	NWSERVER     ?	?  ?	(Win95)
 0493h	SECPROV	     ?	?  ?	(Win95) Security Provider
 0494h	NSCL	     ?	Y  Y	(Win95)
 0495h	AFVXD	     ?	N  N	(Win95)
 0496h	NDIS2SUP     ?	?  ?	(W4Wg???) NDIS2 networking support
 0497h	MSODISUP     ?	N  N	(W4Wg???)
 0498h	Splitter     ?	N  N	(Win95)
 0499h	PPPMAC	     ?	Y  Y	(Win95)
 049Ah	VDHCP	     ?	Y  Y	(Win95)
 049Bh	VNBT	     ?	Y  Y	(Win95) NetBIOS-over-TCP/IP driver
 049Ch	???
 049Dh	LOGGER	     ?	?  ?	(Win95)
 04A2h	IRLAMP	     ?	?  ?	IrDA Infrared Enumerator VxD
 097Ch	PCCARD	     ?	N  Y	(Win95) (see INT 20/VxD=097Ch)
 1020h	VCV	     ?	?  ?	Microsoft C/C++ 7.00 CodeView
 1021h	VMB	     ?	Y  Y	Microsoft C/C++ 7.00 WXSRVR
 1022h	Vpfd	     ?	Y  Y	Microsoft C/C++ 7.00
 1025h	MMD	     ?	Y  Y	Microsoft C/C++ 8.00, Visual C/C++ 1.00
 2020h	PIPE	     ?	Y  Y	by Thomas W. Olson, in Windows/DOS DevJrn 5/92
 21EAh	VADLIBWD     ?	N  Y	Adlib Waveform Driver by John Ridges
 2200h	VFINTD	     ?	Y  Y	Norton VFINTD (Norton Desktop)
 22C0h	???	     Y		Rational Systems DOS/4GW ???
 2402h	ZMAX	     ?	N  N	Qualitas 386MAX v7 DOSMAX handler
 24A0h	VNSS	     ?	N  Y	Norton Screen Saver (Norton Desktop)
 24A1h	VNDWD	     ?	Y  Y	Norton VNDWD Device (Norton Desktop)
 24A2h	SYMEvent     ?	Y  Y	Norton Utilities v8
 2540h	VILD	     ?	Y  N	INTERLNK client from MS-DOS v6.x
 2640h	VASBID	     ?	N  Y	WinResKit: Artisoft Sounding Board Device
 2860h	COMMTASK     N	N  Y	Windows 386-mode preemptive tasker by James
				  A. Kenemuth of Interabang Computing
 28A0h	PHARLAPX     ?	Y  ?	PharLap inter-VM communications DLL
 28A1h	PharLap	     Y	Y  Y	PharLap 386|DOS-Extender DOSXNT.386
 28C0h	VXD	     N	Y  Y	Generic VxD for real and protected mode by
				  Andrew Schulman in MSJ February 1993
 28C1h	PUSHKEYS     ?	?  ?	VKD_Force_Keys device
 28C2h	VCR3D	     ?	?  ?	Virtual CR3, by A.Schulman in MSJ October 1992
 2925h	EDOS	     ?	Y  Y	Enhanced DOS by Firefly Software
 292Dh	VSBPD	     ?	Y  Y	Sound Blaster Pro
 295Ah	GRVSULTR     ?	Y  Y	Gravis UltraSound / UltraSound ACE
 3048h	FTCTCPIP     ?	N  Y	Frontier Technologies' TCP/IP stack
 3049h	???			(called by FNFSC32.VXD, FrontierTech's VNFSD)
 304Ch	DWCFGMG.SYS  ?	Y	Plug-and-Play configuration access
 3098h	VstlthD	     N	N  N	for QEMM Stealth ROM mode
 3099h	VVidramD     ?	Y  N	for QEMM VIDRAM support
 30F6h	WSVV	     ?	N  Y	(Win95) WinSock for Voice-View Modems???
 310Eh	WPS	     ?	N  Y	MS DevNet CD-ROM: Windows Process Status
 3110h	VGSSD	     ?	Y  Y	VSGLX16.386 for Aztech Sound Galaxy 16
 313Bh	PMC	     ?	?  ?	Power Management Coordinator
 318Ah	LMOUSE	     ?	Y  Y	(Win95) Logitech mouse???
 31CFh	STAT.386     ?	?  ?	Ton Plooy's processor statistics VxD
 3202h	VdspD	     ?	N  N	(Win95)
 3203h	vpasd	     ?	N  N	(Win95) Pro Audio Spectrum driver
 32A4h	SBAWE	     ?	Y  Y	(Win95) SoundBlaster AWE driver
 32A5h	VSB16	     ?	N  N	(Win95) SoundBlaster 16 driver
 32CBh	VFRAD	     ?	Y  Y	Dr.Franz - Simultan's diagnotics VFRAD.386
 32DCh	NV3RM	     ?	N  Y	(Win95SR2)
 3354h	Discover     ?	N  Y	(Nuts&Bolts) Discover
 33AAh	DECCORE	     ?	Y  Y	(Win95) DEC Pathworks core VxD
 33B4h	DECLICL	     ?	N  N	(Win95)
 33F0h	VIWD	     ?	Y  Y	Gravis UltraSound Plug-n-Play Interwave v1.x
 33FCh	ASPIENUM     ?	N  N	(Win95)
 34DCh	MAGNARAM     ?	N  Y	Quarterdeck MagnaRAM (MAGNA31.VXD/MAGNA95.VXD)
 357Eh	DSOUND	     ?	Y  Y	(Win95) DirectSound
 3584h	VSNDSYS	     ?	Y  Y	(Win95SR2)
 35C5h	LUGEPS	     ?	Y  Y	Lugaru's Epsilon editor
 36AEh	AIB-PC.386   ?	Y  Y	Sunset Laboratory interface hardware driver
 377Bh	MX1501HAD    ?	?  ?	Cherry keyboard chipcard reader
 38BEh	Vheapx	     ?	N  Y	(Nuts&Bolts) Virtual Heap Expander
 38C0h	Bombshel     ?	N  Y	(Nuts&Bolts) Bombshelter
 38DAh	VIWD	     ?	Y  Y	UltraSound PnP InterWave driver v2.0beta
 39E6h	A3D	     ?	N  N	(Win95SR2)
 3A39h	CINEMSYS     ?	Y  Y	Software Cinemaster MPEG/DVD decoder
 3BFCh	CWCSPUD	     ?	N  N	(Win95SR2)
 3BFDh	CWCPROXY     ?	N  N	(Win95SR2)
 3BFEh	CWCMMSYS     ?	N  Y	(Win95SR2)
 3BFFh	CWCDSND	     ?	N  N	(Win95SR2)
 3C46h	X10MOUSE     ?	Y  Y	X10 RF wireless mouse
 3C78h	VGARTD	     ?	N  N	(Win95SR2)
 3E6Dh	DDRAW	     ?	Y  Y	DirectDraw
 3ED6h	ATIVVXXX     ?	N  Y	ATI Rage128-based video card
 3EE5h	WINTEL.VXD   ?	?  ?	"WinTel" Windows remote-control program
				(see also PORT 063Eh)
 4321h	POSTMSG	     ?	Y  Y	(see #02712)
 4321h	VPCD	     ?	N  N	PCache
 4321h	avvxp500     ?	N  N	(Win95) VxP500 driver
 6001h	REGVXD	     ?	Y  Y	Windows95 Registry Monitor helper
 7A5Fh	SIWVID	     Y	Y  Y	Soft-ICE for Windows video driver
 7FE0h	VSWITCHD     ?	Y  N	by Jeff Prosise
 7FE0h	VWFD	     N	Y  Y	reports windowed/fullscreen state; by Neil
				  Sandlin of Microsoft, shipped with ANSIPLUS
 7FE1h	VWATCHD	     N	Y  Y	basic driver w/ no functionality except tracing
				  by Keith Jin of Microsoft PSS
 7FE5h	VFINTD	     N	Y  Y	Virtual Floppy Interrupt trapper by Neil
				  Sandlin of Microsoft
 7FE7h	VMPAGES	     N	Y  Y	demonstration of exporting VxD services, by
				  Neil Sandlin of Microsoft
 7FE8h	VPOSTD	     ?	Y  Y	PostMessage() demo by Curtis J. Palmer of MS
 7FE9h	VIdleD	     N	N  N	demonstration of Call_When_Idle function, by
				  Bernie McIlroy of Microsoft
 7FEBh	VMIOD	     N	N  N	Virtual Monitor I/O Traffic Device, by Neil
				  Sandlin of Microsoft
 7FEDh	VMIRQD	     N	N  N	Virtual Monitor IRQ Traffic Device, by Neil
				  Sandlin of Microsoft
 8888h	VbillD	     ?	?  ?	Bill Potvin II's for reversing Compaq LTE video
 EEEEh	VEPSD	     ?	N  N	Virtual Extended Paging Services for
				  Borland C++ v4.0
Notes:	The high bit of the VxD ID is reserved for future use. Originally,
	  the next 10 bits were the OEM number which was assigned by Microsoft,
	  and the low 5 bits were the device number.  Currently, Microsoft
	  assigns VxD IDs individually for each driver; send blank email to
	  vxdid@microsoft.com for more information.
	"CallOut"=Y indicates that the VxD uses the INT 2F/AX=1607h/BX=VxDID
	  device callout interface; "PM" and "V86" indicate whether the VxD
	  provides an API entry point in protected mode and Virtual-86 mode
	  (e.g. DOS boxes)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0001" name="2F1684BX0001"><b>2F1684BX0001</b></a> - INT 2F - MS Windows95 - VMM - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows95 - VMM - GET API ENTRY POINT
	AX = 1684h
	BX = 0001h (virtual device ID for VMM) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02643)
		  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02643)
Call Windows VMM 16-bit entry point with:
	AX = function number
	    ---registry functions---
	    0100h "RegOpenKey"
		STACK:	DWORD	-&gt; DWORD for returned key handle
			DWORD	-&gt; ASCIZ registry key name
			DWORD	HKEY (see #02644)
	    0101h "RegCreateKey"
		STACK:	DWORD	-&gt; DWORD for returned key handle
			DWORD	-&gt; ASCIZ registry key name
			DWORD	HKEY (see #02644)
	    0102h "RegCloseKey"
		STACK:	DWORD	key handle from RegOpenKey or RegCreateKey
	    0103h "RegDeleteKey"
		STACK:	DWORD	-&gt; ASCIZ registry key name
			DWORD	HKEY (see #02644)
	    0104h "RegSetValue"
		STACK:	DWORD	???
			DWORD	-&gt; ???
			DWORD	???
			DWORD	-&gt; ???
			DWORD	HKEY (see #02644)
	    0105h "RegQueryValue"
		STACK:	DWORD	-&gt; DWORD for ???
			DWORD	-&gt; ASCIZ ???
			DWORD	-&gt; ASCIZ ???
			DWORD	HKEY (see #02644)
	    0106h "RegEnumKey"
		STACK:	DWORD	???
			DWORD	-&gt; ASCIZ ???
			DWORD	???
			DWORD	HKEY (see #02644)
	    0107h "RegDeleteValue"
	    0108h "RegEnumValue"
		STACK:	DWORD	-&gt; DWORD for ???
			DWORD	-&gt; BYTE ???
			DWORD	-&gt; DWORD for ???
			DWORD	-&gt; DWORD for ???
			DWORD	-&gt; DWORD for ???
			DWORD	-&gt; ASCIZ ???
			DWORD	???
			DWORD	HKEY (see #02644)
	    0109h "RegQueryValueEx"
	    010Ah "RegSetValueEx"
	    010Bh "RegFlushKey"
	    010Ch "RegLoadKey"
	    010Dh "RegUnLoadKey"
	    010Eh "RegSaveKey"
	    010Fh "RegRestore"
	    0110h "RegRemapPreDefKey"
Return: parameters popped from stack
	DX:AX = return value

(Table 02644)
Values for Windows95 VMM predefined HKEY values:
 80000000h	HKEY_CLASSES_ROOT
 80000001h	HKEY_CURRENT_USER
 80000002h	HKEY_LOCAL_MACHINE
 80000003h	HKEY_USERS
 80000004h	HKEY_PERFORMANCE_DATA
 80000005h	HKEY_CURRENT_CONFIG
 80000006h	HKEY_DYN_DATA
SeeAlso: #02643

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0003" name="2F1684BX0003"><b>2F1684BX0003</b></a> - INT 2F - MS Windows - VPICD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VPICD - GET API ENTRY POINT
	AX = 1684h
	BX = 0003h (virtual device ID for VPICD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02645)
		  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02645)
Call VPICD API entry point with:
	EAX = function number
	    0000h get version
		Return: AX = binary version (AH=major, AL=minor)
	    0001h virtualize timer???
	    0002h unvirtualize timer???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0005" name="2F1684BX0005"><b>2F1684BX0005</b></a> - INT 2F - MS Windows - VTD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VTD - GET API ENTRY POINT
	AX = 1684h
	BX = 0005h (virtual device ID for VTD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02646)
		  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02646)
Call VTD.386/VTD.VXD entry point with:
	AX = function number
	    0000h get VTD version number
		Return: CF clear
			AH = major version
			AL = minor version
	    0100h get current clock tick time
		Return: EDX:EAX = clock tick time in 840ns units since Windows
				  was started
	    0101h get current system time in milliseconds
		Return: EAX = time in milliseconds that Windows has been
				  running
	    0102h get current virtual machine time
		Return: EAX = cumulative amount of time the virtual machine has
				  been active, in milliseconds
Note:	this entry point should only be called directly when TOOLHELP.DLL
	  TimerCount() cannot be called
SeeAlso: #01268,#01270,#01269 at INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0006" name="2F1684BX0006"><b>2F1684BX0006</b></a> - INT 2F P - MS Windows95 - V86MMGR - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows95 - V86MMGR - GET API ENTRY POINT
	AX = 1684h
	BX = 0006h (virtual device ID for V86MMGR device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02647)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02647)
Call V86MMGR entry point with:
	EAX = function number
	    0000h get V86MMGR version
		Return: CF clear
			AH = major version
			AL = minor version
	    0001h get ???
		Return: CF clear
			EAX = status bits
				bit 0: ???
				bit 1: ???
				bit 2: ???
				bit 3: ???
				bit 4: ???
	    else
		Return: CF set

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0009" name="2F1684BX0009"><b>2F1684BX0009</b></a> - INT 2F P - MS Windows - REBOOT - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - REBOOT - GET API ENTRY POINT
	AX = 1684h
	BX = 0009h (virtual device ID for REBOOT device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02648)
		  0000h:0000h if the VxD does not support an API
SeeAlso: INT 14/AH=17h"FOSSIL",INT 16/AX=E0FFh

(Table 02648)
Call REBOOT protected-mode entry point with:
	AX = function
	    0100h warm boot
		Return: never
		Note:	broadcasts "Reboot_Processor" message, which is caught
			  by the VKD device
	    0201h set KERNEL Ctrl-Alt-Del handler
		ES:DI -&gt; new Ctrl-Alt-Del handler
		DS:SI -&gt; KERNEL reboot sanity check byte
		Return: CF clear
		Notes:	if an application installs its own handler and then
			  chains to Windows' handler, Windows will no longer
			  be able to detect hung applications, and will always
			  produce an "Application not responding" dialog
			DS must contain a writable, fixed selector because
			  the provided address is converted to a linear address
			  before being stored
			when Ctrl-Alt-Del is pressed in the system VM, Reboot
			  sets the sanity check byte to zero, schedules a
			  750ms wait, and then tests whether the check byte is
			  still zero; if not, it displays a message that there
			  is no hung application and then exits
	    0202h get KERNEL Ctrl-Alt-Del handler
		Return: CF clear
			ES:DI -&gt; current Ctrl-Alt-Del handler
		Note:	the default handler is located in KERNEL
	    0203h display "Application not responding" dialog box
		ES:DI -&gt; ASCIZ name of hung application
		Return: never if user pressed Ctrl-Alt-Del a second time
			CF clear
			AX = result
			    0000h user pressed Esc
			    0001h user pressed Enter
		Note:	this function is used by the default Windows
			  Ctrl-Alt-Del handler
	    0204h set/reset protected-mode INT 01 handler
		CX:EDX -&gt; new protected-mode INT 01 handler
		CX = 0000h restore protected-mode INT 01 handler
		Return: CF clear
		Notes:	if CX is nonzero, the current handler address is saved
			  internally before the new handler is set; this saved
			  address is then used when CX is zero on entry
			used by Windows' default Ctrl-Alt-Del handler; actual
			  fatal exit to DOS will be done on next INT 01
		Warning: opened files are not closed and remain open as
			  orphaned files in DOS
Note:	functions 0201h and 0203h are not useful outside the system VM
SeeAlso: #01271,#01273

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX000A" name="2F1684BX000A"><b>2F1684BX000A</b></a> - INT 2F P - MS Windows - VDD - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - VDD - GET API ENTRY POINT
	AX = 1684h
	BX = 000Ah (virtual device ID for VDD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02649)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02649)
Call VDD entry point with:
	EAX = function
	    0000h get VDD version
		Return: CF clear
			AH = major version
			AL = minor version
		Note:	also performs an internal initialization
	    0001h ???
		Return: ECX = ???
			???
	    0002h
	    0003h
	    0004h
	    0005h
	    0006h
	    0007h
	    0008h
	    0009h
	    0080h
	    0081h
	    0082h
	    0083h
	    0084h
	    0085h
	    0086h
	    0087h
	    0088h
	    0089h
	    else
		Return: nothing

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX000C" name="2F1684BX000C"><b>2F1684BX000C</b></a> - INT 2F - MS Windows - VMD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VMD - GET API ENTRY POINT
	AX = 1684h
	BX = 000Ch (virtual device ID for VMD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02650)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02650)
Call VMOUSE entry point with:
	EAX = function number
	    0000h get VMOUSE version
		Return: CF clear
			AH = major version
			AL = minor version
	    0001h
		EBX = ???
		ECX = ???
		Return: CF clear if successful
			CF set on error (e.g. fn 0003h not yet called)
	    0002h ??? (calls "test system VM handle")
		Return: CF clear if successful (in system VM)
			CF set on error
	    0003h ???
		ECX = ???
		DX = ???
		Return: CF clear
	    0004h ???
		Note: invokes Call_Priority_VM_Event
	    0005h get mouse port data
		Return: CF clear
			AL = ??? (04h)
			AH = mouse IRQ interrupt number (IRQ4=0Ch,etc.)
			CX = mouse I/O port address (e.g. 03F8h)
			DX = COM port number??? (0001h for mouse on COM1)
	    0100h NOP???
		Return: CF clear
	    0101h init???
		Return: CF clear
		Note:	appears to be the same as fn 0005h, but returns no data
	    0102h unimplemented
		Return: CF set
	    0103h check ???
		Return: AX = status (0000h/0001h)
		Note:	checks flag set by fn 0003h
	    else
		Return: CF set
SeeAlso: #02649,#02651

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX000D" name="2F1684BX000D"><b>2F1684BX000D</b></a> - INT 2F P - MS Windows - VKD - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - VKD - GET API ENTRY POINT
	AX = 1684h
	BX = 000Dh (virtual device ID for VKD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02651)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02651)
Call VKD entry point with:
	EAX = function
	    0000h get VKD version
		Return: CF clear
			AH = major version
			AL = minor version
	    0001h ???
		EBX = VM handle or 00000000h to use ??? VM handle
		CH = ???
		CL = ???
		EDX = ??? or FFFFFFFFh
		Return: CF clear if successful
			CF set on error
	    else
		Return: CF set
SeeAlso: #02650,#02652

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX000E" name="2F1684BX000E"><b>2F1684BX000E</b></a> - INT 2F P - MS Windows - VCD - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - VCD - GET API ENTRY POINT
	AX = 1684h
	BX = 000Eh (virtual device ID for VCD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02652)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02652)
Call VCD entry point with:
	EDX = function number
	    0000h get VCD version
		Return: CF clear
			AH = major version
			AL = minor version
	    0001h get ???
		Return: CF clear
			AX = bit mask of ???
	    0002h get ???
		CX = COM port number
		Return: CF clear
			DX:AX -&gt; ???
	    0003h set ???
		CX = COM port number
		DX:AX -&gt; new ???
		Return: CF clear
	    0004h acquire COM port
		AX = ???
		CX = COM port number
		Return: CF clear
			AX = ???
			EBX = ???
			DX = ???
	    0005h release COM port
		CX = COM port number
		Return: CF clear
	    0006h ???
		Return: CF set
			AL = 00h
	    else
		Return: CF set
			EAX = FFFFFFFFh
Note:	these functions are apparently only available from the system VM,
	  returning CF set and EAX=FFFFFFFFh otherwise
SeeAlso: #02651,#02653

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX000F" name="2F1684BX000F"><b>2F1684BX000F</b></a> - INT 2F P - MS Windows - VPD - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - VPD - GET API ENTRY POINT
	AX = 1684h
	BX = 000Fh (virtual device ID for VPD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02653)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02653)
Call VPD entry point with:
	EDX = function number
	    0000h get VPD version
		Return: CF clear
			AH = major version
			AL = minor version
			DX = ??? (CB01h)
	    0001h get valid??? printers
		Return: CF clear
			AX = bitmask of ??? printers (bits 0-2)
	    0002h get ??? for printer
		CX = printer port (0-2)
		Return: CF clear if successful
			    BX:AX = ???
			CF set on error (invalid port number)
	    0003h set ??? for printer
		CX = printer port (0-2)
		BX:AX = ???
		Return:	CF clear if successful
			CF set on error (invalid port number)
	    0004h ???
		CX = printer port (0-2)
		EAX = VM handle
		Return:	CF clear if successful
			CF set on error (invalid port number)
	    0005h ???
		CX = printer port (0-2)
		EAX = VM handle
		Return:	CF clear if successful
			CF set on error (invalid port number or ???)
	    0006h-000Eh unused
		Return: CF set
	    000Fh ???
		CX = printer port (0-2)
		AX = ???
		Return:	CF clear if successful
			CF set on error (e.g. invalid port number)
	    0010h ???
		CX = printer port (0-2)
		Return:	CF clear if successful
			CF set on error (e.g. invalid port number)
	    0011h ???
		CX = printer port (0-2)
		Return:	CF clear if successful
			CF set on error (e.g. invalid port number)
	    0012h get port status
		CX = printer port (0-2)
		Return:	CF clear if successful
			    AX = port status (see #P0658 at PORT 03BCh"LPT")
			CF set on error (e.g. invalid port number)
	    else
		Return: CF set
Note:	these functions are apparently only available from the system VM,
	  returning CF set
SeeAlso: #02652,#02654

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0010" name="2F1684BX0010"><b>2F1684BX0010</b></a> - INT 2F - MS Windows - IOS - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - IOS - GET API ENTRY POINT
	AX = 1684h
	BX = 0010h (virtual device ID for IOS device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02654)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02654)
Call IOS entry point with:
	EAX = function number
	    0000h ???
		Return: CF clear if successful
			    AX = 0000h
			CF set on error
			    AX = FFFFh
	    0001h check if ???
		Return: CF clear if successful
			    AX = 0000h
			CF set on error
			    AX = FFFFh
	    0002h requestor services???
		DL = service number???
		Return: CF clear if successful
			    AX = 0000h
			    DX = ???
			CF set on error
			    AX = FFFFh
		Note:	calls "IOS_Requestor_Service" (see INT 20"Windows")
	    0003h ??? (copies five bytes of data internally)
		Return: CF clear if successful
			    AX = 0000h
			    EDX = ???
			CF set on error
			    AX = FFFFh
	    else
		Return: CF set
			AX = FFFFh
SeeAlso: #02653,#02655

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0011" name="2F1684BX0011"><b>2F1684BX0011</b></a> - INT 2F - MS Windows - VMCPD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VMCPD - GET API ENTRY POINT
	AX = 1684h
	BX = 0011h (virtual device ID for VMCPD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02655)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02655)
Call Windows95 VMCPD protected-mode entry point with:
	EAX = function number
	    0000h get VMCPD version
		Return: CF clear
			AH = major version
			AL = minor version
	    0001h get ??? flags
		Return: CF clear
			AX = ??? flags
			    bit 0: ???
			    bit 1: ???
			    bit 2: ???
			    bit 3: ???
	    else
		Return: CF set
SeeAlso: #02654,#02656

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0015" name="2F1684BX0015"><b>2F1684BX0015</b></a> - INT 2F - MS Windows - DOSMGR - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - DOSMGR - GET API ENTRY POINT
	AX = 1684h
	BX = 0015h (virtual device ID for DOSMGR device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02656,#01282)
		  0000h:0000h if the VxD does not support an API
SeeAlso: #01282 at INT 20"Windows"

(Table 02656)
Call DOSMGR entry point with:
	AX = 0000h get DOSMGR version
	    Return: CF clear
		    AX = version (AH = major, AL = minor)
	AX = 0001h set critical focus
	    Return: CF clear
	AX = 0002h crash current virtual machine
	    Return: never
	    Note:   displays message box stating that "application has been
		      stopped by the DOSMGR device"
	AX = 0003h enter critical section
	    Note:   this function assumes that the code for INT 2A/AX=8001h
		      and INT 2A/AX=8002h have been modified for Windows
	AX = 0004h get VM ID byte
	    Return: CF clear if successful
			ES:DI -&gt; VM ID byte
		    CF set on error
	    Note:   this function fails if the INT 2A modifications have not
		      yet been applied
	AX = 0005h inform Windows of possible media change
	    BL = drive number (00h=A:)
	    Return: CF clear if successful
		    CF set on error
SeeAlso: #01282 at INT 20"Windows",#02655,#02657

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0017" name="2F1684BX0017"><b>2F1684BX0017</b></a> - INT 2F U - MS Windows - SHELL - GET API ENTRY POINT<br />
<pre>
INT 2F U - MS Windows - SHELL - GET API ENTRY POINT
	AX = 1684h
	BX = 0017h (virtual device ID for SHELL device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02657)
		  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h/BX=0021h,#01283 at INT 20"Windows"

(Table 02657)
Call SHELL entry point with:
	EDX = function number (0000h-0027h,0100h-0108h, mostly unknown)
	    0000h get version number
		Return: AX = version number
			EBX = system VM handle
	    0001h "SHELL_Get_SYSVM_Info" get system VM information
		Return: CF clear
			AX bit 0 set if system VM executing exclusively
			BX = background time slice priority
			CX = foreground time slice priority
			SI = minimum time slice in milliseconds
	    0002h "SHELL_Set_SYSVM_Info" set system VM information
		AX bit 0 set if system VM should execute exclusively (ignored?)
		BX = background time slice priority (1-10000)
		CX = foreground time slice priority (1-10000)
		SI = minimum time slice in milliseconds (1-10000)
		Return: CF clear if successful
	    0003h "SHELL_Crt_VM" create a virtual machine
		ES:EDI -&gt; SEB structure (see #02658)
		Return: CF clear if successful
			   EAX = VM handle
			CF set on error
			   EDX,EAX = result from GetSetDetailedVMError()
	    0004h "SHELL_Destroy_VM" destroy a virtual machine
		EBX = VM handle (not system VM)
		Return: nothing
	    0005h "SHELL_Set_Focus"
		EBX = VM handle
		ECX = ???
		Return: nothing
	    0006h "SHELL_Get_VM_State"
		EBX = VM handle (not system VM)
		ES:EDI -&gt; ??? structure
		Return: CF clear if successful
	    0007h "SHELL_Set_VM_State"
		EBX = VM handle (not system VM)
		ES:EDI -&gt; ??? structure
	    0008h "SHELL_Debug_Out"
		???
		Return: ???
		Note:	dummy function in retail version of MS Windows
	    0009h "SHELL_VMDA_Init"
		???
		Return: ???
	    000Ah "SHELL_VMDA_Exit"
		???
		Return: ???
	    000Bh "SHELL_Get_Message_Txt"
		???
		Return: ???
	    000Ch "SHELL_Event_Complete"
		???
		Return: ???
	    000Dh "SHELL_Get_Contention_Info"
		???
		Return: ???
	    000Eh "SHELL_Get_Clip_Info"
		???
		Return: ???
	    000Fh "SHELL_Set_Paste"
		???
		Return: ???
	    0010h "SHELL_Switcher_Assist"
		???
		Return: ???
	    0011h "SHELL_Get_FileSysChng"
		???
		Return: ???
	    0012h "SHELL_Query_Destroy"
		???
		Return: ???
	    0013h "SHELL_SetFocus_Cur_VM" set input focus to current VM
		???
		Return: ???
	    0014h "SHELL_User_Busy_API"
		???
		Return: ???
	    0015h "SHELL_Chng_Hot_Key"
		???
		Return: ???
	    0016h "SHELL_Get_TermInfo"
		???
		Return: ???
	    ---Windows95---
	    0017h ???
	    0018h ???
	    0019h ???
	    001Ah ???
	    001Bh ???
	    001Ch ???
	    001Dh ???
	    001Eh ???
	    001Fh ???
	    0020h ???
	    0021h ???
	    0022h ???
	    0023h ???
	    0024h ???
	    0025h ???
	    0026h ???
		Note:	makes VxDCALL 00178002h (see INT 20"Windows")
	    0027h ???
	    0100h get ??? version
		Return: AX = version??? (0400h for Windows95)
	    0101h not implemented
		Return: CF set
			EAX = FFFFFFFFh
	    0102h not implemented
		Return: CF set
			EAX = FFFFFFFFh
	    0103h not implemented
		Return: CF set
			EAX = FFFFFFFFh
	    0104h ???
	    0105h ???
	    0106h ???
		???
		Return: CF clear if successful
			CF set on error
	    0107h get SDK version for VxD
		AX = VxD identifier
		Return: EAX = VxD ID (high word) and SDK version (low)
			    00000000h if no such VxD loaded
		Note:	makes a VMMCALL 0001013Fh (see INT 20"Windows")
			  followed by ???
	    0108h ???
Return: CF set if called from VM other than system VM
	    EAX = FFFFFFFFh
Note:	except for functions 0013h,0026h,and 010xh, this API may only be
	  called from the system VM
SeeAlso: #01283 at INT 20"Windows"

Format of Shell Execution Block (SEB):
Offset	Size	Description	(Table 02658)
 00h	DWORD	PIF flags (see #02659)
 04h	DWORD	display flags (see #02660)
 08h	PWORD	-&gt; pathname of .EXE to run
 0Eh	PWORD	-&gt; argument list
 14h	PWORD	-&gt; working drive/directory
 1Ah	WORD	desired number of V86 pages for virtual machine
 1Ch	WORD	minimum number of V86 pages for VM
 1Eh	WORD	foreground priority
 20h	WORD	background priority
 22h	WORD	maximum KB of EMS
 24h	WORD	minimum KB of EMS
 26h	WORD	maximum KB of XMS
 28h	WORD	minimum KB of XMS
 2Ah	WORD	maximum KB of DPMI???
 2Ch	WORD	minimum KB of DPMI???
 2Eh 128 BYTEs	title
Note:	the PWORDs at offsets 08h,0Eh, and 14h consist of a DWORD offset
	  followed by a WORD selector

Bitfields for 386 Enhanced Mode PIF flags:
Bit(s)	Description	(Table 02659)
 0	exclusive use of processor when VM is fullscreen
 1	VM runs in background
 2	VM runs in window
 3-4	???
 5	Alt-Tab reserved
 6	Alt-Esc reserved
 7	Alt-Space reserved
 8	Alt-Enter reserved
 9	Alt-PrtSc reserved
 10	PrtSc reserved
 11	Ctrl-Esc reserved
 12	VM will release idle time slice
 13	VM not allowed to use high memory
 14	???
 15	VM expanded memory not pageable
 16	VM extended memory not pageable
 17	Fast paste from clipboard enabled
 18	VM application memory not pageable
 30	Close VM when application exits
SeeAlso: #02658,#02660

Bitfields for SHELL display options:
Bit(s)	Description	(Table 02660)
 0	emulate text mode
 1	monitor text port
 2	monitor low graphics port
 3	monitor high graphics port
 7	Retain video memory
SeeAlso: #02658,#02659

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX001A" name="2F1684BX001A"><b>2F1684BX001A</b></a> - INT 2F - MS Windows - VNETWARE - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VNETWARE - GET API ENTRY POINT
	AX = 1684h
	BX = 001Ah (virtual device ID for VNETWARE device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX001D" name="2F1684BX001D"><b>2F1684BX001D</b></a> - INT 2F P - MS Windows - WINDEBUG - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - WINDEBUG - GET API ENTRY POINT
	AX = 1684h
	BX = 001Dh (virtual device ID for WINDEBUG device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0021" name="2F1684BX0021"><b>2F1684BX0021</b></a> - INT 2F PU - MS Windows - PAGEFILE - GET API ENTRY POINT<br />
<pre>
INT 2F PU - MS Windows - PAGEFILE - GET API ENTRY POINT
	AX = 1684h
	BX = 0021h (virtual device ID for PAGEFILE device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02661)
		  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h/BX=0017h,#01289 at INT 20"Windows"

(Table 02661)
Call PAGEFILE entry point with:
	AX = function
	    0000h get version
		Return: CF clear
			AX = version (AH = major, AL = minor)
	    0001h get swap file info
		DS:SI -&gt; 128-byte buffer for swap file full pathname
		DS:DI -&gt; 128-byte buffer for SPART.PAR full pathname
		Return: CF clear
			AL = pager type (see #02662)
			AH = flags
			    bit 7: swap file corrupted
			ECX = maximum size of swap file
			DS:SI buffer filled if paging enabled
			DS:DI buffer filled if permanent swap file
	    0002h delete permanent swap file on exit
		Return: CF clear
	    0003h get current temporary swap file size
		Return: CF clear
			DX:AX = current swap file size in bytes
				0000h:0000h if permanent swap file
Note:	this API is only available in protected mode, and may only be called
	  from the system VM
SeeAlso: #01289 at INT 20"Windows",#02663

(Table 02662)
Values for MS Windows PAGEFILE pager type:
 00h	paging disabled
 01h	MSDOS
 02h	BIOS
 03h	32-bit disk access
SeeAlso: #02661

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0022" name="2F1684BX0022"><b>2F1684BX0022</b></a> - INT 2F P - MS Windows - APIX - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - APIX - GET API ENTRY POINT
	AX = 1684h
	BX = 0022h (virtual device ID for APIX device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02663)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02663)
Call APIX protected-mode entry point with:
	AH = function number
	    00h get APIX version
		Return: CF clear
			AH = major version
			AL = minor version
	    01h ???
		Return: CF clear
			AX = number of ???
	    02h NOP
		Return: CF clear
	    03h ???
		Return: CF clear
			AX = 0000h/FFFFh
	    else
		Return: CF clear (bug?)
SeeAlso: #02661,#02666

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0026" name="2F1684BX0026"><b>2F1684BX0026</b></a> - INT 2F P - MS Windows - VPOWERD - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - VPOWERD - GET API ENTRY POINT
	AX = 1684h
	BX = 0026h (virtual device ID for VPOWERD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02664)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02664)
Call VPOWERD.VXD entry point with:
	AX = function number
	    0000h get VPOWERD version
		Return: DX = 0000h
			AX = version (AH = major, AL = minor)
	    0001h get APM BIOS version
		Return: DX:AX = APM BIOS version
	    0002h get current power management level
		Return: DX:AX = power management level
	    0003h enable/disable power management (see INT 15/AX=5308h)
		??? = new state of power management
		Return: DX:AX = 0000h:0000h if successful
			   else error code (see #02665)
	    0004h set power state (see INT 15/AX=5307h)
		Return: DX:AX = 0000h:0000h if successful
			   else error code (see #02665)
	    0005h set system power status
		Return: DX:AX = 0000h:0000h if successful
			   else error code (see #02665)
	    0006h restore APM power-on defaults (see INT 15/AX=5309h)
		Return: DX:AX = 0000h:0000h if successful
			   else error code (see #02665)
	    0007h get power status (see INT 15/AX=530Ah)
		Return: ???
	    0008h get APM 1.1 power state (see INT 15/AX=530Ch)
		Return: ???
	    0009h invoke OEM APM function
		??? -&gt; buffer containing parameters for INT 15/AX=5380h
		Return: DX:AX = 0000h:0000h or error code (see #02665)
			buffer updated if successful
	    000Ah register power handler
		???
		Return: DX:AX = 0000h:0000h or error code
	    000Bh deregister power handler
		???
		Return: DX:AX = 0000h:0000h or error code (see #02665)
	    000Ch Win32 get system power status
	    000Dh Win32 set system power status
	    else
		Return: DX = 0000h
			AX = 00FFh
SeeAlso: #02663,#02666

(Table 02665)
Values for VPOWERD.VXD error code:
 000000xxh	APM error code
 000000FFh	function number out of range
 80000001h	??? (service 05h)
 80000002h	??? (service 0Dh)
 80000003h	specified NULL buffer pointer (service 07h,08h,09h)
 80000005h	??? (service 03h)
 80000006h	??? (service 04h)
 80000007h	??? (service 05h)
 80000008h	??? (service 05h)
 80000009h	out of memory (service 0Ah)
 8000000Ah	??? (service 0Ah)
 8000000Bh	invalid power handler (service 0Bh)
 8000000Ch	unsupported/disabled??? function
SeeAlso: #02664,#01290

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0027" name="2F1684BX0027"><b>2F1684BX0027</b></a> - INT 2F - MS Windows95 - VXDLDR - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows95 - VXDLDR - GET API ENTRY POINT
	AX = 1684h
	BX = 0027h (virtual device ID for VXDLDR device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02666)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02666)
Call VXDLDR entry point with:
	EAX = function number
	    0000h get VXDLDR version
		Return: CF clear
			AX = 0000h (successful)
			DH = major version
			DL = minor version
	    0001h load device
		DS(???):DX -&gt; ASCIZ path name of dynamically-loadable VxD
			(driver must reside in current directory or Windows
			  system directory???)
		ES:DI = 0000h:0000h
		Return: CF clear if successful
			    AX = 0000h
			    ES:DI -&gt; VxD API entry point
			CF set on error
			    AX = error code (see #02667)
	    0002h unload device
		EBX = device ID or FFFFFFFFh (Undefined_Device_ID)
		---if EBX=FFFFFFFFh ---
		(DS???):DX -&gt; ASCIZ name of dynamically-loadable device
			  (case-sensitive)
		Return: CF clear if successful
			    AX = 0000h
			CF set on error
			    AX = error code (see #02667)
	    else
		Return: CF set
			AX = 000Bh
SeeAlso: #02664,#02668

(Table 02667)
Values for VXDLDR error code:
 0000h	successful
 000Bh	invalid function number
SeeAlso: #02666

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0028" name="2F1684BX0028"><b>2F1684BX0028</b></a> - INT 2F - MS Windows - NDIS - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - NDIS - GET API ENTRY POINT
	AX = 1684h
	BX = 0028h (virtual device ID for NDIS device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02668)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02668)
Call NDIS.VXD entry point with:
	??? = function number
	    0000h set ??? to ???
		??? = new ???
		Return: DX:AX = 0000h:0001h
	    0002h ???
		???
		Return: DX:AX -&gt; ???
	    0003h reset ??? to default
		Return: DX:AX = 0000h:0001h
	    else
		Return: DX:AX = 0000h:0000h
SeeAlso: #02666,#02669

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX002A" name="2F1684BX002A"><b>2F1684BX002A</b></a> - INT 2F P - MS Windows - VWIN32 - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - VWIN32 - GET API ENTRY POINT
	AX = 1684h
	BX = 002Ah (virtual device ID for VWIN32 device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02669)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02669)
Call VWIN32.VXD entry point with:
	AH = function number
	    00h get VWIN32 version and ???
		Return: CF clear
			AH = major version
			AL = minor version
			EDX = ???
	    01h ???
		EBX = ???
		ECX = ???
		Return: CF clear
			EAX = ???
	    02h ???
		Return: CF clear
			AX = ??? or 0000h
	    03h address allocation
		DS:??? -&gt; buffer containing/for page data
		ECX = length of buffer
		AL = subfunction
		    00h reserve page(s)
		    01h commit page(s)
		    02h decommit page(s)
		    03h free page(s)
		Return: CF clear if successful
			CF set on error
		Note:	this function uses ECX bytes of stack
	    04h get ???
		Return: CF clear
			EAX = ???
	    05h ???
		EBX = ???
		Return: CF clear
			EAX = ???
	    06h ???
		EBX = ???
		Return: CF clear
			EAX = ???
	    07h ???
		EBX = ???
		Return: CF clear
			EAX = ???
	    08h get ???
		Return: CF clear
			AX = ???
	    09h ???
		EBX = ???
		ECX = ???
		Return: CF clear
	    0Ah ???
		EBX = ???
		Return: CF clear
	    0Bh ???
		EBX = ???
		Return: CF clear
	    0Ch ???
		EBX = ???
		ECX = ???
		EDX = ???
		???
		Return: CF clear if successful
			    EAX = ???
			CF set on error
	    0Dh clear ???
		Return: CF clear
	    0Eh ???
		EBX = ???
		ECX = ???
		Return: CF clear
	    0Fh ???
		EBX = ???
		ECX = ???
		Return: CF clear
	    10h ???
		Return: CF clear
		Note:	invokes VMMcall 00010184h
	    11h ???
		Return: CF clear
		Note:	invokes VMMcall 00010160h
	    12h ???
		???
	    13h pop up system error dialogue
		Return: CF clear
			AX = ??? or 0000h
	    14h "IFSMgr_GetConversionTablePtrs"
		Return:	CF clear
			DX:AX -&gt; ???
		Note:	invokes VxDcall 00400051h
	    15h "Boost_With_Decay"
		EBX = ???
		ECX = ???
		EDX = ???
		Return: CF clear
	    else
		Return: CF set
SeeAlso: #02668,#02670

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX002B" name="2F1684BX002B"><b>2F1684BX002B</b></a> - INT 2F - MS Windows - VCOMM - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VCOMM - GET API ENTRY POINT
	AX = 1684h
	BX = 002Bh (virtual device ID for VCOMM device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02670)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02670)
Call VCOMM.VXD entry point with:
	AX = function number
	    0000h open COM/LPT port
		BX = port number (00h-7Fh = COMx, 80h-FFh = LPTx)
		Return: DX:AX = handle???
	    0001h set comm state
		???
		Return: AX = ???
	    0002h setup comm port
		???
		Return: AX = status (0000h failed, FFFFh success)
	    0003h transmit character
		EBX = handle???
		CL = character to transmit
		Return: AX = status???
	    0004h close comm port
		EBX = handle???
		Return: ???
	    0005h clear comm error
		EBX = handle???
		EAX = ???
		Return: AX = status???
	    0006h "EscapeCommFunction"
		EBX = handle???
		CX = ???
		EAX = ???
		Return: DX:AX = ???
	    0007h purge buffers
		EBX = handle???
		CX = ???
		Return: AX = status???
	    0008h set comm event mask
		EBX = handle???
		CX = new event mask
		Return: AX = status???
	    0009h get comm event mask
		EBX = handle???
		Return: AX = current event mask
	    000Ah ???
		EBX = handle???
		Return: ???
	    000Bh "WriteComm"
		EBX = handle???
		CX = number of characters to write
		ES???:BX -&gt; buffer (if CX &gt; 1)
		SI??? low byte contains character if CX=1
		Return: AX = status
			EAX high word may be destroyed
	    000Ch "ReadComm"
		EBX = handle???
		CX = number of bytes to read
		ES???:DI -&gt; buffer
		Return: AX = status ???
			ZF = ???
	    000Dh set ??? callback
		EBX = handle???
		CX = ???
		DX = ???
		Return: AX = status???
	    else
		Return: AX = 0000h
SeeAlso: #02669,#02671

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX002D" name="2F1684BX002D"><b>2F1684BX002D</b></a> - INT 2F P - MS Windows - W32S - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - W32S - GET API ENTRY POINT
	AX = 1684h
	BX = 002Dh (virtual device ID for W32S device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0030" name="2F1684BX0030"><b>2F1684BX0030</b></a> - INT 2F P - MS Windows - MACH32 - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - MACH32 - GET API ENTRY POINT
	AX = 1684h
	BX = 0030h (virtual device ID for MACH32 device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0032" name="2F1684BX0032"><b>2F1684BX0032</b></a> - INT 2F - MS Windows - SERVER / VSERVER - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - SERVER / VSERVER - GET API ENTRY POINT
	AX = 1684h
	BX = 0032h (virtual device ID for SERVER device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02671)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",#01296 at INT 20"Windows"

(Table 02671)
Call Windows95 VSERVER.VXD protected-mode entry point with:
	AX = function number
	    0003h NOP
		Return: AX = 0000h
	    0004h NOP
		Return: AX = 0000h
	    0007h NOP
		Return: AX = 0000h
	    0008h NOP
		Return: nothing
	    000Fh ???
		Return: AX = status
			    0000h successful
			    0842h on error
	    0010h ???
		Return: AX = status
			    0000h successful
			    0842h on error
	    else
		Return: AX = 0032h
SeeAlso: #02670,#02672

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0033" name="2F1684BX0033"><b>2F1684BX0033</b></a> - INT 2F - MS Windows - CONFIGMG - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - CONFIGMG - GET API ENTRY POINT
	AX = 1684h
	BX = 0033h (virtual device ID for CONFIGMG device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02672)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02672)
Call CONFIGMG.VXD entry point with:
	AX = function number
	    0000h get CONFIGMG version
		Return: CF clear
			AH = major version
			AL = minor version
	    ...
	    005Ah
	    else
		Return: CF set
			AX = 0020h
SeeAlso: #01297 at INT 20"Windows",#02671,#02673

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0034" name="2F1684BX0034"><b>2F1684BX0034</b></a> - INT 2F - Intel Plug-and-Play - CONFIGURATION MANAGER - GET ENTRY POINT<br />
<pre>
INT 2F - Intel Plug-and-Play - CONFIGURATION MANAGER - GET ENTRY POINT
	AX = 1684h
	BX = 0034h (ID for Configuration Manager) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; API entry point (see #02673)
		  0000h:0000h if Configuration Manager not loaded
Note:	this API is often provided by a DOS device driver, in which case it
	  is available whether or not MSWindows is running
Index:	installation check;Plug-and-Play Configuration Manager
SeeAlso: AX=1684h/BX=304Ch

(Table 02673)
Call Configuration Manager entry point with:
	AX = function
	    0000h "CM_GetVersion" get supported DDI version
		Return: AH = BCD major version
			AL = BCD minor version
			BX = number of devices identified by configuration
		Note:	returns AX = 0000h if no config manager installed
	    0001h "CM_GetConfig" get device configuration
		BX = device index
		ES:DI -&gt; buffer for configuration information (see #02675)
		Return: AX = status
			    0000h successful
				ES:DI buffer filled
			    other error code (0001h = index out of range)
	    0002h "CM_LockConfig" lock device configuration
		ES:DI -&gt; configuration information (see #02675)
		Return: AX = status
			    0000h successful
				ES:DI buffer filled with assigned config
			    0001h resources conflict
			    0002h invalid request or configuration info
	    0003h "CM_UnlockConfig" unlock device configuration
		ES:DI -&gt; configuration information (see #02675)
		Return: AX = status
			    0000h successful
				ES:DI buffer filled with assigned config
			    0001h invalid request or configuration info
	    0004h "CME_QueryResources" get hot-swappable resources
		ES:DI -&gt; configuration information (see #02675)
		Return: AX = status (see #02674)
	    0005h "CME_AllocResources" remove resources from available pool
		ES:DI -&gt; configuration information (see #02675)
		Return: AX = status (see #02674)
	    0006h "CME_DeallocResources" return resources to available pool
		ES:DI -&gt; configuration information (see #02675)
		Return: AX = status (see #02674)
SeeAlso: #01298 at INT 20"Windows",#02672,#02676

(Table 02674)
Values for Configuration Manager status:
 00h	successful
 01h	device not found, configuration error
 02h	I/O port unavailable
 04h	IRQ unavailable
 08h	DMA channel unavailable
 10h	memory range unavailable
SeeAlso: #02673

Format of Configuration Information Structure:
Offset	Size	Description	(Table 02675)
 00h	DWORD	bus ID
 04h	DWORD	device ID
 08h	DWORD	serial number
 0Ch	DWORD	logical ID
 10h	DWORD	flags
---ISA bus---
 14h	BYTE	Card Select Number
 15h	BYTE	logical device number
 16h	WORD	Read Data port
------
 18h	WORD	number of memory windows
 1Ah  9 DWORDs	physical base addresses of memory windows
 3Eh  9 DWORDs	length of memory windows
 62h  9 WORDs	memory window attributes
 74h	WORD	number of I/O ports
 76h 20 WORDs	I/O port base addresses
 B6h 20 WORDs	lengths of I/O port ranges
 F6h	WORD	number of IRQs
 F8h  7 BYTEs	IRQ registers
 FFh  7 BYTEs	IRQ attributes
106h	WORD	number of DMA channels
108h  7 BYTEs	DMA channels used
10Fh  7 WORDs	DMA channel attributes
11Dh  3 BYTEs	reserved
SeeAlso: #02673

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0036" name="2F1684BX0036"><b>2F1684BX0036</b></a> - INT 2F - MS Windows - VFBACKUP - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VFBACKUP - GET API ENTRY POINT
	AX = 1684h
	BX = 0036h (virtual device ID for VFBACKUP device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02676)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02676)
Call VFBACKUP.VXD entry point with:
	nothing -- this API is a NOP for the default Windows95 VFBACKUP
SeeAlso: #02673,#01126

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0037" name="2F1684BX0037"><b>2F1684BX0037</b></a> - INT 2F - MS Windows - ENABLE.VXD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - ENABLE.VXD - GET API ENTRY POINT
	AX = 1684h
	BX = 0037h (virtual device ID for ENABLE device) (see #02677)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02676)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02677)
Call Windows95 ENABLE.VXD entry point with:
	AX = function number
	    0000h get ENABLE version
		Return:	CF clear
			AX = version (AH = major, AL = minor)
	    0001h
		EBX = ???
		Return: ???
	    0002h get ???
		Return: CF clear
			DX:AX = ???
	    0003h get ???
		Return: CF clear
			DX:AX = ???
	    0004h ???
		EBX = ???
		ECX = ???
		EDX = ???
		Return: CF clear if successful
			CF set on error
	    else
		Return: CF set
SeeAlso: #02676,#02678

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0038" name="2F1684BX0038"><b>2F1684BX0038</b></a> - INT 2F - MS Windows - VCOND - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VCOND - GET API ENTRY POINT
	AX = 1684h
	BX = 0038h (virtual device ID for VCOND device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02678)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02678)
Call VCOND.VXD virtual-86 entry point with:
	AX = function number
	    0202h
	    0203h
	    0204h
	    0205h
	    0206h
	    0207h
	    0208h
	    0209h
	    020Ah
	    020Bh
	    020Dh
	    020Eh
	    020Fh
	    0210h
	    0401h
	    0402h
	    0403h
	    0404h
	    0405h
	    else
		NOP
SeeAlso: #02679,#02677

(Table 02679)
Call VCOND.VXD protected-mode entry point with:
	AX = function number
	    0301h
	    0302h
	    0303h
	    0304h
	    0305h
	    0306h
	    0307h
	    0308h
	    else
		NOP
SeeAlso: #02678,#02676

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX003B" name="2F1684BX003B"><b>2F1684BX003B</b></a> - INT 2F - MS Windows - DSVXD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - DSVXD - GET API ENTRY POINT
	AX = 1684h
	BX = 003Bh (virtual device ID for DSVXD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX003D" name="2F1684BX003D"><b>2F1684BX003D</b></a> - INT 2F - MS Windows - BIOS VxD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - BIOS VxD - GET API ENTRY POINT
	AX = 1684h
	BX = 003Dh (virtual device ID for BIOS device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02680)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02680)
Call BIOS.VXD entry point with:
	AX = function number
	    0000h get BIOS.VXD version
		Return: CF clear
			AH = major version
			AL = minor version
	    0100h ???
		Return: AX = 0000h
		Note:	calls CONFIGMG services 804Eh/804Fh
	    0200h ???
		Return: CF clear if successful
			    AX = ???
			CF set on error
			    AX = error code???
		Note:	invokes VxDcall 00290002h
	    0300h ???
		Return: CF clear if successful
			    AX = ???
			CF set on error
			    AX = error code???
	    else
		Return: CF set
SeeAlso: #02679,#02681

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX003E" name="2F1684BX003E"><b>2F1684BX003E</b></a> - INT 2F - MS Windows - WSOCK - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - WSOCK - GET API ENTRY POINT
	AX = 1684h
	BX = 003Eh (virtual device ID for WSOCK device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX011F" name="2F1684BX011F"><b>2F1684BX011F</b></a> - INT 2F P - MS Windows - VFLATD - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - VFLATD - GET API ENTRY POINT
	AX = 1684h
	BX = 011Fh (virtual device ID for VFLATD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02681)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",AX=1684/BX=045Dh,INT 20"Windows"

(Table 02681)
Call VFLATD.VXD entry point with:
	DL = function number
	    00h get VFLATD version and ???
		Return: CF clear
			EAX = version (AH = major, AL = minor)
			EBX = ???
			ECX = ???
			EDX = ??? or 00000000h
	    01h ???
		AX = ???
		CX = ???
		Return: EAX = ???
			EDX = ???
	    02h ???
		???
	    03h ???
		EAX = ???
		EBX = ???
		ESI = ???
		CX = ???
		DH = ???
		Return: EAX = ???
			EDX = ???
			CF clear
	    04h ???
		DH = ???
		EAX = ???
		ECX = ???
		Return: CF clear
			EAX = ???
			EDX = ???
	    05h ???
		???
		Note:	locks some linear memory and calls fn 02h
	    06h ???
		???
		Return: CF clear if successful
			CF set on error
		Note:	calls fn 02h and unlocks some linear memory
	    else
		Return: CF set
SeeAlso: #02680

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0200" name="2F1684BX0200"><b>2F1684BX0200</b></a> - INT 2F - MS Windows - VIPX - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VIPX - GET API ENTRY POINT
	AX = 1684h
	BX = 0200h (virtual device ID for VIPX device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0202" name="2F1684BX0202"><b>2F1684BX0202</b></a> - INT 2F - MS Windows - WINICE - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - WINICE - GET API ENTRY POINT
	AX = 1684h
	BX = 0202h (virtual device ID for WINICE device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0203" name="2F1684BX0203"><b>2F1684BX0203</b></a> - INT 2F P - MS Windows - VCLIENT - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - VCLIENT - GET API ENTRY POINT
	AX = 1684h
	BX = 0203h (virtual device ID for VCLIENT device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0205" name="2F1684BX0205"><b>2F1684BX0205</b></a> - INT 2F - MS Windows - BCW - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - BCW - GET API ENTRY POINT
	AX = 1684h
	BX = 0205h (virtual device ID for BCW device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0207" name="2F1684BX0207"><b>2F1684BX0207</b></a> - INT 2F R - MS Windows - DPMS VxD - GET API ENTRY POINT<br />
<pre>
INT 2F R - MS Windows - DPMS VxD - GET API ENTRY POINT
	AX = 1684h
	BX = 0207h (virtual device ID for DPMS device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0234" name="2F1684BX0234"><b>2F1684BX0234</b></a> - INT 2F - MS Windows - VCOMMUTE - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VCOMMUTE - GET API ENTRY POINT
	AX = 1684h
	BX = 0234h (virtual device ID for VCOMMUTE device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0442" name="2F1684BX0442"><b>2F1684BX0442</b></a> - INT 2F P - MS Windows - VTDAPI - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - VTDAPI - GET API ENTRY POINT
	AX = 1684h
	BX = 0442h (virtual device ID for VTDAPI device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02682)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02682)
Call VTDAPI.VXD entry point with:
	EAX = function number
	    0000h
	    0001h
	    0002h
	    0003h
	    0004h
	    0005h
	    0006h
	    0007h
	    0008h
	    0009h
	    000Ah
	    000Bh
	    else
		Return: nothing???
SeeAlso: #02682

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0444" name="2F1684BX0444"><b>2F1684BX0444</b></a> - INT 2F - MS Windows - VADMAD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VADMAD - GET API ENTRY POINT
	AX = 1684h
	BX = 0444h (virtual device ID for VADMAD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02683)
		  0000h:0000h if the VxD does not support an API

(Table 02683)
Call VADMAD entry point with:
	DX = operation
	    0000h set VADMAD mode
		AX = desired mode
	    0001h set VADMAD channel
		AX = desired channel
Note:	after setting mode/channel, start the DMA operation with an OUT to
	  I/O port 0Bh (channels 0-3) or D6h (channels 4-7)
SeeAlso: #01268 at INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0445" name="2F1684BX0445"><b>2F1684BX0445</b></a> - INT 2F - MS Windows - VSBD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VSBD - GET API ENTRY POINT
	AX = 1684h
	BX = 0445h (virtual device ID for VSBD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0446" name="2F1684BX0446"><b>2F1684BX0446</b></a> - INT 2F - MS Windows - VADLIBD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VADLIBD - GET API ENTRY POINT
	AX = 1684h
	BX = 0446h (virtual device ID for VADLIBD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0449" name="2F1684BX0449"><b>2F1684BX0449</b></a> - INT 2F P - MS Windows - vjoyd - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - vjoyd - GET API ENTRY POINT
	AX = 1684h
	BX = 0449h (virtual device ID for "vjoyd" device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02684)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02684)
Call VJOYD.VXD entry point with:
	AX = function number
	    0000h get VJOYD version
		Return: AH = major version
			AL = minor version
	    0001h ???
		DX = ???
		Return: DX:AX = ???
	    0002h ???
		DX = ???
		Return: DX:AX = ???
	    0003h ???
		Retrun: AX = 0001h
	    0004h ???
		DX = ???
		Return: DX:AX = ???
	    0005h ???
		Return: ???
	    else
		Return: EAX = 00000000h
SeeAlso: #02682,#02685

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX044A" name="2F1684BX044A"><b>2F1684BX044A</b></a> - INT 2F - MS Windows - mmdevldr - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - mmdevldr - GET API ENTRY POINT
	AX = 1684h
	BX = 044Ah (virtual device ID for "mmdevldr" device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02685)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02685)
Call MMDEVLDR.VXD entry point with:
	DX = function number
	    0000h ???
		Return: CF clear if successful
			    AX = 0000h
			CF set on error
			    AX = error code (000Bh)
		Note:	invokes VxDCall 17000Eh ("CallAtAppyTime")
	    0001h ???
		Return: CF clear if successful
			    AX = 0000h
			CF set on error
			    AX = error code (000Bh)
		Note:	invokes VxDCall 17000Eh ("CallAtAppyTime")
	    0002h ???
		EDX = ???
		Return: CF clear if successful
			    AX = 0000h
			    EDX = ???
			CF set on error
			    AX = error code
	    0003h ???
		Return: CF clear if successful
			    AX = 0000h
			CF set on error
			    AX = error code
		Note:	invokes VxDcall 2A0002h ("VWIN32_QueueUserApc")
	    0004h set Win32 event
		Return: CF clear if successful
			    AX = 0000h
			CF set on error
			    AX = error code
		Note:	invokes VxDcall 2A000Eh ("VWIN32_SetWin32Event")
	    0005h ??? (allocates some memory)
		Return: CF clear
			AX = 0000h
	    0006h ??? (frees memory)
		Return: CF clear if successful
			    AX = 0000h
			CF set on error
			    AX = error code
	    else
		Return: CF set
			AX = 000Bh (invalid function)
SeeAlso: #02684,#02686

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX045D" name="2F1684BX045D"><b>2F1684BX045D</b></a> - INT 2F P - MS Windows - VflatD - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - VflatD - GET API ENTRY POINT
	AX = 1684h
	BX = 045Dh (virtual device ID for VflatD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",AX=1684h/BX=011Fh,INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX045F" name="2F1684BX045F"><b>2F1684BX045F</b></a> - INT 2F - MS Windows - azt16 - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - azt16 - GET API ENTRY POINT
	AX = 1684h
	BX = 045Fh (virtual device ID for "azt16" device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02686)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h/BX=3110h,AX=1684h"DEVICE API",INT 20"Windows"

(Table 02686)
Call azt16.VXD entry point with:
	DX = function number
	    0000h get azt16 version
		Return: CF clear
			AX = version (AH=major, AL=minor)
	    0001h ???
		AX = subfunction
		    0000h ???
			Return:
		    0001h ???
			ECX = ???
		    else error
		Return: CF clear if successful
			    ???
			CF set on error
			    AX = error code
	    0002h ???
		AX = ???
		BX = ???
		Return: ???
	    0003h ???
		AX = ???
		BX = ???
		Return: ???
	    0004h ???
		BX = ???
		CX = ???
		Return: CF clear if successful
			     AX = 0001h
			CF set on error
			     AX = 0000h
	    0005h ???
		BX = ???
		CX = ???
		Return: CF clear if successful
			     AX = 0001h
			CF set on error
			     AX = 0000h
	    0006h ???
		BX = ???
		ECX = ???
		Return: CF clear if succesful
			    AX = ???
			CF set on error
			    AX = FFFFh
	    0100h get azt16 version
		Return: CF clear
			AX = version (AH=major, AL=minor)
	    0101h
		AX = ???
		ECX = ???
		Return: CF clear if successful
			    AX = 0001h
			CF set on error
			    AX = 0000h
	    0102h ???
		AX = ???
		Return: CF clear if successful
			CF set on error
			    AX = reason??? (0/1/2)
	    0103h ???
		AX = ???
		Return: CF clear if successful
			    AX = 0000h
			CF set on error
			    AX = reason??? (1/3)
	    0200h ???
		EDX = ???
		???
		Return: CF clear if successful
			    DX:AX = ???
			CF set on error
			    DX:AX = 0000h:0000h
	    0201h ???
		???
		Return: CF clear
			AX= 0000h
	    else
		Return: CF set
SeeAlso: #02685,#02705

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0460" name="2F1684BX0460"><b>2F1684BX0460</b></a> - INT 2F P - MS Windows - UNIMODEM - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - UNIMODEM - GET API ENTRY POINT
	AX = 1684h
	BX = 0460h (virtual device ID for UNIMODEM device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02687)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02687)
Call UNIMODEM.VXD protected-mode entry point with:
	AX = function number
	    0000h
		Return: AX = ???
	    0001h
		Return: AX = ???
	    0002h
		Return: AX = ???
	    0003h
		Return: AX = ???
	    0004h
		Return: AX = ???
	    0005h
		Return: AX = ???
	    0006h
		Return: AX = ???
	    0007h
		Return: AX = ???
	    else
		Return: AX = 0002h
SeeAlso: #02686,#02688

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0480" name="2F1684BX0480"><b>2F1684BX0480</b></a> - INT 2F - MS Windows - VNetSup - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VNetSup - GET API ENTRY POINT
	AX = 1684h
	BX = 0480h (virtual device ID for VNetSup device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02688)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02688)
Call VNetSup.VXD entry point with:
	AX = function number
	    0000h
		Return: AX = ???
	    0001h
		Return: AX = ???
	    0002h
		Return: AX = ???
	    else
		Return: CF set
			AX = 0001h
SeeAlso: #02687,#02689

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0482" name="2F1684BX0482"><b>2F1684BX0482</b></a> - INT 2F - MS Windows - VBrowse - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VBrowse - GET API ENTRY POINT
	AX = 1684h
	BX = 0482h (virtual device ID for VBrowse device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0483" name="2F1684BX0483"><b>2F1684BX0483</b></a> - INT 2F - MS Windows - VSHARE - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VSHARE - GET API ENTRY POINT
	AX = 1684h
	BX = 0483h (virtual device ID for VSHARE device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02689)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02689)
Call Windows95 VSHARE.VXD entry point with:
	AX = function number
	    0000h get VSHARE version
		Return: AH = major version
			AL = (BCD?) minor version
	    else
		NOP
SeeAlso: #02688

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0484" name="2F1684BX0484"><b>2F1684BX0484</b></a> - INT 2F P - MS Windows - IFSMgr - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - IFSMgr - GET API ENTRY POINT
	AX = 1684h
	BX = 0484h (virtual device ID for IFSMgr device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0486" name="2F1684BX0486"><b>2F1684BX0486</b></a> - INT 2F - MS Windows - VFAT - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VFAT - GET API ENTRY POINT
	AX = 1684h
	BX = 0486h (virtual device ID for VFAT device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0487" name="2F1684BX0487"><b>2F1684BX0487</b></a> - INT 2F - MS Windows - NWLINK - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - NWLINK - GET API ENTRY POINT
	AX = 1684h
	BX = 0487h (virtual device ID for NWLINK device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0489" name="2F1684BX0489"><b>2F1684BX0489</b></a> - INT 2F R - MS Windows - VIP - GET API ENTRY POINT<br />
<pre>
INT 2F R - MS Windows - VIP - GET API ENTRY POINT
	AX = 1684h
	BX = 0489h (virtual device ID for VIP device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX048A" name="2F1684BX048A"><b>2F1684BX048A</b></a> - INT 2F - MS Windows 3.11 - VXDLDR - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows 3.11 - VXDLDR - GET API ENTRY POINT
	AX = 1684h
	BX = 048Ah (virtual device ID for VTCP device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX048A_0" name="2F1684BX048A_0"><b>2F1684BX048A</b></a> - INT 2F - MS Windows - VCACHE - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VCACHE - GET API ENTRY POINT
	AX = 1684h
	BX = 048Ah (virtual device ID for VCACHE device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02691)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02690)
Call Windows95 VCACHE.VXD entry point with:
	Return:	CF set
SeeAlso: #02689,#02691

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX048D" name="2F1684BX048D"><b>2F1684BX048D</b></a> - INT 2F - MS Windows - RASMAC - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - RASMAC - GET API ENTRY POINT
	AX = 1684h
	BX = 048Dh (virtual device ID for RASMAC device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX048E" name="2F1684BX048E"><b>2F1684BX048E</b></a> - INT 2F - MS Windows - NWREDIR - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - NWREDIR - GET API ENTRY POINT
	AX = 1684h
	BX = 048Eh (virtual device ID for NWREDIR device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02691)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02691)
Call Windows95 NWREDIR.VXD entry point with:
	Return:	CF set
		EAX = FFFFFFFFh
SeeAlso: #02690

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0494" name="2F1684BX0494"><b>2F1684BX0494</b></a> - INT 2F - MS Windows - NSCL - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - NSCL - GET API ENTRY POINT
	AX = 1684h
	BX = 0494h (virtual device ID for NSCL device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02692,#02693)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02692)
Call Windows95 NSCL.VXD virtual-86 entry point with:
	AL = function number
	    00h
	    01h
	    02h
	    03h
	    04h
	    05h
	    06h
	    07h
	    08h
	    09h
	    0Ah
	    else
		Return: AX = FFFFh
SeeAlso: #02691,#02692

(Table 02693)
Call Windows95 NSCL.VXD protected-mode entry point with:
	AL = function number
	    00h
	    01h
	    02h
	    03h
	    else
		Return: AX = FFFFh
SeeAlso: #02692

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX0499" name="2F1684BX0499"><b>2F1684BX0499</b></a> - INT 2F - MS Windows - PPPMAC - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - PPPMAC - GET API ENTRY POINT
	AX = 1684h
	BX = 0499h (virtual device ID for PPPMAC device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX049A" name="2F1684BX049A"><b>2F1684BX049A</b></a> - INT 2F - MS Windows - VDHCP - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VDHCP - GET API ENTRY POINT
	AX = 1684h
	BX = 049Ah (virtual device ID for VDHCP device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX049B" name="2F1684BX049B"><b>2F1684BX049B</b></a> - INT 2F - MS Windows - VNBT - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VNBT - GET API ENTRY POINT
	AX = 1684h
	BX = 049Bh (virtual device ID for VNBT device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX1021" name="2F1684BX1021"><b>2F1684BX1021</b></a> - INT 2F - MS Windows - VMB - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VMB - GET API ENTRY POINT
	AX = 1684h
	BX = 1021h (virtual device ID for VMB device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX28A0" name="2F1684BX28A0"><b>2F1684BX28A0</b></a> - INT 2F - MS Windows - PHARLAPX - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - PHARLAPX - GET API ENTRY POINT
	AX = 1684h
	BX = 28A0h (virtual device ID for PHARLAPX device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02694)
		  0000h:0000h if the VxD does not support an API

(Table 02694)
Call PHARLAPX VxD entry point with:
	AX = function
	    0001h get PHARLAP.386 version
		Return: AX = version number (AH = major, AL = minor)
	---queue functions---
	    0101h allocate a new message queue
		CX = size of queue data buffer in bytes
		Return: DX:AX = handle for new queue, or 0000h:0000h on error
	    0102h allocate a new key queue
		CX = size of queue data buffer in bytes
		EDX = VM handle into which keys will be pasted
		Return: DX:AX = handle for new queue, or 0000h:0000h on error
	    0103h free message queue
		EDX = queue handle
		Return: AX = status (0000h,0003h,0007h) (see #02695)
	    0104h free key queue
		EDX = queue handle
		Return: AX = status (0000h,0003h,0005h) (see #02695)
	    0105h add message to communications queue
		EDX = queue handle
		BX = length of message data in bytes
		CX = length of message header in bytes
		ES:(E)SI -&gt; message header
		GS:(E)DI -&gt; message data
		Return: AX = status (0000h-0003h,0007h) (see #02695)
	    0106h remove message from queue
		EDX = queue handle
		CX = length of buffer in bytes
		ES:(E)SI -&gt; buffer for message
		Return: AX = status (0000h,0003h,0006h,0007h,0008h) (see #02695)
			CX = length of returned message (if AX=0000h or 0008h)
	    0107h flush queue (remove all data)
		EDX = queue handle
		Return: AX = status (0000h,0003h) (see #02695)
	    0108h add PasteKey structure(s) to key queue
		EDX = queue handle
		CX = number of PasteKey structures in buffer
		ES:(E)SI -&gt; PasteKey array (see #02696)
		Return: AX = status (0000h-0003h) (see #02695)
	    0109h register enqueueing callback function
		EDX = queue handle
		ECX = function argument
		ES:(E)SI -&gt; callback function
		Return: AX = status (0000h,0003h,0009h) (see #02695)
	    010Ah register dequeueing callback function
		EDX = queue handle
		ECX = function argument
		ES:(E)SI -&gt; callback function
		Return: AX = status (0000h,0003h,0009h) (see #02695)
	    010Bh unregister enqueueing callback function
		EDX = queue handle
		Return: AX = status (0000h,0003h,0009h) (see #02695)
	    010Ch unregister dequeueing callback function
		EDX = queue handle
		Return: AX = status (0000h,0003h,0009h) (see #02695)
	    010Dh get message queue status
		EDX = queue handle
		Return: AX = status (0000h,0003h) (see #02695)
			CX = number of pending messages
	    010Eh peek at message in queue
		EDX = queue handle
		BX = number of message in queue (0000h = first)
		CX = size of buffer in bytes
		ES:(E)SI -&gt; buffer for message
		Return: AX = status (0000h,0003h,0006h,0008h) (see #02695)
			CX = length of returned message (if AX=0000h or 0008h)
	    010Fh peek at last message in queue
		EDX = queue handle
		CX = size of buffer in bytes
		ES:(E)SI -&gt; buffer for message
		Return: AX = status (0000h,0003h,0006h,0008h) (see #02695)
			CX = length of returned message (if AX=0000h or 0008h)
	    0110h replace last message in queue
		EDX = queue handle
		CX = length of message header in bytes
		BX = length of message data in bytes
		ES:(E)SI -&gt; message header
		GS:(E)DI -&gt; message data
		Return: AX = status (0000h,0002h,0003h) (see #02695)
	    0111h set permitted message count for queue
		EDX = queue handle
		CX = maximum number of messages to enqueue (FFFFh = unlimited)
		Return: AX = status (0000h,0003h) (see #02695)
	---generalized VxD services---
	    0202h call VxD function
		ES:(E)BX -&gt; in/out register-set buffer
		Return: buffer updated
	    0203h map flat
		???
	--system register functions---
	    0301h read system registers into buffer
		ES:(E)SI -&gt; 512-byte buffer
		Return: AX = 0000h
			buffer filled (mostly zeros)
	    0302h copy linear memory into buffer
		EDX = linear address
		CX = number of bytes to copy
		ES:(E)SI -&gt; buffer
		Return: AX = 0000h
	    0303h copy data into linear memory
		EDX = linear address
		CX = number of bytes to copy
		ES:(E)SI -&gt; buffer
		Return: AX = 0000h
	    0304h freeze VM
		???
	    0305h unfreeze VM
		???
	---name registration functions---
	    0401h register name
		EDX = magic number to associate with name
		ES:(E)SI -&gt; name to register
		Return: AX = status (0000h,0009h) (see #02695)
	    0402h unregister name
		ES:(E)SI -&gt; name to be unregistered
		Return: AX = status (0000h,0009h) (see #02695)
	    0403h look up name
		ES:(E)SI -&gt; name to look up
		Return: DX:AX = magic number or 0000h:0000h if not registered
	    0404h get name list handle
		Return: DX:AX = name list handle
				0000h:0000h if not initialized
	---special DOS server routines (undocumented)---
	    0501h register
	    0502h unregister
	    0503h validate VM
	    0504h get INT9 count
	    0505h get screen line
	    0506h get shift status
	    0507h get server PB pointer
	    0508h initialize DOS shell
	    0509h get last VM handle

(Table 02695)
Values for PHARLAPX function status:
 00h	successful
 01h	data is too large to fit in queue
 02h	queue is full
 03h	invalid queue handle
 04h	invalid VM handle for queue
 05h	error starting a paste operation
 06h	queue is empty
 07h	a VM is blocked waiting on the queue
 08h	message was too long (truncated)
 09h	unable to register or unregister specified callback
SeeAlso: #02694

Format of PHARLAPX PasteKey structure:
Offset	Size	Description	(Table 02696)
 00h	BYTE	ASCII code
 01h	BYTE	scan code (see #00006)
 02h	WORD	shift states
SeeAlso: #02694

Format of PHARLAPX VxD-call register structure:
Offset	Size	Description	(Table 02697)
 00h	DWORD	call number
 04h	WORD	input register map (see #02698)
 06h	WORD	output register map (see #02698)
 08h  7 DWORDs	values for EAX, EBX, ECX, EDX, EBP, ESI, EDI on call
 24h  4	WORDs	values for DS, ES, FG, GS on call
 2Ch	DWORD	EFLAGS on call
 30h  7 DWORDs	returned values of EAX, EBX, ECX, EDX, EBP, ESI, EDI
 4Ch  4 WORDs	returned values of DS, ES, FS, GS
 54h	DWORD	returned EFLAGS
SeeAlso: #02694

Bitfields for PHARLAPX VxD-call register map:
Bit(s)	Description	(Table 02698)
 0	value in EAX field is valid
 1	value in EBX field is valid
 2	value in ECX field is valid
 3	value in EDX field is valid
 4	value in EBP field is valid
 5	value in ESI field is valid
 6	value in EDI field is valid
 7	value in DS field is valid
 8	value in ES field is valid
 9	value in FS field is valid
 10	value in GS field is valid
 11	value in EFLAGS field is valid
SeeAlso: #02697

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX28A1" name="2F1684BX28A1"><b>2F1684BX28A1</b></a> - INT 2F - MS Windows - PharLap VxD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - PharLap VxD - GET API ENTRY POINT
	AX = 1684h
	BX = 28A1h (virtual device ID for PharLap device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",AX=1684h/BX=28A0h,INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX2925" name="2F1684BX2925"><b>2F1684BX2925</b></a> - INT 2F - MS Windows - EDOS - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - EDOS - GET API ENTRY POINT
	AX = 1684h
	BX = 2925h (virtual device ID for EDOS device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02699)
		  0000h:0000h if the VxD does not support an API

(Table 02699)
Call EDOS entry point with:
	AX = 0000h get EDOS version number
	    Return: AH = major version
		    AL = minor version
	AX = 0001h display message
	    CX = 0
	    DX:BX -&gt; ASCIZ Message
	AX = 0002h get EDOS error coded
	    Return: EAX = time in milliseconds that Windows has been running
	AX = 0003h execute windows program
	    Return: EAX = cumulative amount of time the virtual machine has
			been active, in milliseconds
	AX = 0008h get/set priority
	    BX = 0000h??? foreground
		 0001h background
	    DI = 0000h get
		 0001h set
	    DX = priority setting
	    Return: CX = foreground priority
		    DX = background priority
		    BX:AX = flags
			00000001h exclusive ON
			00000010h background ON
		    SI = CPU percentage

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX292D" name="2F1684BX292D"><b>2F1684BX292D</b></a> - INT 2F - MS Windows - VSBPD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VSBPD - GET API ENTRY POINT
	AX = 1684h
	BX = 292Dh (virtual device ID for VSBPD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX295A" name="2F1684BX295A"><b>2F1684BX295A</b></a> - INT 2F - MS Windows - GRVSULTR - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - GRVSULTR - GET API ENTRY POINT
	AX = 1684h
	BX = 295Ah (virtual device ID for GRVSULTR device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX304C" name="2F1684BX304C"><b>2F1684BX304C</b></a> - INT 2F - Intel Plug-and-Play - CONFIGURATION ACCESS - GET ENTRY POINT<br />
<pre>
INT 2F - Intel Plug-and-Play - CONFIGURATION ACCESS - GET ENTRY POINT
	AX = 1684h
	BX = 304Ch (ID for Configuration Access) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; API entry point (see #02700)
		  0000h:0000h if Configuration Access not loaded
Note:	this API is often provided by a DOS device driver, in which case it
	  is available whether or not MSWindows is running
Index:	installation check;Plug-and-Play Configuration Access
SeeAlso: AX=1684h/BX=0034h

(Table 02700)
Call Plug-and-Play Configuration Access entry point with:
	AX = function
	    0000h "CA_GetVersion"
		Return: AX = BCD version (AH = major, AL = minor)
	    0001h "CA_PCI_Read_Config_Byte" (see also INT 1A/AX=B108h)
	!!!
	    0002h "CA_PCI_Read_Config_Word" (see also INT 1A/AX=B109h)
	    0003h "CA_PCI_Read_Config_DWord" (see also INT 1A/AX=B10Ah)
	    0004h "CA_PCI_Write_Config_Byte" (see also INT 1A/AX=B10Bh)
	    0005h "CA_PCI_Write_Config_Word" (see also INT 1A/AX=B10Ch)
	    0006h "CA_PCI_Write_Config_DWord" (see also INT 1A/AX=B10Dh)
	    0007h "CA_PCI_Generate_Special_Cycle" (see also INT 1A/AX=B106h)
	    0008h "CA_PCI_Get_Routing_Options" (see also INT 1A/AX=B10Eh)
	    0009h invalid function
	    000Ah invalid function
	    000Bh "CA_PnPISA_Get_Info"
	    000Ch "CA_PnPISA_Read_Config_Byte"
	    000Dh "CA_PnPISA_Write_Config_Byte"
	    000Eh "CA_PnPISA_Get_Resource_Data"
	    000Fh invalid function
	    0010h "CA_EISA_Get_Board_ID"
	    0011h "CA_EISA_Get_Slot_Config"
	    0012h "CA_EISA_Get_SlotFunc_Config"
	    0013h "CA_EISA_Clear_NVRAM_Config"
	    0014h "CA_EISA_Write_Config"
	    0015h invalid function
	    0016h "CA_ESCD_Get_Info"
	    0017h "CA_ESCD_Read_Config"
	    0018h "CA_ESCD_Write_Config"
	    0019h invalid function
	    001Ah "CA_Acfg_PCI_Manage_IRQs"
		DL = IRQ???
		ES:DI -&gt; ???
		Return: AX = status
	    001Bh "CA_Acfg_PCI_Get_Routing_Options"
		ES:DI -&gt; IRQ routing table header
			  (see #01259 at INT 1A/AX=B406h)
		Return: AX = status
	    001Ch-001Fh invalid functions
	    0020h "CA_PnPB_Get_Num_Sys_Dev_Nodes"
	    0021h "CA_PnPB_Get_Sys_Dev_Node"
	    0022h "CA_PnPB_Set_Sys_Dev_Node"
	    0023h "CA_PnPB_Get_Stat_Res_Info"
	    0024h "CA_PnPB_Set_Stat_Res_Info"
Return: AX = FFFFh if unsupported function
SeeAlso: #02701

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX3099" name="2F1684BX3099"><b>2F1684BX3099</b></a> - INT 2F - MS Windows - VVidramD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VVidramD - GET API ENTRY POINT
	AX = 1684h
	BX = 3099h (virtual device ID for VVidramD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02701)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02701)
Call VVidramD (VIDRAM.VXD) virtual-86 entry point with:
	AX = function number
	    0000h map page???
		BX = page number???
		Return: CF clear if successful
			CF set on error
	    0001h ???
		Return: CF clear if successful
			CF set on error
	    else
		Return: CF set
SeeAlso: #02700,#02702

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX30F6" name="2F1684BX30F6"><b>2F1684BX30F6</b></a> - INT 2F P - MS Windows - WSVV - GET API ENTRY POINT<br />
<pre>
INT 2F P - MS Windows - WSVV - GET API ENTRY POINT
	AX = 1684h
	BX = 30F6h (virtual device ID for WSVV device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02702)
Call WSVV.VXD protected-mode entry point with:
	AX = function number
	    ????
	Return: ???
SeeAlso: #02701,#02703

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX310E" name="2F1684BX310E"><b>2F1684BX310E</b></a> - INT 2F - MS Windows - WPS - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - WPS - GET API ENTRY POINT
	AX = 1684h
	BX = 310Eh (virtual device ID for WPS device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02703)
		  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02703)
Call WPS protected-mode entry point with:
	DX = function
	    0000h get WPS.386 version
		Return: CF clear
			AX = version (AH = major, AL = minor)
	    0001h get number of installed VxDs
		Return: CF clear
			AX = number of installed VxDs
	    0002h get VxD characteristics
		AX = number of VxD
		ES:BX -&gt; buffer for VxD characteristics structure (see #02704)
		Return: CF clear
			ES:BX buffer filled
SeeAlso: #02702,#02706

Format of WPS.386 VxD characteristics structure:
Offset	Size	Description	(Table 02704)
 00h	WORD	VxD ID number
 02h	BYTE	VxD minor version
 03h	BYTE	VxD major version
 04h	BYTE	DDK minor version
 05h	BYTE	DDK major version
 06h	WORD	flags
		bit 0: V86 API supported
		bit 1: PM API supported
		bit 2: services supported
 08h	DWORD	start order
 0Ch  9 BYTEs	ASCIZ VxD name
SeeAlso: #02703

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX3110" name="2F1684BX3110"><b>2F1684BX3110</b></a> - INT 2F - MS Windows - VSGLX16.386 - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VSGLX16.386 - GET API ENTRY POINT
	AX = 1684h
	BX = 3110h (virtual device ID for VSGLX16.386) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02705)
		  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h/BX=045Fh,AX=1684h"DEVICE API",INT 20"Windows"

(Table 02705)
Call VSGLX16.386 entry point with:
	DX = function number
	    0000h get azt16 version
		Return: CF clear
			AX = version returned by "azt16" device
	    0001h get ???
		AX = ??? (always fails if nonzero)
		ES:BX -&gt; buffer for ???
			first DWORD of buffer must be set to length of buffer
			  (in bytes, 1 &lt;= size &lt;= 92) before calling
		Return: CF clear if successful
			    AX = 0001h
			CF set on error (invalid pointer, bad buffer size)
			    AX = 0000h
	    0002h
		AX = ???
		BX = ???
		Return: CF clear if successful
			    AX = ???
			CF set on error
			    AX = error code
	    0003h
		AX = ???
		BX = ???
		Return: CF clear if successful
			CF set on error
	    0004h set ???
		ES:DI -&gt; buffer containing ???
		BX = ???
		CX = number of bytes to copy
		Return: CF clear if successful
			    AX = 0001h
			CF set on error
			    AX = 0000h
	    0005h get ???
		ES:DI -&gt; buffer for ???
		BX = ???
		CX = number of bytes to copy
		Return: CF clear if successful
			    AX = 0001h
			CF set on error
			    AX = 0000h
	    else
		Return: CF set
SeeAlso: #02686

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX31CF" name="2F1684BX31CF"><b>2F1684BX31CF</b></a> - INT 2F - MS Windows - STAT.386 - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - STAT.386 - GET API ENTRY POINT
	AX = 1684h
	BX = 31CFh (virtual device ID for STAT.386) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02706)
		  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02706)
Call STAT.386 entry point with:
	AX = function
	    0000h get version
		Return: AX = STAT.386 version (AH = major, AL = minor)
	    0001h execute RDMSR/WRMSR/RDTSC
		BH = 00h
		BL = second opcode byte (30h=WRMSR,31h=RDTSC,32h=RDMSR)
		EDX:EDI = value to be written (for BL=30h)
		ECX = MSR number for RDMSR/WRMSR
		Return: EDX:EAX = value read (RDTSR/RDMSR only)
SeeAlso: #02703,#02707

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX34DC" name="2F1684BX34DC"><b>2F1684BX34DC</b></a> - INT 2F - QEMM v8.01 - MAGNARAM VxD - GET API ENTRY POINT<br />
<pre>
INT 2F - QEMM v8.01 - MAGNARAM VxD - GET API ENTRY POINT
	AX = 1684h
	BX = 34DCh (virtual device ID for MAGNARAM) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02707)
		  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02707)
Call MAGNARAM MAGNA95.VXD protected-mode entry point with:
	AX = function number
	    0000h get version and ???
		Return: AX = version (AH = major, AL = minor)
			CX = ???
			    bit 0: ???
			    bit 1: ???
	    0001h get ???
		Return: CF clear
			DX:AX = ??? SHL 2
	    0002h
		Return: CF clear if successful
			    AX = ???
			    DX = ???
			CF set on error
	    0003h get ???
		Return: CF clear
			DX:AX = ??? SHL 2
	    0004h ???
		Return: CF clear
			DX:AX = ???
	    0005h ???
		Return: CF clear
			DX:AX = ???
	    0006h ???
		Return: CF clear
			DX:AX = ???
	    0007h ???
		Return: CF clear
			DX:AX = ???
	    0008h ???
		Return: CF clear
			DX:AX = ???
	    0009h ???
		Return: CF clear
			DX:AX = ???
	    000Ah ???
		Return: CF clear
			DX:AX = ???
	    000Bh get ???
		Return: CF clear
			DX:AX = ??? SHL 2
	    000Ch get ???
		Return: CF clear
			DX:AX = ??? SHL 2
	    000Dh get ???
		Return: CF clear
			DX:AX = ??? SHL 2
	    000Eh get ???
		Return: CF clear
			AX = ???
			DX = ???
	    000Fh get ???
		Return: CF clear
			DX:AX = ???
	    0010h get ???
		Return: CF clear
			DX:AX = ???
	    0011h get ???
		Return: CF clear
			DX:AX = ???
	    0012h get ???
		Return: CF clear
			DX:AX = ???
	    0013h get ???
		Return: CF clear
			DX:AX = ???
	    0014h get ???
		Return: CF clear
			DX:AX = ???
	    0015h get ???
		Return: CF clear
			DX:AX = ???
	    else
		Return: CF set
SeeAlso: #02706,#02708

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX357E" name="2F1684BX357E"><b>2F1684BX357E</b></a> - INT 2F - MS Windows - DSOUND - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - DSOUND - GET API ENTRY POINT
	AX = 1684h
	BX = 357Eh (virtual device ID for DSOUND device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX377B" name="2F1684BX377B"><b>2F1684BX377B</b></a> - INT 2F - MS Windows - MX1501HAD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - MX1501HAD - GET API ENTRY POINT
	AX = 1684h
	BX = 377Bh (virtual device ID for MX1501HAD device)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02708)
		  0000h:0000h if the VxD does not support an API
Note:	The drivers VCMD95C.VXD and VCMD.386 are part of the driver disks
	  provided with the chip-card-reader/keyboard combination MX 1501 HAD,
	  produced by Cherry
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02708)
Call CHERRY VCMD95C.VXD entry point with:
	AX = function
	    0001h get version
		Return: AX = version number (0100h) (AH = major, AL = minor)
	    0002h hook INT 09 (and 8???)
	    0003h unhook INT 09 (and 8???)
	    0004h get number of bytes in FIFO
		Return: AX = bytes in FIFO
	    0005h get next FIFO-data
		Return: AX = data
			BL = port number
			BH = direction (1=in, 0=out)
			DX:CX = timestamp
	    0006h clear FIFO
	    0007h output byte
		DX = port number
		BL = keyboard command
		Return: data in FIFO (see #02710)
		       (value, port, in/out, timestamp)
	    0008h input byte
		DX = port number
		Return: data in FIFO (see #02710)
			(value, port, in/out, timestamp)
	    0009h input byte immediately
		DX = port number
		Return: AX = data
	    000Ah read next FIFO data (nondestructive)
		Return: AX = data
			BL = port number
			BH = direction (1=in, 0=out)
			DX:CX = timestamp
	    000Bh get timestamp
		Return: DX:CX = timestamp (in ms)
	    000Ch enable IRQ 1
	    000Dh disable IRQ 1
	    000Eh enable data retrieval
		Note:	Sets a flag in the internal mode-byte which
			  tells the driver to recognize the data
	    000Fh disable data retrieval
		Note:	resets a flag in the internal mode-byte
	    0010h get retrieval mode
		Return: AX = current retrieval mode
	    0011h set retrieval mode
		BX = new retrieval mode (see #02709)
		Return: AX = old retrieval mode
	    0012h get command value
		Return: AX = command value
	    0013h set command value
		BX = command value
SeeAlso: #02706,#02711

Bitfields for retrieval mode:
Bit(s)	Description	(Table 02709)
 0	enable data retrieval
 1	0 = interrupt-driven
	1 = polling mode
 2	0 = read port 60h everytime
	1 = read port 60h only when OBF of port 64h is set
 3	0 = don't call old INT 9
	1 = call INT 9 before our INT-handler
 4-7	reserved
SeeAlso: #02708,#02710

Format of FIFO entry (1024 entries in FIFO):
Offset	Size	Description	(Table 02710)
 00h	BYTE	data byte
 01h	BYTE	I/O port
 02h	BYTE	direction (1=in, 0=out)
 03h	BYTE	reserved
 04h	DWORD	timestamp
SeeAlso: #02708,#02709

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX38DA" name="2F1684BX38DA"><b>2F1684BX38DA</b></a> - INT 2F - MS Windows - VIWD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VIWD - GET API ENTRY POINT
	AX = 1684h
	BX = 38DAh (virtual device ID for VIWD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02711)
		  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02711)
Call VIWD.VXD entry point with:
	DX = function number
	    0000h ???
		Return: CF clear
			AX = ???
	    0004h ???
		Return: CF clear
			DX = 0000h
	    0006h
		Return: CF clear
	    000Ah
		AX = ???
		Return: CF clear if successful
			CF set on error
	    000Ch
	    000Dh
	    000Eh
		Return: CF clear
	    000Fh
		Return: CF clear
	    0010h
	    0011h
	    0015h
		Return: CF clear if successful
			    AX = ???
			CF set on error
			    AX = ???
			DX = 0000h
	    0016h
	    0017h
		Return: CF clear if successful
			    AX = ???
			CF set on error
			    AX = ???
			DX = 0000h
	    0018h ???
		CX = ???
		Return: CF clear if successful
			    AX = 0000h
			CF set on error
	    else
		Return: CF set
SeeAlso: #02708,#02712

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX4321" name="2F1684BX4321"><b>2F1684BX4321</b></a> - INT 2F - MS Windows - POSTMSG - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - POSTMSG - GET API ENTRY POINT
	AX = 1684h
	BX = 4321h (virtual device ID for POSTMSG device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02712,#02714)
		  0000h:0000h if the VxD does not support an API

(Table 02712)
Call POSTMSG protected-mode entry point with:
	AX = window handle
	CX:BX -&gt; callback procedure (see #02713)
Return: nothing
Note:	this call registers a WinApp with the VxD; the callback must be in a
	  fixed, non-discardable code segment
SeeAlso: #02714,#02715

(Table 02713)
Values POSTMSG callback routine is called with:
	STACK:	DWORD	"lParam" parameter from DOSApp
		WORD	"wParam" parameter from DOSApp
		WORD	Windows message number (WM_USER + 100h)
		WORD	registered HWND

(Table 02714)
Call POSTMSG V86-mode entry point with:
	BX = wParam value to pass to protected-mode callback
	DX:AX = lParam value to pass to protected-mode callback
Return: CF clear if successful
	CF set on error (no WinApp registered)
SeeAlso: #02712

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX7FE0" name="2F1684BX7FE0"><b>2F1684BX7FE0</b></a> - INT 2F - MS Windows - VSWITCHD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VSWITCHD - GET API ENTRY POINT
	AX = 1684h
	BX = 7FE0h (virtual device ID for VSWITCHD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02715)
		  0000h:0000h if the VxD does not support an API

(Table 02715)
Call VSWITCHD entry point with:
	AX = function
	    0000h toggle windowed mode (simulate Alt-Enter keypress)
		Return: nothing
	    0001h get windowed mode
		Return: CF clear if VM is windowed
			CF set if VM is full-screen
SeeAlso: #02712,#02716

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1684BX8888" name="2F1684BX8888"><b>2F1684BX8888</b></a> - INT 2F - MS Windows - VbillD - GET API ENTRY POINT<br />
<pre>
INT 2F - MS Windows - VbillD - GET API ENTRY POINT
	AX = 1684h
	BX = 8888h (virtual device ID for VbillD device) (see #02642)
	ES:DI = 0000h:0000h
Return: ES:DI -&gt; VxD API entry point (see #02716)
		  0000h:0000h if the VxD does not support an API

(Table 02716)
Call VbillD entry point with:
	AX = function
	    0001h set reverse video
	    0002h set normal video
Return: ???
SeeAlso: #02715

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1685" name="2F1685"><b>2F1685</b></a> - INT 2F - MS Windows - SWITCH VMs AND CALLBACK<br />
<pre>
INT 2F - MS Windows - SWITCH VMs AND CALLBACK
	AX = 1685h
	BX = VM ID of virtual machine to switch to
	CX = flags (see #02717)
	DX:SI = priority boost (refer to VMM.INC)
	ES:DI -&gt; FAR procedure to callback
Return: CF set on error
	    AX = error code
		01h invalid VM ID
		02h invalid priority boost
		03h invalid flags
	CF clear if successful
	    event will be or has been called
Notes:	some DOS devices, such as networks, need to call functions in a
	  specific VM. This call forces the appropriate VM to be installed.
	the callback procedure must preserve all registers and return with IRET
SeeAlso: AX=1683h,INT 15/AX=1117h,AX=DB06h"WINGO"

Bitfields for VM switching flags:
Bit(s)	Description	(Table 02717)
 0	wait until interrupts enabled
 1	wait until critical section unowned
 2-15	reserved (zero)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1686" name="2F1686"><b>2F1686</b></a> - INT 2F - DOS Protected-Mode Interface - DETECT MODE<br />
<pre>
INT 2F - DOS Protected-Mode Interface - DETECT MODE
	AX = 1686h
Return: AX = 0000h if operating in protected mode under DPMI (INT 31 available)
	AX nonzero if in real/V86 mode or no DPMI (INT 31 not available)
SeeAlso: AX=1687h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1687" name="2F1687"><b>2F1687</b></a> - INT 2F - DOS Protected-Mode Interface - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS Protected-Mode Interface - INSTALLATION CHECK
	AX = 1687h
Return: AX = 0000h if installed
	    BX = flags
		bit 0: 32-bit programs supported
	    CL = processor type (02h=80286, 03h=80386, 04h=80486)
	    DH = DPMI major version
	    DL = two-digit DPMI minor version (binary)
	    SI = number of paragraphs of DOS extender private data
	    ES:DI -&gt; DPMI mode-switch entry point (see #02718)
	AX nonzero if not installed
SeeAlso: AX=1686h,AX=43E0h,AX=DE01h/BX=4450h,AX=FB42h/BX=0001h
SeeAlso: INT 31/AX=0400h,INT 31/AX=5702h,INT D4/AH=10h

(Table 02718)
Call DPMI mode switch entry point with:
	AX = flags
	    bit 0: set if 32-bit program
	ES = real mode segment of buffer for DPMI private data (ignored if
		SI was zero)
Return: CF set on error
	    program still in real mode
	    AX = error code (DPMI 1.0+)
	       8011h unable to allocate all necessary descriptors
	       8021h 32-bit program specified, but 16-bit DPMI host
	CF clear if successful
	    CS = 16-bit selector corresponding to real-mode CS
	    SS = selector corresponding to real-mode SS (64K limit)
	    DS = selector corresponding to real-mode DS (64K limit)
	    ES = selector to program's PSP (100h byte limit)
	    FS = GS = 0
	    high word of ESP = 0 if 32-bit program
	    program now in protected mode
Note:	this entry point is only called for the initial switch to protected
	  mode

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1688BX0BAD" name="2F1688BX0BAD"><b>2F1688BX0BAD</b></a> - INT 2F U - MS Windows 3.0, 386MAX v6.01 - GET ALIAS SELECTOR TO LDT<br />
<pre>
INT 2F U - MS Windows 3.0, 386MAX v6.01 - GET ALIAS SELECTOR TO LDT
	AX = 1688h
	BX = 0BADh
Return: AX = 0000h if supported
	    BX = alias selector for LDT
Note:	use the LSL instruction or GetSelectorLimit() to find LDT size
	this call should be considered obsolete for Windows 3.1+, as the
	  alias selector can be retrieved via the API entry point for
	  "MS-DOS" retrieved from INT 2F/AX=168Ah (see #02720)
SeeAlso: AX=1687h,#02720

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1689" name="2F1689"><b>2F1689</b></a> - INT 2F U - MS Windows 3.0+ - KERNEL IDLE CALL<br />
<pre>
INT 2F U - MS Windows 3.0+ - KERNEL IDLE CALL
	AX = 1689h
	BX = status flags (see #04105)
Return: ???
Desc:	the Windows KERNEL idle loop calls this function, which VMM uses as an
	  indication that the system is idle, which in turn generates INT 28
	  and INT 2F/AX=1607h/BX=0018h callouts
SeeAlso: AX=1680h,AX=1607h/BX=0018h,INT 15/AX=1000h,INT 28

Bitfields for Kernel Idle status flags:
Bit(s)	Description	(Table 04106)
 15-1	reserved
 0	"Win_Idle_Mouse_Busy"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168A" name="2F168A"><b>2F168A</b></a> - INT 2F - DPMI 0.9+ - GET VENDOR-SPECIFIC API ENTRY POINT<br />
<pre>
INT 2F - DPMI 0.9+ - GET VENDOR-SPECIFIC API ENTRY POINT
	AX = 168Ah
	DS:(E)SI = selector:offset of ASCIZ vendor name (see #02719)
Return: AL = status
	    00h successful
	       ES:(E)DI -&gt; extended API entry point
	    8Ah unsuccessful
Notes:	the vendor name is used to determine which entry point to return; it is
	  case-sensitive
	available in protected mode only
	32-bit applications use ESI and EDI, 16-bit applications use SI and DI
	this call is present but not documented for DPMI 0.9
	the Borland C++ 3.1 DPMILOAD does not handle requests for entry points
	  other than the MS-DOS one gracefully, producing an unhandled
	  exception report; this has been fixed in the Borland Pascal 7 version
SeeAlso: AX=1687h,INT 31/AX=0A00h,INT 31/AH=57h

(Table 02719)
Values for DPMI vendor-specific API names:
 "MS-DOS"	MS Windows and 386MAX v6.00+ (see #02720)
 "386MAX"	386MAX v6.00+
 "HELIX_DPMI"	Helix Netroom's DPMI server
 "Phar Lap"	Phar Lap 286|DOS-Extender RUN286 (see #02721)
 "RATIONAL DOS/4G"  DOS/4G, DOS/4GW
 "VIRTUAL SUPPORT"  Borland 32RTM

(Table 02720)
Call Windows-support ("MS-DOS") entry point with:
	AX = 0100h get LDT alias selector
Return: CF clear if successful
	    AX = alias selector
	CF set on error
SeeAlso: #02719,AX=1688h/BX=0BADh

(Table 02721)
Call Phar Lap RUN286 entry point with:
	AX = 0000h (function "load MSW")
	BX = new value for MSW register (low word of CR0)
Return: ???
SeeAlso: #02719

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168B" name="2F168B"><b>2F168B</b></a> - INT 2F - MS Windows 3.1 - SET FOCUS TO SPECIFIED VIRTUAL MACHINE<br />
<pre>
INT 2F - MS Windows 3.1 - SET FOCUS TO SPECIFIED VIRTUAL MACHINE
	AX = 168Bh
	BX = virtual machine ID (see AX=1683h), 0000h for current DOS box
Return: AL = 00h if focus set to specified VM
Notes:	documented on the Microsoft Developer's Network CD-ROM
	if the VM is a windowed DOS box, it will be set to full screen
SeeAlso: AX=1683h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168C" name="2F168C"><b>2F168C</b></a> - INT 2F - MS Windows 3.1 - RESTART COMMAND<br />
<pre>
INT 2F - MS Windows 3.1 - RESTART COMMAND
	AX = 168Ch
	???
Return: ???
Note:	WIN.COM executes specified application

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168EDX0000" name="2F168EDX0000"><b>2F168EDX0000</b></a> - INT 2F - Windows95 - TITLE - SET APPLICATION TITLE<br />
<pre>
INT 2F - Windows95 - TITLE - SET APPLICATION TITLE
	AX = 168Eh
	DX = 0000h
	ES:DI -&gt; ASCIZ application title (max 79 chars+NUL)
Return: AX = status
	    0000h failed
	    0001h successful
Note:	if ES:DI is 0000h:0000h or points at an empty string, the current
	  title is removed
BUG:	this function can return a successful status even though the title was
	  not changed; reportedly, waiting for two clock ticks after program
	  startup solves this problem
SeeAlso: AX=168Eh/DX=0001h,AX=168Eh/DX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168EDX0001" name="2F168EDX0001"><b>2F168EDX0001</b></a> - INT 2F - Windows95 - TITLE - SET VIRTUAL MACHINE TITLE<br />
<pre>
INT 2F - Windows95 - TITLE - SET VIRTUAL MACHINE TITLE
	AX = 168Eh
	DX = 0001h
	ES:DI -&gt; ASCIZ virtual machine title (max 29 chars+NUL)
Return: AX = status
	    0000h failed
	    0001h successful
Notes:	if ES:DI is 0000h:0000h or points at an empty string, the current
	  title is removed
	the VM title should only be changed on explicit instruction from the
	  user
BUG:	this function can return a successful status even though the title was
	  not changed; reportedly, waiting for two clock ticks after program
	  startup solves this problem
SeeAlso: AX=168Eh/DX=0000h,AX=168Eh/DX=0003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168EDX0002" name="2F168EDX0002"><b>2F168EDX0002</b></a> - INT 2F - Windows95 - TITLE - GET APPLICATION TITLE<br />
<pre>
INT 2F - Windows95 - TITLE - GET APPLICATION TITLE
	AX = 168Eh
	DX = 0002h
	ES:DI -&gt; buffer for ASCIZ application title
	CX = size of buffer in bytes
Return: AX = status
	    0000h failed
	    0001h successful
Desc:	copy as much of the application's window title as possible to the given
	  buffer, appending a terminating NUL to the buffer
SeeAlso: AX=168Eh/DX=0000h,AX=168Eh/DX=0003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168EDX0003" name="2F168EDX0003"><b>2F168EDX0003</b></a> - INT 2F - Windows95 - TITLE - GET VIRTUAL MACHINE TITLE<br />
<pre>
INT 2F - Windows95 - TITLE - GET VIRTUAL MACHINE TITLE
	AX = 168Eh
	DX = 0003h
	ES:DI -&gt; buffer for ASCIZ virtual-machine title
	CX = size of buffer in bytes
Return: AX = status
	    0000h failed
	    0001h successful
Desc:	copy as much of the virtual machine's title as possible to the given
	  buffer, appending a terminating NUL to the buffer
SeeAlso: AX=168Eh/DX=0001h,AX=168Eh/DX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168FDH00" name="2F168FDH00"><b>2F168FDH00</b></a> - INT 2F - Windows95 - CLOSE-AWARENESS - ENABLE/DISABLE CLOSE COMMAND<br />
<pre>
INT 2F - Windows95 - CLOSE-AWARENESS - ENABLE/DISABLE CLOSE COMMAND
	AX = 168Fh
	DH = 00h
	DL = new state
	    00h disabled
	    01h enabled
Return: AX = status
	    0000h successful
	    else failed
Desc:	enable or disable the system menu Close command for an application
SeeAlso: AX=168Fh/DH=01h,AX=168Fh/DH=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168FDH01" name="2F168FDH01"><b>2F168FDH01</b></a> - INT 2F - Windows95 - CLOSE-AWARENESS - QUERY CLOSE<br />
<pre>
INT 2F - Windows95 - CLOSE-AWARENESS - QUERY CLOSE
	AX = 168Fh
	DH = 01h
	DL = 00h (reserved)
Return: AX = status
	    0000h Close command selected but not yet acknowledged
	    0001h Close command issued and acknowledged
	    168Fh Close command not selected -- application should continue
Desc:	determine whether the user has requested that the application be closed
	  by selecting the system menu's Close option
SeeAlso: AX=168Fh/DH=00h,AX=168Fh/DH=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168FDH02" name="2F168FDH02"><b>2F168FDH02</b></a> - INT 2F - Windows95 - CLOSE-AWARENESS - ACKNOWLEDGE CLOSE<br />
<pre>
INT 2F - Windows95 - CLOSE-AWARENESS - ACKNOWLEDGE CLOSE
	AX = 168Fh
	DH = 02h
	DL = 00h (reserved)
Return: AX = status
	    0000h successful
	    else failed
Note:	once a Close command has been issued, no further keyboard input is
	  available to the application until it calls this function to
	  acknowledge the Close request
SeeAlso: AX=168Fh/DH=00h,AX=168Fh/DH=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168FDH03" name="2F168FDH03"><b>2F168FDH03</b></a> - INT 2F - Windows95 - CLOSE-AWARENESS - CANCEL CLOSE<br />
<pre>
INT 2F - Windows95 - CLOSE-AWARENESS - CANCEL CLOSE
	AX = 168Fh
	DH = 03h
	DL = 00h (reserved)
Return: AX = status
	    0000h successful
	    else failed
Desc:	cancels a close request which has already been acknowledged if the
	  application determines that it will not exit at this time
SeeAlso: AX=168Fh/DH=00h,AX=168Fh/DH=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1690" name="2F1690"><b>2F1690</b></a> - INT 2F U - MS-DOS 7 kernel - GET/SET ???<br />
<pre>
INT 2F U - MS-DOS 7 kernel - GET/SET ???
	AX = 1690h
	ES:BX -&gt; ???
Return: ES:BX -&gt; ??? data (see #02722)
SeeAlso: AX=1611h,AX=1614h

Format of MS-DOS 7 kernel ??? data:
Offset	Size	Description	(Table 02722)
 00h	DWORD	-&gt; ??? data (appears to list the installed drivers)
 04h	DWORD	-&gt; ??? (value passed in via ES:BX is stored here)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1700" name="2F1700"><b>2F1700</b></a> - INT 2F - MS Windows "WINOLDAP" - IDENTIFY WinOldAp VERSION<br />
<pre>
INT 2F - MS Windows "WINOLDAP" - IDENTIFY WinOldAp VERSION
	AX = 1700h
Return: AX = 1700h if this version of WINOLDAP doesn't support clipboard
	AX &lt;&gt; 1700h
	    AL = WINOLDAP major version
	    AH = WINOLDAP minor version
Program: WinOldAp (WINOLDAP.MOD) is a Microsoft Windows extension supporting
	  "old" (character-mode) application access to Dynamic Data Exchange,
	  menus, and the Windows clipboard.
Note:	this installation check DOES NOT follow the format used by other
	  software of returning AL=FFh
SeeAlso: AX=1701h,AX=4601h
Index:	installation check;WINOLDAP

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1701" name="2F1701"><b>2F1701</b></a> - INT 2F - MS Windows "WINOLDAP" - OPEN CLIPBOARD<br />
<pre>
INT 2F - MS Windows "WINOLDAP" - OPEN CLIPBOARD
	AX = 1701h
Return: AX = status
	    nonzero success
	    0000h   clipboard is already open
SeeAlso: AX=1700h,AX=1702h,AX=1703h,AX=1704h,INT 16/AX=CB00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1702" name="2F1702"><b>2F1702</b></a> - INT 2F - MS Windows "WINOLDAP" - EMPTY CLIPBOARD<br />
<pre>
INT 2F - MS Windows "WINOLDAP" - EMPTY CLIPBOARD
	AX = 1702h
Return: AX = status
	    nonzero clipboard has been emptied
	    0000h   failure
SeeAlso: AX=1700h,AX=1701h,AX=1703h,AX=1704h,INT 16/AX=CB05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1703" name="2F1703"><b>2F1703</b></a> - INT 2F - MS Windows "WINOLDAP" - SET CLIPBOARD DATA<br />
<pre>
INT 2F - MS Windows "WINOLDAP" - SET CLIPBOARD DATA
	AX = 1703h
	DX = clipboard format supported by WinOldAp (see #02723)
	ES:BX -&gt; data (see #02724,#02725)
	SI:CX = size of data
Return: AX = status
	    nonzero data copied into the Clipboard
	    0000h   failure
SeeAlso: AX=1701h,AX=1705h,INT 16/AX=CB04h

(Table 02723)
Values for WinOldAp clipboard format:
 01h	text
 02h	bitmap
 03h	metafile picture
 04h	SYLK
 05h	DIF
 06h	TIFF
 07h	OEM text
 08h	DIB bitmap
 80h	special format (used by Windows WRITE, maybe other Windows applets???)
 81h	DSP text
 82h	DSP bitmap

Format of Windows Clipboard bitmap:
Offset	Size	Description	(Table 02724)
 00h	WORD	type (0000h)
 02h	WORD	width of bitmap in pixels
 04h	WORD	height of bitmap in pixels
 06h	WORD	bytes per line
 08h	BYTE	number of color planes
 09h	BYTE	number of adjacent color bits in pixel
 0Ah	DWORD	pointer to start of data
 0Eh	WORD	width in 0.1mm units
 10h	WORD	height in 0.1mm units
 12h  N BYTEs	bitmap data

Format of Windows metafile picture:
Offset	Size	Description	(Table 02725)
 00h	WORD	mapping mode
 02h	WORD	X extent
 04h	WORD	Y extent
 06h	WORD	picture data

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1704" name="2F1704"><b>2F1704</b></a> - INT 2F - MS Windows "WINOLDAP" - GET CLIPBOARD DATA SIZE<br />
<pre>
INT 2F - MS Windows "WINOLDAP" - GET CLIPBOARD DATA SIZE
	AX = 1704h
	DX = clipboard format supported by WinOldAp (see #02723)
Return: DX:AX = size of data in bytes, including any headers
		0000h:0000h if no data in this format in the Clipboard
Note:	Windows reportedly rounds up the size of the data to a multiple of 32
	  bytes
SeeAlso: AX=1700h,AX=1703h,AX=1705h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1705" name="2F1705"><b>2F1705</b></a> - INT 2F - MS Windows "WINOLDAP" - GET CLIPBOARD DATA<br />
<pre>
INT 2F - MS Windows "WINOLDAP" - GET CLIPBOARD DATA
	AX = 1705h
	DX = clipboard format supported by WinOldAp (see #02723)
	ES:BX -&gt; buffer
Return: AX = status
	    nonzero success
	    0000h   error, or no data in this format in Clipboard
SeeAlso: AX=1700h,AX=1704h,INT 16/AX=CB03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1708" name="2F1708"><b>2F1708</b></a> - INT 2F - MS Windows "WINOLDAP" - CloseClipboard<br />
<pre>
INT 2F - MS Windows "WINOLDAP" - CloseClipboard
	AX = 1708h
Return: AX = status
	    0000h failure
	    nonzero success

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1709" name="2F1709"><b>2F1709</b></a> - INT 2F - MS Windows "WINOLDAP" - COMPACT CLIPBOARD<br />
<pre>
INT 2F - MS Windows "WINOLDAP" - COMPACT CLIPBOARD
	AX = 1709h
	SI:CX = desired size in bytes
Return: DX:AX = number of bytes in largest block of free memory
Note:	WinOldAp is responsible for including the size of any headers

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F170A" name="2F170A"><b>2F170A</b></a> - INT 2F - MS Windows "WINOLDAP" - GET DEVICE CAPABILITIES<br />
<pre>
INT 2F - MS Windows "WINOLDAP" - GET DEVICE CAPABILITIES
	AX = 170Ah
	DX = GDI information index (see #02726)
Return: AX = integer value of the desired item
	      (see #02727,#02728,#02729,#02730,#02731,#02732,#02733)
Note:	This function returns the device-capability bits for the given display

(Table 02726)
Values for GDI information index:
 00h	device driver version
 02h	device classification
 04h	width in mm
 06h	height in mm
 08h	width in pixels
 0Ah	height in pixels
 0Ch	bits per pixel
 0Eh	number of bit planes
 10h	number of brushes supported by device
 12h	number of pens supported by device
 14h	number of markers supported by device
 16h	number of fonts supported by device
 18h	number of colors
 1Ah	size required for device descriptor
 1Ch	curve capabilities
 1Eh	line capabilities
 20h	polygon capabilities
 22h	text capabilities
 24h	clipping capabilities
 26h	bitblt capabilities
 28h	X aspect
 2Ah	Y aspect
 2Ch	length of hypotenuse of aspect
 58h	logical pixels per inch of width
 5Ah	logical pixels per inch of height
SeeAlso: #02727,#02728,#02729,#02730,#02731,#02732,#02733

(Table 02727)
Values for device classification:
 00h	vector plotter
 01h	raster display
 02h	raster printer
 03h	raster camera
 04h	character-stream, PLP
 05h	Metafile, VDM
 06h	display-file
SeeAlso: #02726,#02728,#02729,#02730,#02731,#02732,#02733

Bitfields for curve capabilities:
Bit(s)	Description	(Table 02728)
 0	circles
 1	pie wedges
 2	chord arcs
 3	ellipses
 4	wide lines
 5	styled lines
 6	wide styled lines
 7	interiors
SeeAlso: #02726,#02727,#02729,#02730,#02731,#02732,#02733

Bitfields for line capabilities:
Bit(s)	Description	(Table 02729)
 1	polylines
 2	markers
 3	polymarkers
 4	wide lines
 5	styled lines
 6	wide styled lines
 7	interiors
SeeAlso: #02726,#02727,#02728,#02730,#02731,#02732,#02733

Bitfields for polygon capabilities:
Bit(s)	Description	(Table 02730)
 0	polygons
 1	rectangles
 2	trapezoids
 3	scanlines
 4	wide borders
 5	styled borders
 6	wide styled borders
 7	interiors
SeeAlso: #02726,#02727,#02728,#02729,#02731,#02732,#02733

Bitfields for text capabilities:
Bit(s)	Description	(Table 02731)
 0	output precision character
 1	output precision stroke
 2	clippping precision stroke
 3	90-degree character rotation
 4	arbitrary character rotation
 5	independent X and Y scaling
 6	double-size
 7	integer scaling
 8	continuous scaling
 9	bold
 10	italic
 11	underline
 12	strikeout
 13	raster fonts
 14	vector fonts
 15	reserved
SeeAlso: #02726,#02727,#02728,#02729,#02730,#02732,#02733

(Table 02732)
Values for clipping capabilities:
 00h	none
 01h	clipping to rectangles
SeeAlso: #02726,#02727,#02728,#02729,#02730,#02731,#02733

Bitfields for raster capabilities:
Bit(s)	Description	(Table 02733)
 0	simple bitBLT
 1	device requires banding support
 2	device requires scaling support
 3	supports &gt;64K bitmap
SeeAlso: #02726,#02727,#02728,#02729,#02730,#02731,#02732

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F18" name="2F18"><b>2F18</b></a> - INT 2F U - MS-Manager<br />
<pre>
INT 2F U - MS-Manager
	AH = 18h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1900" name="2F1900"><b>2F1900</b></a> - INT 2F U - DOS 4.x only SHELLB.COM - INSTALLATION CHECK<br />
<pre>
INT 2F U - DOS 4.x only SHELLB.COM - INSTALLATION CHECK
	AX = 1900h
Return: AL = status
	    00h not installed
	    FFh installed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1901" name="2F1901"><b>2F1901</b></a> - INT 2F U - DOS 4.x only SHELLB.COM - SHELLC.EXE INTERFACE<br />
<pre>
INT 2F U - DOS 4.x only SHELLB.COM - SHELLC.EXE INTERFACE
	AX = 1901h
	BL = SHELLC type
	    00h transient
	    01h resident
	DS:DX -&gt; far call entry point for resident SHELLC.EXE
Return: ES:DI -&gt; SHELLC.EXE workspace within SHELLB.COM
Note:	SHELLB.COM and SHELLC.EXE are parts of the DOS 4.x shell

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1902" name="2F1902"><b>2F1902</b></a> - INT 2F U - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE<br />
<pre>
INT 2F U - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
	AX = 1902h
	ES:DI -&gt; ASCIZ full filename of current batch file, with at least the
		  final filename element uppercased
	DS:DX -&gt; buffer for results
Return: AL = 00h  failed, either
		(a) final filename element quoted at ES:DI does not match
		      identity of shell batch file quoted as parameter of most
		      recent call of SHELLB command, or
		(b) no more Program Start Commands available.
	AL= FFh	 success, then:
		memory at DS:[DX+1] onwards filled as:
		DX+1:	BYTE	count of bytes of PSC
		DX+2: N BYTEs	Program Start Command text
			BYTE	0Dh terminator
Desc:	COMMAND.COM executes the result of this call in preference to
	  reading a command from a batch file.	Thus the batch file does not
	  advance in execution for so long as SHELLB provides PSCs from its
	  workspace.
Note:	The PSCs are planted in SHELLB workspace by SHELLC, the user
	  menu interface.  The final PSC of a sequence is finished with a
	  GOTO COMMON, which causes a loop back in the batch file which called
	  SHELLC so as to execute SHELLC again.	 The check on batch file name
	  permits PSCs to CALL nested batch files while PSCs are still stacked
	  up for subsequent execution.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1903" name="2F1903"><b>2F1903</b></a> - INT 2F U - DOS 4.x only SHELLB.COM - COMMAND.COM interface<br />
<pre>
INT 2F U - DOS 4.x only SHELLB.COM - COMMAND.COM interface
	AX = 1903h
	ES:DI -&gt; ASCIZ batch file name as for AX=1902h
Return: AL = status
	    FFh quoted batch file name matches last SHELLB parameter
	    00h it does not

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1904" name="2F1904"><b>2F1904</b></a> - INT 2F U - DOS 4.x only SHELLB.COM - SHELLB transient to TSR interface<br />
<pre>
INT 2F U - DOS 4.x only SHELLB.COM - SHELLB transient to TSR interface
	AX = 1904h
Return: ES:DI -&gt; name of current shell batch file:
		WORD	number of bytes of name following
		BYTEs	(8 max) uppercase name of shell batch file

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1980" name="2F1980"><b>2F1980</b></a> - INT 2F U - IBM ROM-DOS v4.0 - INSTALLATION CHECK<br />
<pre>
INT 2F U - IBM ROM-DOS v4.0 - INSTALLATION CHECK
	AX = 1980h
Return: AL = FFh if ??? installed/supported
Note:	called at the very beginning of SHELLSTB.COM, which exits if AL is not
	  FFh on return
SeeAlso: AX=1981h,AX=1982h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1981" name="2F1981"><b>2F1981</b></a> - INT 2F U - IBM ROM-DOS v4.0 - GET ??? STRING<br />
<pre>
INT 2F U - IBM ROM-DOS v4.0 - GET ??? STRING
	AX = 1981h
	DS:DX -&gt; buffer for ???
Return: AL = status
	    FFh if successful
		DS:DX buffer filled (refer to note below)
	    81h on error
Note:	the first byte of the buffer is unchanged; depending on a byte in
	  IBMBIO.COM, the remainder of the buffer is filled with either
	  "C:\ROMSHELL.COM",0Dh or xxh,xxh,0Fh,"C:\ROMSHELL.COM",0Dh
SeeAlso: AX=1980h,AX=1982h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1982" name="2F1982"><b>2F1982</b></a> - INT 2F U - IBM ROM-DOS v4.0 - GET ??? TABLE<br />
<pre>
INT 2F U - IBM ROM-DOS v4.0 - GET ??? TABLE
	AX = 1982h
Return: AL = FFh if supported
	    ES:DI -&gt; ??? table (see #02734)
Note:	called by ROMSHELL.COM
SeeAlso: AX=1980h,AX=1981h

Format of ROM-DOS v4.0 ??? table:
Offset	Size	Description	(Table 02734)
 00h	BYTE	??? (00h)
 01h	BYTE	??? (41h) (ROMSHELL.COM checks if =00h)
 02h	BYTE	??? (00h) (ROMSHELL.COM checks if =01h)
 03h	WORD	??? (0001h) (ROMSHELL.COM checks if =0001h)
 05h	BYTE	??? (00h)
 06h	WORD	??? (04D5h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A00" name="2F1A00"><b>2F1A00</b></a> - INT 2F - DOS 4.0+ ANSI.SYS - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS 4.0+ ANSI.SYS - INSTALLATION CHECK
	AX = 1A00h
Return: AL = FFh if installed
Notes:	AVATAR.SYS also responds to this call
	documented for DOS 5+, but undocumented for DOS 4.x

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A00BX414E" name="2F1A00BX414E"><b>2F1A00BX414E</b></a> - INT 2F - ANSIPLUS.SYS v2.00+ - INSTALLATION CHECK<br />
<pre>
INT 2F - ANSIPLUS.SYS v2.00+ - INSTALLATION CHECK
	AX = 1A00h
	BX = 414Eh ('AN')
	CX = 5349h ('SI')
	DX = 2B2Bh ('++')
Return: AL = FFh if installed
	    CF clear
	    ES:BX -&gt; INT 29 entry point
	    CX = ANSIPLUS BCD version number (v3.10+, CH=major, CL=minor)
	    DL = capabilities (v4.00+)
		00h full capability driver
		01h reduced capability driver
		2Bh full capability driver (before v4.00)
Program: ANSIPLUS.SYS is a CON device driver by Kristofer Sweger which
	  replaces the normal ANSI.SYS with a more powerful version having
	  many additional features
Notes:	ANSIPLUS also identifies itself as ANSI.SYS if BX,CX, or DX differ
	  from the magic values above
	an additional installation check is to test for the signature
	  "ANSIPLUS" 12 bytes before the INT 29 entry point; the version
	  number is also available as a four-character ASCII string (e.g.
	  "4.00") four bytes before the entry point
SeeAlso: AX=1AA5h,AX=1AA6h,AX=1AA7h,AX=1AA8h,AX=1AA9h,AX=1AAAh,AX=D44Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A00BX4156" name="2F1A00BX4156"><b>2F1A00BX4156</b></a> - INT 2F - AVATAR.SYS - INSTALLATION CHECK<br />
<pre>
INT 2F - AVATAR.SYS - INSTALLATION CHECK
	AX = 1A00h
	BX = 4156h ('AV')
	CX = 4154h ('AT')
	DX = 4152h ('AR')
Return: AL = FFh if installed
	    CF clear
	    BX = AVATAR protocol level supported
	    CX = driver type
		0000h AVATAR.SYS
		4456h DVAVATAR.COM inside DESQview window
	    DX = 0016h
Program: AVATAR.SYS is a CON replacement by George Adam Stanislav which
	  interprets AVATAR command codes in the same way that ANSI interprets
	  ANSI command codes
Notes:	AVATAR also identifies itself as ANSI.SYS if BX, CX, or DX differ from
	  the magic values
SeeAlso: AX=1A21h,AX=1A3Ch,AX=1A3Fh,AX=1A52h,AX=1A72h,AX=1A7Dh,AX=1AADh"AVATAR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A01" name="2F1A01"><b>2F1A01</b></a> - INT 2F U - DOS 4.0+ ANSI.SYS internal - GET/SET DISPLAY INFORMATION<br />
<pre>
INT 2F U - DOS 4.0+ ANSI.SYS internal - GET/SET DISPLAY INFORMATION
	AX = 1A01h
	CL = function
	    7Fh for GET
	    5Fh for SET
	DS:DX -&gt; parm block as for INT 21,AX=440Ch,CX=037Fh/035Fh respectively
Return: CF clear if successful
	    AX destroyed
	CF set on error
	    AX = error code (many non-standard)
Note:	presumably this is the DOS IOCTL interface to ANSI.SYS
SeeAlso: AX=1A02h,INT 21/AX=440Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A02" name="2F1A02"><b>2F1A02</b></a> - INT 2F U - DOS 4.0+ ANSI.SYS internal - MISCELLANEOUS REQUESTS<br />
<pre>
INT 2F U - DOS 4.0+ ANSI.SYS internal - MISCELLANEOUS REQUESTS
	AX = 1A02h
	DS:DX -&gt; parameter block (see #02735)
Return: CF clear if successful
	CF set on error
	    AX = error code
Note:	DOS 5+ chains to previous handler if AL &gt; 02h on call
SeeAlso: AX=1A01h

Format of ANSI.SYS parameter block:
Offset	Size	Description	(Table 02735)
 00h	BYTE	subfunction
		00h set/reset interlock
		01h get /L flag
 01h	BYTE	interlock state
		00h=reset, 01h=set
		  This interlock prevents some of the ANSI.SYS post-processing
		  in its hook onto INT 10, AH=00h mode set
 02h	BYTE	(returned)
		00h if /L not in effect
		01h if /L in effect

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A21" name="2F1A21"><b>2F1A21</b></a> - INT 2F - AVATAR.SYS - SET DRIVER STATE<br />
<pre>
INT 2F - AVATAR.SYS - SET DRIVER STATE
	AX = 1A21h (AL='!')
	DS:SI -&gt; command string with one or more state characters (see #02736)
	CX = length of command string
Return: CF set on error (invalid subfunction)
	CF clear if successful
Note:	the characters in the state string are interpreted left to right, and
	  need not be in any particular order
SeeAlso: AX=1A00h/BX=4156h,AX=1A3Fh

(Table 02736)
Values for AVATAR.SYS state characters:
 'a'	activate driver
 'd'	disable driver
 'f'	use fast screen output
 'g'	always convert gray keys (+ and -) to function keys
 'G'	never convert gray keys
 'l'	convert gray keys only when ScrollLock active
 's'	use slow screen output
 't'	Tandy 1000 keyboard (not yet implemented)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A3C" name="2F1A3C"><b>2F1A3C</b></a> - INT 2F U - AVATAR.SYS v0.11 - ???<br />
<pre>
INT 2F U - AVATAR.SYS v0.11 - ???
	AX = 1A3Ch
	???
Return: CX = 0000h
SeeAlso: AX=1A00h/BX=4156h,AX=1A21h,AX=1A3Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A3E" name="2F1A3E"><b>2F1A3E</b></a> - INT 2F U - AVATAR.SYS v0.11 - ???<br />
<pre>
INT 2F U - AVATAR.SYS v0.11 - ???
	AX = 1A3Eh
	CL = ???
	CH = ???
	DL = ???
	DH = ???
Return: CL = ???
	CH = ???
	DL = ???
	DH = ???
SeeAlso: AX=1A3Ch,AX=1A3Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A3F" name="2F1A3F"><b>2F1A3F</b></a> - INT 2F - AVATAR.SYS - QUERY DRIVER STATE<br />
<pre>
INT 2F - AVATAR.SYS - QUERY DRIVER STATE
	AX = 1A3Fh (AL='?')
	ES:DI -&gt; buffer
	CX = length of buffer in bytes
Return: CF clear
	CX = actual size of returned info
Note:	the returned information consists of multiple letters whose meanings
	  are described under AX=1A21h
SeeAlso: AX=1A00h/BX=4156h,AX=1A21h,AX=1A44h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A42BX4156" name="2F1A42BX4156"><b>2F1A42BX4156</b></a> - INT 2F - AVATAR Serial Dispatcher - INSTALL IRQ3 HANDLER<br />
<pre>
INT 2F - AVATAR Serial Dispatcher - INSTALL IRQ3 HANDLER
	AX = 1A42h
	BX = 4156h ('AV')
	ES:DI -&gt; FAR handler for serial port using IRQ3
	DS = data segment needed by handler
Return: AX = status/return value
	    0000h if no more room
	    1A42h if ASD not installed
	    else handle to use when uninstalling
Notes:	the handler need not save/restore registers or signal EOI to the
	  interrupt controller
	the handler should return AX=0000h if the interrupt was meant for it,
	  and either leave AX unchanged or return a non-zero value otherwise
	the most recently installed handler will be called first, continuing
	  to earlier handlers until one returns AX=0000h
SeeAlso: AX=1A43h,AX=1A62h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A43BX4156" name="2F1A43BX4156"><b>2F1A43BX4156</b></a> - INT 2F - AVATAR Serial Dispatcher - INSTALL IRQ4 HANDLER<br />
<pre>
INT 2F - AVATAR Serial Dispatcher - INSTALL IRQ4 HANDLER
	AX = 1A43h
	BX = 4156h ('AV')
	ES:DI -&gt; FAR handler for serial port using IRQ4
	DS = data segment needed by handler
Return: AX = status/return value
	    0000h if no more room
	    1A43h if ASD not installed
	    else handle to use when uninstalling
Notes:	(see AX=1A42h)
SeeAlso: AX=1A42h,AX=1A63h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A44BX4156" name="2F1A44BX4156"><b>2F1A44BX4156</b></a> - INT 2F - AVATAR.SYS v0.11+ - GET DATA SEGMENT<br />
<pre>
INT 2F - AVATAR.SYS v0.11+ - GET DATA SEGMENT
	AX = 1A44h
	BX = 4156h ('AV')
Return: AX = 0000h
	DS = data segment
	CX = size of data segment
Note:	AVATAR.SYS calls this function whenever it is invoked.	If each
	  process under a multitasker hooks this function and provides a
	  separate data segment, AVATAR.SYS becomes fully reentrant.
SeeAlso: AX=1A21h,AX=1A3Fh,AX=1A52h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A52" name="2F1A52"><b>2F1A52</b></a> - INT 2F U - AVATAR.SYS v0.11 - GET ???<br />
<pre>
INT 2F U - AVATAR.SYS v0.11 - GET ???
	AX = 1A52h
	CX = size of buffer
	ES:DI -&gt; buffer
Return: ??? copied into user buffer
Note:	the maximum size of the data which may be copied is returned by
	  AX=1A72h
SeeAlso: AX=1A53h,AX=1A72h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A53" name="2F1A53"><b>2F1A53</b></a> - INT 2F U - AVATAR.SYS v0.11 - ???<br />
<pre>
INT 2F U - AVATAR.SYS v0.11 - ???
	AX = 1A53h
	CL = ??? (00h-05h)
	???
Return: ???
SeeAlso: AX=1A00h/BX=4156h,AX=1A52h,AX=1A72h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A62BX4156" name="2F1A62BX4156"><b>2F1A62BX4156</b></a> - INT 2F - AVATAR Serial Dispatcher - UNINSTALL IRQ3 HANDLER<br />
<pre>
INT 2F - AVATAR Serial Dispatcher - UNINSTALL IRQ3 HANDLER
	AX = 1A62h
	BX = 4156h ('AV')
	CX = handle for IRQ routine returned by AX=1A42h
SeeAlso: AX=1A42h,AX=1A63h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A63BX4156" name="2F1A63BX4156"><b>2F1A63BX4156</b></a> - INT 2F - AVATAR Serial Dispatcher - UNINSTALL IRQ4 HANDLER<br />
<pre>
INT 2F - AVATAR Serial Dispatcher - UNINSTALL IRQ4 HANDLER
	AX = 1A63h
	BX = 4156h ('AV')
	CX = handle for IRQ routine returned by AX=1A43h
SeeAlso: AX=1A43h,AX=1A62h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A72" name="2F1A72"><b>2F1A72</b></a> - INT 2F U - AVATAR.SYS v0.11 - GET ??? SIZE<br />
<pre>
INT 2F U - AVATAR.SYS v0.11 - GET ??? SIZE
	AX = 1A72h
Return: CX = maximum size of ???
SeeAlso: AX=1A00h/BX=4156h,AX=1A52h,AX=1A7Bh,AX=1AADh"AVATAR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A7B" name="2F1A7B"><b>2F1A7B</b></a> - INT 2F U - AVATAR.SYS v0.11 - ???<br />
<pre>
INT 2F U - AVATAR.SYS v0.11 - ???
	AX = 1A7Bh
Return: AX = 0000h
	CX = 0000h
SeeAlso: AX=1A00h/BX=4156h,AX=1A72h,AX=1A7Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1A7D" name="2F1A7D"><b>2F1A7D</b></a> - INT 2F U - AVATAR.SYS v0.11 - ???<br />
<pre>
INT 2F U - AVATAR.SYS v0.11 - ???
	AX = 1A7Dh
Return: AX = ???
SeeAlso: AX=1A00h/BX=4156h,AX=1A7Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AA3" name="2F1AA3"><b>2F1AA3</b></a> - INT 2F - ANSIPLUS v4.03+ - GET/SET ANSIPLUS INTERNAL VARIABLES<br />
<pre>
INT 2F - ANSIPLUS v4.03+ - GET/SET ANSIPLUS INTERNAL VARIABLES
	AX = 1AA3h
	BH = function
	    00h get current/default colors
		Return: CH = default colors
			CL = current colors
	    01h set current/default colors
		CH = default colors (00h = leave unchanged)
		CL = current colors
	    02h get current subscreen region
		Return: BH,BL = true screen rows,columns
			CH,CL = top left row,column of region
			DH,DL = bottom right row,column of region
	    03h set subscreen region
		CH,CL = top left row,column of region
		DH,DL = bottom right row,column of region
	    04h get driver features (bits 0-31)
		Return: DX:CX = current feature bits
	    05h set driver features (bits 0-31)
		DX:CX = feature bits
	    06h get driver features (bits 32-63)
		Return: DX:CX = current feature bits
	    07h set driver features (bits 32-63)
		DX:CX = feature bits
	    other: reserved for future use
SeeAlso: AX=1AA4h,AX=1AA5h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AA4" name="2F1AA4"><b>2F1AA4</b></a> - INT 2F - ANSIPLUS v4.02+ - GET/SET ANSIPLUS SMOOTH SCROLLING RATE<br />
<pre>
INT 2F - ANSIPLUS v4.02+ - GET/SET ANSIPLUS SMOOTH SCROLLING RATE
	AX = 1AA4h
	BL = function
	    00h get scrolling rate
	    01h set scrolling rate
		BH = new minimum scrolling rate in scan lines per retrace
Return: BH = smooth scrolling rate
SeeAlso: AX=1AA3h,AX=1AA5h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AA5" name="2F1AA5"><b>2F1AA5</b></a> - INT 2F - ANSIPLUS v4.00+ - GET/SET ANSIPLUS CLIPBOARD<br />
<pre>
INT 2F - ANSIPLUS v4.00+ - GET/SET ANSIPLUS CLIPBOARD
	AX = 1AA5h
	DH = subfunction
	    00h get clipboard information
	    01h get clipboard text
	    02h set clipboard text
	    03h append text to clipboard
	    04h clear clipboard
	    05h paste clipboard to keyboard
	ES:BX -&gt; data area for subfunctions 01h, 02h, and 03h
	CX = size of data area (maximum size for subfunction 01h, actual size
	    to add to clipboard for subfunctions 02h and 03h)
Return: AL = status
	    00h successful
	    01h unsupported subfunction (reduced capability driver)
	    02h insufficient space
	    A5h unsupported function (ANSIPLUS before v4.00)
	ES:BX -&gt; ANSIPLUS local clipboard data
	CX = number of bytes currently in local clipboard
	DX = maximum size of local clipboard
SeeAlso: AX=1A00h/BX=414Eh,AX=1AA4h,AX=1AA6h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AA6" name="2F1AA6"><b>2F1AA6</b></a> - INT 2F - ANSIPLUS v4.00+ - ENABLE/DISABLE ANSIPLUS DRIVER<br />
<pre>
INT 2F - ANSIPLUS v4.00+ - ENABLE/DISABLE ANSIPLUS DRIVER
	AX = 1AA6h
	BH = function
	    00h get hooked interrupts
	    01h set hooked interrupts mask
		BL = new interrupts mask (see #02737)
Return: BL = previous interrupts mask (see #02737)
SeeAlso: AX=1A00h/BX=414Eh,AX=1AA7h

Desc:	used to temporarily disable any prior copies of ANSIPLUS when a new
	  copy is installed, such as in a multitasking system like DESQview
Note:	only the most-recently loaded copy of ANSIPLUS on the current INT 2F
	  chain responds to this call

Bitfields for ANSIPLUS hooked interrupts mask:
Bit(s)	Description	(Table 02737)
 0	INT 09 hook disabled
 1	INT 10 hook disabled
 2	INT 15 hook disabled
 3	INT 16 hook disabled
 4	INT 1C hook disabled
 5	reset all bits when INT 29 called
 6	INT 29 hook disabled
 7	INT 33, INT 74, or other mouse event hook disabled

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AA7" name="2F1AA7"><b>2F1AA7</b></a> - INT 2F - ANSIPLUS v4.00+ - ENABLE/DISABLE ANSIPLUS FEATURES<br />
<pre>
INT 2F - ANSIPLUS v4.00+ - ENABLE/DISABLE ANSIPLUS FEATURES
	AX = 1AA7h
	BL = function
	    00h prevent scroll-back saves
	    01h enable scroll-back saves
	    02h disable key reprogramming and lock changes by escape sequences
	    03h enable key reprogramming by escape sequences
	    04h	disable and lock key stacking changes by escape sequences
	    05h allow key stacking by escape sequences
Return: nothing
SeeAlso: AX=1AA6h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AA8" name="2F1AA8"><b>2F1AA8</b></a> - INT 2F - ANSIPLUS v3.10+ - GET NEXT ANSIPLUS SCROLLBACK LINE<br />
<pre>
INT 2F - ANSIPLUS v3.10+ - GET NEXT ANSIPLUS SCROLLBACK LINE
	AX = 1AA8h
Return: AL = status
	    00h successful
		ES:BX -&gt; screen line (character and attribute pairs)
		CX = length of line in bytes, 0000h if no more lines or
		      unsupported video mode
	    01h unsupported video mode active
	    02h screen currently scrolled back
	    03h reduced capability driver
	    A8h unsupported function (driver before v3.10)
SeeAlso: AX=1A00h/BX=414Eh,AX=1AA9h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AA9" name="2F1AA9"><b>2F1AA9</b></a> - INT 2F - ANSIPLUS v3.10+ - GET ANSIPLUS SCROLLBACK INFORMATION<br />
<pre>
INT 2F - ANSIPLUS v3.10+ - GET ANSIPLUS SCROLLBACK INFORMATION
	AX = 1AA9h
Return: AL = status
	    00h successful
		BX = current number of lines in scrollback buffer
		CX = number of bytes in one line
	    01h unsupported video mode active
	    02h screen currently scrolled back
	    03h reduced capability driver
	    A9h unsupported function (driver before v3.10)
Desc:	determine how much data is in the scrollback buffer and initialize
	  scrollback retrieval to return the first line on the next call to
	  AX=1AA8h
SeeAlso: AX=1A00h/BX=414Eh,AX=1AA8h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AAA" name="2F1AAA"><b>2F1AAA</b></a> - INT 2F - ANSIPLUS v3.01+ - GET/SET ANSIPLUS SCREEN SAVER BLANKING TIME<br />
<pre>
INT 2F - ANSIPLUS v3.01+ - GET/SET ANSIPLUS SCREEN SAVER BLANKING TIME
	AX = 1AAAh
	BX = function
	    FFFFh to get current blanking time
	    other to set time
		CX = blanking time in clock ticks (0000h-7FFFh)
Return: BX = current blanking time
	CX = blanking time when last set
SeeAlso: AX=1A00h/BX=414Eh,AX=1AABh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AAB" name="2F1AAB"><b>2F1AAB</b></a> - INT 2F - ANSIPLUS v3.01+ - SET ANSIPLUS KEY REPEAT RATE<br />
<pre>
INT 2F - ANSIPLUS v3.01+ - SET ANSIPLUS KEY REPEAT RATE
	AX = 1AABh
	BX = repeat rate in characters per second
	    0000h use BIOS repeat rate
Return: nothing
SeeAlso: AX=1A00h/BX=414Eh,AX=1AAAh,AX=1AACh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AAC" name="2F1AAC"><b>2F1AAC</b></a> - INT 2F - ANSIPLUS v3.00+ - LOAD CHARACTER GENERATOR<br />
<pre>
INT 2F - ANSIPLUS v3.00+ - LOAD CHARACTER GENERATOR
	AX = 1AACh
	BH = number of bytes per character pattern
	BL = VGA/EGA character table to be loaded
	CX = number of characters to load
	DX = starting character code (offset into Map2 block)
	ES:BP -&gt; user character table to be loaded
Return: AX = 1100h
Desc:	load the EGA/VGA character generator without the BIOS function's
	  side effects of resetting the video mode and color palette
SeeAlso: AX=1A00h/BX=414Eh,AX=1AABh,AX=1AADh"ANSIPLUS",INT 10/AX=1100h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AAD" name="2F1AAD"><b>2F1AAD</b></a> - INT 2F - ANSIPLUS v2.00+ - ANSIPLUS DEVICE STATUS REPORT<br />
<pre>
INT 2F - ANSIPLUS v2.00+ - ANSIPLUS DEVICE STATUS REPORT
	AX = 1AADh
	BL = report request code (81h-96h for v4.00)
	CX = color selector or key code, if required by request
Return: AX = first reported result
	BX = second result
	CX = third result, if applicable (unchanged otherwise)
	DX = fourth result, if applicable (unchanged otherwise)
Desc:	get device status reports equivalent to those for Esc [#n sequences
	  while bypassing any device redirection and avoiding the need to
	  parse the returned result
Note:	the report request code in BL is identical to the number in the
	  corresponding Esc [#n sequence
SeeAlso: AX=1A00h/BX=414Eh,AX=1AACh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1AADDX0000" name="2F1AADDX0000"><b>2F1AADDX0000</b></a> - INT 2F U - AVATAR.SYS v0.11 - ???<br />
<pre>
INT 2F U - AVATAR.SYS v0.11 - ???
	AX = 1AADh
	DX = 0000h
	CX = subfunction (00h-0Ch)
	???
Return: AX = 0000h if DX was nonzero
	???
SeeAlso: AX=1A00h/BX=4156h,AX=1A72h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1B00" name="2F1B00"><b>2F1B00</b></a> - INT 2F U - DOS 4+ XMA2EMS.SYS extension internal - INSTALLATION CHECK<br />
<pre>
INT 2F U - DOS 4+ XMA2EMS.SYS extension internal - INSTALLATION CHECK
	AX = 1B00h
Return: AL = FFh if installed
Note:	XMA2EMS.SYS extension is only installed if DOS has page frames to hide.
	This extension hooks onto INT 67/AH=58h and returns from that call data
	  which excludes the physical pages being used by DOS.
SeeAlso: AH=1Bh"FRAME INFO"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1B" name="2F1B"><b>2F1B</b></a> - INT 2F U - DOS 4+ XMA2EMS.SYS extension internal - GET HIDDEN FRAME INFORMATION<br />
<pre>
INT 2F U - DOS 4+ XMA2EMS.SYS extension internal - GET HIDDEN FRAME INFORMATION
	AH = 1Bh
	AL &lt;&gt; 00h
	DI = hidden physical page number
Return: AX = FFFFh if failed (no such hidden page)
	AX = 0000h if OK, then
	    ES = segment of page frame
	    DI = physical page number
Notes:	this corresponds to the data edited out of the INT 67/AH=58h call
	FASTOPEN makes this call with AL = FFh
SeeAlso: AX=1B00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2300" name="2F2300"><b>2F2300</b></a> - INT 2F - DR DOS 5.0 GRAFTABL - INSTALLATION CHECK<br />
<pre>
INT 2F - DR DOS 5.0 GRAFTABL - INSTALLATION CHECK
	AX = 2300h
Return: AH = FFh
Note:	this installation check does not follow the usual format
SeeAlso: AH=23h,AX=2E00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F23" name="2F23"><b>2F23</b></a> - INT 2F - DR DOS 5.0 GRAFTABL - GET GRAPHICS DATA<br />
<pre>
INT 2F - DR DOS 5.0 GRAFTABL - GET GRAPHICS DATA
	AH = 23h
	AL nonzero
Return: AH = FFh
	ES:BX -&gt; graphics data (8 bytes for each character from 80h to FFh)
SeeAlso: AX=2300h,AX=2E00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2700" name="2F2700"><b>2F2700</b></a> - INT 2F - DR DOS 6.0 TaskMAX - INSTALLATION CHECK<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - INSTALLATION CHECK
	AX = 2700h
Return: AL = status
	    00h not installed
	    FFh installed
Note:	the TaskMAX API is also supported by Novell DOS 7 TASKMGR in both
	  taskswitching and multitasking modes

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2701" name="2F2701"><b>2F2701</b></a> - INT 2F - DR DOS 6.0 TaskMAX - GET STATUS<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - GET STATUS
	AX = 2701h
Return: AX = maximum simultaneous tasks
	BX = index into TASK_IDS of current foreground task
	CX = currently-active tasks
	DX = version number (DL = major, DH = minor)
	    (DR DOS 6.0 = 0001h, Novell DOS 7 = 0002h)
	ES:SI -&gt; TASK_IDS
	ES:DI -&gt; name table (array of 8-byte names, NUL-terminated if &lt;8 chars)
Notes:	do not attempt to create a new task if CX == AX
	the task's index is its position on the task menu, while its ID is the
	  position within the internal task name table
SeeAlso: AX=2714h,AX=2716h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2702" name="2F2702"><b>2F2702</b></a> - INT 2F - DR DOS 6.0 TaskMAX - GET PER-TASK EMS LIMIT<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - GET PER-TASK EMS LIMIT
	AX = 2702h
Return: DX = maximum pages INT 67/AH=42h will report available
Note:	TaskMAX does not limit EMS allocations other than by limiting the
	  amount which is reported as being available at a given time
SeeAlso: AX=2703h,INT 67/AH=42h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2703" name="2F2703"><b>2F2703</b></a> - INT 2F - DR DOS 6.0 TaskMAX - SET PER-TASK EMS LIMIT<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - SET PER-TASK EMS LIMIT
	AX = 2703h
	DX = maximum pages INT 67/AH=42h should report available
Return: DX = new maximum for reporting
Note:	the TaskMAX API is also supported by Novell DOS 7 TASKMGR in
	  both taskswitching and multitasking modes
SeeAlso: AX=2702h,INT 67/AH=42h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2704" name="2F2704"><b>2F2704</b></a> - INT 2F - DR DOS 6.0 TaskMAX - REGISTER/UNREGISTER TASK MANAGER<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - REGISTER/UNREGISTER TASK MANAGER
	AX = 2704h
	DL = subfunction
	    00h unregister task manager
	    01h register task manager
Return: DL = status
	    00h registered
	    01h unregistered
Notes:	a task manager replaces TaskMAX's menu system with its own user
	  interface; while one is registered, the TaskMAX hotkeys and
	  Ctrl-Alt-Del invoke the manager rather than the built-in menu system
	unregister the task manager before terminating it
SeeAlso: AX=2705h
Index:	hotkeys;TaskMAX

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2705" name="2F2705"><b>2F2705</b></a> - INT 2F - DR DOS 6.0 TaskMAX - ENABLE/DISABLE DIRECT SWITCHING<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - ENABLE/DISABLE DIRECT SWITCHING
	AX = 2705h
	DL = subfunction
	    00h disable keystrokes for switching to next/prev/specified task
	    01h enable
Return: nothing
Note:	should only be called by a registered task manager (see AX=2704h)
SeeAlso: AX=2704h,AX=2706h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2706" name="2F2706"><b>2F2706</b></a> - INT 2F - DR DOS 6.0 TaskMAX - SWITCH TO SPECIFIED TASK<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - SWITCH TO SPECIFIED TASK
	AX = 2706h
	DX = task index (see AX=2701h) of task to be activated
Return: DX = task index of previously-active task
Note:	the TaskMAX API is also supported by Novell DOS 7 TASKMGR in
	  both taskswitching and multitasking modes
SeeAlso: AX=2705h,AX=2707h,AX=2715h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2707" name="2F2707"><b>2F2707</b></a> - INT 2F - DR DOS 6.0 TaskMAX - CREATE NEW TASK<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - CREATE NEW TASK
	AX = 2707h
	DS:DX -&gt; ASCIZ pathname of executable
	ES:BX -&gt; parameter block (see #02738)
	CX = number of ticks before automatic return to task manager
		(0000h = run until termination or explicitly switched)
Return: DX = new task's task index (FFFFh if task terminated)
SeeAlso: AX=2706h,AX=2708h

Format of TaskMAX parameter block:
Offset	Size	Description	(Table 02738)
 00h	WORD	reserved, should be 0000h
 02h	DWORD	pointer to command tail to be copied into child's PSP
 06h	DWORD	pointer to first FCB to be copied into child's PSP
 0Ah	DWORD	pointer to second FCB to be copied into child's PSP

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2708" name="2F2708"><b>2F2708</b></a> - INT 2F - DR DOS 6.0 TaskMAX - DELETE TASK<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - DELETE TASK
	AX = 2708h
	DX = task index
Return: DX = FFFFh (task deleted)
Notes:	this call should only be used for abnormal task termination, after
	  first checking for open files with AX=270Ch; should not be used
	  with programs that allocate EMS or XMS memory
	switches to specified task first
SeeAlso: AX=2707h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2709" name="2F2709"><b>2F2709</b></a> - INT 2F - DR DOS 6.0 TaskMAX - NAME TASK<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - NAME TASK
	AX = 2709h
	DX = task index
	DS:SI -&gt; 8-byte name (8 NULs = remove name)
Return: AL = task flags
	    00h ID unused or task terminated
	    01h ID in use, task name table entry valid
	    81h ID in use, task name fixed
	BX = task ID
	ES:DI -&gt; name in task name table (see AX=2701h)
Note:	the task retains the given name until it terminates or the name is
	  removed by specifying a name of 8 NULs.
SeeAlso: AX=2701h,AX=2707h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F270A" name="2F270A"><b>2F270A</b></a> - INT 2F - DR DOS 6.0 TaskMAX - CONVERT TASK INDEX TO TASK ID<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - CONVERT TASK INDEX TO TASK ID
	AX = 270Ah
	DX = task index
Return: DX = task ID (FFFFh if index invalid)
Note:	task IDs stay constant, while indexes can change when other tasks are
	  deleted
SeeAlso: AX=2701h,AX=270Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F270B" name="2F270B"><b>2F270B</b></a> - INT 2F - DR DOS 6.0 TaskMAX - CONVERT TASK ID TO TASK INDEX<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - CONVERT TASK ID TO TASK INDEX
	AX = 270Bh
	DX = task ID
Return: DX = task index (FFFFh if task not active)
Note:	the TaskMAX API is also supported by Novell DOS 7 TASKMGR in both
	  taskswitching and multitasking modes
SeeAlso: AX=270Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F270C" name="2F270C"><b>2F270C</b></a> - INT 2F - DR DOS 6.0 TaskMAX - CHECK OPEN FILES<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - CHECK OPEN FILES
	AX = 270Ch
	DX = task index
Return: AX = number of files currently open for specified task
SeeAlso: AX=2708h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F270D" name="2F270D"><b>2F270D</b></a> - INT 2F - DR DOS 6.0 TaskMAX - CHECK IF TASK RUNNING PRIMARY COMMAND INTERPRETER<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - CHECK IF TASK RUNNING PRIMARY COMMAND INTERPRETER
	AX = 270Dh
	DX = task index
Return: DX = status
	    0000h if primary command interpreter (COMMAND.COM, etc.) running
	    0001h if not in root shell for task
Note:	TaskMAX will return 0001h if the specified task has spawned another
	  command interpreter with AX=2707h
SeeAlso: AX=2707h,AX=270Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F270E" name="2F270E"><b>2F270E</b></a> - INT 2F - DR DOS 6.0 TaskMAX - GET/SET TEXT PASTE LEAD-IN<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - GET/SET TEXT PASTE LEAD-IN
	AX = 270Eh
	CX = length of string (max 15 keystrokes, 0000h to get current string)
	DS:SI -&gt; pasting lead-in string (character/scan-code pairs)
Return: ES:DI -&gt; current lead-in string
Note:	the specified sequence of keystrokes is sent to the application before
	  every line of a text-mode spreadsheet paste
SeeAlso: AX=270Fh,AX=2710h,AX=2713h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F270F" name="2F270F"><b>2F270F</b></a> - INT 2F - DR DOS 6.0 TaskMAX - GET/SET NUMERIC PASTE LEAD-IN<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - GET/SET NUMERIC PASTE LEAD-IN
	AX = 270Fh
	CX = length of string (max 15 keystrokes, 0000h to get current string)
	DS:SI -&gt; pasting lead-in string (character/scan-code pairs)
Return: ES:DI -&gt; current lead-in string
Note:	the specified sequence of keystrokes is sent to the application before
	  every number in a numeric-mode spreadsheet paste
SeeAlso: AX=270Eh,AX=2710h,AX=2711h,AX=2713h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2710" name="2F2710"><b>2F2710</b></a> - INT 2F - DR DOS 6.0 TaskMAX - GET/SET PASTE LINE TERMINATOR STRING<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - GET/SET PASTE LINE TERMINATOR STRING
	AX = 2710h
	CX = length of string (max 15 keystrokes, 0000h to get current string)
	DS:SI -&gt; pasting terminator string (character/scan-code pairs)
Return: ES:DI -&gt; current terminator string
Note:	the specified sequence of keystrokes is sent to the application after
	  every line of a spreadsheet paste operation
SeeAlso: AX=270Eh,AX=270Fh,AX=2713h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2711" name="2F2711"><b>2F2711</b></a> - INT 2F - DR DOS 6.0 TaskMAX - GET/SET NUMERIC PASTE DECIMAL POINT<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - GET/SET NUMERIC PASTE DECIMAL POINT
	AX = 2711h
	DX = ASCII code for separator (FFFFh to get current)
Return: DL = current separator character
SeeAlso: AX=270Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2712" name="2F2712"><b>2F2712</b></a> - INT 2F - DR DOS 6.0 TaskMAX - INITIATE EXPORTING TASK DATA<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - INITIATE EXPORTING TASK DATA
	AX = 2712h
	DX = task index

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2713" name="2F2713"><b>2F2713</b></a> - INT 2F - DR DOS 6.0 TaskMAX - INITIATE PASTE OPERATION<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - INITIATE PASTE OPERATION
	AX = 2713h
	DX = task index
	CX = paste mode
	    0000h alphanumeric
	    0001h numeric
	    0002h text
SeeAlso: AX=270Eh,AX=270Fh,AX=2710h,AX=2711h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2714" name="2F2714"><b>2F2714</b></a> - INT 2F - DR DOS 6.0 TaskMAX - GET SWAP SPACE INFO<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - GET SWAP SPACE INFO
	AX = 2714h
Return: CX = total KB of swap space
	DX = available KB of swap space
Note:	the TaskMAX API is also supported by Novell DOS 7 TASKMGR in both
	  taskswitching and multitasking modes
SeeAlso: AX=2701h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2715" name="2F2715"><b>2F2715</b></a> - INT 2F - DR DOS 6.0 TaskMAX - SWITCH TO TASK MANAGER<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - SWITCH TO TASK MANAGER
	AX = 2715h
Return: only after calling task is again selected
SeeAlso: AX=2706h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2716" name="2F2716"><b>2F2716</b></a> - INT 2F - DR DOS 6.0 TaskMAX - GET PASTE BUFFER STATUS<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - GET PASTE BUFFER STATUS
	AX = 2716h
Return: AX = 0000h if AX=2716h,AX=2717h,AX=2718h supported
	    CX = bytes in paste buffer
	    DX = current generation number (updated after every copy operation)
BUG:	Novell DOS 7 TASKMGR returns AX=0000h even though it does not support
	  this call (it does support the remainder of the TaskMAX API)
SeeAlso: AX=2701h,AX=2713h,AX=2714h,AX=2717h,AX=2718h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2717" name="2F2717"><b>2F2717</b></a> - INT 2F - DR DOS 6.0 TaskMAX - PASTE DATA DIRECTLY TO APPLICATION BUFFER<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - PASTE DATA DIRECTLY TO APPLICATION BUFFER
	AX = 2717h
	CX = bytes in destination buffer
	ES:DI -&gt; destination buffer
Return: AX = 0000h if function supported
	    CX = bytes actually copied (FFFFh if buffer too small)
	    DX = current generation number for paste buffer
BUG:	Novell DOS 7 TASKMGR returns AX=0000h even though it does not support
	  this call (it does support the remainder of the TaskMAX API)
Note:	the destination buffer may be too small if another task adds more data
	  to the paste buffer after the AX=2716h call but before this call
SeeAlso: AX=2713h,AX=2716h,AX=2718h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2718" name="2F2718"><b>2F2718</b></a> - INT 2F - DR DOS 6.0 TaskMAX - COPY DATA DIRECTLY INTO PASTE BUFFER<br />
<pre>
INT 2F - DR DOS 6.0 TaskMAX - COPY DATA DIRECTLY INTO PASTE BUFFER
	AX = 2718h
	CX = bytes in source buffer
	DS:SI -&gt; source buffer (plain ASCII, lines terminated with CR LF)
Return: AX = 0000h if function supported
	    CX = bytes actually copied
	    DX = current generation number for paste buffer
BUG:	Novell DOS 7 TASKMGR returns AX=0000h even though it does not support
	  this call (it does support the remainder of the TaskMAX API)
SeeAlso: AX=2712h,AX=2716h,AX=2717h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2719" name="2F2719"><b>2F2719</b></a> - INT 2F - Novell DOS 7 TaskMGR - NOP<br />
<pre>
INT 2F - Novell DOS 7 TaskMGR - NOP
	AX = 2719h to 271Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F271C" name="2F271C"><b>2F271C</b></a> - INT 2F U - Novell DOS 7 TaskMGR - ???<br />
<pre>
INT 2F U - Novell DOS 7 TaskMGR - ???
	AX = 271Ch
	DX = ???
	    bit 0: ???
Return: ???
	---if DX bit 0 set---
	AX = 0031h
	CX = 0000h
BUG:	if the task switcher is running, and DX bit 0 is set on call, this
	  function will crash because its exit code attempts to pop several
	  registers which are not pushed when DX bit 0 is set

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2780CL01" name="2F2780CL01"><b>2F2780CL01</b></a> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - SUPERVISOR MODULE<br />
<pre>
INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - SUPERVISOR MODULE
	AX = 2780h
	CL = 01h (module: Supervisor)
	CH = subfunction
	    00h unused
		Return: CX = status (0002h) (see #02739)
	    01h unused
		Return: CX = status (0002h) (see #02739)
	    02h "Z_ModuleReg" register an OS module
		EBX = module number (0005h-000Fh)
		DS:EDX -&gt; module descriptor (see #02741)
		Return: CX = status (0000h,0030h) (see #02739)
	    03h allocate SYSDAT memory
		DX = number of ??? to allocate
		Return: CX = status (0000h,0003h) (see #02739)
	    04h get selector to SYSDAT
		Return: CX = 0000h (successful)
			BX = selector for EMM386 data segment
			EBX high word cleared
	    05h "Z_MoveReal" relocate segment into extended memory
		DS:EDX -&gt; descriptor parameter block
		Return: ECX = status (00h,03h,31h,32h) (see #02739)
			---if successful---
			parameter block filled
	    06h "Z_Reboot" return to real mode via triple fault
	    07h debugger break
		Note:	calls INT 03, then INT 21/AH=02h to output a question
			  mark
	    08h "X_ForeCheck" check if domain is in foreground
		Return: CX = 0000h (successful)
			EBX = ??? (0 or 2)
	    09h register VxD with system
	    0Ah unload VxD hook
	    0Bh indicate end of initialization phase
		Return: CX = status (0002h) (see #02739)
	    0Ch "F_AllocWindow" allocate 4K mapping window
	    0Dh "F_RegisterBoot" register reboot addresses
		EBX = ???
		EDX = ???
		Return: ???
	    0Eh "F_EnquireBoot" check if reboot active
		Return: CX = 0000h (successful)
			BL = ???     \ or BX = 0000h
			BH = ???     /
	    0Fh get debugging level
		Return: CX = 0000h (successful)
			EBX = new value for debugging level
	    10h set debugging level
		EDX = ???
		Return: CX = 0000h (successful)
			EBX = old value of debugging level
	    11h installation check (documented)
		Return: CX = status
			    0000h if multitasker is installed
				EBX = version (0100h for v1.00)
			    1101h if multitasker is not present
	    12h "F_V86BPInstall" install V86 breakpoint
		DX = ???
		Return: CX = 0000h (successful)
			AX = old value of ???
	    13h "F_V86BPRemove" remove V86 breakpoint
		Return: CX = status (0000h,003Fh) (see #02739)
			AX = ???
	    14h "F_V86BPOffer" indicate INT 03 to be used as V86 breakpoint
		EDX = linear address ??? of INT 03 instruction for breakpoint
		Return: CX = status (0000h,003Fh) (see #02739)
	    15h "F_LoaderCleanup" offer opportunity to clean up
		BX = segment of ???
		Return: CX = 0000h (successful)
			BX = segment of ???
	    16h "F_RegisterVxDWindow" register VxD mapping window
	    17h "F_RegisterPNW" register Personal NetWare information
		EBX = subfunction (0-2)
		Return: CX = status (0002h if EBX&gt;2) (see #02739)
			???
	    18h unused
		Return: CX = status (0002h) (see #02739)
Return: CX = status (most subfunctions)
	(E)AX and/or (E)BX contain return values, depending on function
Notes:	called by DPMS.EXE and EMM386.EXE
	this API is only available if AX=12FFh/BX=0EDCh returns successfully;
	  because the request is handled on the initial trap to the memory
	  manager caused by INT instructions, this API must be invoked with
	  an actual INT 2F instruction instead of some simulation such as a
	  far call to the address in the interrupt vector table
SeeAlso: AX=12FFh/BX=0EDCh,AX=2780h/CL=02h,AX=2780h/CL=03h,AX=2780h/CL=04h

(Table 02739)
Values for Novell DOS 7 EMM386 function status:
 0000h	successful
 0001h	not implemented
 0002h	invalid subfunction
 0003h	unable to find memory
 0004h	invalid flag (semaphore) number
 0005h	flag (semaphore) overrun
 0006h	flag (semaphore) underrun
 0007h	no queue handles available
 0009h	no queue buffers available
 000Ah	queue is in use
 000Bh	invalid process handle
 000Ch	no process handles available
 000Dh	queue access not permitted
 000Eh	queue is empty
 000Fh	queue is full
 0012h	no memory handles available
 0014h	can't find process in process list
 001Bh	invalid memory handle
 0023h	unable to terminate process
 002Ah	flag set ignored
 002Dh	no more system flags
 002Eh	flag (semaphore) not in idle state
 002Fh	flag (semaphore) wait timed out
 0030h	bad module number in CL
 0031h	bad descriptor
	invalid value for DESC_PB_SINFO in a descriptor parameter block
 0032h	no free descriptors
 0033h	error while locking/unlocking a page
 0034h	error getting or setting a page
 0035h	no pages available
 0036h	invalid domain
 0037h	process already frozen
 0038h	process not frozen
 0039h	fork failure (no registered swaplist)
 003Ah	page already free
 003Bh	page already allocated
 003Ch	unable to switch tasks
 003Dh	attempted to free critical section which is not active
 003Eh	too many active critical sections
 003Fh	???
 41FFh	current domain is invalid, or no domain in context
 42FFh	domain ID is not a valid descriptor
 43FFh	domain creation still in progress
 44FFh	domain currently being deleted
 45FFh	task manager is busy, cannot unload it
 46FFh	task manager already loaded
 47FFh	task manager not yet loaded
 48FFh	cannot save/restore because prior switch not complete
 49FFh	console already has owner
 4BFFh	unsupported opcode
 4CFFh	32-bit address prefix not supported
 4FFFh	timeout, but not on timer queue
 50FFh	unable to lock timer queue
 53FFh	unable to switch while in Global Message Mode
 54FFh	error while setting Global Message Mode
 55FFh	not in Global Message Mode
 56FFh	system already in Domain Message Mode
 57FFh	not in Domain Message Mode
 58FFh	unable to allocate timeout structure
 59FFh	unsupported video type
 5AFFh	function not handled by any VM
 5BFFh	error in Serial..Set call
 5CFFh	error in Parallel..Set call
 5DFFh	domain list overflowed
 5FFFh	unable to free domain while in nobuffers mode

Format of Novell DOS/OpenDOS EMM386 descriptor parameter block:
Offset	Size	Description	(Table 02740)
 00h	DWORD	"DESC_PB_BASE"
 04h	DWORD	"DESC_PB_LIMIT"
 08h	WORD	"DESC_PB_SEL"
 0Ah	BYTE	"DESC_PB_MINFO"
 0Bh	BYTE	"DESC_PB_SINFO"
SeeAlso: #02741

Format of Novell DOS/OpenDOS EMM386 module descriptor:
Offset	Size	Description	(Table 02741)
 00h 12 BYTEs	descriptor parameter block (see #02740)
 0Ch	DWORD	-&gt; module entry point
Note:	for function "Z_ModuleReg", only DESC_PB_SEL and the module entry point
	  need to be initialized before calling EMM386
SeeAlso: #02740

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2780CL02" name="2F2780CL02"><b>2F2780CL02</b></a> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - REAL-TIME MONITOR<br />
<pre>
INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - REAL-TIME MONITOR
	AX = 2780h
	CL = 02h (module: Real-Time Monitor)
	CH = subfunction
	    00h ???
		???
		Return: CX = status (0000h,0023h, others???) (see #02739)
			BX = ??? (0000h if CX=0000h, FFFFh if CX=0023h)
		Note:	calls func 04h/sf 03h, func 04h/sf 1Eh,func 02h/sf 43h,
			  func 02h/sf 0Bh, and func 04h/sf 01h
	    01h "Z_PCountGet" get and clear count of dispatches
		DX = ??? handle or 0000h for default
		Return: CX = status (0000h,000Bh) (see #02739)
			EBX = old value of ??? if successful
			EDX destroyed
	    02h "Z_FlagWait" wait on semaphore
		DX = index of semaphore???
		Return: CX = status (0000h,0004h,0005h) (see #02739)
			EBX = 0000FFFFh on error, 00000000h if successful
	    03h "Z_FlagSet" set a semaphore flag
		DX = index of semaphore???
		Return: CX = status (0000h,0004h,0006h) (see #02739)
			BX = FFFFh on error, 0000h if successful
	    04h "X_QCreate" create a new queue
		Return: CX = status (0000h,0007h,000Ah) (see #02739)
	    05h "X_QOpen" open queue for reading/writing
		EDX -&gt; ??? data (first 8 bytes seem to be name)
		Return: CX = status (0000h,0009h,000Dh) (see #02739)
	    06h "X_QDelete" delete a queue
		Note:	calls fn 02h/subfn 05h, then fn 02h/subfn 40h
	    07h "X_QRead" read message from queue
		EDX = ???
		Return: CX = status (0000h,0009h,000Eh) (see #02739)
	    08h "X_QReadC" read message from queue, if any
		EDX = ???
		Return: CX = status (0000h,0009h,000Eh) (see #02739)
	    09h "X_QWrite" write message to queue
		EDX = ???
		Return: CX = status (0000h,0009h,000Fh) (see #02739)
	    0Ah "X_QWriteC" write message to queue, if space available
		EDX = ???
		Return: CX = status (0000h,0009h,000Fh) (see #02739)
	    0Bh "X_PDelay" put process to sleep for specified period
		DX = number of clock ticks to sleep???
		Return: CX = 0000h (successful)
	    0Ch "X_PDispatch" force a dispatch (run scheduler)
		Return: CX = 0000h (successful)
	    0Dh "F_PTerm" terminate process???
		Return: CX = status (0000h,0023h) (see #02739)
			BX = FFFFh on error, 0000h if successful
		Note:	calls fn 04h/subfn 03h, fn 04h/subfn 1Eh,
			  fn 02h/subfn 43h, fn 02h/subfn 0Bh, fn 04h/sub 01h
	    0Eh "X_PCreate" create new process
		???
		Return: CX = status (0000h,000Ch) (see #02739)
			EBX = ??? if successful
	    0Fh "Z_PPriorSet" set process priority
		BX = ???
		DX = ??? handle or 0000h for default
		Return: CX = status (0000h,000Bh) (see #02739)
	    10h "X_PHandleGet" get current process handle
		Return: CX = 0000h (successful)
			BX = handle of default ???
			EBX high word cleared
	    11h "X_PTerm" terminate process
		DX = process handle or 0000h for current
		BX = ??? (handle???)
		Return:	CX = status (0000h,000Bh,0014h) (see #02739)
	    12h "F_Sleep" ???
		BX = ???
		DX = ???
		Return: CX = 0000h (successful)
	    13h "F_Wakeup" ???
		DX = ???
		Return: CX = status (see #02739)
	    14h "F_FindPDName" find process by name???
		BX = ???
		DX = ???
		Return: CX = status (0000h,0014h) (see #02739)
			BX = FFFFh on error, ??? if successful
	    15h "F_SetFlags" set ??? flags
		BX = ??? (low two bits only)
		DX = ??? handle or 0000h for default
		Return: CX = status (0000h,000Bh) (see #02739)
			BX = new value of ??? flags (entire word)
			EBX high register cleared
	    16h "F_EndOfInterrupt" issue EOI to PIC
		Return: CX = 0000h (successful)
	    17h "X_PTermOff" disable process termination
	    18h "X_PTermOK" enable process termination
	    19h "Z_FlagStatusGet" get semahprore's status
	    1Ah "F_QRdMX" ???
	    1Bh "F_QWrMX" ???
	    1Ch "Z_FlagAlloc" allocate a new semaphore
	    1Dh "Z_FlagFree" free semaphore
	    1Eh "X_FlagsMaxGet" get number of semaphores supported
	    1Fh "X_QReadNDC" non-destructive read from queue (peek)
	    20h "Z_FlagWWTO" wait on semaphore, with timeout
	    21h "F_UdaAlloc" ???
	    22h "F_UdaFree" ???
	    23h "X_PSuspend" suspend process
	    24h "X_PUnsuspend" restart process after suspension
	    25h "X_CritEnter" enter critical region
	    26h "X_CritExit" leave critical region
	    27h "F_PCreate" ???
	    28h "Z_PHandleListGet" get list of process handles
	    29h "Z_PNameGet" get process name
	    2Ah "Z_PStatusGet" get process status
	    2Bh "F_PDToDomain" get process' domain???
	    2Ch "Z_PPriorGet" get process priority
	    2Dh "F_QDList" get list of queues???
	    2Eh "Z_QNameGet" get queue's name
	    2Fh "X_QMsgLenGet" get message length of queue
	    30h "X_QMsgMaxGet" get message capacity of queue
	    31h "Z_QWriterGet" get handle of process waiting to write queue
	    32h "Z_QReaderGet" get handle of process waiting to read queue
	    33h "X_QMsgNumGet" get number of messages in queue
	    34h "Z_QFlagsGet" get queue's flags
	    35h "F_NameToQD" get queue by name???
	    36h "F_NameToPD" get process by name???
	    37h "X_MXCreate" create a mutex
	    38h "X_MXDelete" delete a mutex
	    39h "X_MXEnter" enter mutual-exclusion zone
	    3Ah "X_MXEnterC" enter mutual-exclusion zone if it is free
	    3Bh "X_MXExit" leave mutual-exclusion zone
	    3Ch "Z_TicksSet" set length of foreground time slices
	    3Dh "X_TickGet" get clock tick period
	    3Eh "F_ProcessID" ???
	    3Fh "X_QClose" close a queue
	    40h "F_QDispose" delete queue???
	    41h "F_PDToFlags" get process flags???
	    42h "F_PDToDParam" ???
	    43h "F_ReleaseMX" release mutex???
	    44h "F_SimulateInt" ???
	    45h "Z_QFlagsSet" set queue's flags
	    46h "F_TickRate" ???
	    47h ???
Return: CX = status (most subfunctions)
	(E)AX and/or (E)BX contain return values, depending on function
Notes:	called by DPMS.EXE and EMM386.EXE
	this API is only available if AX=12FFh/BX=0EDCh returns successfully;
	  because the request is handled on the initial trap to the memory
	  manager caused by INT instructions, this API must be invoked with
	  an actual INT 2F instruction instead of some simulation such as a
	  far call to the address in the interrupt vector table
SeeAlso: AX=12FFh/BX=0EDCh,AX=2780h/CL=01h,AX=2780h/CL=03h,AX=2780h/CL=04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2780CL03" name="2F2780CL03"><b>2F2780CL03</b></a> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - MEMORY<br />
<pre>
INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - MEMORY
	AX = 2780h
	CL = 03h (module: Memory)
	CH = subfunction
	    00h ???
	    01h "F_PdirGet" ???
	    02h "F_PdirSet" ???
	    03h "Z_PageAlloc" allocate a given page of memory
	    04h "F_PageAllocG" allocate global page???
	    05h "F_PageAllocI" allocate instance page???
	    06h "F_PtblRead" get page table???
	    07h "F_PtrlWrite" select page table???
	    08h "Z_PtblGet" read page table
	    09h "Z_PtblSet" change page table
	    0Ah "Z_PagesAlloc" allocate pages of memory
	    0Bh "Z_PageFree" free a given page of memory
	    0Ch "Z_MemAlloc" allocate a memory block
	    0Dh "Z_MemFree" release memory block
	    0Eh "Z_MemSizeGet" get size of memory block
	    0Fh "Z_MemResize" resize a memory block
	    10h "Z_DescAlloc" allocate a memory descriptor
	    11h "Z_DescFree" release a memory descriptor
	    12h "Z_DescGet" get details on memory descriptor
	    13h "Z_DescSet" set a memory descriptor
	    14h "Z_MemDescAlloc" allocate a memory block and its descriptor
	    15h "Z_MemDescFree" release a memory block and its descriptor
	    16h "Z_MemDescSizeGet" get size of memory block
	    17h "Z_MemDescResize" resize a memory block
	    18h "Z_PageLock" lock a page, with existing contents
	    19h "Z_PageUnlock" unlock a page
	    1Ah "Z_PageLockAny" lock a page, contents undefined
	    1Bh "Z_PageUnlockReuse" unlock page, reuse phsyical memory
	    1Ch "Z_PageLockNone" lock a page, no physical memory assigned
	    1Dh "Z_PageUnlockNone" unlock a page, don't reuse physical memory
	    1Eh "F_CallRealRaw" call real mode (SS:ESP supplied)
	    1Fh "F_IntRealRaw" perform real-mode interrupt (SS:ESP supplied)
	    20h "F_CallReal" call real mode with RETF frame
	    21h "F_IntReal" perform real-mode interrupt
	    22h "F_PagedCallReal" paged real-mode call
	    23h "F_PagedIntReal" paged real-mode interrupt
	    24h "F_CallIretReal" call real mode with IRET frame
	    25h "F_CallIretRealRaw" call real mode with IRET (SS:ESP supplied)
	    26h "F_CallProt16" call 16-bit protected-mode code
	    27h "F_CallProt32" call 32-bit protected-mode code
	    28h "F_IAddPage" add kernel instance data
	    29h "Z_PageDomLock" lock page in specific domain, preserve contents
	    2Ah "Z_PatgeDomUnlock" unlock page in specific domain
	    2Bh "Z_PageDomLockAny" lock page in specific domain, undef contents
	    2Ch "Z_PageDomUnlockReuse" unlock page in spec. domain,reuse ph.mem
	    2Dh "Z_PageDomLockNone" lock page in spec. domain, no phys memory
	    2Eh "Z_PageDomUnlockNone" unlock page in spec. domain, no phys. mem
	    2Fh "Z_GateAlloc" allocate a gate
	    30h "Z_GateFree" release a gate
	    31h "X_MemFreeGet" get total free memory
	    32h "X_MemTopGet" get highest memory address
	    33h "X_MemTotalGet" get total memory size
	    34h "F_DescRead" ???
	    35h "F_DescWrite" ???
	    36h "F_GetStack" ???
	    37h "F_SetStack" ???
Return: CX = status (most subfunctions)
	(E)AX and/or (E)BX contain return values, depending on function
Notes:	called by DPMS.EXE and EMM386.EXE
	this API is only available if AX=12FFh/BX=0EDCh returns successfully;
	  because the request is handled on the initial trap to the memory
	  manager caused by INT instructions, this API must be invoked with
	  an actual INT 2F instruction instead of some simulation such as a
	  far call to the address in the interrupt vector table
SeeAlso: AX=12FFh/BX=0EDCh,AX=2780h/CL=01h,AX=2780h/CL=02h,AX=2780h/CL=04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2780CL04" name="2F2780CL04"><b>2F2780CL04</b></a> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - DOMAINS<br />
<pre>
INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - DOMAINS
	AX = 2780h
	CL = 04h (module: Domains)
	CH = subfunction
	    00h "F_DAlloc" create new domain
	    01h "F_DFree" delete a domain
	    02h "X_DomHandleGetMy" get current domain handle
	    03h "F_DSet" switch to another domain
	    04h "Z_HandlerSWInt" install software-interrupt handler
	    05h "Z_HandlerPageFault" install page-fault handler
	    06h "Z_HandlerIOEx" install I/O exception handler
	    07h "Z_HandlerGenEx" install general exception handler
	    08h "Z_HandlerHWInt" install hardware interrupt handler
	    09h "Z_IOBitmapGet" get current domain's I/O bitmap entry
	    0Ah "Z_IOBitmapSet" set current domain's I/O bitmap entry
	    0Bh "Z_IOBitmapDomGet" get domain's I/O bitmap entry
	    0Ch "Z_IOBitmapDomSet" set domain's I/O bitmap entry
	    0Dh "Z_DomMemRead" read memory in another domain
	    0Eh "Z_DomMemWrite" write memory in another domain
	    0Fh "Z_PtblDomGet" read domain's page table
	    10h "Z_PtblDomSet" write domain's page table
	    11h "Z_InstanceSet" register instanced memory
	    12h "X_DomNProcessesGet" get number of processes in domain
	    13h "X_DomSuspend" suspend a domain
	    14h "Z_DomUnsuspend" resume execution of a domain
	    15h "Z_DomFork" make a copy of the current domain
	    16h "Z_DomTerm" terminate domain and all processes in it
	    17h "Z_HandlerUnlink" remove a handler
	    18h "Z_HandlerHWIntDflt" install default hardware interrupt handler
	    19h "Z_HandlerVHWInt" install virtual hardware interrupt handler
	    1Ah "Z_HandlerVHWIntDflt" install default virtual hware int handler
	    1Bh "Z_HandlerSwapIn" install swap-in handler
	    1Ch "Z_HandlerSwapOut" install swap-out handler
	    1Dh "Z_EndOfInterrupt" signal EOI
	    1Eh ???
	    1Fh "Z_HandlerPCreate" install process-creation handler
	    20h "Z_HandlerPTerm" install process-termination handler
	    21h "Z_DomRootProcessGet" get domain's root process' handle
	    22h "F_DForeground" domain has just switched to foreground
	    23h "F_DBackground" domain has just switched to background
	    24h "F_MapHMA" map domain's HMA
	    25h "F_AddInstData" add DOS instance data
	    26h "X_DomMemFreeGet" get free memory in a domain
	    27h "X_DomMemUsedGet" get memory used by current domain
	    28h "Z_DomMemMaxGet" get per-domain memory limit
	    29h "Z_DomMemMaxSet" set per-domain memory limit
	    2Ah "F_ReflectInt21" protected-mode INT 21 support
	    2Bh "Z_DomHandleGet" get domain for a process
	    2Ch ???
	    2Dh ???
	    2Eh ???
	    2Fh ???
	    30h ???
	    31h ???
	    32h ???
Return: CX = status (most subfunctions)
	(E)AX and/or (E)BX contain return values, depending on function
Notes:	called by DPMS.EXE and EMM386.EXE
	this API is only available if AX=12FFh/BX=0EDCh returns successfully;
	  because the request is handled on the initial trap to the memory
	  manager caused by INT instructions, this API must be invoked with
	  an actual INT 2F instruction instead of some simulation such as a
	  far call to the address in the interrupt vector table
SeeAlso: AX=12FFh/BX=0EDCh,AX=2780h/CL=01h,AX=2780h/CL=02h,AX=2780h/CL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2780CL05" name="2F2780CL05"><b>2F2780CL05</b></a> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - VIRTUAL MACHINES<br />
<pre>
INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - VIRTUAL MACHINES
	AX = 2780h
	CL = 05h (module: VM)
	CH = function
	    00h "F_VMProtInit" internal protected-mode initialization
	    01h "Z_TMLoad" load task manager
	    02h "Z_TMUnload" unload task manager
	    03h	"Z_VMBackSet" send virtual machine to background
	    04h "Z_VMForeSet" send virtual machine to foreground
	    05h "Z_VMSaveEnable" enable saving virtual machine
	    06h "Z-VMSaveDisable" disable saving virtual machine
	    07h "Z_TMInit" intialize task manager
	    08h "Z_TMHotKeyGet" get task manager hotkey
	    09h "Z_TMHitKeyEnable" restart scanning for task manager key
	    0Ah "Z_TMHotKeyDisable" stop scanning for task manager key
	    0Bh "X_ForeGet" get current foreground domain
	    0Ch "F_DMAHandlerEnable" (re)enable DMA address translation
	    0Dh "F_DMAHandlerDisable" disable DMA address translation
	    0Eh "Z_SerialTimeoutGet" set serial port timeout
	    0Fh "Z_ParallelTimeoutSet" set parallel port timeout
	    10h "F_VCPIEntry" domain is entering VCPI mode
	    11h "F_VCPIExit" domain is leaving VCPI mode
	    12h "X_MsgGlobalEnter" enter Global Message Mode
	    13h "X_MsgGlobalDisplay" display global message
	    14h "X_MsgGlobalExit" leave Global Message Mode
	    15h "X_MsgDomEnter" enter Domain Message Mode
	    16h "X_MsgDomDisplay" display domain-specific message
	    17h "X_MsgDomExit" leave Domain Message Mode
	    18h "X_MsgFatalDisplay" display fatal error message
	    19h "Z_SerialBaseSet" set serial port address
	    1Ah "Z_ParallelBaseSet" set parallel port address
	    1Bh "Z_SerialIRQSet" set serial port IRQ
	    1Ch "Z_ParallelIRQSet" set parallel port IRQ
	    1Dh "F_ResetVideo" emergency video system reset
	    1Eh "F_SetMouseIRQ" set which IRQ is used by mouse
	    1Fh "F_CheckNotIdle" check whether system is idle
	    20h "F_GetMouseInfo"
	    21h "Z_SerialOwnerGet" get serial port owner
	    22h "Z_SerialTimeoutGet" get serial port timeout
	    23h "Z_ParallelOwnerGet" get parallel port owner
	    24h "Z_ParallelTimeoutGet" get parallel port timeout
	???
Return: ???
Notes:	called by DPMS.EXE and EMM386.EXE
	the handler for this function may be set by one of the subfunctions
	  of AX=2780h/CL=01h; the default handler returns AX=BX=FFFFh and
	  CX=0001h (see #02739)
	this API is only available if AX=12FFh/BX=0EDCh returns successfully;
	  because the request is handled on the initial trap to the memory
	  manager caused by INT instructions, this API must be invoked with
	  an actual INT 2F instruction instead of some simulation such as a
	  far call to the address in the interrupt vector table
SeeAlso: AX=12FFh/BX=0EDCh,AX=2780h/CL=01h,AX=2780h/CL=02h,AX=2780h/CL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2780CL06" name="2F2780CL06"><b>2F2780CL06</b></a> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - DPMI SERVICES<br />
<pre>
INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - DPMI SERVICES
	AX = 2780h
	CL = 06h
	CH = function
	    00h "F_InitDPMI" used for internal initialization
	    01h "F_DescAllocLDT" allocate LDT descriptor
	    02h "F_DescFreeLDT" free LDT descriptor
	    03h "F_DescGetLDT" get details on LDT descriptor
	    04h "F_DescSetLDT" set up LDT descriptor
	    05h "F_DescAllocInt21" allocate descriptor for PM INT 21
	    06h "F_WhereIsDPMI" get address of DPMI global data
Return: ???
Notes:	called by DPMS.EXE and EMM386.EXE
	the handler for this function may be set by one of the subfunctions
	  of AX=2780h/CL=01h; the default handler returns AX=BX=FFFFh and
	  CX=0001h (see #02739)
	this API is only available if AX=12FFh/BX=0EDCh returns successfully;
	  because the request is handled on the initial trap to the memory
	  manager caused by INT instructions, this API must be invoked with
	  an actual INT 2F instruction instead of some simulation such as a
	  far call to the address in the interrupt vector table
SeeAlso: AX=12FFh/BX=0EDCh,AX=2780h/CL=01h,AX=2780h/CL=02h,AX=2780h/CL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2780" name="2F2780"><b>2F2780</b></a> - INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - AVAILABLE FOR APPS<br />
<pre>
INT 2F U - Novell DOS 7 - EMM386.EXE - MULTITASKING API - AVAILABLE FOR APPS
	AX = 2780h
	CL = function (07h-0Fh)
	???
Return: ???
Notes:	called by DPMS.EXE and EMM386.EXE
	the handlers for each of these functions may be set individually by
	  one of the subfunctions of AX=2780h/CL=01h; the default handlers
	  return with all registers unchanged
	this API is only available if AX=12FFh/BX=0EDCh returns successfully;
	  because the request is handled on the initial trap to the memory
	  manager caused by INT instructions, this API must be invoked with
	  an actual INT 2F instruction instead of some simulation such as a
	  far call to the address in the interrupt vector table
SeeAlso: AX=12FFh/BX=0EDCh,AX=2780h/CL=01h,AX=2780h/CL=02h,AX=2780h/CL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2781" name="2F2781"><b>2F2781</b></a> - INT 2F U - Novell DOS 7 TaskMGR - BEGIN CRITICAL SECTION???<br />
<pre>
INT 2F U - Novell DOS 7 TaskMGR - BEGIN CRITICAL SECTION???
	AX = 2781h
Return: ???
SeeAlso: AX=2782h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2782" name="2F2782"><b>2F2782</b></a> - INT 2F U - Novell DOS 7 TaskMGR - END CRITICAL SECTION???<br />
<pre>
INT 2F U - Novell DOS 7 TaskMGR - END CRITICAL SECTION???
	AX = 2782h
Return: ???
SeeAlso: AX=2781h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2783" name="2F2783"><b>2F2783</b></a> - INT 2F U - Novell DOS 7 - EMM386.EXE - GET ???<br />
<pre>
INT 2F U - Novell DOS 7 - EMM386.EXE - GET ???
	AX = 2783h
Return: AX = ???
	BX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F278F" name="2F278F"><b>2F278F</b></a> - INT 2F U - Novell DOS 7 TaskMGR - ??? API<br />
<pre>
INT 2F U - Novell DOS 7 TaskMGR - ??? API
	AX = 278Fh
	as for INT 2F/AX=2780h
Return: as for INT 2F/AX=2780h
Note:	Novell DOS 7 TaskMGR passes this call through to INT 2F/AX=2780h
	  without changing any other registers
SeeAlso: AX=2780h/CL=01h,AX=2782h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2A" name="2F2A"><b>2F2A</b></a> - INT 2F - Gammafax DOS Dispatcher INTERFACE<br />
<pre>
INT 2F - Gammafax DOS Dispatcher INTERFACE
	AH = 2Ah
Note:	details not available at this time
SeeAlso: AX=8000h"FaxBIOS",AX=C000h/BX=444Bh,AX=CB00h,AX=CBDDh,INT 66"BitFax"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2E00" name="2F2E00"><b>2F2E00</b></a> - INT 2F U - Novell DOS 7 - GRAFTABL - INSTALLATION CHECK<br />
<pre>
INT 2F U - Novell DOS 7 - GRAFTABL - INSTALLATION CHECK
	AX = 2E00h
Return: AH = FFh if installed
Note:	this installation check does not follow the usual format of setting
	  AL to FFh
SeeAlso: AX=2300h,AH=2Eh"GRAFTABL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F2E" name="2F2E"><b>2F2E</b></a> - INT 2F U - Novell DOS 7 - GRAFTABL - GET FONT TABLE<br />
<pre>
INT 2F U - Novell DOS 7 - GRAFTABL - GET FONT TABLE
	AH = 2Eh
	AL nonzero
Return: AH = FFh if installed
	    ES:BX -&gt; graphics data (8 bytes per character from 80h to FFh)
SeeAlso: AX=2E00h,AH=23h"GRAFTABL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3900" name="2F3900"><b>2F3900</b></a> - INT 2F - Kingswood TSR INTERFACE - COMPATIBILITY MODE<br />
<pre>
INT 2F - Kingswood TSR INTERFACE - COMPATIBILITY MODE
	AX = 3900h
Return: AL = status
	    00h not installed
	    FFh one or more TSRs using this interface is installed
		DX may be destroyed
Note:	this function is provided to that the multiplex number will appear used
	  to other programs
SeeAlso: AH=39h/BL=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F39--BL00" name="2F39--BL00"><b>2F39--BL00</b></a> - INT 2F - Kingswood TSR INTERFACE - INSTALLATION CHECK<br />
<pre>
INT 2F - Kingswood TSR INTERFACE - INSTALLATION CHECK
	AH = 39h
	BL = 00h
	AL = TSR ID number (01h-FFh, currently only 01h-1Bh used) (see #02742)
Return: AL = status
	    00h not installed
	    FFh installed
		DX = segment address of resident module
Note:	All of Kingswood Software's TSRs use this interface.  Usually the
	  resident module is installed by allocating a block of upper memory,
	  setting its owner ID to 000Ah (used by DOS), and filling the MCB name
	  field with the TSR's name.
SeeAlso: #02743,AX=3900h,AH=39h/BL=01h

(Table 02742)
Values for Kingswood TSR ID number:
 01h	TSR Windows
 02h	NOBUSY
 03h	CD STACK
 04h	DISK WATCH
 05h	PUSHBP
 06h	ALIAS
 07h	KEYMACRO
 08h	SLOWDOWN
 09h	ANSIGRAB
 0Ah	TEE
 0Bh	FASTMOUS
 0Ch	EXTWILD
 0Dh	BREAKOUT
 0Eh	STOPDISK
 0Fh	MEMINIT
 10h	JANUSEXT
 11h	CAPS
 12h	ANSI
 13h	TRAPPER
 14h	EATMEM
 15h	WPJOKE
 16h	SHOWDOS
 17h	LOGINTS
 18h	BLANKVGA
 19h	SWAPEXEC
 1Ah	SHELL
 1Bh	TSRGAMES

Format of Kingswood TSR modules:
Offset	Size	Description	(Table 02743)
 00h  4 BYTEs	signature "FTSR"
 04h	WORD	segment address of this module (used to check validity)
 06h	WORD	number of words to skip (usually 0000h if no PSP present)
 08h  N WORDs	module-defined data that must be at a fixed segment offset
		(usually only a PSP if file access is required)
     5N BYTEs	interrupt list (see #02744)
	BYTE	FFh terminator

Format of Kingswood TSR interrupt list entry:
Offset	Size	Description	(Table 02744)
 00h	BYTE	interrupt number (00h-FEh)
 01h	WORD	offset within segment of DWORD pointer to previous interrupt
 03h	WORD	offset within segment of begin of interrupt handler code

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F39--BL01" name="2F39--BL01"><b>2F39--BL01</b></a> - INT 2F - Kingswood TSR INTERFACE - REMOVAL CHECK<br />
<pre>
INT 2F - Kingswood TSR INTERFACE - REMOVAL CHECK
	AH = 39h
	BL = 01h
	AL = TSR ID number (01h-FFh) (see #02742)
Return: AL = status
	    00h not ready to be removed
	    FFh resident module may be removed by deassigning the interrupts
		  hooked by the TSR and deallocating the TSR's memory block
	AH,BX,CX,DX,ES may be destroyed
SeeAlso: AX=3900h,AH=39h/BL=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F39" name="2F39"><b>2F39</b></a> - INT 2F - Kingswood TSR INTERFACE - APPLICATION-SPECIFIC FUNCTION CALLS<br />
<pre>
INT 2F - Kingswood TSR INTERFACE - APPLICATION-SPECIFIC FUNCTION CALLS
	AH = 39h
	BL = function number (02h-FFh)
	AL = TSR ID number (01h-FFh) (see #02742)
	CX,DX,SI,DI,DS,ES may contain parameters
	BH reserved for use by the function dispatcher
Return: as appropriate for the called function
SeeAlso: AX=3900h,AH=39h/BL=00h,AX=3901h/BL=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3901BL02" name="2F3901BL02"><b>2F3901BL02</b></a> - INT 2F - Kingswood TSR Windows - OPEN WINDOW<br />
<pre>
INT 2F - Kingswood TSR Windows - OPEN WINDOW
	AX = 3901h
	BL = 02h
Return: AX = error code (0000h if successful)
	SI,DI,DS,ES preserved
Notes:	opens the next TSR window on top of any others.	 Only three
	  TSR windows can be opened at any one time.  The three windows
	  are all 40x11 characters, partly overlapping.
SeeAlso: AH=39h/BL=00h,AX=3901h/BL=03h,AX=3901h/BL=05h,AX=3901h/BL=06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3901BL03" name="2F3901BL03"><b>2F3901BL03</b></a> - INT 2F - Kingswood TSR Windows - HIDE WINDOWS<br />
<pre>
INT 2F - Kingswood TSR Windows - HIDE WINDOWS
	AX = 3901h
	BL = 03h
Return: AX = error code (0000h if successful)
	SI,DI,DS,ES preserved
Notes:	Hide any visible TSR windows from view.
SeeAlso: AH=39h/BL=00h,AX=3901h/BL=02h,AX=3901h/BL=05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3901BL04" name="2F3901BL04"><b>2F3901BL04</b></a> - INT 2F - Kingswood TSR Windows - SHOW WINDOWS<br />
<pre>
INT 2F - Kingswood TSR Windows - SHOW WINDOWS
	AX = 3901h
	BL = 04h
Return: AX = error code (0000h if successful)
	SI,DI,DS,ES preserved
Notes:	Re-display all TSR windows after a HIDE WINDOWS call.
SeeAlso: AH=39h/BL=00h,AX=3901h/BL=02h,AX=3901h/BL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3901BL05" name="2F3901BL05"><b>2F3901BL05</b></a> - INT 2F - Kingswood TSR Windows - CLOSE WINDOW<br />
<pre>
INT 2F - Kingswood TSR Windows - CLOSE WINDOW
	AX = 3901h
	BL = 05h
Return: AX = error code (0000h if successful)
	SI,DI,DS,ES preserved
Notes:	Close the last opened TSR window.
SeeAlso: AH=39h/BL=00h,AX=3901h/BL=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3901BL06" name="2F3901BL06"><b>2F3901BL06</b></a> - INT 2F - Kingswood TSR Windows - SET WINDOW TITLE<br />
<pre>
INT 2F - Kingswood TSR Windows - SET WINDOW TITLE
	AX = 3901h
	BL = 06h
	DS:SI -&gt; title string
Return: AX = error code (0000h if successful)
	SI,DI,DS,ES preserved
SeeAlso: AH=39h/BL=00h,AX=3901h/BL=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3901BL07" name="2F3901BL07"><b>2F3901BL07</b></a> - INT 2F - Kingswood TSR Windows - POSITION CURSOR<br />
<pre>
INT 2F - Kingswood TSR Windows - POSITION CURSOR
	AX = 3901h
	BL = 07h
	CH = Y coordinate (0-10)
	CL = X coordinate (0-39)
Return: AX = error code (0000h if successful)
	SI,DI,DS,ES preserved
Note:	the hardware cursor is always disabled when a TSR window is opened;
	  this call only sets a text position
SeeAlso: AH=39h/BL=00h,AX=3901h/BL=08h,AX=3901h/BL=09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3901BL08" name="2F3901BL08"><b>2F3901BL08</b></a> - INT 2F - Kingswood TSR Windows - DISPLAY STRING<br />
<pre>
INT 2F - Kingswood TSR Windows - DISPLAY STRING
	AX = 3901h
	BL = 08h
	DS:SI -&gt; string
Return: AX = error code (0000h if successful)
	SI,DI,DS,ES preserved
Notes:	The text is not clipped.
	This routine understands Tab, NewLine and Carriage Return
SeeAlso: AH=39h/BL=00h,AX=3901h/BL=07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3901BL09" name="2F3901BL09"><b>2F3901BL09</b></a> - INT 2F - Kingswood TSR Windows - SCROLL WINDOW<br />
<pre>
INT 2F - Kingswood TSR Windows - SCROLL WINDOW
	AX = 3901h
	BL = 09h
	CL = scroll direction: 01h up, FFh down, 00h clear window
Return: AX = error code (0000h if successful)
	SI,DI,DS,ES preserved
SeeAlso: AH=39h/BL=00h,AX=3901h/BL=07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3901BL0A" name="2F3901BL0A"><b>2F3901BL0A</b></a> - INT 2F - Kingswood TSR Windows - SOUND BEEPER<br />
<pre>
INT 2F - Kingswood TSR Windows - SOUND BEEPER
	AX = 3901h
	BL = 0Ah
	DX = sound divisor, or 0 for silence.
	     (divide 1843200 by required frequency to get value for DX)
	CL = sound length in 18.2 Hz clock ticks
Return: AX = error code (0000h if successful)
	SI,DI,DS,ES preserved
SeeAlso: AH=39h/BL=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3901BL0B" name="2F3901BL0B"><b>2F3901BL0B</b></a> - INT 2F - Kingswood TSR Windows - ADD OR REMOVE USER<br />
<pre>
INT 2F - Kingswood TSR Windows - ADD OR REMOVE USER
	AX = 3901h
	BL = 0Bh
	CL = number of users increment: +1 if adding a new user
					-1 if removing a user
Return: AX = error code (0000h if successful)
	SI,DI,DS,ES preserved
Note:	the TSR windows resident module may only be removed when the internal
	  user count is zero
SeeAlso: AH=39h/BL=00h,AX=3901h/BL=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3912BL03" name="2F3912BL03"><b>2F3912BL03</b></a> - INT 2F - Kingswood ANSI display driver - SET COMPATIBILITY MODE<br />
<pre>
INT 2F - Kingswood ANSI display driver - SET COMPATIBILITY MODE
	AX = 3912h
	BL = 03h
	CL = new mode (00h fast, FFh BIOS)
Return: AL = old compatibility mode
	SI,DI,DS,ES preserved
SeeAlso: AX=3900h,AX=3912h/BL=04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F3912BL04" name="2F3912BL04"><b>2F3912BL04</b></a> - INT 2F - Kingswood ANSI display driver - SET FLAGS<br />
<pre>
INT 2F - Kingswood ANSI display driver - SET FLAGS
	AX = 3912h
	BL = 04h
	CL = new flags (see #02745)
Return: AL = old flags
	SI,DI,DS,ES preserved
SeeAlso: AX=3900h,AX=3912h/BL=03h

Bitfields for Kingswood ANSI flags:
Bit(s)	Description	(Table 02745)
 0	do not wrap at end of line
 1	wait for beeps to end before displaying next character
 2	do not use graphics cursor

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4000" name="2F4000"><b>2F4000</b></a> - INT 2F - Windows 3+ (OS/2 2.x???) - GET VIRTUAL DEVICE DRIVER (VDD) CAPABILTIES<br />
<pre>
INT 2F - Windows 3+ (OS/2 2.x???) - GET VIRTUAL DEVICE DRIVER (VDD) CAPABILTIES
	AX = 4000h
Return: AL = video virtualization (see #02746)
Notes:	This function is used by display drivers to find out what capabilities
	  exist for the VDD driver and also trigger the VDD driver to call
	  functions 4005h and 4006h (and 4001h/4002h under OS/2?).  This
	  function also gives the Video Driver hardware access to the video
	  registers.
	Once the background/foreground callouts have been activated by a
	  call to this function, the application *must* handle those callouts
	  and save/restore the video memory itself.

(Table 02746)
Values for Windows video virtualization:
 01h	does not virtualize video access
 02h	virtualizes the video when in text mode
 03h	virtualizes the video when in text mode or single plane graphics modes
 04h	virtualizes the video when in text mode, single plane graphics modes,
	  and VGA multiplane modes
 FFh	virtualizes the video fully

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4001" name="2F4001"><b>2F4001</b></a> - INT 2F C - OS/2 compatibility box - SWITCHING DOS TO BACKGROUND<br />
<pre>
INT 2F C - OS/2 compatibility box - SWITCHING DOS TO BACKGROUND
	AX = 4001h
Note:	called by OS/2 when the DOS box is about to be placed in the background
	  and the video driver should save any necessary state
SeeAlso: AX=4002h,AX=4005h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4002" name="2F4002"><b>2F4002</b></a> - INT 2F C - OS/2 compatibility box - SWITCHING DOS TO FOREGROUND<br />
<pre>
INT 2F C - OS/2 compatibility box - SWITCHING DOS TO FOREGROUND
	AX = 4002h
Note:	called by OS/2 when the DOS box is about to be placed in the foreground
	  and the video driver should restore the previously-saved state
SeeAlso: AX=4001h,AX=4006h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4003" name="2F4003"><b>2F4003</b></a> - INT 2F - Windows 3.x - ENTERING VIDEO DRIVER CRITICAL SECTION<br />
<pre>
INT 2F - Windows 3.x - ENTERING VIDEO DRIVER CRITICAL SECTION
	AX = 4003h
Note:	This critical section must be exited within 1 second.
SeeAlso: AX=4004h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4004" name="2F4004"><b>2F4004</b></a> - INT 2F - Windows 3.x - EXITING VIDEO DRIVER CRITICAL SECTION<br />
<pre>
INT 2F - Windows 3.x - EXITING VIDEO DRIVER CRITICAL SECTION
	AX = 4004h
SeeAlso: AX=4003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4005" name="2F4005"><b>2F4005</b></a> - INT 2F C - Windows 3.x - SWITCHING DOS TO BACKGROUND<br />
<pre>
INT 2F C - Windows 3.x - SWITCHING DOS TO BACKGROUND
	AX = 4005h
Notes:	called by Windows when the DOS box is about to be placed in the
	  background and the video driver should save any necessary state
	  information (this may be called only in Standard mode)
	this callout is not made unless the application has first called
	  AX=4000h
SeeAlso: AX=4001h,AX=4006h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4006" name="2F4006"><b>2F4006</b></a> - INT 2F C - Windows 3.x - SWITCHING DOS TO FOREGROUND<br />
<pre>
INT 2F C - Windows 3.x - SWITCHING DOS TO FOREGROUND
	AX = 4006h
Notes:	called by Windows when the DOS box is about to be placed in the
	  foreground and the video driver should restore any necessary state
	  information (this may be called only in Standard mode)
	this callout is not made unless the application has first called
	  AX=4000h
SeeAlso: AX=4002h,AX=4005h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4007" name="2F4007"><b>2F4007</b></a> - INT 2F - Windows 3.x - ENABLE VDD TRAPPING OF VIDEO REGISTERS<br />
<pre>
INT 2F - Windows 3.x - ENABLE VDD TRAPPING OF VIDEO REGISTERS
	AX = 4007h
Note:	used by Windows Standard mode

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4010" name="2F4010"><b>2F4010</b></a> - INT 2F - OS/2 v2.0+ - INSTALLATION CHECK / GET VERSION<br />
<pre>
INT 2F - OS/2 v2.0+ - INSTALLATION CHECK / GET VERSION
	AX = 4010h
Return: AX = 4010h if OS/2 not installed
	AX = 0000h for OS/2 Warp 3.0
	BX = OS/2 version if installed
Note:	OS/2 Warp 3.0
SeeAlso: INT 21/AH=30h,INT 21/AX=3306h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4011" name="2F4011"><b>2F4011</b></a> - INT 2F - OS/2 - GET VDD API ENTRY POINT<br />
<pre>
INT 2F - OS/2 - GET VDD API ENTRY POINT
	AX = 4011h
	DS:(E)SI -&gt; ASCIZ name of VDD registered with VDHRegisterAPI
Return: ES:DI -&gt; breakpoint address to call for VDD API, or 0000h:0000h
Note:	this function may be invoked from either V86 or protected mode, and
	  will return the appropriate address to call for invoking the VDD
	  in that mode
SeeAlso: AX=1684h"DEVICE API"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4021" name="2F4021"><b>2F4021</b></a> - INT 2F UC - Diamond Stealth64 Video - STLTH64.VXD - ???<br />
<pre>
INT 2F UC - Diamond Stealth64 Video - STLTH64.VXD - ???
	AX = 4021h
	???
Return: ???
SeeAlso: AX=4022h,AX=4023h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4022" name="2F4022"><b>2F4022</b></a> - INT 2F UC - Diamond Stealth64 Video - STLTH64.VXD - ???<br />
<pre>
INT 2F UC - Diamond Stealth64 Video - STLTH64.VXD - ???
	AX = 4022h
	???
Return: ???
SeeAlso: AX=4021h,AX=4023h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4023" name="2F4023"><b>2F4023</b></a> - INT 2F UC - Diamond Stealth64 Video - STLTH64.VXD - ???<br />
<pre>
INT 2F UC - Diamond Stealth64 Video - STLTH64.VXD - ???
	AX = 4023h
	???
Return: ???
SeeAlso: AX=4021h,AX=4022h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4027" name="2F4027"><b>2F4027</b></a> - INT 2F UC - Diamond Stealth64 Video - DMSSTL.DRV - ???<br />
<pre>
INT 2F UC - Diamond Stealth64 Video - DMSSTL.DRV - ???
	AX = 4027h
	???
Return: ???
Notes:	called when ???
	a protected-mode handler for this function may be installed with the
	  function RFV_HOOKINT2FHANDLER
SeeAlso: AX=4021h,AX=4022h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4040" name="2F4040"><b>2F4040</b></a> - INT 2F - PharLap 286|DOS-Extender Lite v2.5 - ???<br />
<pre>
INT 2F - PharLap 286|DOS-Extender Lite v2.5 - ???
	AX = 4040h
Return: BX:CX -&gt; ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4100" name="2F4100"><b>2F4100</b></a> - INT 2F - DOS Enhanced LAN Manager 2.0+ MINIPOP/NETPOPUP - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS Enhanced LAN Manager 2.0+ MINIPOP/NETPOPUP - INSTALLATION CHECK
	AX = 4100h
Return: CF clear if successful
	    AL = FFh
	CF set on error
	    AX = ???
Notes:	MINIPOP and NETPOPUP provide a network message popup service
	LAN Manager enhanced mode adds features beyond the standard redirector
	  file/printer services
SeeAlso: AX=118Ah,AX=4103h,AX=4104h,AH=42h,AH=4Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4103" name="2F4103"><b>2F4103</b></a> - INT 2F - DOS Enhanced LAN Manager 2.0+ MINIPOP/NETPOPUP - ???<br />
<pre>
INT 2F - DOS Enhanced LAN Manager 2.0+ MINIPOP/NETPOPUP - ???
	AX = 4103h
Return: ???
SeeAlso: AX=4100h,AX=4104h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4104" name="2F4104"><b>2F4104</b></a> - INT 2F - DOS Enhanced LAN Manager 2.0+ MINIPOP/NETPOPUP - ???<br />
<pre>
INT 2F - DOS Enhanced LAN Manager 2.0+ MINIPOP/NETPOPUP - ???
	AX = 4104h
Return: ???
SeeAlso: AX=4100h,AX=4103h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F42" name="2F42"><b>2F42</b></a> - INT 2F - LAN Manager 2.0 DOS Enhanced MSRV.EXE - MESSENGER SERVICE<br />
<pre>
INT 2F - LAN Manager 2.0 DOS Enhanced MSRV.EXE - MESSENGER SERVICE
	AH = 42h
	???
Return: ???
Note:	LAN Manager enhanced mode adds features beyond the standard redirector
	  file/printer services
SeeAlso: AX=118Ah,AX=4100h,AH=4Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4300" name="2F4300"><b>2F4300</b></a> - INT 2F - EXTENDED MEMORY SPECIFICATION (XMS) v2+ - INSTALLATION CHECK<br />
<pre>
INT 2F - EXTENDED MEMORY SPECIFICATION (XMS) v2+ - INSTALLATION CHECK
	AX = 4300h
Return: AL = 80h XMS driver installed
	AL &lt;&gt; 80h no driver
Notes:	XMS gives access to extended memory and noncontiguous/nonEMS memory
	  above 640K
	this installation check DOES NOT follow the format used by other
	  software
SeeAlso: AX=4310h,AX=1687h,INT 67/AH=40h,@xxxxh:xxxxh"PMM"
Index:	installation check;XMS version 2+

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4308" name="2F4308"><b>2F4308</b></a> - INT 2F U - HIMEM.SYS v2.77+ - GET A20 HANDLER NUMBER<br />
<pre>
INT 2F U - HIMEM.SYS v2.77+ - GET A20 HANDLER NUMBER
	AX = 4308h
Return: AL = 43h if supported
	    BL = A20 handler number (value of /MACHINE:nn switch)
	    BH = AT A20 switch time (00h medium, 01h fast, 02h slow)
Note:	if the A20 handler number returned in BL is 00h, an external handler
	  is being used (see AX=4330h)
SeeAlso: AX=4309h,AX=4330h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4309" name="2F4309"><b>2F4309</b></a> - INT 2F U - HIMEM.SYS v3.09+ - GET XMS HANDLE TABLE<br />
<pre>
INT 2F U - HIMEM.SYS v3.09+ - GET XMS HANDLE TABLE
	AX = 4309h
Return: AL = 43h if function supported
	    ES:BX -&gt; XMS handle table (see #02747)
Note:	HIMEM.SYS v3.09 is part of MS-DOS 6.0.
SeeAlso: AX=4308h

Format of XMS handle table:
Offset	Size	Description	(Table 02747)
 00h	BYTE	??? (01h in HIMEM.SYS v3.09)
 01h	BYTE	size of one handle descriptor
 02h	WORD	number of handles (default = 20h)
 04h	DWORD	pointer to XMS handle array (see #02748)
SeeAlso: #02777

Format of XMS handle descriptor [array]:
Offset	Size	Description	(Table 02748)
 00h	BYTE	flag
		01h=free, 02h=used, 04h=in pool but not associated with any EMB
 01h	BYTE	lock count (00h=unlocked)
 02h	DWORD	address of XMS block in KB (shift left by 10 for abs. address)
 06h	DWORD	size of XMS block in KB

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4310" name="2F4310"><b>2F4310</b></a> - INT 2F - EXTENDED MEMORY SPECIFICATION (XMS) v2+ - GET DRIVER ADDRESS<br />
<pre>
INT 2F - EXTENDED MEMORY SPECIFICATION (XMS) v2+ - GET DRIVER ADDRESS
	AX = 4310h
Return: ES:BX -&gt; driver entry point (see #02749,#02750,#02753,#02760,#02769,#02774)
Notes:	HIMEM.SYS v2.77 chains to previous handler if AH is not 00h or 10h
	HIMEM.SYS requires at least 256 bytes free stack space when calling
	  the driver entry point
SeeAlso: AX=4300h,AX=4310h"Cloaking",AX=4310h"Netroom",AX=4310h"XMZ"

Format of XMS driver entry point:
Offset	Size	Description	(Table 02749)
 00h  5 BYTEs	jump to actual handler
		either short jump (EBh XXh) followed by three NOPs or
		  far jump (EAh XXXX:XXXX) to a program which has hooked itself
		  into the XMS driver chain
Note:	to hook into the XMS driver chain, a program should follow the chain of
	  far jumps until it reaches the short jump of the driver at the end
	  of the chain; this short jump is to be replaced with a far jump to
	  the new handler's entry point, which should contain a short jump
	  followed by three NOPs.  The new handler must return to the address
	  pointed at by the short jump which was overwritten.  Using this
	  method, the new handler becomes the first to see every XMS request.

(Table 02750)
Call the XMS driver "Get XMS version number" function with:
	AH = 00h
Return: AX = XMS version (in BCD, AH=major, AL=minor)
	BX = internal revision number (in BCD for HIMEM.SYS)
	DX = High Memory Area (HMA) state
	    0001h HMA (1M to 1M + 64K) exists
	    0000h HMA does not exist
SeeAlso: #02751,#02752,#02757,#02758,#02764

(Table 02751)
Call the XMS driver "Request High Memory Area" function with:
	AH = 01h
	DX = memory in bytes (for TSR or device drivers)
	    FFFFh if application program
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,81h,90h,91h,92h) (see #02775)
Note:	HIMEM.SYS will fail function 01h with error code 91h if AL=40h and
	  DX=KB free extended memory returned by last call of function 08h
SeeAlso: #02752,#02784

(Table 02752)
Call the XMS driver "Release High Memory Area" function with:
	AH = 02h
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,81h,90h,93h) (see #02775)
SeeAlso: #02751

(Table 02753)
Call the XMS driver "Global enable A20, for using the HMA" function with:
	AH = 03h
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,81h,82h) (see #02775)
SeeAlso: #02754,#02755,MSR 00001000h

(Table 02754)
Call the XMS driver "Global disable A20" function with:
	AH = 04h
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,81h,82h,94h) (see #02775)
SeeAlso: #02753,#02756,MSR 00001000h

(Table 02755)
Call the XMS driver "Local enable A20" function with:
	AH = 05h
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,81h,82h) (see #02775)
Note:	this function is used for direct access to extended memory
SeeAlso: #02753,#02756

(Table 02756)
Call the XMS driver "Local disable A20" function with:
	AH = 06h
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,81h,82h,94h) (see #02775)
SeeAlso: #02754,#02755

(Table 02757)
Call the XMS driver "Query A20 state" function with:
	AH = 07h
Return: AX = status
	    0001h enabled
	    0000h disabled
		BL = error code (00h,80h,81h) (see #02775)
SeeAlso: #02750,#02758

(Table 02758)
Call the XMS driver "Query free extended memory" function with:
	AH = 08h
	BL = 00h (some implementations leave BL unchanged on success)
Return: AX = size of largest extended memory block in KB
	DX = total extended memory in KB
	BL = error code (00h,80h,81h,A0h) (see #02775)
Note:	this function does not include the HMA in the returned memory sizes
SeeAlso: #02750,#02757,#02759,#02771

(Table 02759)
Call the XMS driver "Allocate extended memory block" function with:
	AH = 09h
	DX = Kbytes needed
Return: AX = status
	    0001h success
		DX = handle for memory block
	    0000h failure
		BL = error code (80h,81h,A0h) (see #02775)
SeeAlso: #02758,#02761,#02764,#02765,#02766,#02772

(Table 02760)
Call the XMS driver "Free extended memory block" function with:
	AH = 0Ah
	DX = handle of block to free
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,81h,A2h,ABh) (see #02775)
SeeAlso: #02759,#02772

(Table 02761)
Call the XMS driver "Move extended memory block" function with:
	AH = 0Bh
	DS:SI -&gt; EMM structure (see #02776)
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h-82h,A3h-A9h) (see #02775)
Note:	if either handle in the EMM structure is 0000h, the corresponding
	  offset is considered to be an absolute segment:offset address in
	  directly addressable memory
SeeAlso: #02759,#02762

(Table 02762)
Call the XMS driver "Lock extended memory block" function with:
	AH = 0Ch
	DX = handle of block to lock
Return: AX = status
	    0001h success
		DX:BX = 32-bit physical address of locked block
	    0000h failure
		BL = error code (80h,81h,A2h,ACh,ADh) (see #02775)
Note:	MS Windows 3.x rejects this function for handles allocated after
	  Windows started
SeeAlso: #02759,#02761,#02763,#02777

(Table 02763)
Call the XMS driver "Unlock extended memory block" function with:
	AH = 0Dh
	DX = handle of block to unlock
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,81h,A2h,AAh) (see #02775)
SeeAlso: #02762

(Table 02764)
Call the XMS driver "Get handle information" function with:
	AH = 0Eh
	DX = handle for which to get info
Return: AX = status
	    0001h success
		BH = block's lock count
		BL = number of free handles left
		DX = block size in KB
	    0000h failure
		BL = error code (80h,81h,A2h) (see #02775)
BUG:	MS Windows 3.10 acts as though unallocated handles are in use
Note:	MS Windows 3.00 has problems with this call
SeeAlso: #02750,#02759,#02773

(Table 02765)
Call the XMS driver "Reallocate extended memory block" function with:
	AH = 0Fh
	DX = handle of block
	BX = new size of block in KB
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,81h,A0h-A2h,ABh) (see #02775)
SeeAlso: #02759,#02768

(Table 02766)
Call the XMS driver "Request upper memory block" function with:
	AH = 10h
	DX = size of block in paragraphs
Return: AX = status
	    0001h success
		BX = segment address of UMB
		DX = actual size of block
	    0000h failure
		BL = error code (80h,B0h,B1h) (see #02775)
		DX = largest available block
Notes:	Upper Memory consists of non-EMS memory between 640K and 1024K
	the XMS driver need not implement functions 10h through 12h to be
	  considered compliant with the standard
	under DOS 5+, if CONFIG.SYS contains the line DOS=UMB, then no upper
	  memory blocks will be available for allocation because all blocks
	  have been grabbed by MS-DOS while booting
SeeAlso: #02759,#02767,#02785,INT 21/AH=58h"UMB"

(Table 02767)
Call the XMS driver "Release upper memory block" function with:
	AH = 11h
	DX = segment address of UMB to release
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,B2h) (see #02775)
Note:	the XMS driver need not implement functions 10h through 12h to be
	  considered compliant with the standard
SeeAlso: #02760,#02766,#02768

(Table 02768)
Call the XMS v3.0+ driver "Reallocate upper memory block" function with:
	AH = 12h
	DX = segment address of UMB to resize
	BX = new size of block in paragraphs
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,B0h,B2h) (see #02775)
		DX = maximum available size (RM386)
Note:	the XMS driver need not implement functions 10h through 12h to be
	  considered compliant with the standard
SeeAlso: #02765,#02766,#02767,#02783

(Table 02769)
Call the QEMM v5.11 "???" function with:
	AH = 34h  (QEMM 5.11 only, undocumented)
	???
Return: ???
SeeAlso: #02770

(Table 02770)
Call the QEMM v5.11 "???" function with:
	AH = 44h  (QEMM 5.11 only, undocumented)
	???
Return: ???
SeeAlso: #02769,#02783

(Table 02771)
Call the XMS v3.0 driver "Query free extended memory" function with:
	AH = 88h
Return: EAX = largest block of extended memory, in KB
	BL = status (00h,80h,81h,A0h) (see #02775)
	ECX = physical address of highest byte of memory
	    (valid even on error codes 81h and A0h)
	EDX = total Kbytes of extended memory (0 if status A0h)
BUG:	HIMEM v3.03-3.07 crash on an 80286 machine if any of the 8Xh functions
	  are called
SeeAlso: #02758,#02772

(Table 02772)
Call the XMS v3.0 driver "Allocate any extended memory" function with:
	AH = 89h
	EDX = Kbytes needed
Return: AX = status
	    0001h success
		DX = handle for allocated block (free with AH=0Ah) (see #02760)
	    0000h failure
		BL = status (80h,81h,A0h,A1h,A2h) (see #02775)
SeeAlso: #02759,#02771

(Table 02773)
Call the XMS v3.0 driver "Get extended EMB handle information" function with:
	AH = 8Eh
	DX = handle
Return: AX = status
	    0001h success
		BH = block's lock count
		CX = number of free handles left
		EDX = block size in KB
	    0000h failure
		BL = status (80h,81h,A2h) (see #02775)
BUG:	MS-DOS 6.0 HIMEM.SYS leaves CX unchanged
SeeAlso: #02764,#02772,#02774

(Table 02774)
Call the XMS v3.0 driver "Reallocate any extended memory block" function with:
	AH = 8Fh
	DX = unlocked memory block handle
	EBX = new size in KB
Return: AX = status
	    0001h success
	    0000h failure
		BL = status (80h,81h,A0h-A2h,ABh) (see #02775)
BUG:	HIMEM v3.03-3.07 crash on an 80286 machine if any of the 8Xh functions
	  are called
SeeAlso: #02765,#02773

(Table 02775)
Values for XMS error code returned in BL:
 00h	successful
 80h	function not implemented
 81h	Vdisk was detected
 82h	an A20 error occurred
 8Eh	a general driver error
 8Fh	unrecoverable driver error
 90h	HMA does not exist or is not managed by XMS provider
 91h	HMA is already in use
 92h	DX is less than the /HMAMIN= parameter
 93h	HMA is not allocated
 94h	A20 line still enabled
 A0h	all extended memory is allocated
 A1h	all available extended memory handles are allocated
 A2h	invalid handle
 A3h	source handle is invalid
 A4h	source offset is invalid
 A5h	destination handle is invalid
 A6h	destination offset is invalid
 A7h	length is invalid
 A8h	move has an invalid overlap
 A9h	parity error occurred
 AAh	block is not locked
 ABh	block is locked
 ACh	block lock count overflowed
 ADh	lock failed
 B0h	only a smaller UMB is available
 B1h	no UMB's are available
 B2h	UMB segment number is invalid

Format of EMM structure:
Offset	Size	Description	(Table 02776)
 00h	DWORD	number of bytes to move (must be even)
 04h	WORD	source handle
 06h	DWORD	offset into source block
 0Ah	WORD	destination handle
 0Ch	DWORD	offset into destination block
Notes:	if source and destination overlap, only forward moves (source base
	  less than destination base) are guaranteed to work properly
	if either handle is zero, the corresponding offset is interpreted
	  as a real-mode address referring to memory directly addressable
	  by the processor

Format of XMS handle info [array]:
Offset	Size	Description	(Table 02777)
 00h	BYTE	handle
 01h	BYTE	lock count
 02h	DWORD	handle size
 06h	DWORD	handle physical address (only valid if lock count nonzero)
SeeAlso: #02747,#02762

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4310_0" name="2F4310_0"><b>2F4310</b></a> - INT 2F - Cloaking - REAL-MODE API<br />
<pre>
INT 2F - Cloaking - REAL-MODE API
	AX = 4310h
Return: ES:BX -&gt; driver entry point (see #02749,#02778,#02779,#02780,#02781)
SeeAlso: AX=4310h"XMS"

(Table 02778)
Call the Cloaking v1.01 "Client Registration" function with:
	AH = 7Eh
	BX = subfunction
	    0000h get client registration count
	    0001h get client registration structures
		ES:DI -&gt; buffer for registration structures
Return: AX = status
	    0000h failed
	    0001h successful
		---subfunction 00h---
		BX = size of client structure in bytes
		CX = number of clients installed
		---subfunction 01h---
		ES:DI buffer filled
SeeAlso: #02779,#02781,INT 2C/AX=0033h

(Table 02779)
Call the Cloaking v1.01 "Verify Cloaking Host" function with:
	AH = 7Fh
Return: AX = status
	    0000h failed
	    0001h (successful) if installed
		BX = version (0101h for v1.01)
		CX = flags
		    bit 0: host is VCPI-based
		DS:DX -&gt; ASCIZ Cloaking host signature
		    "CLOAKING.EXE"0, followed by a far-call entry point to
		      uninstall host (see #02780) in Helix's CLOAKING.EXE
SeeAlso: #02778,#02781
Index:	installation check;Cloaking host|installation check;CLOAKING.EXE

(Table 02780)
Call the CLOAKING.EXE "Uninstall Host" function with:
Return: AX = 4F4Bh ('OK') if successfully uninstalled protected-mode code

(Table 02781)
Call the Cloaking "Start Protected-Mode Client" function with:
	AH = 82h
	DX = XMS handle of locked block containing protected-mode code
	CL = code size (00h 16-bit, else 32-bit)
	ESI, EDI = parameters to pass to protected-mode code
Return: AX = status
	    nonzero success
	    0000h failed
		BL = error code (A2h,B0h) (see #02775)
Notes:	this function calls a user initialization function at offset 0 in
	  the XMS memory block (see #02782)
	supported by Helix's RM386 v6.00 and Helix's CLOAKING.EXE
SeeAlso: #02778,#02779

(Table 02782)
Values user initialization function is called with:
	EBX = physical address of block's start
	ESI = user data from function 82h call
	EDI = user data from function 82h call
	CS = code selector for XMS block at EBX (16-bit or 32-bit)
	DS = data selector for XMS block, starting at EBX
	ES = selector for V86 memory access to full real-mode 1088K
	GS = selector for full 4G flat address space
	SS:ESP -&gt; stack provided by host
Return: via 32-bit FAR return
Note:	the initialization function may call any protected-mode Cloaking
	  service; it should store the values of DS, ES, and GS for future
	  reference

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4310_1" name="2F4310_1"><b>2F4310</b></a> - INT 2F - Helix Netroom RM386 v6.00 - XMS EXTENSIONS<br />
<pre>
INT 2F - Helix Netroom RM386 v6.00 - XMS EXTENSIONS
	AX = 4310h
Return: ES:BX -&gt; driver entry point (see #02783,#02784,#02785,#02786)
Notes:	HIMEM.SYS v2.77 chains to previous handler if AH is not 00h or 10h
	HIMEM.SYS requires at least 256 bytes free stack space when calling
	  the driver entry point
SeeAlso: AX=4300h,AX=4310h"XMS",AX=4310h"Cloaking"

(Table 02783)
Call the Netroom RM386 v6.00 "Reallocate upper memory block" function with:
	AH = 80h
	DX = segment address of UMB to resize
	BX = new size of block in paragraphs
Return: AX = status
	    0001h success
	    0000h failure
		BL = error code (80h,B0h,B2h) (see #02775)
		DX = maximum available size
Note:	this function is identical to function 12h
SeeAlso: #02768,#02784

(Table 02784)
Call the Netroom RM386 v6.00 "re-enable HMA allocation" function with:
	AH = 81h
Return: AX = 0001h (success)
SeeAlso: #02751,#02783,#02785

(Table 02785)
Call the Netroom RM386 v6.00 "Create new UMB entry" function with:
	AH = 83h
	BX = segment of high-memory block
	DX = first page of start of block
	CX = number of consecutive pages in block
	DI = start of UMB in block
Return: AX = 0001h (success)
	DI = segment of first high-DOS block
Note:	the new UMB is not linked into the high-memory chain
SeeAlso: #02766,#02784,#02786

(Table 02786)
Call the Netroom RM386 v6.00 "Get all XMS handles info" function with:
	AH = 84h
	CX = size of buffer for handle info
	ES:DI -&gt; buffer for handle info (see #02777)
Return: AX = 0001h (success)
	DX = current number of allocated XMS handles
SeeAlso: #02785,#02771

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4310_2" name="2F4310_2"><b>2F4310</b></a> - INT 2F - NEC PC-9800 - XMZ - PRIVATE API<br />
<pre>
INT 2F - NEC PC-9800 - XMZ - PRIVATE API
	AX = 4310h
Return: ES:BX -&gt; driver entry point (see #02787,#02788)
Program: XMZ is an XMS 2.x-compatible driver for the NEC PC-98 series written
	  by ZOBplus Hayami and available at
	  ftp:/ftp.tohoku.ac.jp/pub/msdos/Memory/xmz/
SeeAlso: AX=4300h,AX=4310h"XMS"

(Table 02787)
Call XMZ v1.02 "Get HMA Information" function with:
	AH = FFh  (XMZ only)
	AL = 01h
Return: AX = 1 on success
	DX = minimum HMA allocation size (/HMAMIN=)
	BX = actual size of HMA allocation, if in use (i.e. the value in DX
	      when XMS function 1 was called)
SeeAlso: #02788

(Table 02788)
Call XMZ v1.02 "Get EMB Handle Information" function with:
	AH = FFh  (XMZ only)
	AL = 02h
Return: AX = 1 on success
	DX = number of EMB handles configured (/NUMHANDLES=)
	BX = offset in XMZ's segment of the handle table (use segment of
	      entry point) (see #02789)
SeeAlso: #02787

Format of XMZ v1.02 EMB Handle structure:
Offset	Size	Description	(Table 02789)
 00h	BYTE	flag byte
		04h unused handle slot
		02h in-use handle slot
		01h handle slot that represents a free block
 01h	BYTE	lock count
 02h	WORD	block start address (1K increments)
 04h	WORD	block length (1K increments)
SeeAlso: #02788

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4320" name="2F4320"><b>2F4320</b></a> - INT 2F U - HIMEM.SYS - Mach 20 SUPPORT<br />
<pre>
INT 2F U - HIMEM.SYS - Mach 20 SUPPORT
	AX = 4320h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4330" name="2F4330"><b>2F4330</b></a> - INT 2F CU - HIMEM.SYS v2.77+ - GET EXTERNAL A20 HANDLER ADDRESS<br />
<pre>
INT 2F CU - HIMEM.SYS v2.77+ - GET EXTERNAL A20 HANDLER ADDRESS
	AX = 4330h
Return: AL = 80h if external A20 handler provided
	    ES:BX -&gt; external A20 handler (see #02790)
	    CL = A20 detection support
		00h handler is unable to report A20 state
		01h handler supports function 0002h to report A20 state
Note:	HIMEM.SYS calls this function to allow an external program to provide
	  an A20 handler (i.e. to support a machine not supported by HIMEM
	  itself)
SeeAlso: AX=4308h,AX=4310h

(Table 02790)
Call parameters for external A20 handler are:
	AX = function
	    0000h disable A20
	    0001h enable A20
	    0002h get A20 state
Return: AX = status (functions 0000h and 0001h)
	    0000h failure
	    0001h successful
	AX = A20 state (function 0002h)
	    0000h disabled
	    0001h enabled
Note:	HIMEM.SYS only calls function 0002h if the returned CL indicated that
	  the handler supports the call

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F43D6" name="2F43D6"><b>2F43D6</b></a> - INT 2F - Multiplex - ???<br />
<pre>
INT 2F - Multiplex - ???
	AX = 43D6h
Note:	Central Point's CPBACKUP v9 calls this function with CX=07FFh and
	  DX=80D3h at startup

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F43E0BX0000" name="2F43E0BX0000"><b>2F43E0BX0000</b></a> - INT 2F - DOS Protected Mode Services (DPMS) v1.0 - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS Protected Mode Services (DPMS) v1.0 - INSTALLATION CHECK
	AX = 43E0h
	BX = 0000h
	CX = 4450h ('DP')
	DX = 4D53h ('MS')
Return: AX = 0000h if installed
	    CF clear
	    ES:DI -&gt; server structure (see #02791)
	    ES:BX -&gt; registration structure (pre-NWDOS 7 beta spec) (see #02793)
Note:	the DPMS 1.0 server included with the original release of Novell DOS
	  7.0 supports both the beta and 1.0 specification, setting ES:BX even
	  if CX and DX are not as specified on entry (since the beta
	  specification did not use those registers).  However, the DPMS 1.1
	  server included with the March 1994 update does not support the beta
	  specification
SeeAlso: AX=43E1h,AX=43E2h,AX=43E3h,INT 2F/AX=1687h
Index:	signature strings;DPMS

Format of DPMS 1.0 server structure:
Offset	Size	Description	(Table 02791)
 00h  4 BYTEs	signature string "DPMS"
 04h  2 BYTEs	DPMS version (major,minor)
 06h  8 BYTEs	blank-padded server OEM name
 0Eh  2 BYTEs	OEM server version (major,minor)
 10h	WORD	DPMS flags (see #02792)
 12h	BYTE	CPU type
		(02h = 286, 03h = 386 or higher, higher values allowed)

Bitfields for DPMS flags:
Bit(s)	Description	(Table 02792)
 0	fast processor reset available (286 only)
 1	DPMS server is enabled
 2	memory is remapped
 3-15	reserved (undefined)

Format of beta DPMS registration structure:
Offset	Size	Description	(Table 02793)
 00h	DWORD	real-mode API entry point (see #02795)
 04h	DWORD	16-bit protected-mode API entry point (see #02795)
 08h  8 BYTEs	reserved (0)
 10h  8 BYTEs	blank-padded server OEM name
 18h	WORD	flags
		bit 0: fast processor reset available (286 only)
		bits 1-15 reserved (undefined)
 1Ah  2 BYTEs	DPMS version (major,minor)
 1Ch	BYTE	CPU type (02h = 286, 03h = 386 or higher)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F43E1" name="2F43E1"><b>2F43E1</b></a> - INT 2F - DOS Protected Mode Services (DPMS) v1.0 - REGISTER CLIENT<br />
<pre>
INT 2F - DOS Protected Mode Services (DPMS) v1.0 - REGISTER CLIENT
	AX = 43E1h
	CX = required protected-mode stack size in bytes
	ES:DI -&gt; DPMS client interface structure (see #02794)
Return: AX = 0000h if supported
	   CF clear
	   ES:DI buffer filled with API entry point code from offset 0Ah
Note:	the client is allowed to copy the returned API code to any location in
	  memory, and need not keep the three code fields together
SeeAlso: AX=43E0h,AX=43E2h,AX=43E3h

Format of DPMS client interface structure:
Offset	Size	Description	(Table 02794)
 00h	WORD	0000h (structure version / flags)
 02h  8 BYTEs	blank-padded client name
 0Ah  7 BYTEs	real/virtual-86 mode API code (see #02795)
 11h	BYTE	space for return instruction
		set to C3h for near return, CBh for far return
 12h  7 BYTEs	16-bit protected-mode API code (see #02795)
 19h	BYTE	space for return instruction
		set to C3h for near return, CBh for far return
 1Ah  9 BYTEs	32-bit protected-mode API code (see #02795)
 23h	BYTE	space for return instruction
		set to C3h for near return, CBh for far return
Note:	the DPMS server fills the return opcode bytes with zeros and DPMS
	  requests will thus crash the system unless the application
	  explicitly sets them (some early versions set them to C3h by
	  default, but one should not rely on that)

(Table 02795)
Call DPMS entry point with:
	AX = 0000h unregister client from server
 ---control transfer functions---
	AX = 0100h call protected-mode procedure
		CX = number of words of stack to copy
		ES:(E)DI -&gt; callup/down register structure (see #02797)
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0101h call real-mode procedure (RETF return)
		CX = number of words of stack to copy
		ES:(E)DI -&gt; callup/down register structure (see #02797)
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0102h call real-mode procedure (IRET return)
		CX = number of words of stack to copy
		ES:(E)DI -&gt; callup/down register structure (see #02797)
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0103h call real-mode interrupt handler
		BL = interrupt number
		CX = number of words of stack to copy
		ES:(E)DI -&gt; callup/down register structure (see #02797)
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0104h register default protected mode procedure
		ES:(E)DI -&gt; default register structure (see #02798)
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0105h register default real-mode procedure (RETF return)
		ES:(E)DI -&gt; default register structure (see #02798)
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
		Note:	the procedure will be called from 16-bit prot. mode
	AX = 0106h register default real-mode procedure (IRET return)
		ES:(E)DI -&gt; default register structure (see #02798)
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
		Note:	the procedure will be called from 16-bit prot. mode
	AX = 0107h register default real-mode interrupt handler
		BL = interrupt number
		ES:(E)DI -&gt; default register structure (see #02798)
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
		Note:	the handler will be called from 16-bit protected mode
	AX = 0108h register default real-mode procedure (RETF return)
		ES:(E)DI -&gt; default register structure (see #02798)
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
		Note:	the procedure will be called from 32-bit prot. mode
	AX = 0109h register default real-mode procedure (IRET return)
		ES:(E)DI -&gt; default register structure (see #02798)
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
		Note:	the procedure will be called from 32-bit prot. mode
	AX = 010Ah register default real-mode interrupt handler
		BL = interrupt number
		ES:(E)DI -&gt; default register structure (see #02798)
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
		Note:	the handler will be called from 32-bit protected mode
 ---descriptor management---
	AX = 0200h allocate descriptors
		CX = number of descriptors to allocate
		Return: CF clear if successful
			    AX = selector for first descriptor allocated
			CF set on error
			    AX = error code (see #02796)
	AX = 0201h free a descriptor
		BX = selector for descriptor
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0202h create alias descriptor
		BX = selector for descriptor to be aliased
		Return: CF clear if successful
			    AX = alias descriptor
			CF set on error
			    AX = error code (see #02796)
	AX = 0203h build alias to real-mode segment
		BX = descriptor
		CX = real-mode segment
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0204h set descriptor base
		BX = descriptor
		CX:DX = base address
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0205h set descriptor limit
		BX = descriptor
		CX = limit
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0206h set descriptor type/attribute
		BX = descriptor
		CL = type
		CH = attribute
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0207h get descriptor base
		BX = descriptor
		Return: CF clear if successful
			    CX:DX = base address
			CF set on error
			    AX = error code (see #02796)
 ---linear memory functions---
	AX = 0300h get size of largest free block of memory
		Return: CF clear if successful
			    BX:CX = size
			CF set on error
			    AX = error code (see #02796)
	AX = 0301h allocate block of extended memory
		BX:CX = required size
		Return: CF clear if successful
			    BX:CX = base address
			    SI:DI = handle
			CF set on error
			    AX = error code (see #02796)
	AX = 0302h free block of extended memory
		SI:DI = handle
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0303h map linear memory
		ES:(E)DI -&gt; DDS (see #02799)
		Return: CF clear if successful
			    BX:CX = base address
			    SI:DI = handle
			CF set on error
			    AX = error code (see #02796)
	AX = 0304h unmap linear memory
		SI:DI = handle
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0305h get page table entries
		ESI = linear address
		(E)CX = count
		ES:(E)DI -&gt; buffer for page table entries
		Return: CF clear if successful
			    ES:(E)DI buffer filled
			CF set on error
			    AX = error code (see #02796)
	AX = 0306h set page table entries
		EBX = linear memory handle
		ESI = linear address
		(E)CX = count
		ES:(E)DI -&gt; buffer containing page table entries
		Return: CF clear if successful
			CF set on error
			    AX = error code (see #02796)
	AX = 0307h get largest mappable block size
		Return: CF clear if successful
			    BX:CX = size
			CF set on error
			    AX = error code (see #02796)
 ---miscellaneous---
	AX = 0400h relocate segment to extended memory
		ES:SI = base address
		CX = limit
		BL = type
		BH = attribute
		DX = selector or 0000h
		Return: CF clear if successful
			    AX = selector
			    BX:CX = new base address
			    SI:DI = handle
			CF set on error
			    AX = error code (see #02796)
Note:	the beta DPMS specification, which is still supported by the Novell
	  DOS 7.0 DPMS host, only supported functions 0100h-0103h, 0200h-0207h,
	  0300h-0304h, and 0400h

(Table 02796)
Values for DPMS error code:
 8000h	general error
 8001h	unsupported function
 8002h	unable to switch to protected mode
 8004h	no default stack defined
 8005h	unknown client
 8010h	resource unavailable
 8011h	descriptor unavailable
 8012h	linear memory unavailable
 8013h	physical memory unavailable
 8021h	invalid value
 8022h	invalid selector
 8023h	invalid handle
 8025h	invalid linear address

Format of DPMS callup/down register structure:
Offset	Size	Description	(Table 02797)
 00h	DWORD	EDI
 04h	DWORD	ESI
 08h	DWORD	EBP
 0Ch  4 BYTEs	reserved (0) (ESP, may be used by DPMS server)
 10h	DWORD	EBX
 14h	DWORD	EDX
 18h	DWORD	ECX
 20h	DWORD	EAX
 24h	DWORD	EIP
 28h	WORD	CS
 2Ah  2 BYTEs	reserved (0)
 2Ch	DWORD	EFLAGS
 30h	DWORD	ESP
 34h	WORD	SS
 36h  2 BYTEs	reserved (0)
 38h	WORD	ES
 3Ah  2 BYTEs	reserved (0)
 3Ch	WORD	DS
 3Eh  2 BYTEs	reserved (0)
 40h	WORD	FS
 42h  2 BYTEs	reserved (0)
 44h	WORD	GS
 46h  2 BYTEs	reserved (0)

Format of DPMS default register structure:
Offset	Size	Description	(Table 02798)
 00h	DWORD	EIP
 04h	WORD	CS
 06h  2 BYTEs	reserved (0)
 08h	WORD	number of words to copy from stack to stack
 0Ah	BYTE	(call) 00h
		(ret) nonzero if call could not be made
 0Bh	BYTE	reserved (may be used by some servers)
 0Ch	DWORD	ESP
 10h	WORD	SS
 12h  2 BYTEs	reserved (0)
 14h	WORD	ES
 16h  2 BYTEs	reserved (0)
 18h	WORD	DS
 1Ah  2 BYTEs	reserved (0)
 1Ch	WORD	FS
 1Eh  2 BYTEs	reserved (0)
 20h	WORD	GS
 22h  2 BYTEs	reserved (0)
 24h  9 BYTEs	API entry code (filled in by server)

Format of DPMS lock DDS:
Offset	Size	Description	(Table 02799)
 00h	DWORD	total size in bytes
 04h	DWORD	offset
 08h	WORD	segment or selector
 0Ah	WORD	reserved
 0Ch	WORD	maximum number of physical blocks structure has space for
 0Eh	WORD	number of physical blocks listed
 10h	DWORD	physical address of first block
 14h	DWORD	size in bytes of first block
	...

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F43E2" name="2F43E2"><b>2F43E2</b></a> - INT 2F - DOS Protected Mode Services (DPMS) v1.0 - ENABLE/DISABLE DPMS<br />
<pre>
INT 2F - DOS Protected Mode Services (DPMS) v1.0 - ENABLE/DISABLE DPMS
	AX = 43E2h
	BX = new state (0000h disable, 0001h enable)
Return: AX = 0000h if supported
Note:	this function should normally be called only by system software
SeeAlso: AX=43E0h,AX=43E1h,AX=43E3h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F43E3BX0000" name="2F43E3BX0000"><b>2F43E3BX0000</b></a> - INT 2F C - DOS Protected Mode Services (DPMS) v1.0 - DPMS STARTUP BROADCAST<br />
<pre>
INT 2F C - DOS Protected Mode Services (DPMS) v1.0 - DPMS STARTUP BROADCAST
	AX = 43E3h
	BX = 0000h
	CX = 4450h ('DP')
	DX = 4D53h ('MS')
	ES:DI -&gt; DPMS server structure (see #02791)
Return: BX = status
	    bit 0 set if server is not allowed to load (e.g. some resident
		  program is incompatible)
Note:	this callout is made while the potential server is running as a normal
	  real-mode DOS program, so there are no BIOS/DOS re-entrancy issues
SeeAlso: AX=43E0h,AX=43E4h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F43E4BX0000" name="2F43E4BX0000"><b>2F43E4BX0000</b></a> - INT 2F C - DOS Protected Mode Services (DPMS) v1.0 - DPMS EXIT BROADCAST<br />
<pre>
INT 2F C - DOS Protected Mode Services (DPMS) v1.0 - DPMS EXIT BROADCAST
	AX = 43E4h
	BX = 0000h
	CX = 4450h ('DP')
	DX = 4D53h ('MS')
Return: BX = status
	    bit 0 set if server is not allowed to unload
Note:	servers never unload until all clients unregister
SeeAlso: AX=43E0h,AX=43E3h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F44" name="2F44"><b>2F44</b></a> - INT 2F U - DOS Extender support???<br />
<pre>
INT 2F U - DOS Extender support???
	AH = 44h
	AL = function (at least 0Bh, 15h, 17h)
	???
Return: ???
Note:	called by Codeview for Windows
SeeAlso: AH=86h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4500" name="2F4500"><b>2F4500</b></a> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - INSTALLATION CHECK<br />
<pre>
INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - INSTALLATION CHECK
	AX = 4500h
Return: AL = installation status
	    01h if PROF.COM installed
	    02h if VPROD.386 installed
SeeAlso: AX=4501h,AX=4502h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4501" name="2F4501"><b>2F4501</b></a> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - SETUP PROFILER<br />
<pre>
INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - SETUP PROFILER
	AX = 4501h
	BX = CSIPS buffer size in KB (first parameter for ProfSetup)
	CX = output limit in KB (second parameter for ProfSetup)
Note:	this call is not supported by PROF.COM
SeeAlso: AX=4502h,AX=4503h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4502" name="2F4502"><b>2F4502</b></a> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - SET SAMPLING RATE<br />
<pre>
INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - SET SAMPLING RATE
	AX = 4502h
	BL = sampling rate for PROF.COM (0 &lt; BL &lt;= 13)
	    (01h = 8192/s, 04h = 1024/s, 08h = 32/s, 0Dh = 1/s)
	CX = sampling rate for VPROD.386
Note:	for PROF.COM, this programs the CMOS clock by setting BL+2 as the
	  low four bits of CMOS register 0Ah.  The interruption rate is
	  1 SHL (15 - BL) per second.
SeeAlso: AX=4501h,AX=4503h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4503" name="2F4503"><b>2F4503</b></a> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - START PROFILING<br />
<pre>
INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - START PROFILING
	AX = 4503h
Notes:	Profiling is also turned on by the key combinations
	  LeftShift + RightShift + Alt and LeftShift + RightShift + Ctrl
	for PROF.COM, this call programs the CMOS clock by reading register
	  0Ch, and setting bit 6 of register 0Bh.  It then makes sure that IRQ8
	  is unmasked
SeeAlso: AX=4504h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4504" name="2F4504"><b>2F4504</b></a> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - STOP PROFILING<br />
<pre>
INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - STOP PROFILING
	AX = 4504h
Notes:	profiling is also turned off by the key combination
	  LeftShift + RightShift
	for PROF.COM, this programs the CMOS clock by reading register 0Ch
	  and clearing bit 6 of register 0Bh.  It then masks IRQ8.
SeeAlso: AX=4503h,AX=4505h,AX=4506h,AX=4507h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4505" name="2F4505"><b>2F4505</b></a> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - CLEAR PROFILING DATA<br />
<pre>
INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - CLEAR PROFILING DATA
	AX = 4505h
SeeAlso: AX=4503h,AX=4504h,AX=4506h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4506" name="2F4506"><b>2F4506</b></a> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - "ProfFlush"<br />
<pre>
INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - "ProfFlush"
	AX = 4506h
SeeAlso: AX=4505h,AX=4507h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4507" name="2F4507"><b>2F4507</b></a> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - "ProfFinish"<br />
<pre>
INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - "ProfFinish"
	AX = 4507h
Note:	this call is essentially a "ProfStop" (AX=4504h) followed by
	  "ProfFlush" (AX=4506h)
SeeAlso: AX=4504h,AX=4505h,AX=4506h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4508" name="2F4508"><b>2F4508</b></a> - INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - ALTERNATE SEGDEBUG IFACE<br />
<pre>
INT 2F U - Microsoft Profiler (PROF.COM/VPROD.386) - ALTERNATE SEGDEBUG IFACE
	AX = 4508h
	BX = ordinal (or 0000h)
	CX = segment
	DX = instance (or 0000h)
	SI = type (or 0000h)
	ES:DI -&gt; ASCIZ module name
Notes:	this call is an alternate entry to the profiler's SEGDEBUG
	  interface, but only to function 0, for notifying the profiler of
	  each new segment loaded.  The SHOWHITS utility then examines the
	  profiler's output files (CSIPS.DAT and SEGENTRY.DAT) in conjunction
	  with symbol files to provide information in a useful form.
	this call does not have a corresponding Windows function
SeeAlso: AX=4500h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4601" name="2F4601"><b>2F4601</b></a> - INT 2F CU - MS Windows WINOLDAP - SWITCHING ???<br />
<pre>
INT 2F CU - MS Windows WINOLDAP - SWITCHING ???
	AX = 4601h
Return: ???
Note:	the DOS 5+ kernel intercepts this function and copies the MCB
	   following the caller's PSP memory block into the DOS data segment;
	   in conjunction with AX=4602h, this intercept is used by DOS to
	   avoid corruption of the Windows real-mode heap's end sentinel
SeeAlso: AX=1700h,AX=4602h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4602" name="2F4602"><b>2F4602</b></a> - INT 2F CU - MS Windows WINOLDAP - SWITCHING ???<br />
<pre>
INT 2F CU - MS Windows WINOLDAP - SWITCHING ???
	AX = 4602h
Return: ???
Note:	the DOS 5+ kernel intercepts this function and copies the
	  previously-saved MCB from the DOS data segment into the MCB following
	  the caller's PSP memory block; in conjunction with AX=4601h, this
	  intercept is used by DOS to avoid corruption of the Windows real-mode
	  heap's end sentinel
SeeAlso: AX=1700h,AX=4601h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F46" name="2F46"><b>2F46</b></a> - INT 2F U - Windows/286 DOS Extender<br />
<pre>
INT 2F U - Windows/286 DOS Extender
	AH = 46h
	AL = subfunction (03h,04h)
Return: ???
Note:	these two subfunctions are called by MS Windows 3.0

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4653CX0002" name="2F4653CX0002"><b>2F4653CX0002</b></a> - INT 2F - F-PROT v1.x only - F-LOCK.EXE - API<br />
<pre>
INT 2F - F-PROT v1.x only - F-LOCK.EXE - API
	AX = 4653h ('FS')
	CX = 0002h
	BX = subfunction
	    0000h  installation check
		Return: AX = FFFFh
	    0001h  uninstall
		Return: AX,BX,ES destroyed
	    0002h  disable (v1.08 and below only)
	    0003h  enable (v1.08 and below only)
Program: F-LOCK is part of the shareware F-PROT virus/trojan protection
	  package by Fridrik Skulason
SeeAlso: AX=4653h/CX=0003h,AX=CA00h,INT 21/AX=4BEEh
Index:	installation check;F-LOCK|uninstall;F-LOCK

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4653CX0003" name="2F4653CX0003"><b>2F4653CX0003</b></a> - INT 2F - F-PROT v1.x only - F-XCHK.EXE - API<br />
<pre>
INT 2F - F-PROT v1.x only - F-XCHK.EXE - API
	AX = 4653h ('FS')
	CX = 0003h
	BX = subfunction
	    0000h  installation check
		Return: AX = FFFFh
	    0001h  uninstall
		Return: AX,BX,ES destroyed
Program: F-XCHK is part of the shareware F-PROT virus/trojan protection
	  package by Fridrik Skulason
SeeAlso: AX=4653h/CX=0002h,AX=4653h/CX=0004h,AX=CA00h
Index:	installation check;F-XCHK|uninstall;F-XCHK

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4653CX0004" name="2F4653CX0004"><b>2F4653CX0004</b></a> - INT 2F - F-PROT v1.x only - F-POPUP.EXE - API<br />
<pre>
INT 2F - F-PROT v1.x only - F-POPUP.EXE - API
	AX = 4653h ('FS')
	CX = 0004h
	BX = subfunction
	    0000h  installation check
		Return: AX = FFFFh
	    0001h  uninstall
		Return: AX,BX,ES destroyed
	    0002h  disable (v1.08 and below only)
		   display message (v1.14+)
			other registers: ???
	    0003h  enable (v1.08 and below only)
		   display message (v1.14+)
			other registers: ???
			Return: AX = key pressed by user
Program: F-POPUP is part of the shareware F-PROT virus/trojan protection
	  package by Fridrik Skulason
SeeAlso: AX=4653h/CX=0003h,AX=4653h/CX=0005h,AX=CA00h
Index:	installation check;F-POPUP|uninstall;F-POPUP

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4653CX0005" name="2F4653CX0005"><b>2F4653CX0005</b></a> - INT 2F - F-PROT v1.x only - F-DLOCK.EXE - API<br />
<pre>
INT 2F - F-PROT v1.x only - F-DLOCK.EXE - API
	AX = 4653h ('FS')
	CX = 0005h
	BX = subfunction
	    0000h installation check
		Return: AX = FFFFh
	    0001h uninstall
		Return: AX,BX,ES destroyed
Program: F-DLOCK is part of the shareware F-PROT virus/trojan protection
	  package by Fridrik Skulason
SeeAlso: AX=4653h/CX=0004h,AX=CA00h
Index:	installation check;F-DLOCK|uninstall;F-DLOCK

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4653CX0007" name="2F4653CX0007"><b>2F4653CX0007</b></a> - INT 2F - F-PROT v2.x - VIRSTOP - ENABLE/DISABLE BOOTSECTOR READ CHECKING<br />
<pre>
INT 2F - F-PROT v2.x - VIRSTOP - ENABLE/DISABLE BOOTSECTOR READ CHECKING
	AX = 4653h ('FS')
	CX = 0007h
	BL = new state of bootsector checking (01h = disabled)
Program: VIRSTOP is the resident virus-checker from Fridrik Skulason's F-PROT
	  virus/trojan protection package

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4653CX0008" name="2F4653CX0008"><b>2F4653CX0008</b></a> - INT 2F - F-PROT v2.x - ???<br />
<pre>
INT 2F - F-PROT v2.x - ???
	AX = 4653h ('FS')
	CX = 0008h
	???
Return: ???
Note:	called by F-PROT v2.x VIRSTOP

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4653CX0008_0" name="2F4653CX0008_0"><b>2F4653CX0008</b></a> - INT 2F - F-PROT v2.x - VIRSTOP - INSTALLATION CHECK<br />
<pre>
INT 2F - F-PROT v2.x - VIRSTOP - INSTALLATION CHECK
	AX = 4653h ('FS')
	CX = 0008h
Return: AX = 5346h if installed
	    BX = version???
	    DS:SI -&gt; ASCIZ name of file containing virus signatures
	    DS:DI -&gt; 80-byte buffer for ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4680" name="2F4680"><b>2F4680</b></a> - INT 2F U - MS Windows v3.0 - INSTALLATION CHECK<br />
<pre>
INT 2F U - MS Windows v3.0 - INSTALLATION CHECK
	AX = 4680h
Return: AX = result
	    0000h MS Windows 3.0 running in real (/R) or standard (/S) mode,
		  or DOS 5 DOSSHELL active
	    nonzero  no Windows, Windows prior to 3.0, or Windows3 in enhanced
		  mode
Note:	Windows 3.1 finally provides an installation check which works in all
	  modes (see AX=160Ah)
SeeAlso: AX=1600h,AX=160Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F47" name="2F47"><b>2F47</b></a> - INT 2F U - ???<br />
<pre>
INT 2F U - ???
	AH = 47h
	???
Return: ???
Note:	reportedly called by Microsoft BASIC Compiler v7.0

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4800" name="2F4800"><b>2F4800</b></a> - INT 2F - DOS 5+ DOSKEY - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS 5+ DOSKEY - INSTALLATION CHECK
	AX = 4800h
Return: AL = nonzero if installed
	    (DOS 5.0 and 6.0 return AX=AA02h, Novell DOS 7 returns AX=EDFFh)
	    ES = segment of DOSKEY resident portion
	    DX = ??? (Novell DOS only; 02E6h for shipped v0.01)
Notes:	DOSKEY chains if AL is not 00h or 10h on entry
	this function is supported by Novell DOS 7 DOSKEY
SeeAlso: AX=4800h"PCED",AX=4810h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4800_0" name="2F4800_0"><b>2F4800</b></a> - INT 2F - PCED v2.1 - INSTALLATION CHECK<br />
<pre>
INT 2F - PCED v2.1 - INSTALLATION CHECK
	AX = 4800h
Return: AX = AACDh if installed
	    ES = segment of PCED kernel (PCED has multiple code segments)
Program: PCED v2.1 is a command line editor/history/macro facility by
	  Cove Software.  It is the commercial version of the freeware CED.
Notes:	DOSKEY also responds to this call if installed, returning AX=AA02h.
	unlike DOSKEY, PCED does *not* chain if AL contains an
	  unsupported function code.  It IRETs with all registers intact.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4810" name="2F4810"><b>2F4810</b></a> - INT 2F - DOS 5+ DOSKEY, PCED v2.1 - READ INPUT LINE FROM CONSOLE<br />
<pre>
INT 2F - DOS 5+ DOSKEY, PCED v2.1 - READ INPUT LINE FROM CONSOLE
	AX = 4810h
	DS:DX -&gt; line buffer (see #01344 at INT 21/AH=0Ah)
Return: AX = 0000h if successful
Notes:	the first byte (length) of the buffer MUST be 80h, or MS-DOS's DOSKEY
	  chains to the previous handler; PCED and Novell DOS allow sizes
	  other than 80h
	if the user's input is a macro name, no text is placed in the buffer
	  even though AX=0000h on return; the program must immediately issue
	  this call again to retrieve the expansion of the macro.  Similarly,
	  if the user enters a special parameter such as $*, this call must
	  be repeated to retrieve the expansion; on the second call, DOSKEY
	  overwrites the macro name on the screen with its expansion.
	unlike DOSKEY, PCED expands all macros on the first call, so it is
	  not necessary to make two calls; since the buffer is not empty on
	  return, DOSKEY-aware programs will not make the second call
	DOSKEY chains if AL is not 00h or 10h on entry
	this function is supported by Novell DOS 7 DOSKEY
SeeAlso: AX=4800h,INT 21/AH=0Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F48C0" name="2F48C0"><b>2F48C0</b></a> - INT 2F - PCED v2.1 - PCED API<br />
<pre>
INT 2F - PCED v2.1 - PCED API
	AX = 48C0h
	DX = API function code
	other registers as required by the specified function
Return: CF clear if successful
	CF set on error
	    AX = PCED error code
	other registers as appropriate for API function
Program: PCED v2.1 is a command line editor/history/macro facility by
	  Cove Software.  It is the commercial version of the freeware CED.
Note:	the full API information is available from Cove Software
SeeAlso: AX=4800h"PCED",AX=48C1h,AX=48C2h,AX=48C3h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F48C1BL00" name="2F48C1BL00"><b>2F48C1BL00</b></a> - INT 2F - PCED/VSTACK - INSTALLATION CHECK<br />
<pre>
INT 2F - PCED/VSTACK - INSTALLATION CHECK
	AX = 48C1h
	BL = 00h
Return: AX = 0000h if installed
	    BX = VSTACK resident segment
Program: VSTACK is a resident backscroll utility included as part of the PCED
	  package by Cove Software
Note:	chains if BL &lt;&gt; 00h on entry
SeeAlso: AX=48C0h,AX=48C2h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F48C2BL00" name="2F48C2BL00"><b>2F48C2BL00</b></a> - INT 2F - PCED/ATTRIB - INSTALLATION CHECK<br />
<pre>
INT 2F - PCED/ATTRIB - INSTALLATION CHECK
	AX = 48C2h
	BL = 00h
Return: AX = 0000h if installed
	    BX = ATTRIB resident segment
Program: ATTRIB is a resident file attribute changer included as part of the
	  PCED package by Cove Software
Note:	chains if BL &lt;&gt; 00h on entry
SeeAlso: AX=48C0h,AX=48C1h,AX=48C3h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F48C3BL00" name="2F48C3BL00"><b>2F48C3BL00</b></a> - INT 2F - PCED/KEYDEF - INSTALLATION CHECK<br />
<pre>
INT 2F - PCED/KEYDEF - INSTALLATION CHECK
	AX = 48C3h
	BL = 00h
Return: AX = 0000h if installed
	    BX = KEYDEF resident segment
Program: KEYDEF is a resident keyboard redefinition utility included as part
	  of the PCED package by Cove Software
Note:	chains if BL &lt;&gt; 00h on entry
SeeAlso: AX=48C0h,AX=48C2h,AX=48C4h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F48C4BL00" name="2F48C4BL00"><b>2F48C4BL00</b></a> - INT 2F - PCED/FLIST - INSTALLATION CHECK<br />
<pre>
INT 2F - PCED/FLIST - INSTALLATION CHECK
	AX = 48C4h
	BL = 00h
Return: AX = 0000h if installed
	    BX = FLIST resident segment
Program: FLIST is a resident filelist processor included as part of the PCED
	  package by Cove Software
Note:	chains if BL &lt;&gt; 00h on entry
SeeAlso: AX=48C0h,AX=48C3h,AX=48C5h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F48C5BL00" name="2F48C5BL00"><b>2F48C5BL00</b></a> - INT 2F - PCED/ASSOC - INSTALLATION CHECK<br />
<pre>
INT 2F - PCED/ASSOC - INSTALLATION CHECK
	AX = 48C5h
	BL = 00h
Return: AX = 0000h if installed
	    BX = ASSOC resident segment
Program: ASSOC is a resident utility included as part of the PCED package which
	  associates files with executable programs based on their extensions
Note:	chains if BL &gt; 02h on entry
SeeAlso: AX=48C0h,AX=48C4h,AX=48C5h/BL=01h,AX=48C5h/BL=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F48C5BL01" name="2F48C5BL01"><b>2F48C5BL01</b></a> - INT 2F - PCED/ASSOC - GET VERSION<br />
<pre>
INT 2F - PCED/ASSOC - GET VERSION
	AX = 48C5h
	BL = 01h
Return: AX = 0000h if installed
	    BX = binary ASSOC version (BL = major, BH = minor)
Note:	chains if BL &gt; 02h on entry
SeeAlso: AX=48C0h,AX=48C5h/BL=00h,AX=48C5h/BL=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F48C5BL02" name="2F48C5BL02"><b>2F48C5BL02</b></a> - INT 2F - PCED/ASSOC - ASSOCIATION TEST<br />
<pre>
INT 2F - PCED/ASSOC - ASSOCIATION TEST
	AX = 48C5h
	BL = 02h
	DS:SI -&gt; ASCIZ filename
Return: AX = status
	    0000h if filename is unknown
	    0001h if there is an association defined for the file
	BX destroyed
Program: ASSOC is a resident utility included as part of the PCED package which
	  associates files with executable programs based on their extensions
Note:	chains if BL &gt; 02h on entry
SeeAlso: AX=48C0h,AX=48C5h/BL=00h,AX=48C5h/BL=01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F49" name="2F49"><b>2F49</b></a> - INT 2F U - DOS 5.0+ SETUP<br />
<pre>
INT 2F U - DOS 5.0+ SETUP
	AH = 49h
	AL = function
	    00h update format completion gauge
		BX = percentage complete, 0000h when done, FFFFh if aborted
		Return: AX = status
			    0000h continue formatting
			    else  installation program wants FORMAT to abort
	    10h get pointer to resident data
		AX = FFFFh if supported
		    ES:BX -&gt; internal structure
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A00CX0000" name="2F4A00CX0000"><b>2F4A00CX0000</b></a> - INT 2F CU - DOS 5+ - FLOPPY-DISK LOGICAL DRIVE CHANGE NOTIFICATION<br />
<pre>
INT 2F CU - DOS 5+ - FLOPPY-DISK LOGICAL DRIVE CHANGE NOTIFICATION
	AX = 4A00h
	CX = 0000h
	DH = new drive number
	DL = current drive number
Return: CX = FFFFh to skip "Insert diskette for drive X:" message
Note:	called by MS-DOS 5.0+ IO.SYS just before displaying the message
	  "Insert diskette for drive X:" on single-floppy systems

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A01" name="2F4A01"><b>2F4A01</b></a> - INT 2F - DOS 5+ - QUERY FREE HMA SPACE<br />
<pre>
INT 2F - DOS 5+ - QUERY FREE HMA SPACE
	AX = 4A01h
Return: BX = number of bytes available in HMA (0000h if DOS not using HMA)
	ES:DI -&gt; start of available HMA area (FFFFh:FFFFh if not using HMA)
Notes:	called by Windows 3.1 DOSX.EXE
	supported by Novell DOS 7
SeeAlso: AX=4310h,AX=4A02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A02" name="2F4A02"><b>2F4A02</b></a> - INT 2F - DOS 5+ - ALLOCATE HMA SPACE<br />
<pre>
INT 2F - DOS 5+ - ALLOCATE HMA SPACE
	AX = 4A02h
	BX = number of bytes
Return: ES:DI -&gt; start of allocated HMA block or FFFFh:FFFFh
	BX = number of bytes actually allocated (rounded up to next paragraph
	      for DOS 5.0 and 6.0)
Notes:	this call is not valid unless DOS is loaded in the HMA (DOS=HIGH)
	called by Windows 3.1 DOSX.EXE
	supported by Novell DOS 7
SeeAlso: AX=4A01h,AX=4A03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A03" name="2F4A03"><b>2F4A03</b></a> - INT 2F U - Windows95 - DOS KERNEL - (DE)ALLOCATE HMA MEMORY BLOCK<br />
<pre>
INT 2F U - Windows95 - DOS KERNEL - (DE)ALLOCATE HMA MEMORY BLOCK
	AX = 4A03h
	CX = segment of block's owner???
	DL = subfunction
	    00h allocate block
		BX = number of bytes
		Return: DI=FFFFh if unable to allocate
			ES:DI -&gt; allocated block
	    01h resize block
		ES:DI -&gt; previously-allocated block
		BX = new size in bytes (must be less than original size???)
		Return: DI=FFFFh if unable to allocate
			ES:DI -&gt; reallocated block
		Note:	the contents of the original block are NOT copied
	    02h free block???
		ES:DI -&gt; block to be freed
Note:	in MS-DOS 7.x, function 4A02h is implemented by calling this function
	  with DL=00h
SeeAlso: AX=4A02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A04" name="2F4A04"><b>2F4A04</b></a> - INT 2F U - Windows95 - DOS KERNEL - GET START OF HMA MEMORY CHAIN<br />
<pre>
INT 2F U - Windows95 - DOS KERNEL - GET START OF HMA MEMORY CHAIN
	AX = 4A04h
Return: AX = 0000h if function supported
	    ES:DI -&gt; first HMA memory control block (see #02800)

Format of Windows95 HMA memory control block:
Offset	Size	Description	(Table 02800)
 00h  2 BYTEs	signature "MS" (4Dh 53h)
 02h	WORD	segment of owner (or segment at which to address block???)
		0000h = free
		0001h = DOS???
		FF33h = IO.SYS
		FFFFh = MSDOS.SYS
 04h	WORD	size of memory block (not including this header)
 06h	WORD	offset of next memory block in segment FFFFh, or 0000h if last
 08h  8 BYTEs	unused (explicitly set to 0 for MS-DOS 7.10)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A05" name="2F4A05"><b>2F4A05</b></a> - INT 2F U - DOS 5+ DOSSHELL - TASK SWITCHING API???<br />
<pre>
INT 2F U - DOS 5+ DOSSHELL - TASK SWITCHING API???
	AX = 4A05h
	SI = function
	    0000h reset???
	    0001h ???
		ES:BP -&gt; 80-byte buffer containing ???
	    0002h ???
	    0003h ???
	    0004h ???
		BL = ???
	    0005h ???
	    0006h get ???
		Return: ES:SI -&gt; ???
	    0007h get ???
		Return: AX = ???
	    0008h get ???
		Return: DX:AX -&gt; ??? (internal control data of some kind)
	    0009h get ???
		Return: ES:SI -&gt; ??? (apparently identical to function 0006h)
	    000Ah ???
		BL = length of buffer
		ES:BP -&gt; buffer containing ???
	    000Bh get ???
		Return: AX = ???
	    000Ch ???
		BL = ???
		Return: if BL nonzero on entry
			    DX:AX -&gt; ???
			if BL = 00h on entry
			    ES:SI -&gt; ???
Notes:	DOSSHELL chains to the previous handler if SI is not one of the values
	  listed above
	the DOSSWAP.EXE module calls functions 03h,04h,05h,07h,08h,09h,0Ch
	the Windows 3.1 DSWAP.EXE and WSWAP.EXE task switchers use these calls
SeeAlso: AX=4B01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A06" name="2F4A06"><b>2F4A06</b></a> - INT 2F CU - DOS 5+ - DOS SUPERVISOR "REBOOT PANEL" - ADJUST MEMORY SIZE<br />
<pre>
INT 2F CU - DOS 5+ - DOS SUPERVISOR "REBOOT PANEL" - ADJUST MEMORY SIZE
	AX = 4A06h
	DX = segment following last byte of conventional memory
Return: DX = segment following last byte of memory available for use by DOS
Desc:	used to override the default memory size when booting diskless
	  workstations
Notes:	called by MS-DOS 5+ IO.SYS and DR DOS 6.0+ IBMBIO.OCM startup code if
	  the signature "RPL" is present three bytes beyond the INT 2F handler;
	  this call overrides the value returned by INT 12
	hooked by RPL code at the top of memory to protect itself from being
	  overwritten; DOS builds a memory block with owner = 0008h and name
	  "RPL" which must be freed by the RPL code when it is done.
	  Under DR DOS, it is sufficient to set the owner field of the MCB to
	  0000h.
	In addition to the test for "RPL", DR PalmDOS (since 1992/08/25),
	  DR DOS 6.0 "Business update March 1993", DR DOS "Panther" and
	  "StarTrek", and Novell DOS 7+ also check for a "RPLOADER" signature.
	  If this 2nd signature is found, IBMBIO.COM will store the INT 2Fh
	  vector for later use after the BIOS init, when at several points it
	  directly calls the RPLOADER via an emulated INT 2Fh with
	  AX=12FFh/BX=5/CX=0/DX=1 and a phase code 1, 2 or 3 on the stack.
	  This permits the RPLOADER to keep track of the initialization
	  process and clean or fix up anything it wishes.  The "phase 1"
	  broadcast is issued after the BIOS init code and data have been
	  relocated (e.g. into the HMA), "phase 2" gets issued immediately
	  before the CONFIG.SYS processing begins and the DOS code and data
	  are relocated, and the closing "phase 3" happens to permit any
	  final tidy ups before the memory manager gets acknowledgement of
	  completion.
SeeAlso: INT 12"BIOS",INT 18"BOOT HOOK",AX=4A07h,INT 2F/AX=12FFh/BX=0005h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A07" name="2F4A07"><b>2F4A07</b></a> - INT 2F U - RESERVED FOR PROTMAN SUPPORT<br />
<pre>
INT 2F U - RESERVED FOR PROTMAN SUPPORT
	AX = 4A07h
	???
Return: ???
SeeAlso: AX=4A06h,INT 18"BOOT HOOK"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX0000" name="2F4A10BX0000"><b>2F4A10BX0000</b></a> - INT 2F - SMARTDRV v4.00+ - INSTALLATION CHECK AND HIT RATIOS<br />
<pre>
INT 2F - SMARTDRV v4.00+ - INSTALLATION CHECK AND HIT RATIOS
	AX = 4A10h
	BX = 0000h
	CX = EBABh (v4.1+; see Note), and CX &lt;&gt; 0EDCh
Return: AX = BABEh if installed
	    DX:BX = cache hits
	    DI:SI = cache misses
	    CX = number of dirty cache elements
	    BP = version in BCD (4.10 = 0410h)
		4.0  = 0400h (Windows 3.1)
		4.01 = 0401h (MS-DOS 6.0, 1992/07/30)
		4.10 = 0410h (1992/11/11)
		4.20 = 0420h
		5.0  = 0500h (MS-DOS 6.2)
Notes:	most of the SMARTDRV API, including this call, is supported by
	  PC-Cache v8.0 and recent versions of the Norton Caches
	the internal name for SMARTDRV is "BAMBI", hence the magic "BABE".
	if DBLSPACE.BIN is installed but SMARTDRV has not yet been installed,
	  then calls of this function with CX&lt;&gt;EBABh on entry cause
	  DBLSPACE.BIN to display the error message
	  "Cannot run SMARTDrive 4.0 with DoubleSpace" and abort the caller
	  with INT 21/AX=4C00h
	Since the Novell DOS 7 - DR-DOS 7.03 NWCACHE supports a similar 
	  install check at this function, but the returned registers
	  contain different data, the caller must take the returned AX value
	  into account to ensure proper interpretation of the returned info.
	  The caller should ensure CX &lt;&gt; 0EDCh to avoid any interaction
	  with the NWCACHE and COMMAND.COM special case of CX=0EDCh.
	  Although this is an install check, NWCACHE always flushes delayed
	  writes to disk, when calling this function with CX&lt;&gt;0EDCh or while
	  /FLUSH:ON is active, but this is nothing to rely upon. The reason
	  for this could be to get more accurate statistics, while SMARTDRV
	  just takes a on-the-fly snapshot of the statistic vars.
	The private NWCACHE/NLCACHE install check INT2Fh/D8C0h does not flush
	  to disk, and therefore can be used by callers that must ensure
	  the buffers aren't flushed on this function (e.g. alternative
	  command shells may need this to make their "flush before prompt"
	  feature configurable).
	The NWCACHE 0EDCh special case will most probably vanish with
	  future issues of NWCACHE (2.0+).
	SMARTDRV v3.x had a completely different API using IOCTL calls, which
	  was also supported by the Norton Caches
BUG:	Although DS and ES registers are listed as unmodified, some
	  releases of SMARTDRV seem to trash the DS register, at least the
	  MS-DOS 6.2+ KEYB takes care to preserve the DS register when calling
	  this function.
SeeAlso: AX=4A10h/BX=0001h,AX=4A10h/BX=0004h,AX=4A10h/BX=0005h
SeeAlso: AX=4A10h/BX=0007h,AX=4A10h/BX=1234h,AX=4A11h/BX=0000h
SeeAlso: INT 21/AX=4402h"SMARTDRV",INT 21/AX=4403h"SMARTDRV"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX0000_0" name="2F4A10BX0000_0"><b>2F4A10BX0000</b></a> - INT 2F U - Novell NWCACHE - INSTALLATION CHECK AND STATISTICS<br />
<pre>
INT 2F U - Novell NWCACHE - INSTALLATION CHECK AND STATISTICS
	AX = 4A10h
	BX = 0000h
	CX = magic value
	    0EDCh flush delayed writes
		('EDC' = Novell European Development Center)
	    other (use EBABh to avoid SMARTDRV/DBLSPACE interaction)
Return: (also refer to notes below)
	AX = 6756h ('gV') if installed
	    CF clear
	    BX = cache memory type
		01h conventional memory
		02h extended memory
		03h EMS
	    DI:SI = cache misses
	    CX:DX = segment:offset address of data area containing statistics
		  (see #04095)
	    BP = version in BCD 
		0100h = 1.00
		0101h = 1.01 & 1.02 (!)
Notes:	SMARTDRV 4.0+ uses a similar installation check on this function but
	  returns different data.  To ensure proper interpretation of
	  the returned values, the caller must check the returned magic
	  value in AX. Since SMARTDRV may also alter DI:SI (and possibly
	  DS), the caller should take care of this, too.
	The Novell DOS / DR-DOS 7.x COMMAND.COM invokes this function with
	  CX=0EDCh, which causes NWCACHE to flush any delayed writes before
	  returning the normal register values if it is configured to flush
	  writes before returning to the DOS prompt (/FLUSH:ON); however, if
	  /FLUSH:OFF, this function becomes a NOP with CX=0EDCh.
	Note that for this function the 0EDCh special case may vanish with
	  future issues of NWCACHE (2.0+), and the function would then always
	  do the normal install check, and not flush the cache.
SeeAlso: AX=4A10h/BX=0001h"NWCACHE"

Format of NWCACHE statistics:
Offset	Size	Description	(Table 04095)
 00h	DWORD	number of read requests
 04h	DWORD	number of reads performed
 08h	DWORD	number of write requests
 0Ch	DWORD	number of writes performed
 10h	WORD	number of disk errors
 12h	WORD	number of cache memory errors

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX0001" name="2F4A10BX0001"><b>2F4A10BX0001</b></a> - INT 2F - SMARTDRV v4.00+ - FLUSH BUFFERS (COMMIT CACHE)<br />
<pre>
INT 2F - SMARTDRV v4.00+ - FLUSH BUFFERS (COMMIT CACHE)
	AX = 4A10h
	BX = 0001h
Note:	this function is also supported by PC-Cache v8.0.
SeeAlso: AX=4A10h/BX=0000h,AX=4A10h/BX=0002h,INT 21/AH=0Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX0001_0" name="2F4A10BX0001_0"><b>2F4A10BX0001</b></a> - INT 2F U - Novell NWCACHE - ???<br />
<pre>
INT 2F U - Novell NWCACHE - ???
	AX = 4A10h
	BX = 0001h
	CX = 0EDCh ('EDC' = Novell European Development Center)
Return: ???
SeeAlso: AX=4A10h/BX=0000h"NWCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX0002" name="2F4A10BX0002"><b>2F4A10BX0002</b></a> - INT 2F - SMARTDRV v4.00+ - RESET CACHE<br />
<pre>
INT 2F - SMARTDRV v4.00+ - RESET CACHE
	AX = 4A10h
	BX = 0002h
Note:	this function is also supported by PC-Cache v8.0.
SeeAlso: AX=4A10h/BX=0000h,AX=4A10h/BX=0001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX0003" name="2F4A10BX0003"><b>2F4A10BX0003</b></a> - INT 2F - SMARTDRV v4.00+ - STATUS<br />
<pre>
INT 2F - SMARTDRV v4.00+ - STATUS
	AX = 4A10h
	BX = 0003h
	BP = drive number (0=A, 1=B, etc.)
		FFFFh = all drives (NWCACHE only)
	DL = subfunction
	    00h only get information
	    01h turn on read cache
	    02h turn off read cache
	    03h turn on write cache
	    04h turn off write cache
	    ---NWCACHE---
	    05h reduce cache size
		CX = number of KB to reduce (can't shrink below min size)
	    06h increase cache size
		CX = number of KB to increase (can't grow above max size)
Return: AX = BABEh if OK
	DL = status (see #02801)
	DL = FFh if drive does not exist
Notes:	If the read cache is off, reads will not be cached, but writes will
	  continue to be cached if the write-cache is enabled.
	this function is also supported by PC-Cache v8.0.
	SMARTDRV flushes the cache if sub-functions 02h or 04h have been
	  called to disable read or write caching.
	On calling this function, NWCACHE flushes any delayed writes,
	  but you should not rely on this, since this behavior may vanish
	  in future versions.
BUG:	The MS-DOS 6.20+ SCANDISK disables a SMARTDRV 4+ compatible cache
	  for the drive it is about to process.  However, at least when the
	  cache loaded is NWCACHE, the cache will still remain disabled for
	  this drive after SCANDISK has finished.  The reason for this behavior
	  is not yet known. The workaround is to re-enable with the
	  NWCACHE d:+ syntax afterwards, where d: is the corresponding
	  drive letter.
SeeAlso: AX=4A10h/BX=0000h

Bitfields for SMARTDRV status:
Bit(s)	Description	(Table 02801)
 7	not cached (no read-caching)
 6	write-through (not write-cached)
 0-5	real drive number (0=A, 1=B...)
Notes:	the "real" drive number is always set to 00h for RAM disks and to 3Fh
	  for CD-ROMs; unfortunately, the latter means that an uncached CD-ROM
	  has status FFh, just as a nonexistent drive does
	also supported by Novell DOS 7 - Caldera/Lineo DR-DOS 7.03 NWCACHE

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX0004" name="2F4A10BX0004"><b>2F4A10BX0004</b></a> - INT 2F - SMARTDRV v4.00+ - GET CACHE SIZE<br />
<pre>
INT 2F - SMARTDRV v4.00+ - GET CACHE SIZE
	AX = 4A10h
	BX = 0004h
Return: AX = size in elements of full-sized cache
	BX = current size in elements
	CX = size of one element in bytes
	DX = number of elements under Windows
Note:	this function is also supported by PC-Cache v8.0.
SeeAlso: AX=4A10h/BX=0000h,AX=4A10h/BX=0003h,AX=4A10h/BX=0005h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX0005" name="2F4A10BX0005"><b>2F4A10BX0005</b></a> - INT 2F - SMARTDRV v4.00+ - GET DOUBLE-BUFFER STATUS<br />
<pre>
INT 2F - SMARTDRV v4.00+ - GET DOUBLE-BUFFER STATUS
	AX = 4A10h
	BX = 0005h
	BP = drive number (0=A, 1=B...)
Return: AX = BABEh if double-buffered
	    ES:DI -&gt; 16-byte array of status bytes for fixed disks (see #02802)
SeeAlso: AX=4A10h/BX=0000h,AX=4A10h/BX=0003h,AX=4A10h/BX=0006h

(Table 02802)
Values for SMARTDRV status byte:
 00h	state unknown
 FFh	drive double-buffered
 else	not double-buffered

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX0006" name="2F4A10BX0006"><b>2F4A10BX0006</b></a> - INT 2F CU - SMARTDRV v4.00+ - CHECK IF DRIVE CACHEABLE<br />
<pre>
INT 2F CU - SMARTDRV v4.00+ - CHECK IF DRIVE CACHEABLE
	AX = 4A10h
	BX = 0006h
	CL = drive number (01h = A:)
Return: AX = 0006h if drive should not be cached by SMARTDRV
Note:	called by SMARTDRV at startup to determine whether it should cache
	  a particular drive
SeeAlso: AX=4A10h/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX0007" name="2F4A10BX0007"><b>2F4A10BX0007</b></a> - INT 2F - SMARTDRV v4.00+ - GET DEVICE DRIVER FOR DRIVE<br />
<pre>
INT 2F - SMARTDRV v4.00+ - GET DEVICE DRIVER FOR DRIVE
	AX = 4A10h
	BX = 0007h
	BP = drive number (00h=A:)
Return: DL = unit number within device driver
	ES:DI -&gt; device driver header for drive (see #01646)
Note:	this function is also supported by PC-Cache v8.0.
	this call is reported to always return the driver header of the
	  standard block driver (A:-C:+) for SmartDrive v5.00 from MS-DOS 6.2
SeeAlso: AX=4A10h/BX=0000h,AX=4A11h/BX=0003h,AX=4A11h/BX=0004h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX0008" name="2F4A10BX0008"><b>2F4A10BX0008</b></a> - INT 2F - SMARTDRV v4.20+ - GET/SET FLUSH BEFORE PROMPT, CD-ROM SUPPORT<br />
<pre>
INT 2F - SMARTDRV v4.20+ - GET/SET FLUSH BEFORE PROMPT, CD-ROM SUPPORT
	AX = 4A10h
	BX = 0008h
	DL = subfunction
	    00h set
		DH = new states
		    bit 0: flush before prompt
		    bits 1-7 reserved (0)
	    01h get
		Return: DH = status flags
			    bit 0: (v4.2+) flush before prompt
			    bit 1: (v5.0+) CD-ROM caching support installed
Note:	v4.2 was an interim release to fix problems in the SMARTDRV included
	  with MS-DOS 6.00; v5.00 is included with MS-DOS 6.2

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX000A" name="2F4A10BX000A"><b>2F4A10BX000A</b></a> - INT 2F - SMARTDRV v4.00+ - GET ELEMENT STATUS TABLE<br />
<pre>
INT 2F - SMARTDRV v4.00+ - GET ELEMENT STATUS TABLE
	AX = 4A10h
	BX = 000Ah
Return: ES:BX -&gt; information pointer table (see #02803)
Note:	this function is also supported by PC-Cache v8.0.
SeeAlso: AX=4A10h/BX=0000h

Format of SMARTDRV information pointer table:
Offset	Size	Description	(Table 02803)
 00h	WORD	offset of ??? byte/word array (byte if elements &lt; 2000h bytes)
 02h	WORD	offset of dirty flag byte/word array (byte if elts &lt; 2000h)
		each byte/word is a bit string of the dirty sectors in element
 04h	WORD	offset of word array containing low halves of unique
		  identifiers for the corresponding element's contents
 06h	WORD	offset of word array containing high halves of unique
		  identifiers for the corresponding element's contents
 08h	WORD	offset of WORD containing current number of elements in cache

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A10BX1234" name="2F4A10BX1234"><b>2F4A10BX1234</b></a> - INT 2F - SMARTDRV v4.00+ - SIGNAL SERIOUS ERROR<br />
<pre>
INT 2F - SMARTDRV v4.00+ - SIGNAL SERIOUS ERROR
	AX = 4A10h
	BX = 1234h
Desc:	this function pops up a message box saying that a serious error
	  occurred and to hit R to retry, then waits for the keypress
Note:	this function is also supported by PC-Cache v8.0.
SeeAlso: AX=4A10h/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX0000" name="2F4A11BX0000"><b>2F4A11BX0000</b></a> - INT 2F - DBLSPACE.BIN - "GetVersion" - INSTALLATION CHECK<br />
<pre>
INT 2F - DBLSPACE.BIN - "GetVersion" - INSTALLATION CHECK
	AX = 4A11h
	BX = 0000h
Return: AX = 0000h (successful)
	BX = 444Dh ("DM")
	CL = first drive letter used by DBLSPACE (41h ['A'] = A:)
	CH = number of drive letters used by DBLSPACE
	DX = internal DBLSPACE.BIN version number (bits 14-0)
		bit 15 set if DBLSPACE.BIN has not yet been relocated to final
		  position in memory (i.e. DBLSPACE.SYS /MOVE)
Program: DBLSPACE.BIN is the resident driver for DoubleSpace, the
	  disk-compression software bundled with MS-DOS 6.0 and 6.20
Notes:	this function is also supported by the version of SuperStor bundled
	  with IBM DOS 6.x and "preloading" versions of Stacker
	the complete DBLSPACE.BIN API is still supported by MS-DOS 6.22's
	  DRVSPACE.BIN
SeeAlso: AX=4A11h/BX=0001h,AX=4A11h/BX=0002h,AX=4A11h/BX=0003h
SeeAlso: AX=4A11h/BX=0005h,AX=4A11h/BX=0007h,AX=4A11h/BX=FFFFh
SeeAlso: INT 21/AX=4404h"DBLSPACE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX0001" name="2F4A11BX0001"><b>2F4A11BX0001</b></a> - INT 2F - DBLSPACE.BIN - "GetDriveMapping" - GET DRIVE MAPPING<br />
<pre>
INT 2F - DBLSPACE.BIN - "GetDriveMapping" - GET DRIVE MAPPING
	AX = 4A11h
	BX = 0001h
	DL = drive number (0=A:)
Return: AX = status (see also #02804)
	    0000h successful
		if DL was compressed drive,
		    BL = host drive (bit 7 set if drive is compressed)
		else if DL was host drive,
		    BL = compressed drive
		else
		    BL = specified drive (if available for DoubleSpace)
		BH = DoubleSpace sequence number
	    other error code (0101h) (see #02804)
		apparently never returned for the MS-DOS 6.2 DoubleSpace
Note:	the compressed volume file for the specified compressed drive is
	  host:\DBLSPACE.sequence
SeeAlso: AX=4A11h/BX=0000h

(Table 02804)
Values for DBLSPACE function status:
 0000h	successful
 0100h	bad function
 0101h	invalid drive
 0102h	not a compressed drive
 0103h	drive already swapped
 0104h	drive not swapped
SeeAlso: #02806

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX0002" name="2F4A11BX0002"><b>2F4A11BX0002</b></a> - INT 2F - DBLSPACE.BIN - "Swap Drive" - SWAP DRIVE LETTERS OF CVF AND HOST DRIVE<br />
<pre>
INT 2F - DBLSPACE.BIN - "Swap Drive" - SWAP DRIVE LETTERS OF CVF AND HOST DRIVE
	AX = 4A11h
	BX = 0002h
	DL = drive number (0=A:) of compressed drive to swap with its host
Return: AX = status (0000h,0101h,0102h,0103h) (see #02804)
Note:	this function is intended for use by DBLSPACE.EXE only
SeeAlso: AX=4A11h/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX0003" name="2F4A11BX0003"><b>2F4A11BX0003</b></a> - INT 2F - DBLSPACE.BIN - "DSGetEntryPoints" - GET DEVICE DRIVER ENTRY POINTS<br />
<pre>
INT 2F - DBLSPACE.BIN - "DSGetEntryPoints" - GET DEVICE DRIVER ENTRY POINTS
	AX = 4A11h
	BX = 0003h
	CL = drive number (0=A:) of compressed drive
Return: CL = FFh on error (not compressed drive)
	CL &lt;&gt; FFh driver unit number of host drive
	    ES:SI -&gt; device driver's strategy routine
	    ES:DI -&gt; device driver's interrupt routine
	BX destroyed
Note:	in conjunction with subfunction 0004h, this call allows disk caches
	  like SMARTDRV to apply a device driver wrapper to DoubleSpaced
	  drives just like SMARTDRV applies to regular block devices
SeeAlso: AX=4A10h/BX=0007h,AX=4A11h/BX=0000h,AX=4A11h/BX=0004h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX0004" name="2F4A11BX0004"><b>2F4A11BX0004</b></a> - INT 2F - DBLSPACE.BIN - "DSSetEntryPoints" - SET DEVICE DRIVER ENTRY POINTS<br />
<pre>
INT 2F - DBLSPACE.BIN - "DSSetEntryPoints" - SET DEVICE DRIVER ENTRY POINTS
	AX = 4A11h
	BX = 0004h
	CL = drive number (0=A:) of compressed drive
	DL = unit number for new driver entry points
	DH = 00h
	ES:SI -&gt; device driver strategy routine to call for drive
	ES:DI -&gt; device driver interrupt routine to call for drive
Return: CL = FFh on error (not a compressed drive)
	BX destroyed
Program: DBLSPACE.BIN is the resident driver for DoubleSpace, the
	  disk-compression software bundled with MS-DOS 6.0
Note:	in conjunction with subfunction 0003h, this call allows disk caches
	  like SMARTDRV to apply a device driver wrapper to DoubleSpaced
	  drives just like SMARTDRV applies to regular block devices
SeeAlso: AX=4A10h/BX=0007h,AX=4A11h/BX=0000h,AX=4A11h/BX=0003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX0005" name="2F4A11BX0005"><b>2F4A11BX0005</b></a> - INT 2F - DBLSPACE.BIN - "ActivateDrive" - MOUNT COMPRESSED DRIVE<br />
<pre>
INT 2F - DBLSPACE.BIN - "ActivateDrive" - MOUNT COMPRESSED DRIVE
	AX = 4A11h
	BX = 0005h
	DL = drive number (0=A:) to assign to new drive
	ES:SI -&gt; activation record (see #02805)
Return: status returned in activation record (see #02806)
SeeAlso: AX=4A11h/BX=0000h,AX=4A11h/BX=0006h

Format of DBLSPACE activation record:
Offset	Size	Description	(Table 02805)
 00h  2 BYTEs	signature "MD" (4Dh 44h)
 02h	BYTE	4Dh ('M') mount command
 03h	BYTE	error code (set to FFh before calling) (see #02806)
 04h	BYTE	host drive number (0=A:)
 05h	???	DISK_UNIT structure (not documented)

(Table 02806)
Values for DBLSPACE Mount error code:
 00h	successful
 01h	drive letter not available for DoubleSpace
 02h	drive letter already in use
 03h	no more disk units (increase MaxRemovableDrives in .INI)
 09h	CVF too fragmented
SeeAlso: #02805,#02804

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX0006" name="2F4A11BX0006"><b>2F4A11BX0006</b></a> - INT 2F - DBLSPACE.BIN - "DeactivateDrive" - UNMOUNT COMPRESSED DRIVE<br />
<pre>
INT 2F - DBLSPACE.BIN - "DeactivateDrive" - UNMOUNT COMPRESSED DRIVE
	AX = 4A11h
	BX = 0006h
	DL = drive number (0=A:) to unmount
Return: AX = status (0000h,0102h) (see #02804)
SeeAlso: AX=4A11h/BX=0000h,AX=4A11h/BX=0005h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX0007" name="2F4A11BX0007"><b>2F4A11BX0007</b></a> - INT 2F - DBLSPACE.BIN - "GetDriveSpace" - GET SPACE AVAIL ON COMPRESSED DRIVE<br />
<pre>
INT 2F - DBLSPACE.BIN - "GetDriveSpace" - GET SPACE AVAIL ON COMPRESSED DRIVE
	AX = 4A11h
	BX = 0007h
	DL = compressed drive number (0=A:)
Return: AX = status (0000h,0102h) (see also #02804)
	    0000h successful
		DS:SI -&gt; free space record (see #02807)
Program: DBLSPACE.BIN is the resident driver for DoubleSpace, the
	  disk-compression software bundled with MS-DOS 6.0
SeeAlso: AX=4A11h/BX=0000h,AX=4A11h/BX=0008h

Format of DBLSPACE free space record:
Offset	Size	Description	(Table 02807)
 00h	DWORD	total number of sectors in drive's sector heap
 04h	DWORD	number of free sectors in drive's sector heap

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX0008" name="2F4A11BX0008"><b>2F4A11BX0008</b></a> - INT 2F - DBLSPACE.BIN - "GetFileFragmentSpace" - GET SIZE OF FRAGMENT HEAP<br />
<pre>
INT 2F - DBLSPACE.BIN - "GetFileFragmentSpace" - GET SIZE OF FRAGMENT HEAP
	AX = 4A11h
	BX = 0008h
	DL = compressed drive number (0=A:)
Return: AX = status (0000h,0102h) (see also #02804)
	    0000h successful
		BX = maximum entries in File Fragment heap
		CX = available entries in File Fragment heap
SeeAlso: AX=4A11h/BX=0000h,AX=4A11h/BX=0007h,AX=4A11h/BX=0009h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX0009" name="2F4A11BX0009"><b>2F4A11BX0009</b></a> - INT 2F - DBLSPACE.BIN - "GetExtraInfo" - DETERMINE NUMBER OF DISK_UNIT STRUCTS<br />
<pre>
INT 2F - DBLSPACE.BIN - "GetExtraInfo" - DETERMINE NUMBER OF DISK_UNIT STRUCTS
	AX = 4A11h
	BX = 0009h
	DL = compressed drive number (0=A:)
Return: AX = status (see also #02804)
	    0000h successful
		CL = number of DISK_UNIT structures allocated
			  (see AX=4A11h/BX=0005h)
		CH = DoubleGuard enabled-checks bitflags in bits 6-0 (DOS 6.2)
Note:	the DoubleGuard checks are enabled or disabled as a block by the
	  DoubleGuard= line in DBLSPACE.INI; they may be individually set with
	  the CheckSum= line.
SeeAlso: AX=4A11h/BX=0000h,AX=4A11h/BX=0008h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX000A" name="2F4A11BX000A"><b>2F4A11BX000A</b></a> - INT 2F - DBLSPACE.BIN v6.2 - SET AUTOMOUNT DRIVES<br />
<pre>
INT 2F - DBLSPACE.BIN v6.2 - SET AUTOMOUNT DRIVES
	AX = 4A11h
	BX = 000Ah
	CX:DX = bitmask of drives on which to enable AutoMount
		(DX bit 0 = A:, CX bit 0 = P:, etc.)
Return: AX = 0000h if supported
	    CX:DX = old mask or 0000h:0000h on error
	BX destroyed
SeeAlso: AX=4A11h/BX=000Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BX000B" name="2F4A11BX000B"><b>2F4A11BX000B</b></a> - INT 2F - DBLSPACE.BIN v6.2 - GET AUTOMOUNT DRIVES<br />
<pre>
INT 2F - DBLSPACE.BIN v6.2 - GET AUTOMOUNT DRIVES
	AX = 4A11h
	BX = 000Bh
Return: AX = 0000h if supported
	    CX:DX = mask of drives with AutoMount enabled
		0000h:0000h on error
	BX destroyed
SeeAlso: AX=4A11h/BX=000Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BXFFFE" name="2F4A11BXFFFE"><b>2F4A11BXFFFE</b></a> - INT 2F U - DBLSPACE.BIN - RELOCATE<br />
<pre>
INT 2F U - DBLSPACE.BIN - RELOCATE
	AX = 4A11h
	BX = FFFEh
	ES = segment to which to relocate DBLSPACE.BIN
Return: ???
Notes:	called by DBLSPACE.SYS to relocate DBLSPACE.BIN to its final position
	  in memory
	this function also unhooks and discards the code providing this
	  function and AX=4A11h/BX=FFFFh
	this function is also supported by the version of SuperStor bundled
	  with IBM DOS 6.x and "preloading" versions of Stacker
SeeAlso: AX=4A11h/BX=FFFFh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A11BXFFFF" name="2F4A11BXFFFF"><b>2F4A11BXFFFF</b></a> - INT 2F U - DBLSPACE.BIN - GET RELOCATION SIZE<br />
<pre>
INT 2F U - DBLSPACE.BIN - GET RELOCATION SIZE
	AX = 4A11h
	BX = FFFFh
Return: AX = number of paragraphs needed by DBLSPACE.BIN
Note:	used by DBLSPACE.SYS to relocate the DBLSPACE driver to its final
	  position in memory
	this function is also supported by the version of SuperStor bundled
	  with IBM DOS 6.x and "preloading" versions of Stacker
SeeAlso: AX=4A11h/BX=0000h,AX=4A11h/BX=FFFEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A12CX4D52" name="2F4A12CX4D52"><b>2F4A12CX4D52</b></a> - INT 2F - Microsoft Realtime Compression Interface (MRCI) - RAM-BASED SERVER<br />
<pre>
INT 2F - Microsoft Realtime Compression Interface (MRCI) - RAM-BASED SERVER
	AX = 4A12h
	CX = 4D52h ("MR")
	DX = 4349h ("CI")
Return: CX = 4943h ("IC") if installed
	DX = 524Dh ("RM") if installed
	    ES:DI -&gt; MRCINFO structure (see #00725 at INT 1A/AX=B001h)
Note:	this call is functionally identical to INT 1A/AX=B001h, but should be
	  called first, as the latter call is used for the first, ROM-based
	  MRCI server, while this call is used for RAM-based servers which
	  may be partially or entirely replacing a prior server
SeeAlso: AX=4A12h/CX=5354h,INT 1A/AX=B001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A12CX5354" name="2F4A12CX5354"><b>2F4A12CX5354</b></a> - INT 2F - Stacker 4 LZS Compression Interface (LZSAPI)<br />
<pre>
INT 2F - Stacker 4 LZS Compression Interface (LZSAPI)
	AX = 4A12h
	CX = 5354h ("ST")
	DX = 4143h ("AC")
Return: AX = 4F4Bh ("OK") if installed
	CX = 7374h ("st") if installed
	DX = 6163h ("ac") if installed
	    ES:DI -&gt; entry point in LZSAPI server (usually, driver
		      STACKER.COM) containing far address of an actual
		      LZSINFO structure (see #02808)
SeeAlso: AX=4A12h/CX=4D52h,INT 25/AX=CDCDh

Format of LZSINFO structure:
Offset	Size	Description	(Table 02808)
 00h  6 BYTEs	signature "LZSAPI"
 06h	WORD	server version (200 (0C8h) for Stacker 4 and Stacker Anywhere)
 08h  4 BYTEs	vendor signature
		"STAC" = Stac Electronics, Inc.
 0Ch  6 BYTEs	???
 12h	WORD	bit flags: server status/capabilities (see #02809)
 14h	DWORD	-&gt; Stacker 3.X-compatible compression procedure
 18h	DWORD	-&gt; Stacker 3.X-compatible decompression procedure
 1Ch  4 BYTEs	reserved (always set to 0)
 20h	DWORD	-&gt; incremental Stacker 3.x-compatible compression procedure
		  (see #02810)
 24h  4 BYTEs	???
 28h	DWORD	-&gt; incremental Stacker 3.x-compatible decompression procedure
		  (see #02811)
 2Ch  4	BYTES	???
 30h	DWORD	-&gt; new (Stacker 4) compression procedure
 34h  4 BYTEs	???
 38h	DWORD	-&gt; new (Stacker 4) decompression procedure
Notes:	Stacker 4 usally keeps two different data-compression algorithms in
	  memory (preferably in XMA):
	    1) new (Stacker 4) data compression algorithm (4K LZ77 with hashing
		  and static Huffman encoding), and
	    2) old (Stacker 3.x-compatible) one (2K LZ77 with hashing), which
		  is used to work with STACVOL files created under older
		  versions of Stacker.

Bitfields for LZSAPI capabilities:
Bit(s)	Description	(Table 02809)
 0	???
 1	busy/error flag
 2-10	???
 11	maximum compressor/decompressor presented

(Table 02810)
Call Stacker 3.x-style non-incremental functions with:
	STACK:	DWORD	return address for compress/decompress procedure
		WORD	compression algorithm parameters (see #02812)
		WORD	size of destination buffer (in bytes)
		DWORD	address of destination buffer
		WORD	size of source buffer (in bytes)
		DWORD	address of source buffer
Return: (compression/decompression procedure)
	AX = size of resulting data in destination buffer
	    0000h if error (either destination buffer too small or error in
		  compressed data)

(Table 02811)
Call Stacker 4-style incremental procedures with:
	STACK:	DWORD	return address for compr./decompr. procedure
		DWORD	address of LZSSWAP structure (see #02813)
			if 0000:0000, procedure uses non-incremental technique
		WORD	compression algorithm parameters (see #02812)
		WORD	size of destination buffer (in bytes)
		DWORD	address of destination buffer
		WORD	size of source buffer (in bytes)
		DWORD	address of source buffer

(Table 02812)
Values for Compression algorithm parameters:
Value	Compression level (/P=xx parameter)
 07F9h	  1
 0621h	  2
 0625h	  3
 0665h	  4
 0669h	  5
 06E9h	  6
 06EDh	  7
 07D1h	  8
 07D9h	  9

Format of LZSSWAP structure:
Offset	Size	Description	(Table 02813)
 00h  2 BYTEs	signature "CS"
 02h  6 BYTEs	reserved
 08h	DWORD	address of destination buffer swapping procedure
 0Ch	DWORD	address of stack swapping procedure

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A13" name="2F4A13"><b>2F4A13</b></a> - INT 2F U - DBLSPACE.BIN - DBLSPACE/MRCI STEALTH PACKET API<br />
<pre>
INT 2F U - DBLSPACE.BIN - DBLSPACE/MRCI STEALTH PACKET API
	AX = 4A13h
Return: AX = 134Ah if supported
	    ES:BX -&gt; entry point record (see #02814)
SeeAlso: AX=4A11h/BX=0000h,AX=4A12h/CX=4D52h"MRCI"

Format of DBLSPACE entry point record:
Offset	Size	Description	(Table 02814)
 00h	DWORD	pointer to FAR function for ???
 04h  5 BYTEs	FAR JUMP instruction to ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A15BX0000" name="2F4A15BX0000"><b>2F4A15BX0000</b></a> - INT 2F - MS EMM386.EXE v4.46+ - INSTALL I/O VIRTUALIZATION HANDLER<br />
<pre>
INT 2F - MS EMM386.EXE v4.46+ - INSTALL I/O VIRTUALIZATION HANDLER
	AX = 4A15h
	BX = 0000h (function number)
	DX = starting I/O address
	EDX high word = ending I/O address
	CX = number of ports to trap
	DS:SI -&gt; I/O dispatch table (see #02815)
	DI = size of client's code and data (size of DS segment which must be
	      made available to I/O dispatch function in protected mode)
Return: CF clear if successful
	CF set on error
Notes:	this interface is only available in virtual-86 mode; the I/O handlers
	  will be called in protected mode
	only ports 0100h-FFFFh may be trapped; EMM386 reserved ports 0000h-
	  00FFh

Format of EMM386 I/O dispatch table [array]:
Offset	Size	Description	(Table 02815)
 00h	WORD	I/O port number
 02h	WORD	offset of I/O handler for port (see #02816)

(Table 02816)
Values EMM386 I/O dispatch function is called with:
	CX = Ring0 code selector for I/O handler's segment
	DS = Ring0 data selector for I/O handler's segment (alias of CS)
	EDX = faulting I/O address
	ECX = direction (00000008h for byte output, 00000000h for byte input)
		(reportedly 00h for byte/word input, 04h for byte/word output
		  under DOS 6.22 EMM386)
	EAX = data in/out
Return: (via FAR RET)
	CF clear if I/O access successfully virtualized
	CF set if access not virtualized (default handler will be called to
	      perform the I/O)
BUG:	32-bit I/O on trapped ports hangs the DOS 6.22 EMM386
SeeAlso: #02815

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A16" name="2F4A16"><b>2F4A16</b></a> - INT 2F U - Windows95 - OPEN BOOT LOG<br />
<pre>
INT 2F U - Windows95 - OPEN BOOT LOG
	AX = 4A16h
Return: AX = status
	    0000h successful
	    FFFFh boot log file already open
	    else  DOS error code
	BX destroyed
SeeAlso: AX=4A17h,AX=4A18h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A17" name="2F4A17"><b>2F4A17</b></a> - INT 2F U - Windows95 - WRITE TO BOOT LOG<br />
<pre>
INT 2F U - Windows95 - WRITE TO BOOT LOG
	AX = 4A17h
	CX = number of bytes to write
	DS:DX -&gt; message to write (must include CR-LF if it is desired)
Return: AX = status
	    0000h successful
	    FFFFh boot log file not open
	    else  DOS error code
Note:	calls the code for INT 2F/AX=4A21h after writing to the file
SeeAlso: AX=4A17h,AX=4A18h,AX=4A21h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A18" name="2F4A18"><b>2F4A18</b></a> - INT 2F U - Windows95 - CLOSE BOOT LOG<br />
<pre>
INT 2F U - Windows95 - CLOSE BOOT LOG
	AX = 4A18h
Return: AX = status
	    0000h successful
	    FFFFh boot log file not open
	    else  DOS error code from closing file
	BX destroyed
SeeAlso: AX=4A16h,AX=4A17h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A21" name="2F4A21"><b>2F4A21</b></a> - INT 2F U - Windows95 - ???<br />
<pre>
INT 2F U - Windows95 - ???
	AX = 4A21h
Return: AX destroyed
Note:	calls INT 21/AX=4404h"IOCTL" with a five-byte buffer containing "MDF??"
SeeAlso: AX=4A17h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A31" name="2F4A31"><b>2F4A31</b></a> - INT 2F U - Windows95 - ???<br />
<pre>
INT 2F U - Windows95 - ???
	AX = 4A31h
	CL = new value for ???
	DS:SI -&gt; BYTE to be set to CL
Return: nothing

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A32" name="2F4A32"><b>2F4A32</b></a> - INT 2F U - Windows95 - PATCH ???<br />
<pre>
INT 2F U - Windows95 - PATCH ???
	AX = 4A32h
	BL = subfunction
	    00h get ???
		Return: AX = flag: subfunction 04h has been used (0000h/FFFFh)
			DX = ??? (0000h/?)
	    01h	patch ??? in IO.SYS (segment 0070h)
	    02h unpatch ??? in IO.SYS
	    03h ???
	    04h set ???, then do subfunction 01h
	    05h unset ???, then do subfunction 02h
	    else
		Return: nothing

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4A33" name="2F4A33"><b>2F4A33</b></a> - INT 2F - Windows95 - CHECK MS-DOS VERSION 7<br />
<pre>
INT 2F - Windows95 - CHECK MS-DOS VERSION 7
	AX = 4A33h
Return: AX = 0000h for MS-DOS 7.00+
	    (officially) BX,DX,SI,DS may be destroyed
	    (undoc) DS:DX -&gt; ASCIZ primary shell executable name
	    (undoc) DS:SI -&gt; CONFIG.SYS SHELL= command line (counted string)
	    (undoc) BH = ??? (0000h)
	    (undoc) BL = ??? (0000h)
	AX nonzero (usually 4A33h) if MS-DOS 6- or other DOS
SeeAlso: AX=1611h,INT 21/AH=30h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4B" name="2F4B"><b>2F4B</b></a> - INT 2F - LAN Manager 2.0 DOS Enh NETWKSTA.EXE - NETWORK WORKSTATION REDIRECTOR<br />
<pre>
INT 2F - LAN Manager 2.0 DOS Enh NETWKSTA.EXE - NETWORK WORKSTATION REDIRECTOR
	AH = 4Bh
	???
Return: ???
Note:	LAN Manager enhanced mode adds features beyond the standard redirector
	  file/printer services
SeeAlso: AX=118Ah,AX=4100h,AH=42h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4B01" name="2F4B01"><b>2F4B01</b></a> - INT 2F C - DOS 5+ TASK SWITCHER - BUILD CALLOUT CHAIN<br />
<pre>
INT 2F C - DOS 5+ TASK SWITCHER - BUILD CALLOUT CHAIN
	AX = 4B01h
	CX:DX -&gt; task switcher entry point (see #02819)
	ES:BX = 0000h:0000h
Return: ES:BX -&gt; callback info structure (see #02817) or 0000h:0000h
Notes:	called by the task switcher
	this function is hooked by clients which require notification of task
	  switcher activities; the call must first be passed on to the prior
	  handler with registers unchanged using a simulated interrupt.	 On
	  return, the client must build a callback info structure and store
	  the returned ES:BX in the "next" field, then return the address of
	  its own callback info structure.
	a client program must add itself to the notification chain if it
	  provides services to other programs; before terminating, it must
	  remove itself from the chain by calling the task switcher's entry
	  point with AX=0005h (see #02819)
	the task switcher entry point should not be saved, as it is subject to
	  change and will be provided on any notification call
	the Windows 3.1 Standard Mode supports this API
SeeAlso: AX=160Bh,AX=4B02h

Format of task switcher callback info structure:
Offset	Size	Description	(Table 02817)
 00h	DWORD	pointer to next callback info structure
 04h	DWORD	pointer to notification function (see #02818)
 08h	DWORD	reserved
 0Ch	DWORD	address of zero-terminated list of API info structures
		(see #02821)

(Table 02818)
Values task switcher notification function is called with:
	AX = function
	    0000h switcher initialization
		Return: AX = status
			    0000h if OK to load
			    nonzero to abort task switcher
	    0001h query suspend
		BX = session ID
		Return: AX = status
			    0000h if OK to switch session
			    0001h if not
	    0002h suspend session
		BX = session ID
		interrupts disabled
		Return: AX = 0000h if OK to switch session
			   = 0001h if not
	    0003h activate session
		BX = session ID
		CX = session status flags
			bit 0: set if first activation of session
			bits 1-15: reserved (0)
		interrupts disabled
		Return: AX = 0000h
	    0004h session active
		BX = session ID
		CX = session status flags
			bit 0: set if first activation of session
			bits 1-15: reserved (0)
		Return: AX = 0000h
	    0005h create session
		BX = session ID
		Return: AX = 0000h if OK to create session
			   = 0001h if not
	    0006h destroy session
		BX = session ID
		Return: AX = 0000h
	    0007h switcher termination
		BX = flags
		    bit 0: set if calling switcher is only switcher loaded
		    bits 1-15: reserved (0)
		Return: AX = 0000h
	ES:DI -&gt; task switcher entry point (see #02819)
Notes:	function 0000h is generally called by the program which controls or
	  invokes the task switcher, rather than by the task switcher itself;
	  the entry point supplied to this function is not necessarily the
	  entry point to the task switcher itself, and may be 0000h:0000h.  If
	  any client indicates that loading is not possible, all clients will
	  be called with function 0007h; thus it is possible for a client to
	  receive a termination notice without a corresponding initialization
	  notice.
	except for functions 0002h and 0003h, the notification handler is
	  called with interrupts enabled and may make any INT 21h function
	  call; interrupts must not be enabled in functions 0002h and 0003h
	function 0007h may be called with ES:DI = 0000h:0000h if the entry
	  point is no longer valid

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4B02BX0000" name="2F4B02BX0000"><b>2F4B02BX0000</b></a> - INT 2F - DOS 5+ TASK SWITCHER - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS 5+ TASK SWITCHER - INSTALLATION CHECK
	AX = 4B02h
	BX = 0000h
	ES:DI = 0000h:0000h
Return: ES:DI = 0000h:0000h if task switcher not loaded
	ES:DI -&gt; task switcher entry point (see #02819) if loaded
	    AX = 0000h
Notes:	the returned entry point is that for the most-recently loaded task
	  switcher; the entry points for prior task switchers may be determined
	  with the "get version" call (see #02819)
	this function is supported by PC Tools v8+ CPTASK
SeeAlso: AX=4A05h,AX=4B03h

(Table 02819)
Call task switcher entry point with:
	AX = 0000h get version
		Return: CF clear if successful
			    AX = 0000h
			    ES:BX -&gt; task switcher version struct (see #02820)
			CF set if unsupported function
	AX = 0001h test memory region
		ES:DI -&gt; first byte to be tested
		CX = size of region to test
		Return: CF clear if successful
			    AX = memory type of tested region
				0000h global
				0001h global and local
				0002h local (replaced on session switch)
			CF set if unsupported function
	AX = 0002h suspend switcher
		ES:DI -&gt; new task switcher's entry point
		Return: CF clear if successful
			    AX = state
				0000h switcher has been suspended
				0001h switcher not suspended, new switcher must
					abort
				0002h switcher not suspended, but new switcher
					may run anyway
			CF set if unsupported function
	AX = 0003h resume switcher
		ES:DI -&gt; new task switcher's entry point
		Return: CF clear if successful
			    AX = 0000h
			CF set if unsupported function
	AX = 0004h hook notification chain
		ES:DI -&gt; callback info structure to be added to chain
			  (see #02817)
		Return: CF clear if successful
			    AX = 0000h
			CF set if unsupported function
	AX = 0005h unhook notification chain
		ES:DI -&gt; callback info structure to be removed from chain
			  (see #02817)
		Return: CF clear if successful
			    AX = 0000h
			CF set if unsupported function
	AX = 0006h query API support
		BX = asynchronous API identifier
		Return: CF clear if successful
			    AX = 0000h
			    ES:BX -&gt; API info structure (see #02821) for the
				      client which provides the highest
				      level of API support
			CF set if unsupported function

Format of task switcher version structure:
Offset	Size	Description	(Table 02820)
 00h	WORD	major version of supported protocol  (current protocol is 1.0)
 02h	WORD	minor version of supported protocol
 04h	WORD	major version of task switcher
 06h	WORD	minor version of task switcher
 08h	WORD	task switcher ID (see AX=4B03h)
 0Ah	WORD	operation flags
		bit 0: set if task switcher disabled
		bits 1-15: reserved (0)
 0Ch	DWORD	pointer to ASCIZ task switcher name
		("MS-DOS Shell Task Switcher" for DOSSHELL task switcher)
 10h	DWORD	pointer to previous task switcher's entry point or 0000h:0000h

Format of API info structure:
Offset	Size	Description	(Table 02821)
 00h	WORD	size of structure in bytes (000Ah)
 02h	WORD	API identifier
		0001h NetBIOS
		0002h 802.2
		0003h TCP/IP
		0004h LAN Manager named pipes
		0005h Novell NetWare IPX
 04h	WORD	major version \ of highest version of API for which the support
 06h	WORD	minor version / level specified in the next field is provided
 08h	WORD	support level
		0001h minimal support
		0002h API-level support
		0003h switcher compatibility
		0004h seamless compatibility

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4B03" name="2F4B03"><b>2F4B03</b></a> - INT 2F - DOS 5+ TASK SWITCHER - ALLOCATE SWITCHER ID<br />
<pre>
INT 2F - DOS 5+ TASK SWITCHER - ALLOCATE SWITCHER ID
	AX = 4B03h
	ES:DI -&gt; task switcher entry point (see #02819)
Return: AX = 0000h
	BX = switcher ID (0001h-000Fh), or 0000h if no more available
Notes:	if a task switcher has determined that it is the first to be loaded, it
	  must allocate an identifier for itself and provide this function to
	  all subsequent task switchers; if it is not the first to be loaded,
	  it must call this function to allocate an ID.	 The switcher ID is
	  used as the high four bits of all session identifiers to ensure
	  unique session IDs.
	if no more switcher IDs are available, the new task switcher making the
	  call must terminate or disable itself
	the task switcher providing the identifiers may call the new task
	  switcher's entry point as needed
	this call is available from within DOSSHELL even if the task switcher
	  is not installed
	this function is supported by PC Tools v8+ CPTASK, but appears to
	  always return an ID of 0000h
SeeAlso: AX=4B02h,AX=4B04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4B04" name="2F4B04"><b>2F4B04</b></a> - INT 2F - DOS 5+ TASK SWITCHER - FREE SWITCHER ID<br />
<pre>
INT 2F - DOS 5+ TASK SWITCHER - FREE SWITCHER ID
	AX = 4B04h
	BX = switcher ID
	ES:DI -&gt; task switcher entry point (see #02819)
Return: AX = 0000h
	BX = status
	    0000h successful
	    other error (invalid ID or ID not allocated)
Notes:	called by a task switcher when it exits, unless it was the first loaded
	  and is providing the support for AX=4B03h and AX=4B04h
	the task switcher providing the identifiers may call the terminating
	  task switcher's entry point as needed
	this call is available from within DOSSHELL even if the task switcher
	  is not installed
	this call is supported by PC Tools v8+ CPTASK, but appears to return
	  sucessfully no matter which ID is given
SeeAlso: AX=4B02h,AX=4B03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4B05" name="2F4B05"><b>2F4B05</b></a> - INT 2F C - DOS 5+ TASK SWITCHER - IDENTIFY INSTANCE DATA<br />
<pre>
INT 2F C - DOS 5+ TASK SWITCHER - IDENTIFY INSTANCE DATA
	AX = 4B05h
	ES:BX = 0000h:0000h
	CX:DX -&gt; task switcher entry point (see #02819)
Return: ES:BX -&gt; startup info structure (see #02822) or 0000h:0000h
Notes:	called by task switcher
	clients with instance data should hook this call, pass it through to
	  the previous handler with unchanged registers using a simulated
	  interrupt.  On return, the client should create a startup info
	  structure (see #02822), store the returned ES:BX in the "next"
	  field, and return the address of the created structure in ES:BX
	all MS-DOS function calls are available from within this call
	this function is supported by Novell DOS 7 DOSKEY, with structure v3.00
SeeAlso: AX=1605h,AX=160Bh,AX=4B02h

Format of task switcher startup info structure:
Offset	Size	Description	(Table 02822)
 00h  2 BYTEs	major, minor version of info structure (03h,00h)
 02h	DWORD	pointer to next startup info structure or 0000h:0000h
 06h	DWORD	0000h:0000h (ignored)
 0Ah	DWORD	ignored
 0Eh	DWORD	pointer to instance data records (see #02823)

Format of one instance data record in array:
Offset	Size	Description	(Table 02823)
 00h	DWORD	address of instance data (end of array if 0000h:0000h)
 04h	WORD	size of instance data

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4B06" name="2F4B06"><b>2F4B06</b></a> - INT 2F - MS Windows - WIN.COM - GET ??? POINTER TO WIN.COM<br />
<pre>
INT 2F - MS Windows - WIN.COM - GET ??? POINTER TO WIN.COM
	AX = 4B06h
Return: AX = 0000h
	ES:BX -&gt; ??? function in WIN.COM
Note:	the entry point is called with
	    AX = 0001h or 0003h
	    BX = ???
SeeAlso: AX=4B80h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4B20" name="2F4B20"><b>2F4B20</b></a> - INT 2F - MS Windows 3+ - WIN.COM - SET PROGRAM TO EXECUTE ON EXIT<br />
<pre>
INT 2F - MS Windows 3+ - WIN.COM - SET PROGRAM TO EXECUTE ON EXIT
	AX = 4B20h
Return: AX = 0000h if successful
	    DX:CX -&gt; 256-byte buffer for pathname and commandline (see #02824)
Notes:	when the Windows function ExitWindows is called with an exit code of
	  44h, WIN.COM executes the program specified in the returned buffer
	  and then restarts Windows
	the returned address is a real-mode segment:offset value
SeeAlso: AX=4B21h

Format of WIN.COM buffer:
Offset	Size	Description	(Table 02824)
 00h 128 BYTEs	commandline for program (count byte, command tail, 0Dh)
 80h 128 BYTEs	ASCIZ pathname of program to execute
Note:	the order above is for a Windows95 DOS box; it may be reversed under
	  Windows 3.x

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4B21" name="2F4B21"><b>2F4B21</b></a> - INT 2F - Windows95 - WIN.COM - GET NESTING LEVEL<br />
<pre>
INT 2F - Windows95 - WIN.COM - GET NESTING LEVEL
	AX = 4B21h
Return: AH = 00h if WIN.COM already active
	    AL = number of instances of WIN.COM in memory
SeeAlso: AX=4B20h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4B52" name="2F4B52"><b>2F4B52</b></a> - INT 2F - KeyRus v7.3 - API<br />
<pre>
INT 2F - KeyRus v7.3 - API
	AX = 4B52h ('KR')
	BL = function number
	    00h installation check
		Return: AL = 82h if installed
			    BH = major version number
			    BL = minor version number
			    ES destroyed
	    01h get driver status
		Return: AL??? = current status (see #02825)
	    02h set driver state
		AL = new driver state (see #02825)
	    03h blank screen (if blanking enabled when TSR was loaded)
	    04h unblank screen
	    4Ch switch to English keyboard mode
	    90h switch to Russian keyboard mode
Return:

Bitfields for KeyRus driver status:
Bit(s)	Description	(Table 02825)
 1-0	language mode
	00 Latin
	01 Russian
	10 Alternative
	11 unused
 2	allow character loading (if disabled, use ROM fonts)
 3	English keyboard support
 7-4	used internally (read-only)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4B80" name="2F4B80"><b>2F4B80</b></a> - INT 2F - MS Windows - WSWAP.EXE - RESET INTERNAL VARIABLES<br />
<pre>
INT 2F - MS Windows - WSWAP.EXE - RESET INTERNAL VARIABLES
	AX = 4B80h
Return: nothing
Note:	called by WINOLDAP.MOD
SeeAlso: AX=4B06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4C" name="2F4C"><b>2F4C</b></a> - INT 2F U - Advanced Power Management<br />
<pre>
INT 2F U - Advanced Power Management
	AH = 4Ch
	AL = function
	    00h version check
	    01h suspend system requested
	    FFh suspend/resume battery notification
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4D" name="2F4D"><b>2F4D</b></a> - INT 2F U - KKCFUNC<br />
<pre>
INT 2F U - KKCFUNC
	AH = 4Dh
	AL = function
	    00h get function address
	    01h get error number of last call to KKC DOS function
	    02h	register/release KKC
	    03h get table address
	!!! details to follow
Return: ???
Notes:	This API is provided by KKCFUNC.SYS, a support driver for Kana Kanji
	  Converters (KKC), which is used to handle multiple client KKCs and
	  provide all the necessary framework to call DOS functions at any
	  time.
	also called by MSKK
	For AL &gt; 3, KKCFUNC passes the call down to the original INT 2Fh,
	  as recorded at initialization.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4E53BL00" name="2F4E53BL00"><b>2F4E53BL00</b></a> - INT 2F - SilverNET v2+ - INSTALLATION CHECK<br />
<pre>
INT 2F - SilverNET v2+ - INSTALLATION CHECK
	AX = 4E53h ("NS")
	BL = 00h (function "installation check")
	BH = module ID (see #02826)
Return: AX = 0000h if specified module installed
	BX = 4E53h if installed
Program: SilverNET is an SMB-compatible peer-to-peer NOS for DOS or
	  Windows systems, by Net-Source, Inc. of Santa Clara, CA.
SeeAlso: AX=4E53h/BL=01h,AX=4E53h/BL=02h,AX=B800h,AX=B809h

(Table 02826)
Values for SilverNET module ID:
 01h	SilverCACHE
 02h	Workstation
 03h	NetBIOS
 04h	Peer
 20h	NS Share
 80h	NetWare help TSR

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4E53BL01" name="2F4E53BL01"><b>2F4E53BL01</b></a> - INT 2F - SilverNET - GET RUNTIME PARAMETER<br />
<pre>
INT 2F - SilverNET - GET RUNTIME PARAMETER
	AX = 4E53h ("NS")
	BL = 01h (function "get runtime parameter")
	BH = module ID (see #02826)
	CX = parameter index (see #02827,#02829,#02830)
Return: AX = WORD value at specified index (see #02828)
Desc:	retrieve a word of data from the specified SilverNET module

(Table 02827)
Values for SilverNET Peer parameter index (* = read-only):
 00h *	maximum outstanding SMB buffers
 02h *	maximum logged-in nodes
 04h *	number of shareable resources
 06h *	number of characters to print per time slice
 08h *	number of printers that can be shared
 0Ah *	number of nodes logged in
 0Ch *	number of files to allow opened
 0Eh	how fast to despool (/PSLICE)
 10h	audit flag
 24h *	far pointer to resource table (each resource is 96 bytes in length)
 32h *	far pointer to SFT (internal if SilverNET files &gt; CONFIG.SYS files,
	else DOS SFT)
 36h	spool flags (see #02828)
SeeAlso: #02829

Bitfields for spool flags:
Bit(s)	Description	(Table 02828)
 0	LPT1 needs despooling
 1	LPT2 needs despooling
 2	LPT2 needs despooling
 4	COM1 needs despooling
 5	COM2 needs despooling
 6	COM3 needs despooling
SeeAlso: #02827

(Table 02829)
Values for NS Share parameter index (* = read-only):
 00h	version number (high byte = minor, low byte = major)
 10h *	segment of first lock record (other records in consecutive paragraphs)
	(if PSP field = 0000h, lock record is free)
 12h *	maximum possible number of lock records
 14h *	starting segment of sharing buffer
	(NS Share's sharing records are identical to DOS SHARE except that
	  fields which are normally offsets into SHARE are segment numbers)
 18h *	size of sharing buffer in paragraphs
 1Ah *	total free paragraphs in sharing buffer
 1Ch *	current number of shared files
 1Eh *	current number of locked records
SeeAlso: #02827,#02830

(Table 02830)
Values for Workstation parameter index (* = read-only):
 00h	version number (high byte = minor, low byte = major)
 02h *	size of each network buffer for file operations
 04h *	number of redirector file buffers
 06h *	size of each print cache buffer
 08h *	number of network LPT printers
 0Ch	flush time in ticks (idle time on network printer before flushing)
 0Eh	(16 WORDs) last active time for each printer
 2Eh *	stub segment if program split into two parts
 60h	receive name number for datagram listens
 62h *	18-byte machine name
 74h *	LASTDRIVE (01h = A:, etc.)
 7Ch	row number of message box on screen
 7Eh	message time in clock ticks
 82h *	number of network adapters in use
 84h	station ID broadcast flag (never set on redirectors)
 96h *	NetBIOS names left
 98h *	NCBs left
 9Ah *	sessions left
 A2h *	total number of network printers (LPT+COM)
 A4h *	number of serial network printers
 A8h *	segment containing file cache buffers
 AAh *	segment containing print cache buffers
 ACh *	bytes remaining free in HMA before program loaded
 AEh *	start of free memory in HMA
 B2h *	flag: using HMA
SeeAlso: #02829

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4E53BL02" name="2F4E53BL02"><b>2F4E53BL02</b></a> - INT 2F - SilverNET - SET RUNTIME PARAMETERS<br />
<pre>
INT 2F - SilverNET - SET RUNTIME PARAMETERS
	AX = 4E53h ("NS")
	BL = 02h (function "set runtime parameters")
	BH = module ID (see #02826)
	CX = parameter index (see #02829,#02830)
	DX = new value for specified parameter
Desc:	set a WORD value in the specified SilverNET module
Note:	not all indexed parameters are writable; modifying a read-only
	  parameter can result in system crashes
SeeAlso: AX=4E53h/BL=00h,AX=4E53h/BL=01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5100" name="2F5100"><b>2F5100</b></a> - INT 2F U - ODIHLP.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F U - ODIHLP.EXE - INSTALLATION CHECK
	AX = 5100h
Return: AL = FFh if installed
	    BX = 0000h
	    DX:SI -&gt; signature string "ODI$HLP$"
Program: ODIHLP is a real-mode helper allowing the Windows for Workgroups 3.11
	  protected-mode NDIS3 protocol to work with real-mode ODI drivers
	  and LSL.COM
Note:	the returned signature string might be the first field of a structure
SeeAlso: AX=C000h"LSL.COM"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5200" name="2F5200"><b>2F5200</b></a> - INT 2F - JAM.SYS v1.10+ - "GetVersion" - INSTALLATION CHECK<br />
<pre>
INT 2F - JAM.SYS v1.10+ - "GetVersion" - INSTALLATION CHECK
	AX = 5200h
Return: AH = 80h (successful) if installed
	BX = internal JAM.SYS version number
	CX = size of JAMINFO structure (see #02831,#02832)
	DX = JAM.SYS segment address
Program: JAM.SYS is a main component of the JAM Real-Time Data Compression
	  Utilities by George A. Reznik and friends (JAM Software).
SeeAlso: AX=5201h

Format of JAMINFO v1.10 structure:
Offset	Size	Description	(Table 02831)
 00h 25 BYTEs	extended BIOS parameter block (BPB)
 19h 11 BYTEs	???
 25h	DWORD	total number of sectors in JAM archive file
		(size of compressed data area)
 29h	BYTE	flags (see #02833)
 2Ah 127 BYTEs	full JAM archive file name
 A9h	WORD	the number of fragments in archive file
 ABh 96 BYTEs	archive file fragmentation list -
		array of 16 FRAGMENT structures (see #02834)
10Bh	DWORD	address of the host-drive DPB (Drive Parameter Block)
10Fh	DWORD	number of free sectors in JAM archive file
113h	WORD	device status word (see #02835)
SeeAlso: #02832

Format of JAMINFO v1.20 structure:
Offset	Size	Description	(Table 02832)
 00h 25 BYTEs	extended BIOS parameter block (BPB)
 19h	BYTE	physical driver number
 1Ah	BYTE	reserved
 1Bh	BYTE	extended boot record signature
 1Ch	DWORD	volume serial number
 20h 11 BYTEs	volume label
 2Bh  8 BYTEs	file system ID
 33h	DWORD	total number of sectors in JAM archive file
		(size of compressed data area)
 37h	BYTE	flags (see #02833)
 38h 128 BYTEs	full JAM archive file name
 B8h	WORD	the number of fragments in archive file
 BAh 96 BYTEs	archive file fragmentation list -
		array of 16 FRAGMENT structures (see #02834)
11Ah	DWORD	address of the host-drive DPB (Drive Parameter Block)
11Eh	DWORD	number of free sectors in JAM archive file
122h	WORD	device status word (see #02835)
Note:	the first 33h bytes are copied from the archive file's boot sector
SeeAlso: #02831

Bitfields for JAMINFO flags:
Bit(s)	Description	(Table 02833)
 2-0	reserved
 3	(v1.20+)
 4	enable direct write requests (Int 26h, non-DOS requests, etc.)
 5	read-only mode
 6	no write-behind caching
 7	full undelete-compatible allocation strategy
SeeAlso: #02831,#02832

Format of JAM FRAGMENT structure:
Offset	Size	Description	(Table 02834)
 00h	WORD	starting sector (low word)
 02h	BYTE	starting sector (high byte)
 03h	WORD	size of fragment (low word)
 05h	BYTE	size of fragment (high byte)
SeeAlso: #02831,#02832

(Table 02835)
Values for JAM.SYS status (high byte):
 00h	successful
 01h	drive is not a JAM drive
 02h	drive is already attached
 03h	archive file cluster size value is larger than driver's one
 04h	drive is not attached
 05h	drive is locked
 06h	drive is not locked
 07h	bad physical-level request
 08h	host drive reading/writing error
 09h	bad entries in JAM descriptor table
 0Ah	compressed data integrity error
 0Bh	archive file overflow
 0Ch	bad DOS request
 0Dh	incorrect parameters in JAMINFO structure
Note:	the low byte of the status is the DOS error code for the Host drive
SeeAlso: #02598 at INT 2F/AX=0802h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5201" name="2F5201"><b>2F5201</b></a> - INT 2F - JAM.SYS v1.10+ - "GetInfo" - GET COMPRESSED DRIVE INFORMATION<br />
<pre>
INT 2F - JAM.SYS v1.10+ - "GetInfo" - GET COMPRESSED DRIVE INFORMATION
	AX = 5201h
	DL = compressed drive number (0-default, 1-A:, etc.)
	DS:BX -&gt; buffer for JAMINFO structure (see #02831,#02832)
Return: AH = status (00h,01h) (see #02835)
SeeAlso: AX=5200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5202" name="2F5202"><b>2F5202</b></a> - INT 2F - JAM.SYS v1.10+ - "Attach" - MOUNT COMPRESSED DRIVE<br />
<pre>
INT 2F - JAM.SYS v1.10+ - "Attach" - MOUNT COMPRESSED DRIVE
	AX = 5202h
	DL = drive number (0-default, 1-A:, etc.) to attach to the JAM
	      archive file
	DS:BX -&gt; pointer to JAMINFO structure (see #02831,#02832), which
	      contains parameters of the JAM file to mount, and pointer
	      to the host drive DPB (i.e. DPB of the drive on which the
	      JAM file is located)
Return: AH = status (00h,02h,03h,08h,09h,0Dh) (see also #02835)
	    03h archive file cluster size value is larger than driver's - not
		  mounted
	    09h bad entries in JAM descriptor table - file mounted read-only
	AL = host drive error code (see #02598 at INT 2F/AX=0802h)
SeeAlso: AX=5203h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5203" name="2F5203"><b>2F5203</b></a> - INT 2F - JAM.SYS v1.10+ - "Detach" - UNMOUNT COMPRESSED DRIVE<br />
<pre>
INT 2F - JAM.SYS v1.10+ - "Detach" - UNMOUNT COMPRESSED DRIVE
	AX = 5203h
	DL = drive number (0-default, 1-A:, etc.) to detach
Return: AH = status (00h,01h,04h,05h,08h,09h,0Bh,0Dh) (see #02835)
	AL = host drive error code (see #02598 at INT 2F/AX=0802h)
SeeAlso: AX=5202h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5204" name="2F5204"><b>2F5204</b></a> - INT 2F - JAM.SYS v1.10+ - "Lock" - LOCK COMPRESSED DRIVE<br />
<pre>
INT 2F - JAM.SYS v1.10+ - "Lock" - LOCK COMPRESSED DRIVE
	AX = 5204h
	DL = drive number (0-default, 1-A:, etc.) to lock
Return: AH = status (00h,01h,04h,05h,08h,09h,0Bh,0Dh) (see #02835)
	AL = host drive error code (see #02598 at INT 2F/AX=0802h)
SeeAlso: AX=5205h, AX=5206h, AX=5207h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5205" name="2F5205"><b>2F5205</b></a> - INT 2F - JAM.SYS v1.10+ - "UnLock" - UNLOCK COMPRESSED DRIVE<br />
<pre>
INT 2F - JAM.SYS v1.10+ - "UnLock" - UNLOCK COMPRESSED DRIVE
	AX = 5205h
	DL = drive number (0-default, 1-A:, etc.) to unlock
Return: AH = status (00h,01h,04h,06h,08h,09h,0Dh) (see #02835)
	AL = host drive error code (see #02598 at INT 2F/AX=0802h)
SeeAlso: AX=5204h, AX=5206h, AX=5207h
Note:	Lock and UnLock functions were added to the JAM API to prevent
	  asynchronous physical-level access (see AX=5206h,AX=5207h) to
	  compressed data on JAM drives. In other words, two or more programs
	  which use JAM API (say, JMAX optimizer and JCHKDSK - disk checker)
	  cannot be run on the same JAM drive simultaneously.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5206" name="2F5206"><b>2F5206</b></a> - INT 2F - JAM.SYS v1.10+ - "Read" - PHYSICAL READ DATA FROM JAM ARCHIVE<br />
<pre>
INT 2F - JAM.SYS v1.10+ - "Read" - PHYSICAL READ DATA FROM JAM ARCHIVE
	AX = 5206h
	DL = drive number (0-default, 1-A:, etc.)
	DS:BX -&gt; disk transfer packet (see #02836)
Return: AH = status (00h,01h,04h,06h,07h,08h,0Dh) (see #02835)
	AL = host drive error code (see #02598 at INT 2F/AX=0802h)
Program: JAM.SYS is a main component of the JAM Real-Time Data Compression
	  Utilities by George A. Reznik and friends (JAM Software).
SeeAlso: AX=5207h

Format of disk transfer packet:
Offset	Size	Description	(Table 02836)
 00h	DWORD	sector number
 04h	WORD	number of sectors to read(write)
 06h	DWORD	transfer address

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5207" name="2F5207"><b>2F5207</b></a> - INT 2F - JAM.SYS v1.10+ - "Write" - PHYSICAL WRITE DATA TO JAM ARCHIVE<br />
<pre>
INT 2F - JAM.SYS v1.10+ - "Write" - PHYSICAL WRITE DATA TO JAM ARCHIVE
	AX = 5207h
	DL = drive number (0-default, 1-A:, etc.)
	DS:BX -&gt; disk transfer packet (see #02836)
Return: AH = status (00h,01h,04h,06h,07h,08h,0Dh) (see #02835)
	AL = host drive error code (see #02598 at INT 2F/AX=0802h)
SeeAlso: AX=5206h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F53" name="2F53"><b>2F53</b></a> - INT 2F U - POWER.EXE - APM event broadcasting???<br />
<pre>
INT 2F U - POWER.EXE - APM event broadcasting???
	AH = 53h
	AL = event???
	    05h CPU idle
	    0Bh PM event broadcast API
Return: ???
Note:	called by MS Windows 3.1 POWER.DRV; hooked by MS Mouse driver v8.20+
	  and PC-Cache v8.0
SeeAlso: AX=530Bh,AX=5400h,INT 33/AX=002Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F530B" name="2F530B"><b>2F530B</b></a> - INT 2F U - ??? (MOUSEPWR.COM, others) - ???<br />
<pre>
INT 2F U - ??? (MOUSEPWR.COM, others) - ???
	AX = 530Bh
	BX = subfunction
	    0003h ???
	    0004h ???
	???
Return: ???
Note:	it appears that subfunction 0003h reads or restores the current mouse
	  settings (the MS Mouse driver hooks AX=530Bh), and 0004h might be
	  the converse

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5400" name="2F5400"><b>2F5400</b></a> - INT 2F U - POWER.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F U - POWER.EXE - INSTALLATION CHECK
	AX = 5400h
Return: AX = POWER.EXE version (AH = major, AL = minor) if installed
	BX = 504Dh ("PM")
	CF clear
Note:	called by MS Windows 3.1 POWER.DRV
SeeAlso: AH=53h,AX=5401h,AX=5402h,AX=5481h,AX=5482h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5401" name="2F5401"><b>2F5401</b></a> - INT 2F U - POWER.EXE - GET/SET POWER STATUS<br />
<pre>
INT 2F U - POWER.EXE - GET/SET POWER STATUS
	AX = 5401h
	BH = function
	    00h get status
		Return: BL = current power management status (see #02837)
	    01h set status
		BL = new power managment status (see #02837)
Return: AX = function status (see #02838)
Note:	called by MS Windows 3.1 POWER.DRV
SeeAlso: AH=53h,AX=5400h,AX=5402h,AX=5403h

Bitfields for power management status:
Bit(s)	Description	(Table 02837)
 0	POWER.EXE power management enabled
 1	APM firmware power management enabled
 2-7	reserved (0)
Notes:	bit 1 is ignored if there is no APM firmware
	bits 1-0: 00 = POWER OFF, 10 = POWER STD, 11 = POWER ADV

(Table 02838)
Values for POWER.EXE function status:
 0000h	successful
 0002h	"ERROR_PM_ALREADY_CONNECTED"
 0003h	"ERROR_PM_NOT_CONNECTED"
 0087h	"ERROR_PM_INVALID_PARAMETER"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5402" name="2F5402"><b>2F5402</b></a> - INT 2F U - POWER.EXE - GET/SET IDLE DETECTION STRATEGY<br />
<pre>
INT 2F U - POWER.EXE - GET/SET IDLE DETECTION STRATEGY
	AX = 5402h
	BH = subfunction
	    00h get
	    other set
		BL = detection strategy (00h-0Fh or FFh)
Return: BX = current/new detection strategy
SeeAlso: AH=53h,AX=5400h,AX=5401h,AX=5481h,AX=5482h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5403" name="2F5403"><b>2F5403</b></a> - INT 2F U - POWER.EXE - GET/SET ADVANCED POWER MANAGEMENT SETTING<br />
<pre>
INT 2F U - POWER.EXE - GET/SET ADVANCED POWER MANAGEMENT SETTING
	AX = 5403h
	BX = new power management setting or 0000h to get current setting
Return: AX = status
	    0000h successful
		BX = power management setting (see #02839)
	    other error code
SeeAlso: AX=5401h,AX=5480h

(Table 02839)
Values for power management setting:
 0001h-0005h "min"
 0006h	     "reg"
 0007h-0008h "max"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5453" name="2F5453"><b>2F5453</b></a> - INT 2F - TesSeRact RAM-RESIDENT PROGRAM INTERFACE<br />
<pre>
INT 2F - TesSeRact RAM-RESIDENT PROGRAM INTERFACE
	AX = 5453h
	BX = subfunction
	    00h installation check
		CX = 0000h
		DS:SI -&gt; 8-char blank-padded name (see #02840)
		Return: AX = FFFFh installed
				CX = ID number of already-installed copy
			AX = anything else, not installed
				CX = ID number for TSR when installed
	    01h get user parameters
		CX = TSR ID number
		Return: AX = status
			    0000h successful
				ES:BX -&gt; user parameter block (see #02841)
			    nonzero failed
	    02h check if hotkey in use
		CL = scan code of hot key (see #00006)
		Return: AX = FFFFh hot key conflicts with another TSR
			     otherwise safe to use the hotkey
	    03h replace default critical error handler
		CX = TSR ID number
		DS:SI -&gt; new routine for INT 24h
		Return: AX = nonzero, unable to install new handler
	    04h get internal data area
		CX = TSR ID number
		Return: AX = status
			    0000h successful
				ES:BX -&gt; TSR's internal data area (see #02842)
			    nonzero, TSR not found
	    05h set multiple hot keys
		CX = TSR ID number
		DL = number of additional hot keys to allocate
		DS:SI -&gt; table of hot keys
			BYTE  hotkey scan code (see #00006)
			BYTE  hotkey shift state
			BYTE  flag value to pass to TSR (nonzero)
		Return: AX = nonzero, unable to install hot keys
	    06h - 0Fh reserved
	    10h enable TSR
		CX = TSR ID number
		Return: AX = nonzero, unable to enable
	    11h disable TSR
		CX = TSR ID number
		Return: AX = nonzero, unable to disable
	    12h unload TSR
		CX = TSR ID number
		Return: AX = nonzero, invalid TSR number
		Note: if any interrupts used by TSR have been grabbed by
			another TSR, the TesSeRact routines will wait until
			it is safe to remove the indicated TSR from memory
	    13h restart TSR
		CX = TSR ID number of TSR which was unloaded but is still in
		     memory
		Return: AX = nonzero, unable to restart TSR
	    14h get status word
		CX = TSR ID number
		Return: AX = FFFFh invalid ID number
			   = other, successful
				BX = bit flags
	    15h set status word
		CX = TSR ID number
		DX = new bit flags
		Return: AX = nonzero, unable to set status word
	    16h get INDOS state at popup
		CX = TSR ID number
		Return: AX = 0000h successful
			    BX = value of INDOS flag
	    17h - 1Fh reserved
	    20h call user procedure
		CX = TSR ID number
		ES:DI -&gt; user-defined data
		Return: AX = 0000h successful
	    21h stuff keystrokes into keyboard buffer
		CX = TSR ID number
		DL = speed
		    00h stuff keystrokes only when buffer is empty
		    01h stuff up to four keystrokes per clock tick
		    02h stuff up to 15 keystrokes per clock tick
		DH = scan code flag
		    if zero, buffer contains alternating ASCII and scan codes
		    if nonzero, buffer contains only ASCII codes
		SI = number of keystrokes
		ES:DI -&gt; buffer to stuff
		Return: AX = 0000h success
			     F0F0h user aborted with ^C or ^Break
			     other unable to stuff keystrokes
	    22h (v1.10) trigger popup
		CX = TSR ID number
		Return: AX = 0000h success, TSR will either pop up or beep to
				   indicate that it is unable to pop up
			     nonzero invalid ID number
	    23h (v1.10) invoke TSR's background function
		CX = TSR ID number
		Return: AX = 0000h success
			     FFFFh not safe to call background function
			     nonzero invalid ID number
	    24h - 2Fh reserved
Notes:	Borland's THELP.COM popup help system for Turbo Pascal and Turbo C
	  (versions 1.x and 2.x only) fully supports the TesSeRact API, as
	  do the SWAP?? programs by Innovative Data Concepts.
	AVATAR.SYS supports functions 00h and 01h (only the first three fields
	  of the user parameter block) using the name "AVATAR  "
SeeAlso: AX=CAFEh,INT 16/AX=55FFh,INT 2D"AMIS"
Index:	installation check;TesSeRact TSR interface|uninstall;TesSeRact

(Table 02840)
Values for TesSeRact names:
 "AVATAR  "	AVATAR.SYS
 "QeditTSR"	TSR version of SemWare's Qedit editor
 "SCRNBLNK"	Trusted Access screen blanker

Format of TesSeRact User Parameter Block:
Offset	Size	Description	(Table 02841)
 00h  8 BYTEs	blank-padded TSR name
 08h	WORD	TSR ID number
 0Ah	DWORD	bitmap of supported functions
 0Eh	BYTE	scan code of primary hotkey (see #00006)
		00h = pop up when shift states match
		FFh = no popup (if shift state also FFh)
 0Fh	BYTE	shift state of primary hotkey
		FFh = no popup (if scan code also FFh)
 10h	BYTE	number of secondary hotkeys
 11h	DWORD	pointer to extra hotkeys set by func 05h
 15h	WORD	current TSR status flags
 17h	WORD	PSP segment of TSR
 19h	DWORD	DTA for TSR
 1Dh	WORD	default DS for TSR
 1Fh	DWORD	stack at popup
 23h	DWORD	stack at background invocation
Index:	hotkeys;TesSeRact TSR interface

Format of TSR internal data area:
Offset	Size	Description	(Table 02842)
 00h	BYTE	revision level of TesSeRact library
 01h	BYTE	type of popup in effect
 02h	BYTE	INT 08 occurred since last invocation
 03h	BYTE	INT 13 occurred since last invocation
 04h	BYTE	active interrupts
 05h	BYTE	active soft interrupts
 06h	BYTE	DOS major version
 07h	BYTE	how long to wait before popping up
 08h	DWORD	pointer to INDOS flag
 0CH	DWORD	pointer to DOS critical error flag
 10h	WORD	PSP segment of interrupted program
 12h	WORD	PSP segment of prog interrupted by INT 28
 14h	DWORD	DTA of interrupted program
 18h	DWORD	DTA of program interrupted by INT 28
 1Ch	WORD	SS of interrupted program
 1Eh	WORD	SP of interrupted program
 20h	WORD	SS of program interrupted by INT 28
 22h	WORD	SP of program interrupted by INT 28
 24h	DWORD	INT 24 of interrupted program
 28h  3 WORDs	DOS 3.0+ extended error info
 2Eh	BYTE	old BREAK setting
 2Fh	BYTE	old VERIFY setting
 30h	BYTE	were running MS WORD 4.0 before popup
 31h	BYTE	MS WORD 4.0 special popup flag
 32h	BYTE	enhanced keyboard call in use
 33h	BYTE	delay for MS WORD 4.0
11 times (for INTs 08h,09h,13h,16h,1Ch,21h,28h,2Fh,1Bh,23h, and 24h):
	DWORD	old interrupt vector
	BYTE	interrupt number
	WORD	offset in TesSeRact code segment of new interrupt handler

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5480" name="2F5480"><b>2F5480</b></a> - INT 2F U - POWER.EXE - GET/SET ???<br />
<pre>
INT 2F U - POWER.EXE - GET/SET ???
	AX = 5480h
	BX = direction
	    0000h get
	    other set
	CX = size of buffer (at least 0010h)
	DS:SI -&gt; buffer
Return: AX = status
	    0000h successful
	    other error code
SeeAlso: AX=5400h,AX=5481h,AX=548Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5481" name="2F5481"><b>2F5481</b></a> - INT 2F U - POWER.EXE - GET STATISTICS<br />
<pre>
INT 2F U - POWER.EXE - GET STATISTICS
	AX = 5481h
	BX = which statistics
	    0000h idle detection
	    0001h APM statistics
	CX = length of buffer in bytes
	DS:SI -&gt; buffer for statistics (see #02843,#02844)
Return: AX = status
	    0000h successful
	    0071h "ERROR_PM_BUFFER_TOO_SMALL"
	    0087h "ERROR_PM_INVALID_PARAMETER"
SeeAlso: AH=53h,AX=5400h,AX=5480h,AX=5402h,AX=5482h

Format of POWER.EXE idle detection statistics:
Offset	Size	Description	(Table 02843)
 00h	DWORD	"CPU_ON_TIME" total time CPU is active with POWER.EXE idle
		  detection enabled, in timer ticks
 04h	DWORD	"CPU_IDLE_TIME" timer ticks during which CPU was idle
		(divide by previous to get idle	rate)
 08h	DWORD	total idle calls
 0Ch	DWORD	"TOTAL_APP_IDLE" total INT 2Fh idle calls
 10h	DWORD	"TOTAL_DOS_YIELD" total INT 28h idle calls
 14h	DWORD	"TOTAL_KEY_IDLE" total INT 16h idle calls
 18h	DWORD	"TOTAL_DOS_IDLE" total INT 2Ah idle calls

Format of APM statistics:
Offset	Size	Description	(Table 02844)
 00h	DWORD	"RESUME_COUNT" total number of resumes since last APM_ENABLE

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5482" name="2F5482"><b>2F5482</b></a> - INT 2F U - POWER.EXE - GET/SET APM POLLING FREQUENCY<br />
<pre>
INT 2F U - POWER.EXE - GET/SET APM POLLING FREQUENCY
	AX = 5482h
	BX = new polling frequency or 0000h to get current frequency
Return: AX = 0000h (successful)
	BX = current frequency if BX=0000h on entry
SeeAlso: AH=53h,AX=5400h,AX=5401h,AX=5480h,AX=5481h,AX=548Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F548F" name="2F548F"><b>2F548F</b></a> - INT 2F U - POWER.EXE - GET/SET ???<br />
<pre>
INT 2F U - POWER.EXE - GET/SET ???
	AX = 548Fh
	BX = ??? or 0000h to get current ???
Return: AX = 0000h (successful)
	BX = current ???
	CX = ???
SeeAlso: AX=5400h,AX=5480h,AX=5482h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5500" name="2F5500"><b>2F5500</b></a> - INT 2F U - DOS 5+ - COMMAND.COM INTERFACE<br />
<pre>
INT 2F U - DOS 5+ - COMMAND.COM INTERFACE
	AX = 5500h
Return: AX = 0000h if an instance of COMMAND.COM is already running
	DS:SI -&gt; entry point table
Notes:	used to access the shareable portion of COMMAND.COM, which may have
	  been moved into the HMA; only the primary COMMAND.COM retains this
	  portion
	procedures called from a dispatcher in COMMAND's resident portion;
	  most assume that the segment address of the resident portion is on
	  the stack and are thus not of general use
	DR PalmDOS up to DR-DOS 7.03 COMMAND.COM do not support this call.
	When loading the default command processor (no SHELL= directive in
	  CONFIG.SYS), MS-DOS 6.0-6.22 IO.SYS & PC DOS 6.1-2000 IBMBIO.COM
	  check a signature (see #04099) in the COMMAND.COM file image to test
	  if it is actually their own shell and has the correct version, before
	  they will launch it. If the signature is not found, the message
	  "Invalid COMMAND.COM" will be displayed. This test seems to have
	  vanished with MS-DOS 7+, as it uses an .EXE style file format.
	In addition to this, the MS-DOS/PC DOS COMMAND.COM checks the version
	  of the underlaying OS to see if it is their own. Hence, the
	  PC DOS 6.1 (and by SETVER version faking also the PC DOS 7 and 2000)
	  COMMAND.COM also run on Novell DOS 7 - DR DOS 7.03, which all
	  identify themselves as DOS API level 6.0 and IBM OEM (not yet tested
	  as primary shell).  PC DOS 5.0 COMMAND.COM should run on DR PalmDOS
	  (untested).
	The MS-DOS 7+ COMMAND.COM seems to no longer perform this kind of
	  version check any more, which can cause a serious deadlock situation
	  on a multi-boot system with DR-DOS installed, when the MS-DOS 7+
	  COMMAND.COM is placed in C:\. When IBMBIO.COM attempts to load the
	  MS-DOS 7+ COMMAND.COM as a primary shell under DR-OpenDOS 7.02 to
	  DR-DOS 7.03 no error message will be displayed by COMMAND.COM, but
	  the machine will just hang. To defuse this situation, DR-DOS 7.02+
	  IBMBIO.COM was changed to still scan for a SHELL= directive in
	  [D]CONFIG.SYS even in F5-mode. For maximum safety, the MS-DOS 7
	  COMMAND.COM should be moved from C:\ to C:\WINDOWS\COMMAND\
	  and a DCONFIG.SYS file should be created containing for example
	  SHELL=C:\DRDOS\COMMAND.COM instead. If a MS-DOS CONFIG.SYS file
	  exists, it should contain a SHELL=C:\WINDOWS\COMMAND\COMMAND.COM
	  directive. (If no shell can be found at all, DR-DOS IBMBIO.COM would
	  display a prompt to enter the proper path to COMMAND.COM).
	The DR-OpenDOS 7.02+ COMMAND.COM is designed to also run on 3rd party
	  operating systems like MS-DOS/PC DOS 3.31+, Windows 9x, and in DOS
	  boxes of OS/2, Windows NT and 2000, and will for example also take
	  advantage of long filenames.
SeeAlso: AX=5501h

Format of Microsoft COMMAND.COM file image signature:
Offset	Size	Description	(Table 04100)
 00h  3 BYTEs	E9h xxh xxh (JMP instruction)
 03h	BYTE	version
		bits 7-4: major version
		bits 3-0: minor version code
		( 60h for MS-DOS 6.0 and PC-DOS 6.1;
		  64h for MS-DOS 6.20, Japanese MS-DOS 6.2, Hangeul MS-DOS 6.2;
		  66h for MS-DOS 6.22, PRC (Chinese) MS-DOS 6.22;
		  70h for PC DOS 7, PC DOS 7 Y2K edition )
Notes:	Since DR DOS 6.0+, MS-DOS 7.0+, PTS-DOS, S/DOS, 4DOS/NDOS use an .EXE
	  style shell file format, this signature is not met by any release of
	  these shells. DR DOS 3.31-5.0 used a different jump (E8h) at offset
	  00h.
	Older releases of MS-DOS/PC DOS all had a jump (E9h) at offset 00h, but
	  other values at offset 03h. For reference here is a list of the
	  values for some of these older shells:
	    00h for PC DOS 1.10, Olivetti DOS 2.11, MS-DOS 5.0,
		  Russian MS-DOS 5.0
	    1Eh for MS-DOS 4.01
	    BAh for PC DOS 3.10, 3.20, MS-DOS 3.30

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5501" name="2F5501"><b>2F5501</b></a> - INT 2F U - DOS 5+ - ROM COMMAND.COM INTERFACE<br />
<pre>
INT 2F U - DOS 5+ - ROM COMMAND.COM INTERFACE
	AX = 5501h
Return: ???
Note:	used to determine whether the caller is the first instance of ROM
	  COMMAND.COM
SeeAlso: AX=5500h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5600" name="2F5600"><b>2F5600</b></a> - INT 2F - INTERLNK - INSTALLATION CHECK<br />
<pre>
INT 2F - INTERLNK - INSTALLATION CHECK
	AX = 5600h
	DX = magic value FFFFh
	BL = instance number (00h = any, 01h = first loaded, etc.)
	(BH = 00h and CX = 0000h, see note)
Return: AL = FFh if installed
	    BL = instance number
	    CX = version number (CL = major, CH = minor)
	    DX = resident CS of driver, DX:0000h -&gt; header (see #02845)
Notes:	INTERLNK was derived from Sewell Development Corporation's FASTLYNX.
	Some Microsoft software explicitly clears the BH and CX registers
	  before calling this function.
BUG:	reportedly, the MS-DOS INTERSRV program (though not INTERLNK) causes
	  serious FAT corruption and data loss when run under Novell DOS 7.
	  INTERSRV apparently checks for DR-DOS by testing the "OS"
	  environment variable for the value "DRDOS", which is no longer
	  correct for PalmDOS, Novell DOS, or OpenDOS.  A workaround may be
	  to explicitly set the OS variable to "DRDOS".
SeeAlso: AX=5601h,AX=5602h,INT 60/AX=0000h

Format of Interlnk device driver header:
Offset	Size	Description	(Table 02845)
 00h	DWORD	pointer to next driver, offset=FFFFh if last driver
 04h	WORD	device attributes (see #01647,#01648)
 06h	WORD	device strategy entry point
 08h	WORD	device interrupt entry point
 0Ah  8 BYTEs	character device name "NUL2    "
 12h 165 BYTEs	???
 B7h 67 BYTEs	fully qualified Interlnk filename
 FAh  6 BYTEs	???
100h	DWORD	pointer back to Interlnk filename at offset B7h
104h  8 BYTEs	???
10Ch	BYTE	total number of redirected drives
10Dh	BYTE	first local drive number (0=A:)
10Eh	BYTE	printer redirection (0=no, 1=yes)
10Fh	BYTE	???
110h  3	BYTEs	LPT1...3 status (0FFh=invalid)
113h 26 BYTEs	remote drive number (0=A:, 0FEh=unused) (refer to note below)
12Dh 26 BYTEs	always 0FEh ???
147h 26 BYTEs	always 0FFh ???
Note:	to obtain the remote drive number, subtract the value at offset 10Ch
	  from the local drive number before indexing into the table at 113h
	  (example: if local drives F, G, H are remote drives C, F, E then
	  the first three bytes at offset 113h are 02h, 05h, 04h)
	for each instance of Interlnk, an extra device driver is loaded, but
	  all have the same device name NUL2
SeeAlso: #01646 at INT 21/AH=52h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5601" name="2F5601"><b>2F5601</b></a> - INT 2F - INTERLNK - CHECK IF REDIRECTED DRIVE<br />
<pre>
INT 2F - INTERLNK - CHECK IF REDIRECTED DRIVE
	AX = 5601h
	DX = magic value FFFFh
	BH = drive number (0=A:)
	BL = instance number (00h=any, 01h=first loaded, etc.)
	(CX = 0000h, see note)
Return: (as for AL=00h if redirected drive)
Note:	some Microsoft software explicitly clears the CX register before
	  calling this function.
SeeAlso: AX=5600h,AX=5601h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5602" name="2F5602"><b>2F5602</b></a> - INT 2F - INTERLNK - CHECK IF PORT IN USE<br />
<pre>
INT 2F - INTERLNK - CHECK IF PORT IN USE
	AX = 5602h
	DX = magic value FFFFh
	BL = instance number (00h=any, 01h=first loaded, etc.)
	CX = base port address of COM / LPT port to check
Return: (as for AL=00h if port in use for a redirected drive)
SeeAlso: AX=5600h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5700" name="2F5700"><b>2F5700</b></a> - INT 2F U - IOMEGA DRIVERS - INSTALLATION CHECK<br />
<pre>
INT 2F U - IOMEGA DRIVERS - INSTALLATION CHECK
	AX = 5700h
	BX = program ID??? (0201h used by GUEST.EXE)
	DX = 496Fh ('Io')
Return: AL = status
	    00h not installed
	    FFh installed
SeeAlso: AX=5701h,AX=5710h,AX=5711h,AX=5712h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5701" name="2F5701"><b>2F5701</b></a> - INT 2F U - IOMEGA DRIVERS - SECONDARY INSTALLATION CHECK<br />
<pre>
INT 2F U - IOMEGA DRIVERS - SECONDARY INSTALLATION CHECK
	AX = 5701h
	BX = program ID??? (0201h used by GUEST.EXE)
	DX = 496Fh ('Io')
Return: AX = 0001h if GUEST.EXE installed
SeeAlso: AX=5700h,AX=5710h,AX=5711h,AX=5712h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5710" name="2F5710"><b>2F5710</b></a> - INT 2F U - IOMEGA DRIVERS - GET DRIVER INFORMATION???<br />
<pre>
INT 2F U - IOMEGA DRIVERS - GET DRIVER INFORMATION???
	AX = 5710h
	BX = program ID??? (0201h used by GUEST.EXE)
	DX = 496Fh ('Io')
Return: AX = ??? (BX ORed with ???)
	BX = ??? (internal variable)
	CX = ??? (internal variable)
	DX = ??? (CX ORed with ???)
SeeAlso: AX=5700h,AX=5701h,AX=5711h,AX=5712h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5711" name="2F5711"><b>2F5711</b></a> - INT 2F U - IOMEGA DRIVERS - LOCK MEDIA IN DRIVE<br />
<pre>
INT 2F U - IOMEGA DRIVERS - LOCK MEDIA IN DRIVE
	AX = 5711h
	BX = program ID??? (0201h used by GUEST.EXE)
	DX = 496Fh ('Io')
Return: CF clear if successful (storage medium in drive)
	    AX = new lock count
	CF set on error (drive empty)
SeeAlso: AX=5700h,AX=5701h,AX=5710h,AX=5712h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5712" name="2F5712"><b>2F5712</b></a> - INT 2F U - IOMEGA DRIVERS - UNLOCK MEDIA IN DRIVE / EJECT<br />
<pre>
INT 2F U - IOMEGA DRIVERS - UNLOCK MEDIA IN DRIVE / EJECT
	AX = 5712h
	BX = program ID??? (0201h used by GUEST.EXE)
	DX = 496Fh ('Io')
Return: AX = new lock count (00h = unlocked)
Note:	if the lock count was already zero, the storage medium is ejected
	  from the drive
SeeAlso: AX=5700h,AX=5701h,AX=5710h,AX=5711h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5758BX4858" name="2F5758BX4858"><b>2F5758BX4858</b></a> - INT 2F U - Helix Multimedia Cloaking - CACHECLK - INSTALLATION CHECK<br />
<pre>
INT 2F U - Helix Multimedia Cloaking - CACHECLK - INSTALLATION CHECK
	AX = 5758h
	BX = 4858h ('HX')
	DX = 4443h ('DC')
	CX &lt;&gt; 5758h
Return: BX = 6878h if installed
	DX = 6463h if installed
	   CX = version (CH=major,CL=minor)
Program: CACHECLK is a 'Cloaked' disk cache by Helix Software
Note:	returns with registers unchanged if CX=5758h on entry
SeeAlso: INT 16/AX=5758h/BX=4858h,INT 2F/AX=4310h"Cloaking"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5D00" name="2F5D00"><b>2F5D00</b></a> - INT 2F U - PCMCIA - AWARD PCDISK - GET INFO FROM DRIVER ???<br />
<pre>
INT 2F U - PCMCIA - AWARD PCDISK - GET INFO FROM DRIVER ???
	AX = 5D00h
Return: ES:BX -&gt; ???
Note:	supported by Ventura Micro / Award PCDISK.EXE v1.02c PCMCIA/ATA driver
SeeAlso: AX=5D01h,INT 21/AX=440Dh"DOS 3.2+"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F5D01" name="2F5D01"><b>2F5D01</b></a> - INT 2F U - PCMCIA - AWARD PCDISK - PUT INFO INTO DRIVER ???<br />
<pre>
INT 2F U - PCMCIA - AWARD PCDISK - PUT INFO INTO DRIVER ???
	AX = 5D01h
	ES:BX -&gt; ???
Return: nothing
Note:	supported by Ventura Micro / Award PCDISK.EXE v1.02c PCMCIA/ATA driver
SeeAlso: AX=5D00h,INT 21/AX=440Dh"DOS 3.2+"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F60FFDL00" name="2F60FFDL00"><b>2F60FFDL00</b></a> - INT 2F U - IPLAY v1.00b - INSTALLATION CHECK<br />
<pre>
INT 2F U - IPLAY v1.00b - INSTALLATION CHECK
	AX = 60FFh
	DL = 00h (function number)
	BX = 5344h ('SD')
	CX = 4D50h ('MP')
Return: AX = 4F4Bh ('OK') if installed
Program: IPLAY is the Inertia Player by Prime and Excalibur for .MODules
	  (digitized music files)
Note:	in version 1.00b, any value for DL except 01h invokes this function
SeeAlso: AX=60FFh/DL=01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F60FFDL01" name="2F60FFDL01"><b>2F60FFDL01</b></a> - INT 2F U - IPLAY v1.00b - GET DATA SEGMENT<br />
<pre>
INT 2F U - IPLAY v1.00b - GET DATA SEGMENT
	AX = 60FFh
	DL = 01h (function number)
	BX = 5344h ('SD')
	CX = 4D50h ('MP')
Return: AX = data segment
Program: IPLAY is the Inertia Player by Prime and Excalibur for .MODules
	  (digitized music files)
SeeAlso: AX=60FFh/DL=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F6282" name="2F6282"><b>2F6282</b></a> - INT 2F U - PC Tools v7.0+ VDEFEND, VSAFE, VWATCH, DATAMON - SET ??? ADDRESS<br />
<pre>
INT 2F U - PC Tools v7.0+ VDEFEND, VSAFE, VWATCH, DATAMON - SET ??? ADDRESS
	AX = 6282h
	CX:DX -&gt; ??? or 0000h:0000h
	DI = segment of ??? record (see #02846) or 0000h/FFFFh to ignore
Return: BX = 0062h
Note:	if CX:DX = 0000h:0000h on entry, the ??? address is not changed
	  (DATAMON only)
SeeAlso: INT 13/AH=FAh"VSAFE",INT 21/AH=FAh"VDEFEND"

Format of VSAFE/VWATCH record:
Offset	Size	Description	(Table 02846)
 00h	DWORD	???
 04h	WORD	offset of ??? in record's segment
		VSAFE 2.0 sets byte at +01h to 56h or 58h
		VWATCH 2.1 sets byte at +02h to 56h or 58h
 06h  2 BYTEs	???
 08h	BYTE	??? (01h/other)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F6284BX0000" name="2F6284BX0000"><b>2F6284BX0000</b></a> - INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT	- INSTALLATION CHECK<br />
<pre>
INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT	- INSTALLATION CHECK
	AX = 6284h
	BX = 0000h
	CX = 0000h
Return: AX = segment of resident code
	BX = 5555h
	CX = 5555h
Note:	also supported by DOS 6 UNDELETE which is licensed from PC Tools
SeeAlso: AX=6284h/BX=0001h,INT 16/AX=FFA3h/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F6284BX0001" name="2F6284BX0001"><b>2F6284BX0001</b></a> - INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT - GET ???<br />
<pre>
INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT - GET ???
	AX = 6284h
	BX = 0001h
	CX = 0001h
Return: AX:BX -&gt; ??? data (see #02847)
	CX = BX
SeeAlso: AX=6284h/BX=0000h

Format of DPROTECT data for v9.0:
Offset	Size	Description	(Table 02847)
 00h  5 BYTEs	???
 05h	WORD	resident code segment (may be segment of DWORD at +03h)
 07h	DWORD	-&gt; FAR function to sound alert tone
	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F6284BX0002" name="2F6284BX0002"><b>2F6284BX0002</b></a> - INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT - GET OPTIONS<br />
<pre>
INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT - GET OPTIONS
	AX = 6284h
	BX = 0002h
	CX = 0002h
Return: AX = options (see #02848)
	BX = ??? (0000h for v9)
	CX = AX
	DX = BX
Note:	also supported by DOS 6 UNDELETE which is licensed from PC Tools
SeeAlso: AX=6284h/BX=0000h,AX=6284h/BX=0003h

Bitfields for DATAMON/DPROTECT options:
Bit(s)	Description	(Table 02848)
 1	???
 12	disabled
 13	using Delete Sentry
 14	using Delete Tracker

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F6284BX0003" name="2F6284BX0003"><b>2F6284BX0003</b></a> - INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT - SET OPTION??? FLAGS<br />
<pre>
INT 2F U - PC Tools v7-8 DATAMON, v9+ DPROTECT - SET OPTION??? FLAGS
	AX = 6284h
	BX = 0003h
	CX = flags (see #02849)
	DX = flags
	    bit 15: ???
Note:	v9 DPROTECT only checks bit 12 of CX, and ignores DX entirely
SeeAlso: AX=6284h/BX=0002h

Bitfields for DATAMON/DPROTECT CX flags:
Bit(s)	Description	(Table 02849)
 3	???
 5	???
 10	???
 12	disable DATAMON/DPROTECT

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F6284BX0004" name="2F6284BX0004"><b>2F6284BX0004</b></a> - INT 2F U - PC Tools v8 DATAMON, v9+ DPROTECT - ???<br />
<pre>
INT 2F U - PC Tools v8 DATAMON, v9+ DPROTECT - ???
	AX = 6284h
	BX = 0004h
	CX = 0004h
Return: AX = 5555h
	BX = ??? (0800h)
	CX = ??? (FCCCh for v8, FCCBh for v9)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F6400" name="2F6400"><b>2F6400</b></a> - INT 2F - SCRNSAV2.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - SCRNSAV2.COM - INSTALLATION CHECK
	AX = 6400h
Return: AL = installation state
	    00h not installed
	    FFh installed
Program: SCRNSAV2.COM is a screen saver for PS/2s with VGA by Alan Ballard
SeeAlso: INT 10/AX=5555h,INT 14/AX=AA01h
Index:	screen saver;SCRNSAV2

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7000" name="2F7000"><b>2F7000</b></a> - INT 2F - License Service API - INSTALLATION CHECK<br />
<pre>
INT 2F - License Service API - INSTALLATION CHECK
	AX = 7000h
	CX = license server index (0000h to 001Fh)
Return: AL = status
	    00h not installed
	    FFh installed
Notes:	The License Service API is being maintained by Microsoft but is being
	  supported by a large number of companies including Apple, Banyan,
	  DEC, HP, Lotus, Microsoft, Novell, Software Publishers Association,
	  and Wordperfect (not a complete list!)
	Each license service provider must search for the next free index
	  slot to use
SeeAlso: AX=7001h,AX=7003h,AX=7004h,AX=7005h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7001" name="2F7001"><b>2F7001</b></a> - INT 2F - License Service API - REQUEST LICENSE<br />
<pre>
INT 2F - License Service API - REQUEST LICENSE
	AX = 7001h
	CX = license server index (0000h to 001Fh)
	DS:DX -&gt; SLSREQUEST structure (see #02850)
Return: AX = status
	    0000h success
	    else  provider error code
	ES:BX = provider specific handle for the license context
SeeAlso: AX=7002h,AX=7004h,AX=7005h

Format of License Service SLSREQUEST structure:
Offset	Size	Description	(Table 02850)
 00h	DWORD	(ret) status code
 04h	DWORD	(ret) handle identifying context
 08h	DWORD	(call) address of Publisher string
 0Ch	DWORD	(call) address of Product string
 10h	DWORD	(call) address of Version string
 14h	DWORD	units required
 18h	DWORD	address of comment string
 1Ch	DWORD	address of SLSCHALLENGE structure (see #02851)

Format of License Service SLSCHALLENGE structure:
Offset	Size	Description	(Table 02851)
 00h	DWORD	algorithm (currently always 1)
 04h	DWORD	secret to be challenged (1-255)
 08h	DWORD	size of challenge in bytes (1-255)
 0Ch  N BYTEs	challenge data

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7002" name="2F7002"><b>2F7002</b></a> - INT 2F - License Service API - RELEASE LICENSE<br />
<pre>
INT 2F - License Service API - RELEASE LICENSE
	AX = 7002h
	CX = license server index (0000h to 001Fh)
	DS:DX -&gt; SLSRELEASE structure (see #02852)
	ES:BX = provider specific handle for the license context
Return: AL = status
	    00h not installed
	    FFh installed
SeeAlso: AX=7001h,AX=7005h

Format of License Service SLSRELEASE structure:
Offset	Size	Description	(Table 02852)
 00h	DWORD	handle indentifying license context
 04h	DWORD	total units consumed
 08h	DWORD	address of comment string

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7003" name="2F7003"><b>2F7003</b></a> - INT 2F - License Service API - UPDATE<br />
<pre>
INT 2F - License Service API - UPDATE
	AX = 7003h
	CX = license server index (0000h to 001Fh)
	DS:DX -&gt; SLSUPDATE structure (see #02853)
	ES:BX = provider specific handle for the license context
Return: AL = status
	    00h not installed
	    FFh installed
SeeAlso: AX=7004h,AX=7005h

Format of License Service SLSUPDATE structure:
Offset	Size	Description	(Table 02853)
 00h	DWORD	(ret) status code
 04h	DWORD	(call) handle identifying license context
 08h	DWORD	(call) total units consumed
 0Ch	DWORD	additional units required
 10h	DWORD	address of comment string
 14h	DWORD	address of SLSCHALLENGE structure (see #02851)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7004" name="2F7004"><b>2F7004</b></a> - INT 2F - License Service API - GET ERROR<br />
<pre>
INT 2F - License Service API - GET ERROR
	AX = 7004h
	CX = license server index (0000h to 001Fh)
	DS:DX -&gt; SLSGETERROR structure (see #02854)
	ES:BX = provider specific handle for the license context
Return: AL = status
	    00h not installed
	    FFh installed
SeeAlso: AX=7000h,AX=7001h

Format of License Service SLSGETERROR structure:
Offset	Size	Description	(Table 02854)
 00h	DWORD	(ret) status code
 04h	DWORD	handle identifying license context
 08h	DWORD	error code
 0Ch	DWORD	buffer size in bytes
 10h  N BYTEs	data buffer

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7005" name="2F7005"><b>2F7005</b></a> - INT 2F - License Service API - QUERY LICENSE<br />
<pre>
INT 2F - License Service API - QUERY LICENSE
	AX = 7005h
	CX = license server index (0000h to 001Fh)
	DS:DX -&gt; SLSQUERY structure (see #02855)
	ES:BX = provider specific handle for the license context
Return: AL = status
	    00h not installed
	    FFh installed
SeeAlso: AX=7001h,AX=7002h

Format of License Service SLSQUERY structure:
Offset	Size	Description	(Table 02855)
 00h	DWORD	(ret) status code
 04h	DWORD	handle identifying license context
 08h	DWORD	information index
 0Ch	DWORD	buffer size in bytes
 10h  N BYTEs	data buffer

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7041BX4B70" name="2F7041BX4B70"><b>2F7041BX4B70</b></a> - INT 2F U - HP 200LX - KEY200 - INSTALLATION CHECK<br />
<pre>
INT 2F U - HP 200LX - KEY200 - INSTALLATION CHECK
	AX = 7041h
	BX = 4B70h
Return: BX = 7965h if keyboard remapper KEY200.COM installed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7200" name="2F7200"><b>2F7200</b></a> - INT 2F - SRDISK v1.30+ - INSTALLATION CHECK<br />
<pre>
INT 2F - SRDISK v1.30+ - INSTALLATION CHECK
	AX = 7200h
Return: AL = FFh if installed
	    ES = segment of device driver header (see #02856)
Program: SRDISK is a freeware resizeable RAMdisk by Marko Kohtala
SeeAlso: AX=7201h

Format of SRDISK device driver header:
Offset	Size	Description	(Table 02856)
 00h 10 BYTEs	same as standard device driver header
		  (see #01646 at INT 21/AH=52h)
 0Ah	BYTE	number of subunits (drives) supported by driver
 0Bh  3 BYTEs	signature "SRD"
 0Eh  4 BYTEs	memory type string ("XMS "/"EMS ")
 12h  4 BYTEs	ASCII driver version string "N.NN"
 16h	BYTE	00h
 17h	BYTE	configuration format version (currently 00h or 01h)
 18h	WORD	offset of drive configuration data
SeeAlso: #01646

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7201" name="2F7201"><b>2F7201</b></a> - INT 2F - SRDISK v2.02 - GET CODE/DATA SEGMENT<br />
<pre>
INT 2F - SRDISK v2.02 - GET CODE/DATA SEGMENT
	AX = 7201h
Return: AL = FFh if installed
	    ES = segment of device driver header (see #02856)
Program: SRDISK is a freeware resizeable RAMdisk by Marko Kohtala
SeeAlso: AX=7200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A00" name="2F7A00"><b>2F7A00</b></a> - INT 2F - Novell NetWare - LOW-LEVEL API (IPX) INSTALLATION CHECK<br />
<pre>
INT 2F - Novell NetWare - LOW-LEVEL API (IPX) INSTALLATION CHECK
	AX = 7A00h
Return: AL = status
	    00h not installed
	    FFh installed
		ES:DI -&gt; FAR entry point for routines accessed exclusively
			  through INT 7A in NetWare versions through 2.0a.
			  Call with same values as INT 7A
		ES:BX -&gt; two bytes containing IPX major/minor version
			(IPXODI v2.12; BX unchanged by older IPX drivers)
		CX = ES ???
SeeAlso: AX=7AFFh/BX=0000h,AX=D800h,INT 64"Novell",INT 7A"LOW-LEVEL API"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A10" name="2F7A10"><b>2F7A10</b></a> - INT 2F U - Novell NetWare - TBMI v1.1+ - GET TBMI STATUS<br />
<pre>
INT 2F U - Novell NetWare - TBMI v1.1+ - GET TBMI STATUS
	AX = 7A10h
Return: DH = major TBMI version number
	DL = minor TBMI version number (01h for v1.1)
	CX = segment address of TBMI resident part
	BX = status word of TBMI (see #02857)
Note:	TBMI is the Task-Switched Buffer Manager Interface
SeeAlso: AX=7A11h,AX=7A12h,AX=7A13h,AX=7A14h

Bitfields for NetWare TBMI status word:
Bit(s)	Description	(Table 02857)
 0	INT2F intercepted by TBMI
 1	INT7A intercepted by TBMI
 2	INT64 intercepted by TBMI
 3-14	reserved or unused ???
 15	outstanding task ID was detected

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A11" name="2F7A11"><b>2F7A11</b></a> - INT 2F U - Novell NetWare - TBMI v1.1+ - GET INT2F HANDLERS<br />
<pre>
INT 2F U - Novell NetWare - TBMI v1.1+ - GET INT2F HANDLERS
	AX = 7A11h
Return: ES:BX -&gt; old INT 2F handler
	DS:DX -&gt; TBMI INT 2F handler
SeeAlso: AX=7A10h,AX=7A12h,AX=7A13h,AX=7A1Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A12" name="2F7A12"><b>2F7A12</b></a> - INT 2F U - Novell NetWare - TBMI v1.1+ - GET INT64 HANDLERS<br />
<pre>
INT 2F U - Novell NetWare - TBMI v1.1+ - GET INT64 HANDLERS
	AX = 7A12h
Return: ES:BX -&gt; old INT 64 handler
	DS:DX -&gt; TBMI INT 64 handler
SeeAlso: AX=7A10h,AX=7A11h,AX=7A13h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A13" name="2F7A13"><b>2F7A13</b></a> - INT 2F U - Novell NetWare - TBMI v1.1+ - GET INT7A HANDLERS<br />
<pre>
INT 2F U - Novell NetWare - TBMI v1.1+ - GET INT7A HANDLERS
	AX = 7A13h
Return: ES:BX -&gt; old INT 7A handler
	DS:DX -&gt; TBMI INT 7A handler
SeeAlso: AX=7A10h,AX=7A11h,AX=7A12h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A14" name="2F7A14"><b>2F7A14</b></a> - INT 2F U - Novell NetWare - TBMI v1.1+ - GET STATISTICS<br />
<pre>
INT 2F U - Novell NetWare - TBMI v1.1+ - GET STATISTICS
	AX = 7A14h
	CX = statistic to retrieve
	    0000h available diagnostic functions???
		Return: CX = maximum available function??? (000Ch for v2.0)
	    0001h buffers in use
		Return: CX = TBMI buffers currently in use
	    0002h maximum buffers used
		Return: CX = maximum number of buffers ever in use
	    0003h unavailable buffers
		Return: CX = count of unavailable TBMI buffers
	    0004h old interrupt usage
		Return: CX = TBMI accesses to intercepted old vectors INT 2F,
			      INT 64, and INT 7A
	    0005h far call usage
		Return: CX = TBMI accesses to IPX/SPX far call handler (not
			      including internal accesses)
	    0006h task buffering
		Return: CX = TBMI task buffering status (enabled/disabled or
			      disable/enable switch count???)
	    0007h current task ID
		Return: CX = TBMI current task ID number (0000h if ???)
	    0008h outstanding ID count
		Return: CX = number of outstanding TBMI IDs
	    0009h configured ECBs
		Return: CX = number of TBMI Event Control Blocks configured
	    000Ah configured data ECBs
		Return: CX = number of TBMI data ECBs configured
	    000Bh configured sockets
		Return: CX = number of TBMI sockets configured (from NETCFG)
	    000Ch current sockets
		Return: CX = number of TBMI sockets currently in use
Return: BX = maximum supported subfunction (000Ch)
SeeAlso: AX=7A10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A15" name="2F7A15"><b>2F7A15</b></a> - INT 2F OU - Novell NetWare - TBMI v1.1 only - RESET ???<br />
<pre>
INT 2F OU - Novell NetWare - TBMI v1.1 only - RESET ???
	AX = 7A15h
Return: BX = new value of ???
Desc:	set ??? to its default value
Note:	this call is a NOP under TBMI v2.0 (TBMI2)
SeeAlso: AX=7A17h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A16" name="2F7A16"><b>2F7A16</b></a> - INT 2F OU - Novell NetWare - TBMI v1.1 only - ???<br />
<pre>
INT 2F OU - Novell NetWare - TBMI v1.1 only - ???
	AX = 7A16h
	CX = ???
	???
Return: ???
Note:	this call is a NOP under TBMI v2.0 (TBMI2)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A17" name="2F7A17"><b>2F7A17</b></a> - INT 2F OU - Novell NetWare - TBMI v1.1 only - ???<br />
<pre>
INT 2F OU - Novell NetWare - TBMI v1.1 only - ???
	AX = 7A17h
	???
Return: BX = old value of ???
	CX = new value of ???
Note:	this call is a NOP under TBMI v2.0 (TBMI2)
SeeAlso: AX=7A15h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A18" name="2F7A18"><b>2F7A18</b></a> - INT 2F U - Novell NetWare - TASKID v1.0 - INSTALLATION CHECK<br />
<pre>
INT 2F U - Novell NetWare - TASKID v1.0 - INSTALLATION CHECK
	AX = 7A18h
Return: AL = FFh if installed
	    BX = configuration flags (see #02858)
	    CX = resident code segment
SeeAlso: AX=7A10h

Bitfields for NetWare TASKID configuration flags:
Bit(s)	Description	(Table 02858)
 0	INT 2F hooked
 3	INT 08 hooked
 other	unused

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A19" name="2F7A19"><b>2F7A19</b></a> - INT 2F U - Novell NetWare - TASKID v1.0 - GET INT 08 HANDLERS<br />
<pre>
INT 2F U - Novell NetWare - TASKID v1.0 - GET INT 08 HANDLERS
	AX = 7A19h
Return: AL = FFh
	DS:DX -&gt; TASKID INT 08 handler
	ES:BX -&gt; original INT 08 handler

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A1A" name="2F7A1A"><b>2F7A1A</b></a> - INT 2F U - Novell NetWare - TASKID v1.0 - GET INT 2F HANDLERS<br />
<pre>
INT 2F U - Novell NetWare - TASKID v1.0 - GET INT 2F HANDLERS
	AX = 7A1Ah
Return: AL = FFh
	DX:DX -&gt; TASKID INT 2F handler
	ES:BX -&gt; original INT 2F handler
SeeAlso: AX=7A11h,AX=7A19h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A1B" name="2F7A1B"><b>2F7A1B</b></a> - INT 2F U - Novell NetWare - TASKID v1.0 - GET DIAGNOSTICS INFORMATION<br />
<pre>
INT 2F U - Novell NetWare - TASKID v1.0 - GET DIAGNOSTICS INFORMATION
	AX = 7A1Bh
	CX = desired information
	    0000h supported functions
	    0001h TASKID ID number
		Return: CX = ID number
	    0002h set-ID count
		Return: CX = ID set count
Return: AL = FFh
	BX = highest supported subfunction number (0002h)
SeeAlso: AX=7A14h,AX=7A18h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A1C" name="2F7A1C"><b>2F7A1C</b></a> - INT 2F U - Novell NetWare - TBMI v1.1+ - ???<br />
<pre>
INT 2F U - Novell NetWare - TBMI v1.1+ - ???
	AX = 7A1Ch
	BP = ???
	CX:DX = ???
Return: AX = 70FFh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A1D" name="2F7A1D"><b>2F7A1D</b></a> - INT 2F U - Novell NetWare - TBMI v1.1+ - ???<br />
<pre>
INT 2F U - Novell NetWare - TBMI v1.1+ - ???
	AX = 7A1Dh
	???
Return: ES = ???
	???
	SI destroyed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A1E" name="2F7A1E"><b>2F7A1E</b></a> - INT 2F U - Novell NetWare - TBMI v1.1+ - ???<br />
<pre>
INT 2F U - Novell NetWare - TBMI v1.1+ - ???
	AX = 7A1Eh
	ES:SI -&gt; ???
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0000" name="2F7A20BX0000"><b>2F7A20BX0000</b></a> - INT 2F - Novell NetWare - Adv NetWare 4.0 DOS Requester - GET VLM CALL ADDRESS<br />
<pre>
INT 2F - Novell NetWare - Adv NetWare 4.0 DOS Requester - GET VLM CALL ADDRESS
	AX = 7A20h
	BX = 0000h
Return: AX = 0000h on success (installed)
	    ES:BX -&gt; far call address for DOS Requester (see #02859)
Notes:	the DOS Requester replaces the NetWare Shell (ANETx, NETx) on
	  NetWare LAN's as of the release of Advanced NetWare 4.0 (1993).  It
	  is backward compatible with NetWare 2.1x through 3.11 servers as
	  well.	 Note that there was a NetWare 4.0 in the early 1980's, which
	  can cause confusion.
	this call is used as the installation check by VLM.EXE, which is the
	  loader for all the modules of the DOS Requester
	.VLMs are standard old .EXE format executables whose normal entry point
	  merely terminates to prevent loading from the command line (Novell's
	  VLMs all return errorlevel 6).  The real entry point is found by
	  looking at the VLM header at the beginning of the load image
	  (see #02862)
Index:	installation check;NetWare 4.0 DOS Requester
SeeAlso: AX=7A20h/BX=0001h,AX=7A20h/BX=0002h

(Table 02859)
Call DOS Requester entry point with:
	STACK:	WORD	destination function
		WORD	destination VLM ID (see #02861)
		WORD	source VLM ID (0000h = application program)
	other registers (except BP) as appropriate for function
Return: AX = status code (0000h,8811h,8846h,8848h,8853h) (see #02860)
	ZF set if successful, clear on error
	other registers as appropriate for function
	STACK popped
	BP destroyed

(Table 02860)
Values for VLM status code:
 0000h	successful
 88xxh	error generated by requester
 8801h	invalid or non-attached connection handle
 8802h	drive in use (OS/2 only)
 8803h	cannot add CDS
 8804h	bad path
 8805h	error sending or receiving NCP packets
 8806h	unknown network error
 8807h	invalid server connection slot
 8808h	no connection slots available
 880Ah	no route to server
 880Bh	"BAD_LOCAL_TARGET" (OS/2 only)
 880Ch	too many request fragments
 880Dh	"CONNECT_LIST_OVERFLOW" (OS/2 only)
 880Eh	buffer overflow on receive
 880Fh	no connection to server
 8810h	no router found (OS/2 only)
 8811h	nonexistent function called
 8830h	internal server request attempted between two separate connections
 8831h	no primary connection set
 8833h	invalid buffer length
 8834h	invalid user name
 8835h	no local print spooler installed
 8836h	attempted function with invalid parameter
 8837h	failed to open configuration file (OS/2 only)
 8838h	no configuration file (OS/2 only)
 8839h	configuration file read failed (OS/2 only)
 883Ah	line too long in configuration file (OS/2 only)
 883Bh	configuration lines ignored (OS/2 only)
 883Ch	foreign resource
 883Dh	daemon already installed (OS/2 only)
 883Eh	print spooler already installed
 883Fh	local connection table already full
 8840h	configuration section not found (OS/2 only)
 8841h	invalid transport type
 8842h	TDS tag in use (OS/2 only)
 8843h	TDS out of memory (OS/2 only)
 8844h	called TDS function with invalid tag
 8845h	TDS write was truncated
 8846h	called partially asynchronous function while it was busy
 8847h	unable to find any responding servers
 8848h	non-loaded or nonexistent VLM called
 8849h	network drive already mapped
 884Ah	attempted map to local drive which was already in use
 884Bh	no more drives available for mapping
 884Ch	device is not redirected
 884Dh	no more SFT entries (too many handles)
 884Eh	unable to unload
 884Fh	connection entry was already in use
 8850h	too many reply fragments
 8851h	name table already full
 8852h	socket not open
 8853h	memory management error
 8854h	SFT III switch occurred in mid-transfer
 8855h	preferred server was not found (alternate returned)
 8856h	device not recognized
 8857h	bad network byte
 88A0h	memory allocation error
 88A1h	connection timeout failure
 88A2h	transport: bad request
 88A3h	specified transport not installed
 88A4h	unable to open connection with specified parameters
 88A6h	unsupported function
 88A7h	no such task
 88A8h	too many tasks
 88A9h	version mismatch
 88AAh	request cancelled
 88ABh	invalid NDS name
 88ACh	unable to perform operation while logged into NDS
 88ADh	requester not available for use
 88AEh	MacIPX not configured properly
 88AFh	no servers found
 88B0h	no volume or session associated with identifier
 88B1h	not a NetWare volume
 88B2h	MacIPX version incompatible with Requester
 88B4h	MacIPX not open
 88B5h	insufficient stack
 88B6h	client API already initialized
 88B7h	checksums required by client are not available
 88B8h	packet signing required by client are not available
 88B9h	server requires checksum
 88BAh	server requires packet signing
 88BBh	already logged in
 88BCh	negotiated checksums but connection timed out
 89xxh	error generated by server
	low byte = return code from server (see also #01927,#01961)
 8900h	server successful
 8901h	out of disk space
 897Eh	NCP boundary check failed
 897Fh	???
 8980h	lock failed; file in use
 8981h	out of handles
 8982h	no open privileges
 8983h	hard (non-correctable) I/O error
 8984h	no creation privileges
 8985h	no create/delete privileges
 8986h	attempted to create a file which already exists read-only
 8987h	filename error during creation (wildcards in name)
 8988h	invalid file handle
 8989h	no search privileges
 898Ah	no deletion privileges
 898Bh	no rename privileges
 898Ch	no modify privileges
 898Dh	some affected files are in use
 898Eh	all affected files are in use
 898Fh	some affected files are read-only
 8990h	all affected files are read-only; volume read-only
 8991h	some files could not be renamed because target names already exist
 8992h	all affected names exist
 8993h	no read privileges
 8994h	no write privileges
 8995h	file detached
 8996h	server out of memory
 8997h	no disk space for spool file
 8998h	disk map error; volume does not exist
 8999h	directory full
 899Ah	attempt to rename across volumes
 899Bh	bad directory handle
 899Ch	invalid path; no more trustees
 899Dh	no directory handles
 899Eh	bad filename
 899Fh	directory active
 89A0h	directory not empty
 89A1h	directory I/O error
 89A2h	I/O lock error
 89A3h-89A5h ???
 89A6h	auditing is active
 89A7h	auditing version error
 89A8h	no auditing rights
 89A3h-89BEh ???
 89BFh	invalid name space
 89C0h	no account privileges
 89C1h	no account balance
 89C2h	credit limit exceeded
 89C4h	account disabled
 89C5h	login lockout (intruder detection activated)
 89C6h	no console rights
 89C7h-89CFh
 89D0h	queue error
 89D1h	no queue
 89D2h	no queue server
 89D3h	no queue rights
 89D4h	queue full
 89D5h	no queue job
 89D6h	no job rights; unencrypted password
 89D7h	queue servicing error; duplicate password; bad account
 89D8h	queue not active; password too short
 89D9h	station not queue server; maximum logins exceeded
 89DAh	queue halted; bad login time
 89DBh	maximum queue servers; unauthorized login station
 89DCh	account disabled or expired
 89DEh	password expired (all grace logins used up)
 89DFh	password expired but login allowed (grace login)
 89E0h-89E6h ???
 89E7h	no disk track
 89E8h	property is not an item property; write to group
 89E9h	member exists
 89EAh	no such member
 89EBh	property is not a set property
 89ECh	no such set
 89EDh	property exists
 89EEh	object exists
 89EFh	illegal name
 89F0h	illegal wildcard
 89F1h	invalid bindery security level
 89F2h	not allowed to read object
 89F3h	not allowed to write/rename object
 89F4h	not allowed to delete object
 89F5h	not allowed to create object
 89F6h	not allowed to delete property
 89F7h	not allowed to create property; attempt to use non-local drive
 89F8h	not allowed to write property; already attached to server
 89F9h	not allowed to read property; no free connection slots
 89FAh	temporary remap error; no more server slots
 89FBh	no such property; invalid parameters
 89FCh	no such object; internet packet request canceled; unknown file server
 89FDh	bad station number; lock collision
 89FEh	directory locked; bindery locked; timeout
 89FFh	general error; hard error; lock error
Note:	some server-generated error codes have multiple interpretations; use
	  the one appropriate to the failing call

(Table 02861)
Values for VLM identifier:
 0001h	VLM.EXE		Virtual Loadable Modules manager (see also #02864)
 0010h	CONN.VLM	connection table manager (see also #02867)
 0020h	TRAN.VLM	transport protocol multiplexor (see also #02871)
 0021h	IPXNCP.VLM	transport protocol implementation using IPX (see #02873)
 0022h	TCPNCP.VLM	TCP/IP transport
 0030h	NWP.VLM		NetWare protocol multiplexor (see also #02875)
 0031h	BIND.VLM	bindery
 0032h	NDS.VLM		NetWare Directory Services (see also #02877)
 0033h	PNW.VLM		Personal NetWare
 0034h	RSA.VLM		RSA encryption for directory services re-authentication
 0040h	REDIR.VLM	DOS redirector (see also #02879)
 0041h	FIO.VLM		file I/O (see also #02882)
 0042h	PRINT.VLM	printer redirector (see also #02884)
 0043h	GENERAL.VLM	misc functions for NETx and REDIR (see also #02888)
 0050h	NETX.VLM	NetWare shell compatibility (see also #02890)
 0060h	AUTO.VLM	auto-reconnect/auto-retry
 0061h	SECURITY.VLM	enhanced security module (see #02892)
 0100h	NMR.VLM		NetWare management responder
 09F2h	DRVPRN.VLM	Desktop SNMP Services - Drive/Printer Mappings
 09F5h	SAA.VLM		SAA client API for Netware
 09F6h	IPXMIB.VLM	SNMP IPX-monitoring Module???
 09F7h	PNWMIB.VLM	Personal Netware SNMP Instrumentation Module
 09F8h	PNWTRAP.VLM	Personal Netware SNMP Trap Module
 09F9h	MIB2PROT.VLM	MIB-II Protocol Groups
 09FAh	MIB2IF.VLM	MIB-II Interfaces Group
 09FBh	NVT.VLM		???
 09FCh	WSTRAP.VLM	Desktop SNMP Services - Trap Module
 09FDh	WSREG.VLM	Desktop SNMP Services - Registration Module
 09FEh	WSASN1.VLM	Desktop SNMP Services - ASN.1 Module
 09FFh	WSSNMP.VLM	Desktop SNMP Services - Agent Module

Format of VLM header:
Offset	Size	Description	(Table 02862)
 00h	DWORD	-&gt; initialization entry point
 04h	DWORD	-&gt; VLM API entry point
 08h	DWORD	-&gt; ??? entry point
 0Ch	DWORD	-&gt; ??? entry point
 10h	DWORD	-&gt; ??? entry point
	...
 var	DWORD	00000000h (end of entry point list)
      4 BYTEs	signature "NVlm"
	WORD	VLM identifier (see #02861)
---v1.20+ ---
 1Eh	WORD	???
 20h	WORD	Transient Switch Count
 22h	WORD	VLM Call Count
 24h	WORD	Offset ControlBlocks (See #02863)
 26h	WORD	Current VLMID
 28h	BYTE	Memory Type
		00h=Conventional 02h=EMS 04h=XMS
 29h	BYTE	Modules Loaded
 2Ah	WORD	BlockId
 2Ch	WORD	Transient Block
 2Eh	WORD	Global Segment
 30h  3	DWORDs	pointers to AsyncQueue head, tail, and s???
 3Ch  3	DWORDs	pointers BusyQueue head, tail, and s???
 48h	WORD	ReEntrance Level
 4Ah	WORD	Full Map Count
 4Ch	WORD	???
 4Eh 80 BYTEs	ASCIZ configuration file filename
Note:	the number of entry points in the header is reported as "Func" in the
	  VLM /D display.

Format of VLM Control Block for VLM v1.20 [array]:
Offset	Size	Description	(Table 02863)
 00h	WORD	Flag
 02h	WORD	VLM Identifier (See #02861)
 04h	WORD	Func
 06h	WORD	Maps
 08h	WORD	number of times called
 0Ah	WORD	???
 0Ch	WORD	Transient Segment
 0Eh	WORD	Global Segment
 10h	WORD	Address Low
 12h	WORD	Address High
 14h	WORD	TSegSize
 16h	WORD	GSegSize
 18h	WORD	SSegSize
 1Ah	BYTE	VLMName[9] ASCIZ
Note:	this information is shown in VLM /d under the dashed line. There are
	  as many 35-byte blocks as modules loaded
SeeAlso: #02862

(Table 02864)
Call VLM Manager (VLM.EXE, ID 0001h) with:
Func	Description/Registers
 01h	VLM Notify
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	VLM Statistics
	CX = length of buffer
	ES:DI -&gt; buffer for statistics (see #02865)
	Return: AX = status (0000h if successful)
		buffer filled if successful
 04h	VLM internal use
	BX = function
	    0000h get interrupt vector (calls INT 21/AH=35h)
	    0001h begin critical section (calls INT 2F/AX=1681h)
	    0002h end critical section (calls INT 2F/AX=1682h)
	    0003h ???

Format of VLM.EXE statistics:
Offset	Size	Description	(Table 02865)
 00h	WORD	size of statistics record in bytes (including this word)
 02h	WORD	number of times a VLM has been mapped into memory
 04h	WORD	number of times a VLM has been called
 06h	WORD	offset of vcbArray buffer
 08h	WORD	VLM ID of VLM currently mapped into memory
 0Ah	BYTE	memory type: conventional/EMS/XMS
 0Bh	BYTE	number of loaded VLMs
 0Ch	WORD	EMS/XMS handle or 0000h if conventional memory
 0Eh	WORD	start segment for conventional memory swap
 10h	WORD	segment for global memory, or 0000h if conventional memory
 12h 12 BYTEs	queue structure for asynchronous calls (see #02866)
 1Eh 12 BYTEs	queue structure for synchronous calls (see #02866)
 2Ah	WORD	current re-entrance level
 2Ch	WORD	number of times EMS/XMS map-out performed
 2Eh	BYTE	stack switch control
 2Fh	BYTE	flag: nonzero if switcher loaded
 30h 80 BYTEs	pathname of configuration file
SeeAlso: #02864

Format of VLM.EXE queue structure:
Offset	Size	Description	(Table 02866)
 00h	DWORD	queue head (initially 00000000h)
 04h	DWORD	queue tail (initialized to be same as head)
 08h	WORD	current queue size (number of nodes in queue)
 0Ah	WORD	maximum queue size (in nodes)
SeeAlso: #02865

(Table 02867)
Call Connection Manager (CONN.VLM, ID 0010h) with:
Func	Description/Registers
 01h	Conn Get Version
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	Conn Statistics
	CX = length of buffer
	ES:DI -&gt; buffer for connection statistics (see #02868)
	Return: AX = status (0000h successful)
 04h	Conn Alloc Handle
	Return: AX = status (0000h successful)
		CX = connection handle
 05h	Conn Validate Handle
	CX = connection handle
	Return: AX = 0000h if valid handle
 06h	Conn Free Handle
	CX = connection handle
	Return: AX = status (0000h successful)
 07h	Conn Get Entry Field
	BH = connection parameter (see #02870)
	CX = connection handle
	DX = value if BH is non-array parameter
	DH = offset in array if BH is array parameter
	DL = number of bytes to copy if BH is array
	ES:DI -&gt; return buffer if BH is array
	Return: AX = 0000h if successful
		DL/DX = value if non-array parameter
		DH = maximum number of bytes in buffer if array parameter
		DL = number of bytes copied if array
		BX destroyed
 08h	Conn Set Entry Field
	BH = connection parameter (see #02870)
	CX = connection handle
	DL/DX = value if BH is non-array parameter
	DH = offset in array if BH is array parameter
	DL = number of bytes to copy if BH is array
	DS:SI -&gt; buffer if BH is array
	Return: AX = 0000h if successful
		DH = maximum number of bytes in buffer
		DL = number of bytes copied
		BX destroyed
 09h	Conn Reset Entry Field
	BH = connection parameter (see #02870)
	CX = connection handle
	Return: AX = 0000h if successful
		BX,DX destroyed
 0Ah	Conn Lookup Handle
	BL = lookup type (00h equal, 40h not equal)
	BH = connection parameter (see #02870)
	CX = connection handle, 0000h if first
	DL/DX = value if BH is non-array parameter
	DH = offset in array if BH is array parameter
	DL = number of bytes to copy if BH is array
	DS:SI (ES:DI???) -&gt; buffer if BH is array
	Return: AX = 0000h if successful
		CX = handle matching given parameters
 0Dh	Conn Name Lookup
	CX = connection handle
	ES:DI -&gt; 49-byte buffer for server name or 0000h:0000h
	Return: AX = 0000h if successful
		BX = length of server name
		ES:DI buffer filled if pointer not 0000h:0000h
 0Eh	Conn Name To Handle
	DS:SI -&gt; uppercased server name
	CX = length of server name, 0000h if ASCIZ name
	Return: AX = error code or 0000h if successful
		    CX = connection handle if successful
 0Fh	Conn Get Num Connections
	Return: AX = status (0000h if successful)
		DX = number of connections
		CX = segment of connection table
		    first entry in table (See #02869)

Format of VLM connection statistics:
Offset	Size	Description	(Table 02868)
 00h	WORD	total length of statistics record (including this word)
 02h	WORD	number of connection handles allocated
 04h	WORD	average name length (configured in NET.CFG)
 06h	WORD	maximum number of tasks (configured in NET.CFG)
 08h	WORD	number of failed "allocate handle" calls
 0Ah	WORD	number of failed "add name" calls
 0Ch	WORD	number of failed task calls
Note:	some versions of the NetWare requester reportedly do not implement
	  this correctly
SeeAlso: #02867

Format of NetWare VLM Connection Table [array]:
Offset	Size	Description	(Table 02869)
 00h	WORD	Protocol VLMid	  0032(NDS) 0031(BIND)		Func 07 equiv.
				  0033(PNW) 0000(unused)       BH=01h
 02h	BYTE	(connection status)
		bit 6: connection locked		       BH=16h
		bit 5: authenticated			       BH=03h
		bit 4: permanent			       BH=02h
		bit 2: broadcast msg waiting		       BH=12h
 03h	BYTE	(connection capabilities)
		bit 5: Large Internet Packets		       none
		bit 3: Packet Burst Reset		       BH=07h
		bit 2: Max I/O				       BH=06h
		bit 1: SFT3 change			       BH=05h
		bit 0: Packet Burst Support		       BH=04h
 04h	WORD	reference count				       BH=09h
 06h	WORD	soft resource count			       BH=15h
 08h	BYTE	NCP Order Number			       BH=0Eh
 09h	BYTE	Server security options			       BH=14h
		bit 0: CRC enabled
		bit 1: packet signing required
		bit 5: packet signing enabled
 0Ah	BYTE	OS Major Version			       BH=08h
 0Bh	BYTE	OS Minor Version			       BH=08h
 0Ch	WORD	Hops to Server				       BH=0Ah
 0Eh	WORD	Maximum Packet Size for this connection	       BH=0Bh
 10h	WORD	LIP Parameters				       BH=13h
 12h	WORD	NCP Request Type			       BH=10h
 14h	BYTE	NCP Sequence				       BH=0Ch
 15h	WORD	Connection Number			       BH=0Dh
 17h	BYTE	???					       none
 18h	WORD	Transport VLMid 21(IPXNCP) 22(TCPNCP)	       BH=0Fh
 1Ah	BYTE	Node Address[4]				       BH=11h
 1Eh	BYTE	Network[6]				       BH=11h
 24h	BYTE	Socket[2]				       BH=11h
 26h	BYTE	Local Target[6]				       BH=11h
 2Ch	WORD	Round Trip Time				       BH=11h
 2Eh	WORD	???					       none
SeeAlso: #02867

(Table 02870)
Values for NetWare Connection Manager CEI (Connection Entry Information):
 number	flags	description
 00h	FR	error
 01h	WL	VLM id of transport protocol (NDS/BIND/PNW)
		00h = wildcard
 02h	FR	permanent flag (01h if connection is permanent)
 03h	F	authenticated flag (01h if connection is authenticated)
 04h	F	packet burst supported
 05h	FR	SFT3 change status
 06h	FR	connection needs maximum I/O transmission
 07h	FR	packet burst reset needed
 08h	W	server version
 09h	W	reference count (tasks using connection, 00h = dynamic)
 0Ah	W	distance to server associated with connection
 0Bh	W	maximum packet size supported by transport protocol
 0Ch	B	NCP sequence number
 0Dh	W	connection number
 0Eh	B	NCP order number
 0Fh	WL	VLM id for transport protocol
		00h = wildcard, 21h = IPX, 22h = TCP
 10h	W	NCP request type
 11h	A	transport specific buffer
		12 byte server address
		6 byte	router address
		2 byte round trip time
 12h	FR	broadcast message waiting
 13h	W	large internet packets supported
 14h	B	security options
		bit 0: CRC enabled
		bit 1: packet signing enabled
		bit 5: packet signing active
 15h	W	soft resource count
 16h	FR	connection locked
Note:	flag meanings
	    F=flag value
	    B=byte value
	    W=word value
	    A=array
	    R=resettable
	    L=settable only before authentication
	    others=read only
SeeAlso: #02867

(Table 02871)
Call TRAN.VLM (VLM ID 0020h) with:
Func	Description/Registers
 01h	TRAN Get Version
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	TRAN Statistics
 06h	TRAN Request Reply (see INT 21/AH=F2h)
	AL = NCP request code (see #02095 at INT 21/AH=F2h)
	BH = error handler flag
	    00h default error handler
	    01h return network errors to caller
	    02h handle network errors in requester
	BL = request list length (max 5 fragments) (see #02872)
	CX = connection handle
	DH = 00h (reserved)
	DL = reply list length (max 5 fragments) (see #02872)
	DS:SI -&gt; address list (each element is DWORD address + WORD length)
	ES:DI -&gt; address list
	Return: AX = error code, 0000h if successful (see #02860)
		BX,DX destroyed
		ES:DI buffer filled with reply packet fragments
 08h	TRAN Schedule/Cancel Event
	BX = subfunction
	    0000h schedule event
		AX = number of timer ticks to delay before calling function
		ES:SI -&gt; event control block (including valid call address)
	    0001h cancel event
		ES:SI -&gt; event control block (including call address)
	Return: AX = status (0000h = successful) (see #02860)
 09h	TRAN Get Max Phys Size
	BX = subfunction
	    00h get maximum node size
		Return: AX = status (0000h = successful) (see #02860)
			BX = maximum supported physical packet size
			DX = size of protocol header
			SI = RequestReply socket number
	    01h get maximum route size to specified server
		CX = connection handle for route to be checked
		Return: AX = status (0000h = successful) (see #02860)
			DX = maximum supported packet size for current route
 0Ah	TRAN Broadcast Mux
	BX = subfunction
	    0001h get stored broadcast (Personal NetWare)
		ES:DI -&gt; 60-byte buffer for counted ASCIZ message string
	Return: AX = status (0000h = successful) (see #02860)

Format of TRAN.VLM request/reply fragment descriptor (array):
Offset	Size	Description	(Table 02872)
 00h	DWORD	address of buffer
 04h	WORD	length of buffer

(Table 02873)
Call IPXNCP.VLM (VLM ID 0021h) with:
Func	Description/Registers
 01h	IPX Get Version
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	IPX Statistics
	CX = length of buffer
	ES:DI -&gt; buffer for statistics (see #02874)
	Return:	AX = status (see #02860)
 06h	IPXNCP Request Reply???
	functionally equivalent to Tran Request Reply???

Format of NetWare IPX statistics:
Offset	Size	Description	(Table 02874)
 00h	WORD	size of statistics, including this word
 02h	DWORD	number of TRAN Request Reply calls made
 06h	WORD	number of user aborts
 08h	WORD	number of user retries
 0Ah	WORD	IPX receive errors
 0Ch	WORD	IPX send errors
 0Eh	WORD	number of unrecognized responses
 10h	WORD	number of bad connection numbers in requests
 12h	WORD	number of bad sequence responses
 14h	WORD	receive buffer overflows
 16h	WORD	number of times route to attached server was lost
 18h	WORD	number of times server responded "busy"
 1Ah	WORD	number of unknown "NCPRepCompCode" values
 1Ch	WORD	number of bad connection numbers in responses
 1Eh	WORD	padding for NETX compatibility
 20h	WORD	padding for NETX compatibility
 22h	WORD	number of attach requests to server without route
 24h	WORD	number of times server responded to attach without slot
 26h	WORD	number of times a server went down during a request
 28h	DWORD	same-server optimizations
 2Ch	WORD	local route changes
 2Eh	WORD	IPX CRC errors
 30h	WORD	number of user fails
 32h	BYTE	flag: CRCs enabled
 33h	BYTE	flag: LIP enabled
 34h	BYTE	flag: configurable NET error handler
SeeAlso: #02873

(Table 02875)
Call NWP.VLM (VLM ID 0030h) with:
Func	Description/Registers
 01h	NWP Get Version
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	NWP Statistics
	CX = size of buffer for statistics
	ES:DI -&gt; buffer for statistics (see #02876)
	Return: AX = status (see #02860)
 04h	NWP Connect
	DL = resource count state (NDS connections only)
	CX = proposed connection handle (not yet connected to server)
	DS:SI -&gt; 48-byte server name (NUL-terminated if less than 48 bytes)
	Return: AX = status (0000h = successful) (see #02860)
		CX = actual connection handle to use
	Note:	if the returned handle differs from the proposed handle, the
		  proposed handle should be freed
 05h	NWP Disconnect
	DL = ???
	    00h global disconnect -- clear all resources associated with conn.
	    01h destroy connection -- send disconnect request to server
	CX = connected connection handle
	Return: AX = status (0000h = successful) (see #02860)
 06h	NWP Attach
	DL = resource count state (NDS connections only)
	CX = connection handle (allocated by not yet attached to server)
	DS:SI -&gt; full network address for desired server
	Return: AX = status (0000h = successful) (see #02860)
 08h	NWP Login
	BX = object type
	CX = connection handle (must be connected) to be authenticated
	DS:SI -&gt; ASCIZ user name (max 48 bytes)
	ES:DI -&gt; ASCIZ user password (max 128 bytes)
	Return: AX = status (0000h = successful) (see #02860)
 09h	NWP Logout
	CX = connection handle
	Return: AX = status (0000h = successful) (see #02860)
 0Ah	NWP Get Bindery Object/Get Message Handler
	BX = subfunction
	    0002h set workstation's broadcast message mode
		DL = message mode
		    00h client hold client message set on, retrieve/display on
		    01h client hold client message set off, retr/display on
		    02h client hold client message set on, retrieve/dislay off
		    03h client hold client message set off, retr/display off
		    04h get current message mode
		    05h set broadcast callback
			CX:SI -&gt; callback handler
		    06h get broadcast timeout
		    07h set broadcast timeout
			CX = timeout in timer ticks (0000h = never)
		CX = connection handle, or 0000h to notify all servers
	    0003h get object ID for object name
		AX = object type (big-endian)
		CX = connection handle
		DX = length of object name
		ES:DI -&gt; uppercased ASCIZ object name
		Return: AX = status (see #02860)
			DX:BX = object ID
	    0004h get object name for object ID
		DX:SI = object ID
		CX = connection handle for server which is to do the lookup
		ES:DI -&gt; 48-byte buffer for object name
		Return: AX = status (see #02860)
	    0005h retrieve broadcast message
 0Ch	NDS Fragment Request (passed to NDS.VLM's function 0Ch) (see #02877)
	AX = verb or request type
	CX = connection handle
	DS:SI -&gt; request structure (DWORD data address followed by WORD size)
	ES:DI -&gt; buffer for reply structure (same format as request)
	Return: AX = status (0000h = successful) (see #02860)
 0Eh	NWP Ordered Send To All
	AL = NCP request code
	AH = inverse request code (FFh if none) to back out from failures
	BX = number of fragments in request list
	DX = number of fragments in reply list buffer
	DS:SI -&gt; request fragment list
	ES:DI -&gt; reply fragment list
	Return: AX = status (see #02860)
		BX, CX, DX destroyed
	Note:	the available functions are described under INT 21/AX=F2xxh
 0Fh	NWP Preferred Handler
	BX = subfunction
	    0000h get preferred connection name
		DX = VLM ID (NDS/BIND/PNW)
		ES:DI -&gt; 49-byte buffer for connection name
		Return: ES:DI buffer filled
	    0001h set preferred connection name
		DX = VLM ID (NDS/BIND/PNW)
		CX = length of connection name (may be 0000h, max 48)
		DS:SI -&gt; name of preferred connection
	    0002h get preferred connection ID
		DX = VLM ID (NDS/BIND/PNW)
		Return: AX = status (see #02860)
			CX = connection handle if successful
	    0003h get server address
		CX = connection handle or 0000h
		DS:SI -&gt; ASCIZ name to be resolved
		ES:DI -&gt; 12-byte buffer for server address
 10h	NWP Security???
	BX = subfunction
	    0001h get security flags (see also INT 21/AX=B301h)
		Return: BX:CX indicates signature level
				= 0100h:0000h if signature level=0
				= 0300h:0000h if signature level=1
				= 0302h:0000h if signature level=2
				= 0302h:0202h if signature level=3
	    0002h create session keys (see also INT 21/AX=B302h)
		CX = server connection handle
		DS:SI -&gt; 24-byte input buffer
	    0004h set security flags (see also INT 21/AX=B304h)
		BL:CL = new flags
	    0006h renegotiate security level (see also INT 21/AX=B306h)
		CX = server connection number (01h-08h)

Format of NWP.VLM statistics:
Offset	Size	Description	(Table 02876)
 00h	WORD	size of statistics record (including this byte)
 02h	BYTE	flag: Large Internet Packets enabled
 03h	BYTE	bit flags: enabled security features
 04h	BYTE	bit flags: preferred security features
 05h	BYTE	bit flags: required security features
 06h	BYTE	minimum level of required security
SeeAlso: #02875

(Table 02877)
Call NDS.VLM (VLM ID 0032h) with:
Func	Description/Registers
 01h	NDS Get Version
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	NDS Statistics
 06h	NDS Attach
	CX = allocated connection handle
	DS:SI -&gt; server address
 08h	NDS Fragment Requst
	Return: AX = 8836h (invalid parameter)
	Note:	this function was documented but does not work
 0Ch	NDS context
	BX = subfunction
	    0000h get default name context
		CX = length of buffer for default context
		ES:DI -&gt; buffer to receive name
		Return: ES:DI buffer filled
	    0001h set default context
		CX = length of new default context name
		DS:SI -&gt; context name
	    0002h read from TDS
		CX = reply buffer length
		DX = 0110h ???
		SI = offset in TDS
		ES:DI -&gt; reply buffer
	    0003h write to TDS
	    0005h "NWDSChangeResourceConnection/Lock Connection"
		CX = connection handle
		DL = subfunction (00h-09h)
		    04h = NWDSChangeResourceOnConnection
		    07h = NWDSChangeResourceOnConnection
		    08h = NWDSLockConnection
	    0006h NDS change connection state (internal)
		CX = connection handle
		AL = 00h or 01h
	    0007h "NWDSSetMonitoredConnection"
		AX = subfunction
		    0001h get monitored connection
			Return: CX = connection handle???
		    0002h set monitored connection
			CX = connection handle???
	    0008h send NDS request
		AX = NDS function
		CX = connection handle
		DS:SI -&gt; request buffer descriptor (see #02878)
		ES:DI -&gt; reply buffer descriptor (see #02878)
	    000Ah set NDS CEI Info
		DL = buffer length
		DS:SI -&gt; input buffer

Format of NetWare NDS request/reply buffer descriptor:
Offset	Size	Description	(Table 02878)
 00h	DWORD	-&gt; buffer
 04h	WORD	length of buffer in bytes
SeeAlso: #02877

(Table 02879)
Call REDIR.VLM (VLM ID 0040h) with:
Func	Description/Registers
 01h	Redir Get Version
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	Redir Statistics
	CX = length of buffer
	ES:DI -&gt; buffer for statistics (see #02880)
	Return: AX = status (0000h if successful) (see #02860)
		buffer filled if successful
 04h	Redir Build SFT (see INT 21/AH=B4h"NetWare")
	CX = connection handle
	ES:DI -&gt; SFT build request (see #02881)
	Return: AX = 0000h if successful
		    BX = DOS file handle
 05h	Redir DOS To NW Handle
	BX = DOS file handle
	ES:DI -&gt; 11-byte buffer for NetWare handle
 08h	Redir Specific
	BX = 0000h get item
	    DS:SI -&gt; ASCIZ string "LPTx" (x='1'-'9') or drive spec ("d:")
	    ES:DI -&gt; 512-byte reply buffer for
		      "\\server\resource",00h,"path",00h
	Return: AX = status (0000h if successful) (see #02860)

Format of REDIR.VLM statistics:
Offset	Size	Description	(Table 02880)
 00h	WORD	size of statistics record (including this word)
 02h	WORD	number of network errors causing a critical error (see INT 24)
 04h	WORD	number of drives currently redirected
SeeAlso: #02879

Format of NetWare SFT build request:
Offset	Size	Description	(Table 02881)
 00h  6 BYTEs	NetWare handle
 06h	WORD	reserved for internal use
 08h 14 BYTEs	ASCIZ filename
 16h	BYTE	DOS file attributes
		bit 7: file is shareable
 17h	BYTE	reserved
 18h	LONG	file size
 1Ch	WORD	creation date
 1Eh	WORD	last access date or 0000h
 20h	WORD	last update date or 0000h
 22h	WORD	last update time or 0000h

(Table 02882)
Call File I/O FIO.VLM (VLM ID 0041h) with:
Func	Description/Registers
 01h	FIO Get Version
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	FIO Statistics
	CX = length of buffer
	ES:DI -&gt; buffer for statistics (see #02883)
	Return: AX = status (0000h if successful)
		buffer filled if successful
 04h	FIO Remote Copy

Format of NetWare FIO statistics:
Offset	Size	Description	(Table 02883)
 00h	WORD	length of statistics record (including this word)
 02h	WORD	number of read requests
 04h	WORD	number of write requests
 06h	WORD	number of cache read hits
 08h	WORD	number of cache write hits
 0Ah	WORD	number of cacheable files with free blocks
 0Ch	WORD	number of cacheable files without free blocks
 0Eh	WORD	number of standard read requests
 10h	WORD	number of standard write requests
 12h	WORD	number of burst read requests
 14h	WORD	number of burst write requests
 16h	BYTE	flag: cache writes enabled
 17h	BYTE	flag: true commits enabled
 18h	WORD	number of cache blocks
 1Ah	WORD	size of a cache buffer
 1Ch	WORD	number of ECBs for packet bursts (0000h if bursts disabled)
SeeAlso: #02882

(Table 02884)
Call PRINT.VLM (VLM ID 0042h) with:
Func	Description/Registers
 01h	Print Get Version
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	Print Statistics
	CX = length of buffer
	ES:DI -&gt; buffer for statistics (see #02885)
	Return: AX = status (0000h if successful) (see #02860)
		buffer filled if successful
 04h	Print Get/Set Data
	BX = subfunction
	    00h set printer control flags (see #02886)
	    01h get printer control flags
	    02h set extended printer control flags (see #02887)
	    03h get extended printer control flags
	AX = offset within Print structures at which to start read/write
	CX = number of bytes to transfer
	DX = printing device number (00h=LPT1/PRN, 01h=LPT2, etc.)
	DS:SI -&gt; buffer containing values for flags (subfunctions 00h/02h)
	ES:DI -&gt; buffer for flags (subfunctions 01h/03h
	Return: AX = status (see #02860)
		---if successful---
		CX = number of bytes returned (subfunctions 01h/03h)
		DX = maximum supported size for function/type of data
 05h	Print Open Capture File
 07h	Print Get Num Of Printers
	BX = subfunction
	    0000h get number of physical printers
	    nonzero: get configured printer (from NET.CFG)
	Return: AX = status (see #02860)
		---if successful---
		BX = number of physical/configured printers
 08h	Print Redirection
	BX = subfunction
	    0000h redirect device to queue
		AX = length of queue name, 0000h to use queue ID
		CX = connection handle
		DX = printer/device number (00h=LPT1/PRN, 01h=LPT2, etc.)
		DS:SI -&gt; uppercased ASCIZ queue name
		ES:DI -&gt; DWORD queue ID, 00000000h to use queue name
	    0001h test whether device is redirected
		DX = printer/device number (00h=LPT1/PRN, 01h=LPT2, etc.)
	    0002h cancel redirection
		DX = printer/device number (00h=LPT1/PRN, 01h=LPT2, etc.)
	    0003h redirect device to file
		AX = 0000h or 4E57h ('NW')
		CX = connection handle
		DX = printer/device number (00h=LPT1/PRN, 01h=LPT2, etc.)
		ES:DI -&gt; ASCIZ path of file
	    0004h get extended redirection information (see #02886)
		DX = printer/device number (00h=LPT1/PRN, 01h=LPT2, etc.)
		ES:DI -&gt; buffer for server/queue name
		Return: ES:DI buffer filled
	Return: AX = 0000h if successful
 09h	Print Flush And Close Job
	BX = subfunction
	    0000h unconditional close
	    nonzero: conditional close -- close only if concatenate flag is
		  clear
	DX = index of printing device (00h=LPT1/PRN, 01h=LPT2, etc.)
	Return: AX = status (see #02860)
 0Ch	Print Get/Set Banner Name
	BL = subfunction
	    00h set banner name
		DS:SI -&gt; ASCIZ banner name (12 bytes, including NUL)
	    01h get banner name
		ES:DI -&gt; 12-byte buffer for banner name
	Return: AX = status (see #02860)

Format of PRINT.VLM statistics:
Offset	Size	Description	(Table 02885)
 00h	WOFD	size of statistics buffer (including this word)
 02h	DWORD	-&gt; old INT 17 handler
 06h	WORD	number of physical printers reported by BIOS
SeeAlso: #02884

Format of PRINT.VLM standard print control information:
Offset	Size	Description	(Table 02886)
 00h	BYTE	PFStatus (reserved, 00h)
 01h	BYTE	print flags (default 80h)
		bit 2: release job for printing if capture interrupted
		bit 3: suppress form feed
		bit 4: notify
		bit 6: text file
		bit 7: print banner
 02h	BYTE	tab size (01h-12h, default 08h)
 03h	BYTE	number of copies (default 01h)
 04h	BYTE	??? (may be number of copies instead of offset 03h)
 05h	BYTE	form type to be mounted in printer (default 00h)
 06h	BYTE	reserved (00h)
 07h 14 BYTEs	banner
 15h	BYTE	capture printer (LPT) number
 16h	WORD	capture timeout in seconds
 18h	BYTE	job concatenation flag (00h or 01h, default 00h)
 19h	BYTE	maximum lines per page (default 66)
 1Ah	BYTE	??? (may be maximum lines instead of offset 19h)
 1Bh	BYTE	maximum characters per line (default 132)
 1Ch	BYTE	??? (may be maximum characters instead of offset 1Ch)
 1Dh 13 BYTEs	name of form to be mounted in printer
 2Ah	BYTE	flag: capture active (00h or FFh, default 00h)
 2Bh	BYTE	flag: capturing to file (00h or 01h, default 00h)
 2Ch	BYTE	flag: timeout field is being decremented (default 00h)
 2Dh	DWORD	-&gt; printer setup string
 31h	DWORD	-&gt; printer reset string
 35h	BYTE	reserved (01h)
---remainder is read-only---
 36h	BYTE	flag: job has started printing (00h or FFh, default 00h)
 37h	BYTE	flag: job placed in queue (00h or FFh, default 00h)
 38h	BYTE	flag: PJobValid (00h or FFh, default 00h)
		FFh if associated capture file is open for capturing data
 39h	DWORD	print-queue ID
 3Dh	WORD	print-job number (default 00h) (1-999)
 3Fh	BYTE	number of chars in INT 17h print cache buffer (default 00h)
 40h	BYTE	???
 41h	WORD	high word of print-job number (default 00h)
SeeAlso: #02884,#02887

Format of PRINT.VLM extended print control information:
Offset	Size	Description	(Table 02887)
 00h	DWORD	NDS printer object ID or directory entry number (when capturing
		  to a file)
 04h	BYTE	connection handle for server
 06h 48 BYTEs	ASCIZ print queue name on server
 36h	DWORD	ID of target server, or FFFFFFFFh if any server may be used
 3Ah  6 BYTEs	target print time, FFFFFFFFFFFFh for immediate printing
 40h	BYTE	status flags
 41h	BYTE	???
 42h 13 BYTEs	client's banner name (overrides global banner if set)
 4Fh 13 BYTEs	job description
 5Ch  4 BYTEs	reserved (0)
SeeAlso: #02884,#02886

(Table 02888)
Call GENERAL.VLM (VLM ID 0043h) with:
Func	Description/Registers
 01h	Gen Get Version
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	Gen Statistics
	CX = length of statistics buffer
	ES:DI -&gt; buffer for statistics (see #02889)
	Return: AX = status (see #02860)
 04h	Gen Get/Set Primary
	BX = subfunction
	    0001h get primary connection
		CX = primary connection handle to be retrieved
		Return: AX = status (see #02860)
			CX = primary connection handle
	    0002h set primary connection
		CX = primary connection handle to be stored
		Return: AX = status (see #02860)
 06h	Gen Specific
	BX = subfunction
	    0000h get command processor and master environment addresses
		Return: DX = segment of master environment
			ES:DI -&gt; command processor's private COMSPEC= copy
	    0001h get default or primary connection
		Return: AX = status (0000h successful)
			CX = connection handle if successful
	    0002h last queue information
		AL = operation
		    00h zap
		    01h set
		    02h get
		DI:DX = queue file handle
		CX = connection handle
		Return: AX = status (0000h successful)
			DI:DX = queue file handle
			CX = connection handle or 0000h if queue info invalid
	    0003h get/set machine name(s)
		AX = name type
		    00h get short machine name
		    02h get long machine name
		    04h set short machine name
		    06h set long machine name
		    08h get DOS name
		    0Ah set DOS name
		ES:SI -&gt; ASCIZ name if setting
		Return: AX = status (0000h if successful)
			ES:SI -&gt; ASCIZ name if getting
	    0004h set per-task EXEC search mode
		Return: AX = status (0000h if successful)
 09h	Gen Return Drive Info
	BX = subfunction
	    0000h get first available drive
		Return: AX = status (see #02860)
			BX = drive letter of first drive
	    0001h get Lastdrive
		Return: AX = status (see #02860)
			CH = number lastdrive 1=A: - 1Ah=Z:

Format of NetWare GENERAL.VLM statistics:
Offset	Size	Description	(Table 02889)
 00h	WORD	size of statistics record, including this word
 02h	DWORD	previous INT 21 vector
SeeAlso: #02888

(Table 02890)
Call NETX.VLM (VLM ID 0050h) with:
Func	Description/Registers
 01h	NetX Get Version
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	NetX Statistics
	CX = length of statistics buffer
	ES:DI -&gt; buffer for statistics (see #02891)
	Return: AX = status (see #02860)

Format of NETX.VLM statistics:
Offset	Size	Description	(Table 02891)
 00h	WORD	buffer size, including this word
 02h	DWORD	previous INT 21 handler
SeeAlso: #02890

(Table 02892)
Call SECURITY.VLM (VLM ID 0061h) with:
Func	Description/Registers
 01h	Security Get Version
	BX = function
	    0000h get version
		Return: AX = status (see #02860)
			BX = major version of VLM supported (0001h)
			CX = minor version of VLM supported (0000h)
 03h	Security Statistics
 04h	???
	AL = subfunction
	    01h compute session key
		DS:SI -&gt; 24-byte input buffer
		ES:DI -&gt; 8-byte output buffer

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0001" name="2F7A20BX0001"><b>2F7A20BX0001</b></a> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM CallA ADDRESS<br />
<pre>
INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM CallA ADDRESS
	AX = 7A20h
	BX = 0001h
Return: AX = 0000h if request was handled
	    ES:BX -&gt; CallA entry point (see #02893)
SeeAlso: AX=7A20h/BX=0000h

(Table 02893)
Call VLM CallA entry point with:
	AX = function
	    0000h submit
	    0001h cancel (not implemented)
	ES:DI -&gt; Overlay Asynchronous Control Block structure (see #02894)
Return: DI, DS, ES preserved; all other registers may be destroyed
	interrupts disabled
Desc:	asychronously call the specified VLM and then return to caller, which
	  might be another VLM

Format of Overlay Asynchronous Control Block (OACB):
Offset	Size	Description	(Table 02894)
 00h	DWORD	link to next OACB, 0000h:0000h if last (filled by VLM.EXE)
 04h	DWORD	callback address or 0000h:0000h
 08h	BYTE	InUse flag (00h if complete) (set by VLM.EXE)
 09h	BYTE	flag, reserved for VLM use
 0Ah	WORD	destination VLM
 0Ch	WORD	destination function
 0Eh	WORD	temporary storage for VLM.EXE
 10h  6 BYTEs	reserved
 16h  6 DWORDs	EAX,EBX,ECX,EDX,ESI,EDI
 2Eh  4 WORDs	DS,ES,FS,GS (FS and GS not used)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0002" name="2F7A20BX0002"><b>2F7A20BX0002</b></a> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM MULTIPLEX ADDRESS<br />
<pre>
INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM MULTIPLEX ADDRESS
	AX = 7A20h
	BX = 0002h
Return: AX = 0000h
	ES:BX -&gt; VLM multiplex entry point (see #02895)
Note:	for v1.10, this function is only available while VLM.EXE is loading
	  the .VLM modules, because ES is destroyed on return
SeeAlso: AX=7A20h/BX=0000h,AX=7A20h/BX=0001h,AX=7A20h/BX=0003h

(Table 02895)
Call DOS Requester entry point with:
	BX = function???
	    0000h
		DX = ???
		DI = ???
		BP = ???
	    0002h
		CX = ???
	    0003h
		DX = ???
		BP = ???
	    0006h
		AH = subfunction???
		AL = ???
		STACK: variable (0, 4, 10, 14 bytes seen)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0003" name="2F7A20BX0003"><b>2F7A20BX0003</b></a> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM PARSE API ADDRESS<br />
<pre>
INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM PARSE API ADDRESS
	AX = 7A20h
	BX = 0003h
Return: AX = 0000h if request was handled
	    ES:BX -&gt; VLM parse API entry point

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0004" name="2F7A20BX0004"><b>2F7A20BX0004</b></a> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM MULTICAST CALLOUT<br />
<pre>
INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM MULTICAST CALLOUT
	AX = 7A20h
	BX = 0004h
Return: AX = 0000h if request was handled
	    ES:BX -&gt; VLM multicast data (see #02896)
SeeAlso: AX=7A20h/BX=0000h,AX=7A20h/BX=0002h,AX=7A20h/BX=0005h

Format of DOS Requester data:
Offset	Size	Description	(Table 02896)
 00h	DWORD	pointer to ??? (code)
 04h  4 BYTEs	???
 08h	DWORD	pointer to ??? (code) (see #02897)
	???

(Table 02897)
Call offset 08h function with:
	AL = function (00h-07h)
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0005" name="2F7A20BX0005"><b>2F7A20BX0005</b></a> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM INT 24 ADDRESS<br />
<pre>
INT 2F - Novell NetWare - DOS Requester v1.03+ - GET VLM INT 24 ADDRESS
	AX = 7A20h
	BX = 0005h
Return: AX = 0000h if request was handled
	    ES:BX -&gt; VLM INT 24 handler
SeeAlso: AX=7A20h/BX=0000h,AX=7A20h/BX=0002h,AX=7A20h/BX=0004h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0006" name="2F7A20BX0006"><b>2F7A20BX0006</b></a> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT<br />
<pre>
INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT
	AX = 7A20h
	BX = 0006h
Return: AX = 0000h if request was handled
	    ES:BX -&gt; ??? entry point (RETF in v1.03 and v1.10)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0007" name="2F7A20BX0007"><b>2F7A20BX0007</b></a> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT<br />
<pre>
INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT
	AX = 7A20h
	BX = 0007h
Return: AX = 0000h
	ES:BX -&gt; ??? entry point (RETF in v1.03 and v1.10)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0008" name="2F7A20BX0008"><b>2F7A20BX0008</b></a> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT<br />
<pre>
INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT
	AX = 7A20h
	BX = 0008h
Return: AX = 0000h
	ES:BX -&gt; ??? entry point (RETF in v1.03 and v1.10)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0080" name="2F7A20BX0080"><b>2F7A20BX0080</b></a> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT<br />
<pre>
INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT
	AX = 7A20h
	BX = 0080h
Return: AX = 0000h
	ES:BX -&gt; ??? entry point (RETF in v1.03 and v1.10)
Note:	this function is identical to AX=7A20h/BX=0006h in v1.03 and v1.10

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0081" name="2F7A20BX0081"><b>2F7A20BX0081</b></a> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT<br />
<pre>
INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT
	AX = 7A20h
	BX = 0081h
Return: AX = 0000h
	ES:BX -&gt; ??? entry point (RETF in v1.03 and v1.10)
Note:	this function is identical to AX=7A20h/BX=0007h in v1.03 and v1.10

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A20BX0082" name="2F7A20BX0082"><b>2F7A20BX0082</b></a> - INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT<br />
<pre>
INT 2F - Novell NetWare - DOS Requester v1.03+ - GET ??? ENTRY POINT
	AX = 7A20h
	BX = 0082h
Return: AX = 0000h
	ES:BX -&gt; ??? entry point (RETF in v1.03 and v1.10)
Note:	this function is identical to AX=7A20h/BX=0008h in v1.03 and v1.10

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A21" name="2F7A21"><b>2F7A21</b></a> - INT 2F C - Novell NetWare - DOS Requester - BROADCAST CALLBACK<br />
<pre>
INT 2F C - Novell NetWare - DOS Requester - BROADCAST CALLBACK
	AX = 7A21h
	CX = server connection (FFFFh if message from Personal NetWare user)
	interrupts disabled
Return: CX = 0000h if broadcast handled
	interrupts disabled
Note:	this function is only linked into INT 2F when INT 21/AH=DEh/DL=05h
	  has been issued
SeeAlso: AX=7A22h,AX=7A85h,INT 21/AH=DEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A22" name="2F7A22"><b>2F7A22</b></a> - INT 2F C - Novell NetWare - DOS Requester - BROADCAST/SFT3 INFORM<br />
<pre>
INT 2F C - Novell NetWare - DOS Requester - BROADCAST/SFT3 INFORM
	AX = 7A22h
	DL = function
	    21h ('!') broadcast waiting for workstation
	    40h ('@') SFT3 server-change inform
	BX = transport type
	    0021h IPX
	    0022h TCP
	ES:SI -&gt; transport-specific data block
	    (ECB for IPX, undefined for TCP)
	interrupts disabled
Return: AX = 0000h if event handled, unchanged if not
	interrupts disabled
Note:	this callback is made from within a hardware interrupt handler; a
	  separate call to AX=7A21h is made once the system is in a safe
	  state for receiving the message
SeeAlso: AX=7A21h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A2F" name="2F7A2F"><b>2F7A2F</b></a> - INT 2F - Novell NetWare - IPXODI v2.12 - GET GNMA SUPPORT<br />
<pre>
INT 2F - Novell NetWare - IPXODI v2.12 - GET GNMA SUPPORT
	AX = 7A2Fh
Return: AX = 0000h if supported and active
	    BX = support level (0001h)
	    ES:DI -&gt; GNMA entry point (see #02898)
Program: GNMA is the Generic NetWare Management Agent
Note:	IPXODI v2.12 is distributed as part of the Personal NetWare system
	  bundled with Novell DOS 7
SeeAlso: INT 7A/BX=001Fh

(Table 02898)
Call IPXODI GNMA entry point with:
	BX = function
	    0000h Register Responder
		ES:SI -&gt; responder structure (see #02899)
		Return: CF clear if successful
			CF set on error
			AX = status
			    FFFFh if specified responder is already registered
			interrupts enabled
			all other registers except DS, CS:IP, SS:SP destroyed
		Note:	the responder structure must not be deallocated until
			  the responder is deregistered
	    0001h Deregister Responder
		AX = type of responder to deregister
		Return: AX = status
			    FFFFh if specified responder not registered
			interrupts enabled
			ES:SI buffer from original registration may now be
			      freed
			all other registers except DS, CS:IP, SS:SP destroyed
	    0002h Get Responders
		Return: ES:SI -&gt; head of responder structure list (read-only)
			interrupts enabled
			all other registers except DS, CS:IP, SS:SP destroyed
		Note:	the returned list may change as tasks are swapped in
			  and out
	    0003h Send Acknowledgement
		AL = completion code
		    00h successful
		    01h-FCh responder-specific
		    FDh invalid function
		CX = length of return data (0000h if none)
		DX:SI -&gt; return data
		Return: interrupts enabled
			all other registers except DS, CS:IP, SS:SP destroyed

Format of NetWare GNMA responder structure:
Offset	Size	Description	(Table 02899)
 00h	DWORD	-&gt; next responder structure (used by GNMA)
 04h	DWORD	-&gt; responder's request handler (called by GNMA) (see #02900)
 08h	WORD	responder ID
 0Ah	WORD	number of functions supported by responder
 0Ch	DWORD	reserved for use by GNMA
SeeAlso: #02898

(Table 02900)
Values GNMA responder's request handler is called with:
	AL = function
	    00h responder request
		CX = length of request data (not including header) (see #02901)
		DS:DI -&gt; request data (see #02901)
		DS:BX -&gt; 528-byte reply buffer
		ES:SI -&gt; responder structure (see #02899) from registration
		DF clear
		interrupts disabled
		Return: AH = acknowledement status
			    00h acknowledgment being returned synchronously
			    nonzero: acknowledgment will be sent via GNMA
				  function 0003h (see #02898)
				CX = length of acknowledement data
				DX:BX -&gt; acknowledgment (may use provided
					  buffer or another buffer)
			AL = completion code
			    00h successful
			    01h-FCh responder-specific
			    FDh invalid request
			DF clear
			interrupts disabled
			other registers may be destroyed
	    01h responder acknowledgement complete
		ES:SI -&gt; responder structure (see #02899) from registration
		DF clear
		interrupts disabled
		Return:	DF clear
			interrupts disabled
			all registers (except SS:SP) may be destroyed
		Note:	this function is called if function 00h returned a
			  responder-provided data buffer; once this function
			  is called, the responder may deallocate the buffer
	    02h responder reset
		ES:SI -&gt; responder structure (see #02899) from registration
		DF clear
		interrupts disabled
		Return:	DF clear
			interrupts disabled
			all registers (except SS:SP) may be destroyed
		Note:	called whenever a network managment application
			  terminates
Note:	the responder handler should switch to a local stack if it enables
	  interrupts or uses more than a few words of stack space
SeeAlso: #02899

Format of GNMA responder request data:
Offset	Size	Description	(Table 02901)
 00h	WORD	responder's assigned ID
 02h	WORD	function number (defined by responder)
 04h  N BYTEs	data for request (max 528 bytes; actual amount is determined
		  by CX)
SeeAlso: #02900

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A2FBX0EDC" name="2F7A2FBX0EDC"><b>2F7A2FBX0EDC</b></a> - INT 2F U - Personal NetWare - HRMIB - UNINSTALL<br />
<pre>
INT 2F U - Personal NetWare - HRMIB - UNINSTALL
	AX = 7A2Fh
	BX = 0EDCh ('EDC' = Novell European Development Center)
Return: ???
SeeAlso: AX=7AA0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A40" name="2F7A40"><b>2F7A40</b></a> - INT 2F - Novell NetWare - TCP/IP Protocol Stack - INSTALLATION CHECK<br />
<pre>
INT 2F - Novell NetWare - TCP/IP Protocol Stack - INSTALLATION CHECK
	AX = 7A40h
Return: AX = 7AFFh if installed
	    0000h:BX = address of interrupt vector for MLID ISR
	    CX = version (CH=major, CL=minor)
	    DX = 0000h
	    ES:DI -&gt; entry point for TCP/IP stack (see #02903)
Notes:	Novell's LAN Workplace for DOS TCPIP.EXE also supports this interface
	this function is also supported by the Beame&Whiteside BWLWP40 shim,
	  but it only returns AL and ES:DI, and does not support AX=7A41h
SeeAlso: AX=7A41h,INT 15/AX=DE2Eh,INT 60"Excelan"


(Table 02902)
Values for NetWare TCP/IP function code:
 01h	"accept" accept a network connection request
 02h	"bind" associate an address with a socket
 03h	close socket
	Call:	socket number field set
 04h	"connect" connect to a remote host
 05h	"getmyipaddr" get IP address
	Call:	socket number field in sockaddr set to 0000h
 06h	"getmymacaddr" get hardware address
 07h	"getpeername"
 08h	"getsockname" get socket name
 09h	"getsockopt" get socket options
 0Ah	"getsubnetmask" get subnet mask
 0Bh	"ioctl"
 0Ch	"listen" wait for connection request on socket
 0Dh	"select"
	Return: socket bitmap updated (1=active)
 0Eh	"setmyipaddr" (obsolete) set IP address
 0Fh	"setsockopt" set socket options
 10h	"shutdown"
 11h	"socket" open socket
	Call:	socket number field set to 0000h
	Return: socket number set
 12h	"recv" get data from peer
 13h	"recvfrom" get data from specified remote host
	Call:	socket number set
		packet length and buffer descriptors set
	Return:	packet length and receive buffers updated
		sockaddr field set to source port number + IP address
 14h	"send" write data to socket
 15h	"sendto" write data to specified recipient
	Call:	socket number set
		flags at offset 18h = 0000h
		packet length and buffer descriptors set
---v4.02+ ---
 16h	get BOOTP data
	Return: BOOTP data stored in parameter block (see #02906)
 17h	"getsnmpinfo"
 18h	"getpathinfo" get/set configuration???
---v4.??? ---
 19h	"getifn"	get interface number
 1Ah	"setipinfo"	set IP information
 1Bh	"getipinfo"	get IP information
 1Ch	"setdnsinfo"	set DNS information
 1Dh	"getdnsinfo"	get DNS information
 1Eh	"setroutes"	set/modify route entry(ies)
 1Fh	"getroutes"	get route entry(ies)
 20h	"removeroutes"	remove route entry(ies)
 21h	"setarpe"	set/modify ARP entry(ies)
 22h	"getarpe"	get ARP entry(ies)
 23h	"removearpe"	remove ARP entry(ies)
Notes:	these functions are based on the Unix socket interface
	OR function number with 80h to call ESR
SeeAlso: #02904

(Table 02903)
Call NetWare TCP/IP entry point with:
	ES:SI -&gt; parameter block (see #02904)
Return: ES:SI parameter block updated
	DX may be destroyed

Format of NetWare TCP/IP Request Control Block (RCB):
Offset	Size	Description	(Table 02904)
 00h	DWORD	-&gt; next RCB
 04h	DWORD	-&gt; previous RCB
 08h	DWORD	-&gt; FAR post routine called if bit 7 of function code set
 0Ch	BYTE	flags (internal use)
		bit 0: request in progress
		bit 1: posted
		bit 2: Windows
		bit 3: "PROTBUF"
		bit 4: "ABORTRCB" for Ctrl-Break handling
		bit 5: call INT 21/AX=0B00h while blocking
 0Dh  7 BYTEs	???
 14h	BYTE	(ret) temporary result code
 15h	BYTE	(call) function code (bit 7 set if non-blocking) (see #02902)
 16h	BYTE	socket number
 17h	BYTE	(ret) result or error code (see #02905)
---accept/bind/connect/getmyipaddr/getpeername/getsockname commands---
 18h		sockaddr structure (WORD port + DWORD IP address)
---close comand---
 no additional fields
---getmymacaddr command---
 18h  6 BYTEs	low-level hardware network address
---BOOTP command---
 18h 64 BYTEs	BOOTP VSA data (see #02906)
---getpathinfo command
 18h  8 BYTEs	key
		"TCP_CFG" used by PING.EXE
 20h 128 BYTEs	path
 A0h	WORD	length of path in previous field
---getsockopt/setsockopt commands---
 18h	WORD	option name
		0004h SO_REUSEADDR
		0008h SO_KEEPALIVE
		0080h SO_LINGER
 1Ah	WORD	option value
 1Ch	WORD	"linger"
---getsubnetmask command---
 18h	DWORD	sockaddr structure (WORD port + DWORD subnet mask)
---ioctl command---
 18h	DWORD	argument value
 1Ch	WORD	ioctl number
---listen command---
 18h	WORD	maximum allowable connection backlog
---select command---
 18h	WORD	number of sockets
 1Ah		fd_set readfds (bitmap of sockets)
		fd_set writefds
		fd_set expectionfds
	DWORD	timeout in clock ticks
---shutdown command---
 18h	WORD	shutdown type
---socket command---
 18h	WORD	protocol (1 = ICMP, 6 = TCP, 17 = UDP)
---I/O commands (recv,recvfrom,send,sendto)---
 18h	WORD	flags
 1Ah  6 BYTEs	sockaddr from/to
		WORD	port number
		DWORD	IP address
 20h	WORD	length of packet sent/received
 22h	WORD	number of pointer/length pairs following (max 8)
 24h 6N BYTEs	buffer descriptors, each
		Offset	Size	Description
		 00h	DWORD	pointer to buffer
		 04h	WORD	length of buffer
---getsnmpinfo command---
 18h	DWORD	(ret) -&gt; ??? data in TCPIP code segment
--getifn command---
 18h	WORD	interface number
 1Ah	WORD	MLID instance number
 1Ch 128 BYTEs	MLID name
---getipinfo/setipinfo commands---
 18h	WORD	interface number (00h = default)
 1Ah	DWORD	IP address
 1Eh	DWORD	IP netmask
 22h  3 DWORDs	router addresses (00000000h = unused entry)
---getdnsinfo/setdnsinfo commands---
 18h	WORD	interface number (00h = default)
 1Ah  3 DWORDs	name server IP addresses (00000000h = unused entry)
 26h 128 BYTEs	domain name
---getroutes/setroutes/removeroutes commands---
 18h	WORD	number of route entries to follow (max 5)
 1Ah 10N BYTEs	route entries
		DWORD	destination host/net IP address
		DWORD	IP address of first router
		WORD	route type
---getarpe/setarpe/removearpe commands---
 18h	WORD	number of ARP entries to follow (max 16)
 1Ah 10N BYTEs	ARP entries
		DWORD	destination IP address
		6 BYTEs	destination hardware address
---other commands---
 18h  4 WORDs	parameter words 0 to 3 (see #02902 for usage)

(Table 02905)
Values for NetWare TCP/IP status:
 00h	successful
 04h	would block
 09h	invalid socket
 23h	would block
 24h	operation in progress
 25h	already in progress
 26h	not a socket
 27h	destination address required
 28h	message too long
 29h	wrong protocol type for socket
 2Ah	protocol not available
 2Bh	protocol not supported
 2Ch	socket type not supported
 2Dh	operation not supported on socket
 2Eh	protocol family not supported
 2Fh	address family not supported by protocol family
 30h	address already in use
 31h	unable to assign requested address
 32h	network is down
 33h	network is unreachable
 34h	network dropped connection
 35h	software caused connection abort
 36h	connection reset by peer
 37h	no buffer space
 38h	socket is already connected
 39h	socket is not connected
 3Ah	socket is in shutdown mode
 3Bh	too many references
 3Ch	connection timed out
 3Dh	connection refused
 3Eh	too many levels of symbolic links
 3Fh	file name too long
 40h	host is down
 41h	host unreachable
 42h	protocol stack not installed
 43h	asynchronous operation not supported
 44h	synchronous operation not supported
 45h	no RCB available
 FFh	blocking (call has not yet returned)
SeeAlso: #02904

Format of BOOTP data (stored in parameter block):
Offset	Size	Description	(Table 02906)
 18h  4 BYTEs	???
 1Ch	BYTE	??? (01h)
 1Dh	BYTE	address length (04h)
 1Eh  4 BYTEs	subnet mask
 22h	BYTE	??? (03h)
 23h	BYTE	??? (04h)
 24h  4 BYTEs	IP address of nearest router
 28h	BYTE	??? (06h)
 29h	BYTE	length of following data (08h)
 2Ah  4 BYTEs	IP address of nameserver 1
 2Eh  4 BYTEs	IP address of nameserver 2
 32h	BYTE	??? (0Ch)
 33h	BYTE	length of local name
 34h  N BYTEs	local host name
	BYTE	FFh (end marker)
SeeAlso: #02904,#02902

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A41" name="2F7A41"><b>2F7A41</b></a> - INT 2F U - Novell NetWare - TCP/IP Protocol Stack - WINDOWS SUPPORT???<br />
<pre>
INT 2F U - Novell NetWare - TCP/IP Protocol Stack - WINDOWS SUPPORT???
	AX = 7A41h
	ES:DI -&gt; FAR entry point for ??? (will be called with BX=1,2,3,4)
Return: AX = 7AFFh if supported
	    0000h:BX = address of interrupt vector for MLID ISR
	    CX = version (CH=major, CL=minor)
	    DX = 0000h
	    ES:SI -&gt; DWORD containing passed value of ES:DI
	    ES:DI -&gt; entry point for TCP/IP stack
Notes:	Novell's LAN Workplace for DOS TCPIP.EXE also supports this interface
	the pointer which is set to ES:DI is cleared to 0000h:0000h when
	  a Windows exit broadcast is received
SeeAlso: AX=7A40h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A42" name="2F7A42"><b>2F7A42</b></a> - INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - GET ??? ENTRY POINT<br />
<pre>
INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - GET ??? ENTRY POINT
	AX = 7A42h
Return: AX = 7AFFh if supported
	    ES:DI -&gt; ??? entry point (see #02907)

(Table 02907)
Call NetWare TCPIP.EXE entry point with:
	DX = ???
	ES:DI -&gt; ??? (see #02908)
Return: AX = 0000h
	other registers destroyed

Format of data buffer:
Offset	Size	Description	(Table 02908)
 00h	WORD	offset of WORD ??? or 0000h
 02h	WORD	offset of DWORD ??? or 0000h
 04h	WORD	offset of DWORD ??? or 0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A43" name="2F7A43"><b>2F7A43</b></a> - INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - GET ???<br />
<pre>
INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - GET ???
	AX = 7A43h
Return: AX = 7AFFh if supported
	    DX = offset of ???
SeeAlso: AX=7A44h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A44" name="2F7A44"><b>2F7A44</b></a> - INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - SET ???<br />
<pre>
INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - SET ???
	AX = 7A44h
	DX = offset of ??? (see AX=7A43h)
Return: AX = 7AFFh if supported
SeeAlso: AX=7A43h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A4C" name="2F7A4C"><b>2F7A4C</b></a> - INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - GET ???<br />
<pre>
INT 2F U - Novell NetWare - TCPIP.EXE v4.1 - GET ???
	AX = 7A4Ch
Return: AX = 7AFFh if supported
	    BX = ??? (0037h)
	    CX = ??? (001Ch)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A4DBX0001" name="2F7A4DBX0001"><b>2F7A4DBX0001</b></a> - INT 2F U - Novell NetWare - ???<br />
<pre>
INT 2F U - Novell NetWare - ???
	AX = 7A4Dh
	BX = 0001h
	ES:DI -&gt; ???
Return: AL = FFh if ???
	    ES:DI -&gt; ???
Note:	called by NETBIOS.EXE v3.01

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A4E" name="2F7A4E"><b>2F7A4E</b></a> - INT 2F U - Novell LAN Workplace for DOS - RARPD.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F U - Novell LAN Workplace for DOS - RARPD.EXE - INSTALLATION CHECK
	AX = 7A4Eh
Return: AX = 7AFFh if installed
SeeAlso: AX=7A4Fh"RARPD"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A4F" name="2F7A4F"><b>2F7A4F</b></a> - INT 2F U - Novell LAN Workplace for DOS - RARPD.EXE - UNINSTALL<br />
<pre>
INT 2F U - Novell LAN Workplace for DOS - RARPD.EXE - UNINSTALL
	AX = 7A4Fh
Return: AX = 7AFFh if installed
	DX,ES destroyed
Note:	this call conflicts with SNMP.EXE (both RARPD and SNMP are supplied
	  with LAN Workplace for DOS!), such that running SNMP will uninstall
	  RARPD as SNMP checks whether it is already installed!
SeeAlso: AX=7A4Eh"RARPD",AX=7A4Fh/BX=0001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A4FBX0001" name="2F7A4FBX0001"><b>2F7A4FBX0001</b></a> - INT 2F U - Novell NetWare - SNMP.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F U - Novell NetWare - SNMP.EXE - INSTALLATION CHECK
	AX = 7A4Fh
	BX = 0001h
Return: AX = 7AFFh if installed
Note:	this call conflicts with RARPD.EXE (both SNMP and RARPD are supplied
	  with LAN Workplace for DOS!), such that running SNMP will uninstall
	  RARPD as SNMP checks whether it is already installed!
SeeAlso: AX=7A4Fh"RARPD",AX=7A4Fh/BX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A4FBX0002" name="2F7A4FBX0002"><b>2F7A4FBX0002</b></a> - INT 2F U - Novell NetWare - SNMP.EXE - ???<br />
<pre>
INT 2F U - Novell NetWare - SNMP.EXE - ???
	AX = 7A4Fh
	BX = 0002h
Return: AL = status
	    4Fh if failed
	    FFh if successful
SeeAlso: AX=7A4Fh/BX=0001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A80" name="2F7A80"><b>2F7A80</b></a> - INT 2F C - Novell NetWare - SHELL 3.01d BROADCAST - ABNORMAL EXIT<br />
<pre>
INT 2F C - Novell NetWare - SHELL 3.01d BROADCAST - ABNORMAL EXIT
	AX = 7A80h
Return: nothing
Notes:	called on abnormal exit of the NetWare shell to notify other Novell
	  TSRs that it is unsafe to call the shell in the future; also called
	  by NETX.VLM when it is unloaded
	must be passed through so that all interested programs see the exit
	on receiving this call, IPXODI clears an internal pointer to a
	  default value; Novell's NETBIOS.EXE clears its INT 21h pointer to
	  0000h:0000h and stops calling it
SeeAlso: AX=7A81h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A81" name="2F7A81"><b>2F7A81</b></a> - INT 2F C - Novell NetWare - SHELL 3.01d BROADCAST - SET SHELL INT 21 HANDLER<br />
<pre>
INT 2F C - Novell NetWare - SHELL 3.01d BROADCAST - SET SHELL INT 21 HANDLER
	AX = 7A81h
	CX:DX -&gt; shell's INT 21h entry point
Return: nothing
Notes:	the shell calls this function as it loads to allow interested TSRs
	  and drivers to make a local copy of the shell's entry point
	must be passed through so that all interested programs see it

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A85" name="2F7A85"><b>2F7A85</b></a> - INT 2F C - Novell NetWare - shell 3.01 - BROADCAST INFORM<br />
<pre>
INT 2F C - Novell NetWare - shell 3.01 - BROADCAST INFORM
	AX = 7A85h
	CX = broadcast server number
Return: CX = 0000h if broadcast message handled by another program
	CX unchanged if broadcast not handled
SeeAlso: AX=7A21h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7A90" name="2F7A90"><b>2F7A90</b></a> - INT 2F U - Novell NetWare - NETBIOS.EXE 3+ - INSTALLATION CHECK<br />
<pre>
INT 2F U - Novell NetWare - NETBIOS.EXE 3+ - INSTALLATION CHECK
	AX = 7A90h
Return: AL = 00h if present
	    BX = ???
	    CX = PSP segment of NETBIOS resident code
SeeAlso: AX=7AFEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7AA0" name="2F7AA0"><b>2F7AA0</b></a> - INT 2F U - Personal NetWare - HRMIB - ???<br />
<pre>
INT 2F U - Personal NetWare - HRMIB - ???
	AX = 7AA0h
	BX = function
	    0000h ???
	    0001h ???
Return: ???
SeeAlso: AX=7A2Fh/BX=0EDCh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7AC1" name="2F7AC1"><b>2F7AC1</b></a> - INT 2F - LAN HiJack - LHR - DISABLE???<br />
<pre>
INT 2F - LAN HiJack - LHR - DISABLE???
	AX = 7AC1h
Program: LAN HiJack is a NetWare utility by KDS Software which allows a user
	  to take over control of a workstation remotely; LHR is the program
	  run on the slave workstation
SeeAlso: AX=7AC8h,AX=7AC9h,AX=7ACFh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7AC2" name="2F7AC2"><b>2F7AC2</b></a> - INT 2F - LAN HiJack - LHR - SYNCHRONIZE SHIFT STATES???<br />
<pre>
INT 2F - LAN HiJack - LHR - SYNCHRONIZE SHIFT STATES???
	AX = 7AC2h
Note:	sets BIOS keyboard status byte to an internal variable
SeeAlso: AX=7AC3h,AX=7ACFh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7AC3" name="2F7AC3"><b>2F7AC3</b></a> - INT 2F - LAN HiJack - LHR - CLEAR ??? FLAG<br />
<pre>
INT 2F - LAN HiJack - LHR - CLEAR ??? FLAG
	AX = 7AC3h
SeeAlso: AX=7AC2h,AX=7ACFh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7AC8" name="2F7AC8"><b>2F7AC8</b></a> - INT 2F - LAN HiJack - LHR - ENABLE FUNCTIONS<br />
<pre>
INT 2F - LAN HiJack - LHR - ENABLE FUNCTIONS
	AX = 7AC8h
	BL = function(s) to enable (see #02909)
SeeAlso: AX=7AC1h,AX=7AC9h,AX=7ACFh

Bitfields for LAN HiJack function(s) to enable/disable:
Bit(s)	Description	(Table 02909)
 0	???
 1	remote keyboard enabled
 2	support remote's mouse
 3-7	unused

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7AC9" name="2F7AC9"><b>2F7AC9</b></a> - INT 2F - LAN HiJack - LHR - DISABLE FUNCTIONS<br />
<pre>
INT 2F - LAN HiJack - LHR - DISABLE FUNCTIONS
	AX = 7AC9h
	BL = function(s) to disable (see #02909)
SeeAlso: AX=7AC1h,AX=7AC8h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7ACA" name="2F7ACA"><b>2F7ACA</b></a> - INT 2F - LAN HiJack - LHJ - ???<br />
<pre>
INT 2F - LAN HiJack - LHJ - ???
	AX = 7ACAh
	BL = ???
Return: ???
Program: LAN HiJack is a NetWare utility by KDS Software which allows a user
	  to take over control of a workstation remotely; LHJ is the program
	  run on the controlling workstation

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7ACB" name="2F7ACB"><b>2F7ACB</b></a> - INT 2F - LAN HiJack - LHJ - ???<br />
<pre>
INT 2F - LAN HiJack - LHJ - ???
	AX = 7ACBh
	BX = ???
Return: ???
Note:	this function appears to be related to the keyboard
SeeAlso: AX=7ACCh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7ACC" name="2F7ACC"><b>2F7ACC</b></a> - INT 2F - LAN HiJack - LHJ - ???<br />
<pre>
INT 2F - LAN HiJack - LHJ - ???
	AX = 7ACCh
	BX = ???
Return: ???
Note:	this function appears to be related to the mouse
SeeAlso: AX=7ACBh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7ACFBX0000" name="2F7ACFBX0000"><b>2F7ACFBX0000</b></a> - INT 2F - LAN HiJack - LHR - INSTALLATION CHECK<br />
<pre>
INT 2F - LAN HiJack - LHR - INSTALLATION CHECK
	AX = 7ACFh
	BX = 0000h
Return: BX = segment of resident code if installed
Program: LAN HiJack is a NetWare utility by KDS Software which allows a user
	  to take over control of a workstation remotely; LHR is the program
	  run on the slave workstation

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7AF0" name="2F7AF0"><b>2F7AF0</b></a> - INT 2F - Novell NetWare - DOSNP.EXE v1.30G - INSTALLATION CHECK<br />
<pre>
INT 2F - Novell NetWare - DOSNP.EXE v1.30G - INSTALLATION CHECK
	AX = 7AF0h
Return: AL = FFh if present
	    ES = 7AF0h
	    CX = PSP segment of resident code

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7AF1" name="2F7AF1"><b>2F7AF1</b></a> - INT 2F - Novell NetWare - Access Server Driver - INSTALLATION CHECK<br />
<pre>
INT 2F - Novell NetWare - Access Server Driver - INSTALLATION CHECK
	AX = 7AF1h
	BL = sequence number (01h first driver, 02h second, 00h no driver)
Return: AX &lt;&gt; 7AF1h if present
	    BH = total number of drivers
	    ---if BL nonzero on entry---
	    AL = number of ports provided by specified driver
	    ES:DI -&gt; driver entry point
		      (see #02910,#02911,#02912,#02913,#02914,#02915,#02916,#02917)
	    ES:DX -&gt; ID string
SeeAlso: INT 7A/BX=001Ch

(Table 02910)
Call Access Server driver "initialize port" function with:
	AH = 01h
	AL = port number (00h-0Fh)
	ES:BX -&gt; configuration parameter block (see #02923)
	interrupts disabled
Return: CF clear if successful
	CF set on error
SeeAlso: #02911

(Table 02911)
Call Access Server driver "get port status" function with:
	AH = 02h
	AL = port number (00h-0Fh)
	interrupts disabled
Return: CF clear if successful
	    BL = transmitter status (see #02920)
	    BH = receiver status (see #02921)
	    DL = external status signals (see #02922)
	CF set on error
	interrupts disabled
SeeAlso: #02910,#02912,#02915

(Table 02912)
Call Access Server driver "get input from port" function with:
	AH = 03h
	AL = port number (00h-0Fh)
	CX = size of data buffer
	ES:BX -&gt; buffer for data
	interrupts disabled
Return: CF clear if successful
	CF set on error
	interrupts disabled
	CX = number of bytes read
Note:	the driver will add a NUL to the buffer when a break signal is detected
SeeAlso: #02912,#02913

(Table 02913)
Call driver "send output data to port" function with:
	AH = 04h
	AL = port number (00h-0Fh)
	CX = number of bytes to send
	ES:BX -&gt; buffer containing data
	interrupts disabled
Return: CF clear if successful
	CF set on error
	interrupts disabled
	CX = number of bytes actually written
SeeAlso: #02912,#02914

(Table 02914)
Call driver "get I/O character counts" function with:
	AH = 05h
	AL = port number (00h-0Fh)
	interrupts disabled
Return: CF clear if successful
	    BX = number of bytes pending transmission
	    CX = number of bytes available for reading
	CF set on error
	interrupts disabled
SeeAlso: #02912,#02913

(Table 02915)
Call driver "control XON/XOFF" function with:
	AH = 06h
	AL = port number (00h-0Fh)
	DL = new state
	    (00h software flow control disabled, else enabled)
	interrupts disabled
Return: CF clear if successful
	CF set on error
	interrupts disabled
SeeAlso: #02916

(Table 02916)
Call driver "get error counts and statistics" function with:
	AH = 07h
	AL = port number (00h-0Fh)
	ES:BX -&gt; buffer for statistics (see #02924)
	interrupts disabled
Return: CF clear if successful
	    ES:BX buffer filled
	CF set on error
	interrupts disabled
SeeAlso: #02917,#02918,#02919

(Table 02917)
Call driver "general request" function with:
	AH = 08h
	AL = port number (00h-0Fh)
	DX = requested operations
	    bit 0: flush transmit buffers
	    bit 1: flush receive buffers
	    bit 4: define XON/XOFF characters
	ES:BX -&gt; XON/XOFF characters (see #02925) if DX bit 4 set
	interrupts disabled
Return: CF clear if successful
	CF set on error
	interrupts disabled

(Table 02918)
Call driver "deadman timer management" function with:
	AH = 09h
	AL = port number (00h-0Fh)
	BX = next time interval in seconds (0000h to disable timer)
	interrupts disabled
Return: CF clear
	interrupts disabled
SeeAlso: #02919

(Table 02919)
Call driver "get buffer sizes" function with:
	AH = 0Ah
	AL = port number (00h-0Fh)
	interrupts disabled
Return: CF clear if successful
	   BX = size of transmit buffer
	   CX = size of receive buffer
	CF set on error
	interrupts disabled
SeeAlso: #02918

(Table 02920)
Values for Access Server transmitter status:
 00h	uninitialized
 01h	ready, not transmitting
 02h	transmitting
 03h	XOFF received
 04h	transmitting, buffer full
 05h	XOFF received and buffer full

(Table 02921)
Values for Access Server receiver status:
 00h	uninitialized
 01h	ready
 02h	receive buffer full, data may have been lost

Bitfields for external status signals:
Bit(s)	Description	(Table 02922)
 7,6	undefined
 5	CTS active
 4	DSR active
 3	DCD active
 2,1	undefined
 0	ring indicator

Format of Access Server configuration parameter block:
Offset	Size	Description	(Table 02923)
 00h	BYTE	receive baud rate index
		00h 50 bps, 01h 75 bps, 02h 110 bps, 03h 134.5 bps,
		04h 150 bps, 05h 300 bps, 06h 600 bps, 07h 1200 bps,
		08h 1800 bps, 09h 2000 bps, 0Ah 2400 bps, 0Bh 3600 bps,
		0Ch 4800 bps, 0Dh 7200 bps, 0Eh 9600 bps, 0Fh 19200 bps,
		10h 38400 bps, 11h 57600 bps, 12h 115200 bps
 01h	BYTE	receive bits per character (0=5 bits..3=8 bits)
 02h	BYTE	receive stop bits
 03h	BYTE	receive parity
		00h none, 01h odd, 02h even, 03h mark, 04h space
 04h	BYTE	transmit baud rate index (same as receive baud rate)
 05h	BYTE	transmit bits per character (0=5 bits..3=8 bits)
 06h	BYTE	transmit stop bits
 07h	BYTE	transmit parity (same as receive parity)
 08h	BYTE	DTR state (00h off, 01h on)
 09h	BYTE	RTS state (00h off, 01h on)
 0Ah	BYTE	flow control (00h none, 01h XON/XOFF, 02h RTS/CTS, 03h both)
 0Bh	BYTE	break control (00h off, 01h on)

Format of Access Server statistics:
Offset	Size	Description	(Table 02924)
 00h	BYTE	port number
 01h	BYTE	external status signals (see #02922)
 02h	BYTE	transmitter status (see #02920)
 03h	BYTE	receiver status (see #02921)
 04h	DWORD	number of characters received
 08h	DWORD	number of characters transmitted
 0Ch	WORD	input parity errors
 0Eh	WORD	input framing errors
 10h	WORD	lost characters due to hardware overrun
 12h	WORD	lost characters due to data buffer overrun
Note:	the counts are not allowed to wrap around; once a count reaches FFFFh
	  or FFFFFFFFh, it is no longer incremented

Format of Access Server XON/XOFF characters:
Offset	Size	Description	(Table 02925)
 00h	BYTE	04h (number of bytes following)
 01h	BYTE	transmit XON character
 02h	BYTE	transmit XOFF character
 03h	BYTE	receive XON character
 04h	BYTE	receive XOFF character

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7AFE" name="2F7AFE"><b>2F7AFE</b></a> - INT 2F U - Novell NetWare - DOSNP.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F U - Novell NetWare - DOSNP.EXE - INSTALLATION CHECK
	AX = 7AFEh
Return: AL = FFh if present
	    ES = (data???) segment of DOSNP
Program: DOSNP.EXE provides "named pipes" support for DOS workstations running
	   NetWare
Note:	the NetWare shell calls this function and refuses to load if DOSNP is
	  present
SeeAlso: AX=7A90h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7AFFBX0000" name="2F7AFFBX0000"><b>2F7AFFBX0000</b></a> - INT 2F - Novell NetWare - TBMI v1.1+ - INSTALLATION CHECK / Windows SUPPORT<br />
<pre>
INT 2F - Novell NetWare - TBMI v1.1+ - INSTALLATION CHECK / Windows SUPPORT
	AX = 7AFFh
	BX = 0000h
	CX = 4E65h ("Ne")
	DX = 7457h ("tW")
	ES:DI -&gt; Windows support procedure (see #02926)
Return: AL = FFh if installed
	    CX = configured sockets (14h)
	    DS:SI -&gt; data table ???
	    ES:DI -&gt; IPX far call handler
Notes:	for IPX/SPX this call reportedly returns DS:SI pointing to the table
	  of pointers to service events queue head and tail
	this function is also supported by IPXODI; v2.12 does not change DS,
	  but does set SI to an internal address
SeeAlso: AX=7AFFh/BX=0001h

(Table 02926)
Values Windows support procedure called with:
	BP = function
	    0001h Get ECB
		BX = socket number
		Return: ES:SI -&gt; ECB or 0000h:0000h if none available
	    0002h Count Listen ECBs
		AX = BX = socket
		Return: CX = number of listen ECBs for socket
				(must be &gt;= 2 for SPX to work)
	    0003h ???
	    0004h Inform task switcher of ECB locations
		Note:	registers other than those listed above are equal
			  to the values when IPX was called
Note:	the support function will not be called if IPX is called with BX
	  bit 15 set

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7AFFBX0001" name="2F7AFFBX0001"><b>2F7AFFBX0001</b></a> - INT 2F - Novell NetWare - TBMI v1.1+, shell v3.01d - INSTALLATION CHECK???<br />
<pre>
INT 2F - Novell NetWare - TBMI v1.1+, shell v3.01d - INSTALLATION CHECK???
	AX = 7AFFh
	BX = 0001h
	CX = 4E65h ("Ne")
	DX = 7457h ("tW")
Return: AL = FFh if installed
	    CX = ???  (8000h)
	    SI = ??? (or -&gt; ???) (0002h and 0007h seen)
	    ES:DI -&gt; IPX far call handler
	    ES:DX -&gt; 6-byte data area ???
Note:	this function is also supported by IPXODI, but IPXODI v2.12 does not
	  return ES:DX
SeeAlso: AX=7AFFh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F00" name="2F7F00"><b>2F7F00</b></a> - INT 2F - Jim Harper's CD-ROM redirector SCSI driver - INSTALLATION CHECK<br />
<pre>
INT 2F - Jim Harper's CD-ROM redirector SCSI driver - INSTALLATION CHECK
	AX = 7F00h
Return: AL = FFh if installed
SeeAlso: AX=7F01h"Harper",AX=7F02h"Harper",AX=7F03h"Harper"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F00_0" name="2F7F00_0"><b>2F7F00</b></a> - INT 2F - PRINDIR v9.0 - INSTALLATION CHECK<br />
<pre>
INT 2F - PRINDIR v9.0 - INSTALLATION CHECK
	AX = 7F00h
Return: AL = FFh if installed
	    BX = version (BH = major, BL = minor)
	    CX:DX -&gt; ASCIZ signature "PRINDIR"
Range:	AH=7Fh is the default, may be changed at installation time
Note:	prior versions of PRINDIR used INT 7C or INT 7A
SeeAlso: AX=7F01h"PRINDIR",AX=7F02h"PRINDIR",AX=7F03h"PRINDIR"
SeeAlso: AX=7F06h"PRINDIR",AX=7F08h,AX=7F0Ah,AX=7F0Ch,AX=7F0Eh,INT 7C"PRINDIR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F01" name="2F7F01"><b>2F7F01</b></a> - INT 2F - Jim Harper's CD-ROM redirector SCSI driver - DO COMMAND<br />
<pre>
INT 2F - Jim Harper's CD-ROM redirector SCSI driver - DO COMMAND
	AX = 7F01h
	DS:DX -&gt; command record (see #02927)
Return: AL = status
	    00h successful
	    else error code
SeeAlso: AX=7F00h"Harper",AX=7F02h"Harper",INT 11/AH=FFh"SDLP"
SeeAlso: INT 21/AX=4402h"ASPI",INT 4F/AX=8100h

Format of CD-ROM redirector command record:
Offset	Size	Description	(Table 02927)
 00h	BYTE	ID
 01h 10 BYTEs	CDB (Command Descriptor Block) for operation (see #03236,#03237)
 0Bh	WORD	segment of buffer
 0Dh	WORD	offset of buffer
 0Fh	BYTE	status
 10h	BYTE	sense
 12h	WORD	count

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F01_0" name="2F7F01_0"><b>2F7F01</b></a> - INT 2F - PRINDIR v9.0 - SET CAPTURE DEVICE<br />
<pre>
INT 2F - PRINDIR v9.0 - SET CAPTURE DEVICE
	AX = 7F01h
	DX = capture device (as used by /GET commandline option)
Return: AX = status
	    0000h successful
	    FFFFh invalid device
SeeAlso: AX=7F00h"PRINDIR",AX=7F02h"PRINDIR",AX=7F03h"PRINDIR"
SeeAlso: AX=7F05h"PRINDIR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F02" name="2F7F02"><b>2F7F02</b></a> - INT 2F - Jim Harper's CD-ROM redirector SCSI driver - DO RESET<br />
<pre>
INT 2F - Jim Harper's CD-ROM redirector SCSI driver - DO RESET
	AX = 7F02h
SeeAlso: AX=7F00h,AX=7F01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F02_0" name="2F7F02_0"><b>2F7F02</b></a> - INT 2F - PRINDIR v9.0 - SET DESTINATION DEVICE<br />
<pre>
INT 2F - PRINDIR v9.0 - SET DESTINATION DEVICE
	AX = 7F02h
	DX = destination device number (as used by /PUT commandline option)
Return: AX = status
	    0000h successful
	    FFFFh invalid device number
SeeAlso: AX=7F00h"PRINDIR",AX=7F01h"PRINDIR",AX=7F04h"PRINDIR"
SeeAlso: AX=7F06h"PRINDIR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F03" name="2F7F03"><b>2F7F03</b></a> - INT 2F - Jim Harper's CD-ROM redirector SCSI driver - UNINSTALL<br />
<pre>
INT 2F - Jim Harper's CD-ROM redirector SCSI driver - UNINSTALL
	AX = 7F03h
Return: AL = status
	    00h successful
	    01h unable to uninstall
SeeAlso: AX=7F00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F03_0" name="2F7F03_0"><b>2F7F03</b></a> - INT 2F - PRINDIR v9.0 - SET CAPTURE FILENAME<br />
<pre>
INT 2F - PRINDIR v9.0 - SET CAPTURE FILENAME
	AX = 7F03h
	CX:DX -&gt; ASCIZ name of capture file
Return: AX = status
	    0000h successful
	    FFFFh name too long
SeeAlso: AX=7F00h"PRINDIR",AX=7F01h"PRINDIR",AX=7F04h"PRINDIR"
SeeAlso: AX=7F05h"PRINDIR",AX=7F07h"PRINDIR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F04" name="2F7F04"><b>2F7F04</b></a> - INT 2F - PRINDIR v9.0 - SET LOCK FILENAME<br />
<pre>
INT 2F - PRINDIR v9.0 - SET LOCK FILENAME
	AX = 7F04h
	CX:DX -&gt; ASCIZ name of lock file
Return: AX = status
	    0000h successful
	    FFFFh invalid device number
SeeAlso: AX=7F00h"PRINDIR",AX=7F01h"PRINDIR",AX=7F03h"PRINDIR"
SeeAlso: AX=7F05h,AX=7F06h,AX=7F08h,AX=7F0Ah,AX=7F0Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F05" name="2F7F05"><b>2F7F05</b></a> - INT 2F - PRINDIR v9.0 - DUMP CAPTURE BUFFER<br />
<pre>
INT 2F - PRINDIR v9.0 - DUMP CAPTURE BUFFER
	AX = 7F05h
Return: AX = status
	    0000h successful
SeeAlso: AX=7F00h"PRINDIR",AX=7F01h"PRINDIR",AX=7F04h"PRINDIR",AX=7F06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F06" name="2F7F06"><b>2F7F06</b></a> - INT 2F - PRINDIR v9.0 - SET NORMAL TEXT COLOR<br />
<pre>
INT 2F - PRINDIR v9.0 - SET NORMAL TEXT COLOR
	AX = 7F06h
	DH = new attribute for normal text
Return: AX = status
	    0000h successful
SeeAlso: AX=7F00h"PRINDIR",AX=7F01h"PRINDIR",AX=7F05h"PRINDIR",AX=7F07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F07" name="2F7F07"><b>2F7F07</b></a> - INT 2F - PRINDIR v9.0 - SET HIGHLIGHT TEXT COLOR<br />
<pre>
INT 2F - PRINDIR v9.0 - SET HIGHLIGHT TEXT COLOR
	AX = 7F07h
	DH = new attribute for highlighted text
Return: AX = status
	    0000h successful
SeeAlso: AX=7F00h"PRINDIR",AX=7F01h"PRINDIR",AX=7F06h"PRINDIR",AX=7F08h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F08" name="2F7F08"><b>2F7F08</b></a> - INT 2F - PRINDIR v9.0 - SET POPUP HOTKEY<br />
<pre>
INT 2F - PRINDIR v9.0 - SET POPUP HOTKEY
	AX = 7F08h
	DH = new scancode for hotkey
Return: AX = status
	    0000h successful
SeeAlso: AX=7F00h"PRINDIR",AX=7F05h"PRINDIR",AX=7F09h,AX=7F0Bh,AX=7F0Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F09" name="2F7F09"><b>2F7F09</b></a> - INT 2F - PRINDIR v9.0 - SET BYTE COUNTER DISPLAY<br />
<pre>
INT 2F - PRINDIR v9.0 - SET BYTE COUNTER DISPLAY
	AX = 7F09h
	DH = new state (00h off, 01h on)
Return: AX = status
	    0000h successful
SeeAlso: AX=7F00h"PRINDIR",AX=7F07h"PRINDIR",AX=7F08h,AX=7F0Ah,AX=7F0Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F0A" name="2F7F0A"><b>2F7F0A</b></a> - INT 2F - PRINDIR v9.0 - SET FLUSH DELAY<br />
<pre>
INT 2F - PRINDIR v9.0 - SET FLUSH DELAY
	AX = 7F0Ah
	DX = number of clock ticks before flushing
Return: AX = status
	    0000h successful
SeeAlso: AX=7F00h"PRINDIR",AX=7F07h"PRINDIR",AX=7F09h,AX=7F0Bh,AX=7F0Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F0B" name="2F7F0B"><b>2F7F0B</b></a> - INT 2F - PRINDIR v9.0 - SET MINIMUM DUMP SIZE<br />
<pre>
INT 2F - PRINDIR v9.0 - SET MINIMUM DUMP SIZE
	AX = 7F0Bh
	DX = number of kilobytes to accumulate before dumping
Return: AX = status
	    0000h successful
SeeAlso: AX=7F00h"PRINDIR",AX=7F0Ah,AX=7F0Ch,AX=7F0Dh,AX=7F0Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F0C" name="2F7F0C"><b>2F7F0C</b></a> - INT 2F - PRINDIR v9.0 - SET ECHO STATE<br />
<pre>
INT 2F - PRINDIR v9.0 - SET ECHO STATE
	AX = 7F0Ch
	DX = new state (00h echo off, 01h echo on)
Return: AX = status
	    0000h successful
SeeAlso: AX=7F00h"PRINDIR",AX=7F0Ah,AX=7F0Bh,AX=7F0Dh,AX=7F0Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F0D" name="2F7F0D"><b>2F7F0D</b></a> - INT 2F - PRINDIR v9.0 - SHOW POPUP PARAMETER MENU<br />
<pre>
INT 2F - PRINDIR v9.0 - SHOW POPUP PARAMETER MENU
	AX = 7F0Dh
Return: AX = status
	    0000h successful
	    else  failed
SeeAlso: AX=7F00h"PRINDIR",AX=7F0Ah,AX=7F0Bh,AX=7F0Ch,AX=7F0Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F0E" name="2F7F0E"><b>2F7F0E</b></a> - INT 2F - PRINDIR v9.0 - SUBMIT BYTE TO CURRENT DESTINATION DEVICE<br />
<pre>
INT 2F - PRINDIR v9.0 - SUBMIT BYTE TO CURRENT DESTINATION DEVICE
	AX = 7F0Eh
	DL = byte to send to destination device
Return: AX = status
	    0000h successful
	    else  failed
SeeAlso: AX=7F00h"PRINDIR",AX=7F0Ah,AX=7F0Bh,AX=7F0Ch,AX=7F0Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F24" name="2F7F24"><b>2F7F24</b></a> - INT 2F - Multiplex - ???<br />
<pre>
INT 2F - Multiplex - ???
	AX = 7F24h
	???
Return: ???
Note:	called by PC/370, an IBM 370 emulator by Donald S. Higgins

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F7F26" name="2F7F26"><b>2F7F26</b></a> - INT 2F - Multiplex - ???<br />
<pre>
INT 2F - Multiplex - ???
	AX = 7F26h
	???
Return: ???
Note:	called by PC/370, an IBM 370 emulator by Donald S. Higgins

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8000" name="2F8000"><b>2F8000</b></a> - INT 2F - EASY-NET - INSTALLATION CHECK<br />
<pre>
INT 2F - EASY-NET - INSTALLATION CHECK
	AX = 8000h
Return: AL = 00h not installed
	     FFh installed
Program: EASY-NET is a shareware two-machine serial-port network

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8000_0" name="2F8000_0"><b>2F8000</b></a> - INT 2F - Nanosoft, Inc. TurboNET server - INSTALLATION CHECK<br />
<pre>
INT 2F - Nanosoft, Inc. TurboNET server - INSTALLATION CHECK
	AX = 8000h
Return: AL = FFh if installed
	    BX = CS of resident code
	    CX = ??? (03FCh)
Program: TurboNET is a NetBIOS-based file redirector and server; a
	  demonstration version may be downloaded from Nanosoft's BBS
SeeAlso: AX=8100h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8000_1" name="2F8000_1"><b>2F8000</b></a> - INT 2F - CS_TSR specification - TSR INSTALLATION CHECK<br />
<pre>
INT 2F - CS_TSR specification - TSR INSTALLATION CHECK
	AX = 8000h
	DS:SI -&gt; 4-byte CS_TSR signature (11h 43h 53h 10h)
Return: AL = status
	    00h no CS_TSR-compliant TSRs installed
	    01h installed, but signature did not match
	    FFh installed, signature matches
		ES:DI -&gt; resident process block (see #02928) of last installed
			  TSR (if DS:SI pointed at signature on entry)
Program: the CS_TSR specification is a standardized TSR interface by Compact
	  Soft group in Kiev, Ukraine
Desc:	determine whether any CS_TSR-compliant TSRs are installed on the
	  selected multiplex number
Range:	AH=80h to AH=FFh
SeeAlso: AX=8001h"CS_TSR",AX=8002h"CS_TSR",AX=8003h"CS_TSR"

Format of CS_TSR process block:
Offset	Size	Description	(Table 02928)
 00h  4 BYTEs	CS_TSR signature 11h 43h 53h 10h
 04h	BYTE	INT 2F multiplex number
 05h	WORD	virtual process handle (unique among loaded TSRs)
 07h  2 BYTEs	version (binary minor version, then major version)
 09h	WORD	PSP segment of TSR
 0Bh	DWORD	pointer to ASCIZ program name
 0Fh  3 BYTEs	program creation date (day, month, year)
 12h  3 BYTEs	process start time (seconds, minutes, hours)
 15h  3 BYTEs	process start date (day, month, year)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8000DX0000" name="2F8000DX0000"><b>2F8000DX0000</b></a> - INT 2F - FaxBIOS interface - INSTALLATION CHECK<br />
<pre>
INT 2F - FaxBIOS interface - INSTALLATION CHECK
	AX = 8000h
	DX = 0000h
	DI = 0000h
Return: AL = FFh if installed
	DX:DI -&gt; signature "FaxBiosjpc"
Range:	AH=80h to AH=FFh, selected by scanning multiplex numbers for signature
SeeAlso: AH=2Ah,AX=80FBh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8001" name="2F8001"><b>2F8001</b></a> - INT 2F - Nanosoft, Inc. TurboNET server - ???<br />
<pre>
INT 2F - Nanosoft, Inc. TurboNET server - ???
	AX = 8001h
	DS:SI -&gt; 16-byte buffer for ???
Return: AH = status
	    00h successful
	    01h error (TurboNET busy)
Note:	makes NetBIOS calls

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8001_0" name="2F8001_0"><b>2F8001</b></a> - INT 2F - CS_TSR specification - GET HANDLE (TSR-SPECIFIC INSTALLATION CHECK)<br />
<pre>
INT 2F - CS_TSR specification - GET HANDLE (TSR-SPECIFIC INSTALLATION CHECK)
	AX = 8001h
	DS:SI -&gt; ASCIZ signature string for desired TSR (see #02929)
Return: BX = process handle or 0000h if specified TSR not installed
	ES:DI -&gt; process block for TSR (see #02928) if BX&lt;&gt;0000h
Note:	A widely-available copy of ASCII billing itself as "ASCII 2.OO by
	  Nick Zaikin Jr." is in fact a hacked copy of the Compact Soft
	  ASCII v4.23 which is identical except for the changed attribution
	  and version (in fact, some instances of "4.23" were missed); the
	  hacked copy requires the signature string
	  "ASCII 2.OO by Nick Zaikin Jr." instead of the unhacked version's
	  simple signature "ASCII"
SeeAlso: AX=8000h"CS_TSR",AX=8002h"CS_TSR"

(Table 02929)
Values for CS_TSR signature strings:
 "ASCII"	ASCII, a popup ASCII table with character input
 "Halculator"	HALC, a 32-bit RPN WYSIWIH calculator with undo and ptr support
 "AntiTurbo"	AT!, an intelligent system slow-down utility

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8002" name="2F8002"><b>2F8002</b></a> - INT 2F - CS_TSR specification - GET PROCESS BLOCK BY PROCESS HANDLE<br />
<pre>
INT 2F - CS_TSR specification - GET PROCESS BLOCK BY PROCESS HANDLE
	AX = 8002h
	BX = process handle for TSR (see AX=8001h"CS_TSR")
Return: ES:DI -&gt; process block for specified TSR (see #02928)
		unchanged if no match for process handle
Note:	This function is used to allocate a process handle when the TSR
	  installs itself, by setting ES:DI to point at something other than
	  a CS_TSR process block's signature string and iterating through the
	  possible process handles (0001h to FFFFh) until ES:DI is returned
	  unchanged
SeeAlso: AX=8000h"CS_TSR",AX=8001h"CS_TSR",AX=8003h"CS_TSR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8003" name="2F8003"><b>2F8003</b></a> - INT 2F - CS_TSR specification - CUSTOM SUBFUNCTION<br />
<pre>
INT 2F - CS_TSR specification - CUSTOM SUBFUNCTION
	AX = 8003h
	BX = process handle for TSR (see AX=8001h"CS_TSR")
	other registers vary by TSR
Return: vary by TSR, unchanged if not supported
Program: the CS_TSR specification is a standardized TSR interface by Compact
	  Soft group in Kiev, Ukraine
SeeAlso: AX=8000h"CS_TSR",AX=8001h"CS_TSR",AX=8002h"CS_TSR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F80FB" name="2F80FB"><b>2F80FB</b></a> - INT 2F - FaxBIOS interface - COMMAND SUBMISSION<br />
<pre>
INT 2F - FaxBIOS interface - COMMAND SUBMISSION
	AX = 80FBh
	BX = function number (see #02930)
	DX:DI -&gt; command buffer
		  (see #02932,#02935,#02936,#02937,#02938,#02939,#02944,#02950,#02957)
Return: AL = FFh if submitted OK
	CX = result code (see #02931)
Range:	AH=80h to AH=FFh, selected by scanning multiplex numbers for signature
SeeAlso: AX=8000h"FaxBIOS",AX=CBDDh

(Table 02930)
Values for FaxBIOS function number:
 0001h	SYS_LOGIN
 0002h	SYS_LOGOUT
 0003h	SYS_GET_FAXAPP_INFO
 0004h	STAT_IO_GET
 0005h	STAT_FAXBIOS_GET
 0006h	PDIR_OPEN
 0007h	PDIR_CLOSE (see #02940)
 0008h	PDIR_READ_PERSON (see #02941)
 0009h	PDIR_PARTIAL_READ
 000Ah	PDIR_READ_GROUP
 000Bh	PDIR_READ_MEMBER_LIST
 000Ch	PDIR_WRITE_PERSON
 000Dh	PDIR_WRITE_GROUP
 000Eh	PDIR_DELETE_PERSON
 000Fh	PDIR_DELETE_GROUP
 0010h	PDIR_READ_GROUP_LIST
 0011h	PDIR_IN_GROUP
 0012h	PDIR_OUT_GROUP
 0013h	SCHED_OPEN (see #02942)
 0014h	SCHED_ADD_DEST (see #02943)
 0015h	SCHED_ADD_FILE (see #02944)
 0016h	SCHED_SET_PARAMS (see #02945)
 0017h	SCHED_CANCEL (see #02942)
 0018h	SCHED_CLOSE (see #02946)
 0019h	SLOG_OPEN (see #02947)
 001Ah	SLOG_CLOSE (see #02947)
 001Bh	SLOG_SHORT_ENV_STAT
 001Ch	SLOG_LONG_ENV_STAT
 001Dh	SLOG_DEST_STAT
 001Eh	SLOG_FILE_STAT
 001Fh	SLOG_CANCEL_ENV
 0020h	RLOG_OPEN (see #02947)
 0021h	RLOG_CLOSE (see #02947)
 0022h	RLOG_READ
 0023h	GRAPH_GET_FILE_TYPE (see #02948)
 0024h	GRAPH_EXPORT_FILE
 0025h	GRAPH_GET_LAYOUT_INFO
 0026h	GRAPH_CREATE_FILE (see #02949)
 0027h	GRAPH_CLOSE_FILE (see #02950)
 0028h	GRAPH_CREATE_PAGE (see #02951)
 0029h	GRAPH_WRITE (see #02952)
 002Ah	GRAPH_END_PAGE
 002Bh	GRAPH_OPEN_FILE (see #02953)
 002Ch	GRAPH_GOTO_PAGE (see #02954)
 002Dh	GRAPH_READ (see #02955)
 002Eh	IOCTL_GET
 002Fh	IOCTL_SET
 0030h	IOCTL_ANSWER_FAX (see #02956)
 0031h	IOCTL_DIAL (see #02957)

(Table 02931)
Values for FaxBIOS result code:
 0000h	successful
 0001h	not prepared or servicing another client (busy)
 0002h	call failed due to sharing (LOCKED)
 0003h	logged-in client limit reached (FULL)
 0004h	transport denied (TRANSPORT_DENIED)
 0005h	not implemented (NOT_IMPLEMENTED)
 0006h	aborted while in progress (ABORTED)
 0007h	permissions denied (PERMISSION_DENIED)
 0008h	requested data is no longer valid (NO_LONGER_VALID)
 0080h	unspecified system error occurred
 0081h	an internal file was not found
 0082h	an internal file could not be created
 0083h	an internal file could not be opened
 0084h	an internal file could not be closed
 0085h	error occurred writing to an internal file
 0086h	error occurred reading from an internal file
 0087h	bad or corrupted file encountered
 0088h	an access violation occurred
 0089h	an internal file is empty
 008Ah	insufficient memory to process request
 008Bh	FaxBIOS was unable to issue a handle
 008Ch	an error internal to FaxBIOS occurred
 008Dh	no room on disk
 0100h	unspecified error accessing client file
 0101h	file not found
 0102h	creation fault
 0103h	open fault
 0104h	close fault
 0105h	write fault
 0106h	read fault
 0107h	file corrupted
 0108h	access violation
 0109h	empty file
 0200h	unspecified argument error
 0201h	bad function
 0202h	bad option
 0203h	bad structure size
 0204h	bad buffer size
 0205h	bad client ID
 0300h	unspecified error with token
 0301h	cover sheet token was invalid
 0302h	logo token was invalid
 0303h	signature token was invalid
 0304h	font token was invalid
 0305h	phone directory token was invalid
 0306h	outbound route token was invalid
 0307h	priority token was invalid
 0308h	sort token was invalid
 0309h	billing token was invalid
 0400h	unspecified handle error
 0401h	bad Phone Directory handle
 0402h	bad scheduling handle
 0403h	bad read send log handle
 0404h	bad read receive log handle
 0405h	bad graphics handle
 0500h	data passed in structure was invalid
 0501h	name field given is invalid
 0502h	phone number given is invalid
 0503h	poll code submitted is invalid
 0504h	file type constant was invalid
 0505h	BFT constant not defined or supported
 0506h	resolution not defined or supported
 0507h	page length not defined or supported
 0508h	page width not defined or supported
 0509h	date & time requested are ridiculous
 050Ah	Subject text was not an ASCIZ string
 050Bh	From text was not an ASCIZ string
 050Ch	requested envelope ID was not found
 050Dh	requested envelope ID is not valid
 050Eh	envelope requested was not found
 050Fh	destination index is out of range
 0510h	file index is out of range
 0511h	index into receive log is out of range
 0512h	file name specified was incomplete or invalid
 0513h	page selected was out of range
 0514h	bit width more than byte width
 0515h	mode for open is not defined
 0516h	person index is out of range
 0517h	person ID is out of range
 0518h	group index out of range or invalid
 0519h	group ID out of range or invalid
 051Ah	range of indices to read is invalid
 051Bh	group name given is invalid
 051Ch	field_to_use is badly specified
 051Dh	predicate invalid for field specified
 0600h	unspecified client procedure error
 0601h	device of interest is not present
 0602h	device of interest has been removed
 0603h	device of interest is not responding
 0604h	device of interest is disabled
 0605h	could not dial because device was in use
 0606h	maximum destination limit exceeded
 0607h	maximum file limit exceeded
 0608h	scheduling closed with no destination
 0609h	scheduling closed with no files or poll
 060Ah	scheduling closed with no parameters specified
 060Bh	file type specified does not match file
 060Ch	file type specified is not supported
 060Dh	file submitted is not exportable
 060Eh	file type specified is not imageable
 060Fh	error converting file
 0610h	envelope could not be cancelled
 0611h	Phone Directory is full
 0612h	record is already in the Phone Directory
 0613h	selected group in Phone Directory is full
 0614h	person is already in the group
 0615h	person is not in the group & cannot be removed
 0616h	a graphics file to be created already exists
 0617h	a graphics file to be read is empty
 0618h	GRAPH_CREATE_PAGE called before GRAPH_END_PAGE
 0619h	graph read or write attempted without goto or create
 061Ah	graph page contains no data
 061Bh	Phone Directory is already open for this client
 061Ch	schedule log is already open for this client
 061Dh	receive log is aready open for this client
 061Eh	Phone Directory function requires write mode
 0800h	denied exclusive use of the API

Format of FaxBIOS SYS_LOGIN command buffer:
Offset	Size	Description	(Table 02932)
 00h	WORD	structure size
 02h	WORD	function number
 04h	WORD	return code
 06h	WORD	client ID
 08h	WORD	API Major Version
 0Ah	WORD	API Minor Version
 0Ch	DWORD	reserved for manufacturer's use
 10h 22 BYTEs	manufacturer's ID
 26h	WORD	highest possible device number
 28h	WORD	maximum destinations per envelope
 2Ah	WORD	maximum files per envelope
 2Ch	WORD	FaxBIOS capabilities (see #02933)
 2Eh	DWORD	T.30 capabilities (see #02934)
 32h	WORD	IPC handle
 34h	DWORD	amount of memory needed to load
 38h	WORD	scope (00h for public, nonzero for private)
 3Ah  6 BYTEs	future expansion
 40h	WORD	structure size

Bitfields for FaxBIOS capabilities:
Bit(s)	Description	(Table 02933)
 0	transmit supported
 1	receive supported
 2	IOCTL supported
 3	IOCTL_DIAL supported
 4	IOCTL_ANSWER_FAX supported
 5	manual transmit supported
 6	optional phone services supported
 7	canonical phone objects
 8	seam with next supported

Bitfields for T.30 capabilities:
Bit(s)	Description	(Table 02934)
 0	low vertical resolution (minimum)
 1	high vertical resolution
 2	page width 107mm (4.21 in)
 3	page width 151mm (5.91 in)
 4	page width 215mm (8.46 in) (minimum)
 5	page width 255mm (10.04 in)
 6	page width 303mm (11.93 in)
 7	unused
 8	page length 297mm (11.69 in) (minimum)
 9	page length 364mm (14.33 in)
 10	page length 279mm (11 in)
 11	page length unlimited
 12	Group 4 resolution 300x300
 13	Group 4 resolution 400x400
 14	able to respond to poll from remote
 15	able to poll remote
 16	binary file transfer supported

Format of FaxBIOS SYS_LOGOUT command buffer:
Offset	Size	Description	(Table 02935)
 00h	WORD	structure size
 02h	WORD	function number
 04h	WORD	return code
 06h	WORD	client ID
 08h	DWORD	client tag (for client's internal use)
 0Ch  6 BYTEs	future expansion
 12h	WORD	structure size

Format of FaxBIOS SYS_GET_FAXAPP_INFO command buffer:
Offset	Size	Description	(Table 02936)
 00h 12 BYTEs	common data (see #02935)
 0Ch 80 BYTEs	FaxBIOS data
 5Ch 80 BYTEs	default cover
 ACh 80 BYTEs	default logo
 FCh 80 BYTEs	default signature
14Ch 80 BYTEs	default font 10
19Ch 80 BYTEs	default font 165
1ECh 80 BYTEs	default user font
23Ch 80 BYTEs	default Pdir
28Ch 80 BYTEs	default sort
2DCh 10 BYTEs	default bill
2E6h 10 BYTEs	default route
2F0h 40 BYTEs	default cover sheet form
318h 34 BYTEs	valid dial characters
33Ah  6 BYTEs	local country code
340h  6 BYTEs	local city or area code
346h  6 BYTEs	future expansion
34Ch	WORD	structure size

Format of FaxBIOS STAT_IO_GET command buffer:
Offset	Size	Description	(Table 02937)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	device number
 0Eh	WORD	current activity
 10h	WORD	number of rings (if ringing)
 12h	WORD	number of fascimiles transmitted
 14h	WORD	number of fascimiles received
 16h	WORD	status of last transmission
 18h	WORD	envelope number of last transmission
 1Ah	WORD	index of last destination in envelope
 1Ch	WORD	status of last reception
 1Eh	WORD	current page (if session in progress)
 20h 80 BYTEs	current file
 70h 104 BYTEs	remote number
 D8h 20 BYTEs	last name
 ECh 20 BYTEs	first name
100h 32 BYTEs	company name
120h 32 BYTEs	notes
140h	WORD	current envelope ID (if sending)
142h	WORD	total pages in transmission (if sending)
144h  6 BYTEs	future expansion
14h	WORD	structure size

Format of FaxBIOS STAT_FAXBIOS_GET command buffer:
Offset	Size	Description	(Table 02938)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	status ID
 0Eh	WORD	currenty FaxBIOS function number
 10h	WORD	current Client ID being serviced
 12h	WORD	number of things to do
 14h	WORD	number of them done
 16h	WORD	number of pages to do (if any)
 18h	WORD	number of them done
 1Ah	WORD	number of files to do
 1Ch	WORD	number of them done
 1Eh 80 BYTEs	current File
 6Eh	WORD	0 if all devices are idle
 70h	WORD	number of fascimiles transmitted
 72h	WORD	number of fascimiles received
 74h	WORD	status of last transmission in system
 76h	WORD	envelope ID of last transmission
 78h	WORD	index of last destination in envelope
 7Ah	WORD	status of last reception in system
 7Ch	DWORD	time of next transmission
 80h  6 BYTEs	future expansion
 86h	WORD	structure size

Format of FaxBIOS PDIR_OPEN command buffer:
Offset	Size	Description	(Table 02939)
 00h 12 BYTEs	common data (see #02935)
 0Ch 80 BYTEs	Phone Directory token
 5Ch 80 BYTEs	sort order token
 ACh	WORD	open Mode (0 = read, 1 = write)
 AEh	WORD	Phone Directory handle
 B0h	WORD	number of people
 B2h	WORD	number of groups
 B4h	WORD	bitmap of fields supported by partial read
 B6h  6 BYTEs	future expansion
 BCh	WORD	structure size

Format of FaxBIOS PDIR_CLOSE command buffer:
Offset	Size	Description	(Table 02940)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	Phone Directory handle
 0Eh  6 BYTEs	future expansion
 14h	WORD	structure size

Format of FaxBIOS PDIR_READ_PERSON command buffer:
Offset	Size	Description	(Table 02941)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	Phone Directory handle
 0Eh	WORD	retrieve by index
 10h	WORD	person ID or index
 12h	WORD	how many groups person is in
 14h	WORD	person ID
 16h 20 BYTEs	last name
 2Ah 20 BYTEs	first name
 3Eh 32 BYTEs	company
 5Eh 32 BYTEs	notes
 7Eh  6 BYTEs	FAX country code
 84h  6 BYTEs	FAX city/area code
 8Ah 14 BYTEs	FAX local number
 98h 14 BYTEs	FAX extension
 A6h 24 BYTEs	reserved
 BEh  6 BYTEs	voice country code
 C4h  6 BYTEs	voice city/area code
 CAh 14 BYTEs	voice local number
 D8h 14 BYTEs	voice extension
 E6h 24 BYTEs	reserved
 FEh 10 BYTEs	outbound routing information
108h 10 BYTEs	billing information, credit card etc
112h	DWORD	remote FAX capabilities
116h 21 BYTEs	T.30 poll code of FAX number
12Bh 15 BYTEs	reserved
13Ah  6 BYTEs	future expansion
140h	WORD	structure size

Format of FaxBIOS SCHED_OPEN, SCHED_CANCEL command buffer:
Offset	Size	Description	(Table 02942)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	scheduler handle
 0Eh  6 BYTEs	future expansion
 14h	WORD	structure size

Format of FaxBIOS SCHED_ADD_DEST command buffer:
Offset	Size	Description	(Table 02943)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	schedule handle
 0Eh	WORD	device number if manual send wanted
 10h	WORD	non-zero if poll desired
 12h	WORD	person ID
 14h 20 BYTEs	last name
 28h 20 BYTEs	first name
 3Ch 32 BYTEs	company
 5Ch 32 BYTEs	notes
 7Ch  6 BYTEs	FAX country code
 82h  6 BYTEs	FAX city/area code
 88h 14 BYTEs	FAX local number
 96h 14 BYTEs	FAX extension
 A4h 24 BYTEs	reserved
 BCh  6 BYTEs	voice country code
 C2h  6 BYTEs	voice city/area code
 C8h 14 BYTEs	voice local number
 D6h 14 BYTEs	voice extension
 E4h 24 BYTEs	reserved
 FCh 10 BYTEs	outbound routing information
106h 10 BYTEs	billing information, credit card etc
110h	DWORD	remote FAX capabilities
114h 21 BYTEs	T.30 poll code of FAX number
129h 15 BYTEs	reserved
138h  6 BYTEs	future expansion
13Eh	WORD	structure size
SeeAlso: #02944

Format of FaxBIOS SCHED_ADD_FILE command buffer:
Offset	Size	Description	(Table 02944)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	schedule handle
 0Eh	WORD	file type
		0000h unidentified
		0001h native file format
		0002h ASCII
		0003h FaxBIOS Tiff Class F
 10h 80 BYTEs	file name
 60h 80 BYTEs	font token
 B0h	WORD	conversion options bitmap
 B2h	WORD	resolution
		0000h standard 98 lines per inch, 204 dpi
		0001h fine 196 lines per inch, 204 dpi
		0002h Group4 300 dpi
		0003h Group4 400 dpi
 B4h	WORD	page length
		0000h 279 mm (11 in)
		0001h 297 mm (11.69 in)
		0002h 364 mm (14.33 in)
		0003h unlimited
 B6h	WORD	page width
		0000h 215 mm (8.46 in)
		0001h 255 mm (10.04 in)
		0002h 303 mm (11.93 in)
		0003h 151 mm (5.91 in)
		0004h 107 mm (4.21 in)
 B8h	WORD	binary file transfer specification
		0000h only as FAX
		0001h only as file (for non-faxable files)
		0002h as file when possible else FAX
 BAh	WORD	seam flag (nonzero for seam with next)
 BCh	WORD	delete flag (nonzero to delete when done)
 BEh  6 BYTEs	future expansion
 C4h	WORD	structure size
SeeAlso: #02943,#02945

Format of FaxBIOS SCHED_SET_PARAMS command buffer:
Offset	Size	Description	(Table 02945)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	scheduler handle
 0Eh	DWORD	time to send
 10h 10 BYTEs	priority token
 1Ch 80 BYTEs	logo file token
 6Ch 80 BYTEs	signature file token
 BCh 80 BYTEs	cover page token
10Ch 40 BYTEs	Subject text
134h 40 BYTEs	From text
15Ch	WORD	user ID
15Eh  6 BYTEs	future expansion
164h	WORD	structure size
SeeAlso: #02943,#02944,#02946

Format of FaxBIOS SCHED_CLOSE command buffer:
Offset	Size	Description	(Table 02946)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	scheduler handle
 0Eh	WORD	envelope ID generated
 10h  6 BYTEs	future expansion
 16h	WORD	structure size
SeeAlso: #02945

Format of FaxBIOS SLOG_OPEN, SLOG_CLOSE, RLOG_OPEN, RLOG_CLOSE command buffer:
Offset	Size	Description	(Table 02947)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	log handle
 0Eh	WORD	number of entries
 10h  6 BYTEs	future expansion
 16h	WORD	structure size

Format of FaxBIOS GRAPH_GET_FILE_TYPE command buffer:
Offset	Size	Description	(Table 02948)
 00h 12 BYTEs	common data (see #02935)
 0Ch 80 BYTEs	filename
 5Ch	WORD	file type
		0000h unidentified
		0001h native file format
		0002h ASCII
		0003h FaxBIOS Tiff Class F
 5Eh	WORD	bitmap of supported capabilities
 60h  6 BYTEs	future expansion
 66h	WORD	structure size
SeeAlso: #02949,#02950

Format of FaxBIOS GRAPH_CREATE_FILE command buffer:
Offset	Size	Description	(Table 02949)
 00h 12 BYTEs	common data (see #02935)
 0Ch 80 BYTEs	filename
 5Ch	WORD	graph handle
 5Eh  6 BYTEs	future expansion
 64h	WORD	structure size
SeeAlso: #02948,#02950,#02951

Format of FaxBIOS GRAPH_CLOSE_FILE, GRAPH_END_PAGE command buffer:
Offset	Size	Description	(Table 02950)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	graph handle
 0Eh  6 BYTEs	future expansion
 14h	WORD	structure size
SeeAlso: #02949,#02951

Format of FaxBIOS GRAPH_CREATE_PAGE command buffer:
Offset	Size	Description	(Table 02951)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	graph handle
 0Eh	WORD	resolution
 10h	WORD	page width
 12h  6 BYTEs	future expansion
 18h	WORD	structure size
SeeAlso: #02949,#02950,#02952

Format of FaxBIOS GRAPH_WRITE_PAGE command buffer:
Offset	Size	Description	(Table 02952)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	graph handle
 0Eh	DWORD	pointer to storage for image
 12h	WORD	band height in lines
 14h	WORD	width of page image in bytes
 16h	WORD	facsimile page width constant
 18h	WORD	width of page image in bits
 1Ah	WORD	number of bytes actually processed
 1Ch  6 BYTEs	future expansion
 22h	WORD	structure size
SeeAlso: #02951,#02953

Format of FaxBIOS GRAPH_OPEN_FILE command buffer:
Offset	Size	Description	(Table 02953)
 00h 12 BYTEs	common data (see #02935)
 0Ch 80 BYTEs	filename
 5Ch	WORD	file type
 5Eh	WORD	graph handle
 60h	WORD	number of pages
 62h  6 BYTEs	future expansion
 68h	WORD	structure size
SeeAlso: #02952,#02954

Format of FaxBIOS GRAPH_GOTO_PAGE command buffer:
Offset	Size	Description	(Table 02954)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	graph handle
 0Eh	WORD	page number
 10h	WORD	vertical resolution
 12h	WORD	page width
 14h	DWORD	page length
 18h  6 BYTEs	future expansion
 1Eh	WORD	structure size
SeeAlso: #02952,#02953,#02955

Format of FaxBIOS GRAPH_READ_PAGE command buffer:
Offset	Size	Description	(Table 02955)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	graph handle
 0Eh	DWORD	pointer to storage for image
 12h	WORD	band height in lines
 14h	WORD	width of page image in bytes
 16h	WORD	facsimile page width constant
 18h	WORD	width of page image in bits
 1Ah	WORD	number of bytes actually processed
 1Ch  6 BYTEs	future expansion
 22h	WORD	structure size

Format of FaxBIOS IOCTL_ANSWER_FAX command buffer:
Offset	Size	Description	(Table 02956)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	device number
 0Eh  6 BYTEs	future expansion
 14h	WORD	structure size
SeeAlso: #02957

Format of FaxBIOS IOCTL_DIAL command buffer:
Offset	Size	Description	(Table 02957)
 00h 12 BYTEs	common data (see #02935)
 0Ch	WORD	device number
 0Eh  6 BYTEs	country code
 14h  6 BYTEs	city or area code
 1Ah 14 BYTEs	local number
 28h 14 BYTEs	extension
 36h 14 BYTEs	reserved
 4Eh  6 BYTEs	future expansion
 54h	WORD	structure size
SeeAlso: #02956

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8100" name="2F8100"><b>2F8100</b></a> - INT 2F U - Nanosoft, Inc. TurboNET redirector - INSTALLATION CHECK<br />
<pre>
INT 2F U - Nanosoft, Inc. TurboNET redirector - INSTALLATION CHECK
	AX = 8100h
Return: AL = FFh if installed
Program: TurboNET is a NetBIOS-based file redirector and server; a
	  demonstration version may be downloaded from Nanosoft's BBS
SeeAlso: AX=8000h"TurboNET"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8101" name="2F8101"><b>2F8101</b></a> - INT 2F U - Nanosoft, Inc. TurboNET redirector - ???<br />
<pre>
INT 2F U - Nanosoft, Inc. TurboNET redirector - ???
	AX = 8101h
Return: AL = ???
	DL = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8102" name="2F8102"><b>2F8102</b></a> - INT 2F U - Nanosoft, Inc. TurboNET redirector - ???<br />
<pre>
INT 2F U - Nanosoft, Inc. TurboNET redirector - ???
	AX = 8102h
Return: AL = ???
	DL = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8103" name="2F8103"><b>2F8103</b></a> - INT 2F U - Nanosoft, Inc. TurboNET redirector - GET MACHINE NAME???<br />
<pre>
INT 2F U - Nanosoft, Inc. TurboNET redirector - GET MACHINE NAME???
	AX = 8103h
	ES:DI -&gt; 17-byte buffer
Return: buffer filled

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8104" name="2F8104"><b>2F8104</b></a> - INT 2F U - Nanosoft, Inc. TurboNET redirector - ???<br />
<pre>
INT 2F U - Nanosoft, Inc. TurboNET redirector - ???
	AX = 8104h
	BL = ???
	BH = ???
	CX = ???
	DX = ???
	DS:SI -&gt; 16-byte buffer containing ???
Return: AL = 00h ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8105" name="2F8105"><b>2F8105</b></a> - INT 2F U - Nanosoft, Inc. TurboNET redirector - ???<br />
<pre>
INT 2F U - Nanosoft, Inc. TurboNET redirector - ???
	AX = 8105h
	CX = ??? (don't change current value if 0000h)
	DX = ??? (don't change current value if 0000h)
Return: AL = 00h successful

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8200" name="2F8200"><b>2F8200</b></a> - INT 2F - RESPLAY - SAMPLE/PLAYBACK<br />
<pre>
INT 2F - RESPLAY - SAMPLE/PLAYBACK
	AX = 8200h
	DX:DI -&gt; start of sample space
	CX:BX = length in bytes
Return: AX = status (see #02958)
Program: RESPLAY is a freeware sound sampling/playback utility by Mark J. Cox
SeeAlso: AX=8201h"RESPLAY",AX=8210h

(Table 02958)
Values for RESPLAY status:
 1000h	successful
 2000h	not initialized (see AX=8210h)
 other	RESPLAY not installed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8200_0" name="2F8200_0"><b>2F8200</b></a> - INT 2F U - Nanosoft, Inc. CAPDOS - INSTALLATION CHECK<br />
<pre>
INT 2F U - Nanosoft, Inc. CAPDOS - INSTALLATION CHECK
	AX = 8200h
Return: AL = FFh if installed
Program: CAPDOS is a TSR by Nanosoft, Inc. which allows INT 21h calls to be
	  captured and recorded for later analysis
SeeAlso: AX=8100h,AX=8201h"CAPDOS",AX=8202h"CAPDOS",AX=8203h"CAPDOS"
SeeAlso: AX=8204h"CAPDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8201" name="2F8201"><b>2F8201</b></a> - INT 2F - RESPLAY - INSTALLATION CHECK<br />
<pre>
INT 2F - RESPLAY - INSTALLATION CHECK
	AX = 8201h
Return: AX = 7746h if installed
SeeAlso: AX=8202h"RESPLAY",AX=8210h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8201_0" name="2F8201_0"><b>2F8201</b></a> - INT 2F - Nanosoft, Inc. CAPDOS - CLEAR QUEUE<br />
<pre>
INT 2F - Nanosoft, Inc. CAPDOS - CLEAR QUEUE
	AX = 8201h
Note:	resets queue of captured INT 21 calls
SeeAlso: AX=8200h"CAPDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8202" name="2F8202"><b>2F8202</b></a> - INT 2F - RESPLAY - UNINSTALL<br />
<pre>
INT 2F - RESPLAY - UNINSTALL
	AX = 8202h
Return: AX = status
	    1000h successful
SeeAlso: AX=8201h"RESPLAY",AX=8210h"RESPLAY"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8202_0" name="2F8202_0"><b>2F8202</b></a> - INT 2F - Nanosoft, Inc. CAPDOS - START COLLECTION<br />
<pre>
INT 2F - Nanosoft, Inc. CAPDOS - START COLLECTION
	AX = 8202h
SeeAlso: AX=8200h"CAPDOS",AX=8203h"CAPDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8203" name="2F8203"><b>2F8203</b></a> - INT 2F - Nanosoft, Inc. CAPDOS - STOP COLLECTION<br />
<pre>
INT 2F - Nanosoft, Inc. CAPDOS - STOP COLLECTION
	AX = 8203h
SeeAlso: AX=8200h"CAPDOS",AX=8202h"CAPDOS",AX=8204h"CAPDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8204" name="2F8204"><b>2F8204</b></a> - INT 2F - Nanosoft, Inc. CAPDOS - GET QUEUE PARAMETERS<br />
<pre>
INT 2F - Nanosoft, Inc. CAPDOS - GET QUEUE PARAMETERS
	AX = 8204h
Return: AH = flag: queue wrapped if nonzero
	BX = index of current start of queue
	CX = size of queue in entries
SeeAlso: AX=8200h"CAPDOS",AX=8202h"CAPDOS",AX=8205h"CAPDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8205" name="2F8205"><b>2F8205</b></a> - INT 2F - Nanosoft, Inc. CAPDOS - GET QUEUE ITEM<br />
<pre>
INT 2F - Nanosoft, Inc. CAPDOS - GET QUEUE ITEM
	AX = 8205h
	BX = queue item number
Return: AX,BX,CX,DX,SI,DI,DS,ES as on entry to captured DOS call
SeeAlso: AX=8200h"CAPDOS",AX=8204h"CAPDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8210" name="2F8210"><b>2F8210</b></a> - INT 2F - RESPLAY - INITIALIZE<br />
<pre>
INT 2F - RESPLAY - INITIALIZE
	AX = 8210h
	BL = sound device number (see #02959)
	BH = sample rate in multiples of 250 Hz (14h to A0h)
	CL = direction
	    00h playback
	    01h sample
Return: AX = status (see #02958)
SeeAlso: AX=8200h"RESPLAY",AX=8220h"MODRES"

(Table 02959)
Values for RESPLAY sound device:
 00h	printer port LPT1
 01h	printer port LPT2
 02h	prototype board at I/O address 0300h
 03h	printer port (alternative LPT1)
 04h	internal speaker

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8220" name="2F8220"><b>2F8220</b></a> - INT 2F - MODRES - PLAY MODULE<br />
<pre>
INT 2F - MODRES - PLAY MODULE
	AX = 8220h
	DX:CX -&gt; MODPARM structure (see #02960)
Return: AX = status
	    5722h succesful
	    2000h parameters out of range
	    other MODRES not installed
SeeAlso: AX=8221h,AX=8223h,AX=8225h,AX=8227h,AX=8200h"RESPLAY"

Format of MODPARM Structure:
Offset	Size	Description	(Table 02960)
 00h	WORD	signature 504Dh ("MP" = Modparm)
 02h	BYTE	output device (see #02962 at INT 2F/AX=8221h)
 03h	WORD	segment of start of main module (pattern) data
 05h 31	WORDs	segment of start of sample numbers 1-31
 43h	BYTE	pattern at which to start playing (00h to 7Fh)
 44h	BYTE	function
		00h play from pattern [offset 43h] until end of the song
		01h play indicated pattern [offset 43h] only
 45h	BYTE	Machine speed
		00h 10-12Mhz
		01h 12-25Mhz (default)
		02h 25Mhz+
		03h mix speed 10kHz (fast 8Mhz machines)
		04h mix speed 12kHz (10Mhz machines)
		05h mix speed 13kHz
		06h mix speed 8kHz (test for 8Mhz machines)
 46h	BYTE	allow &gt;64k sample playing
		80h MOD has samples &gt;64k in it
		else all samples in MOD are &lt;64k
Notes:	Main module data and all samples must start on segment boundaries.
	In version 2.00 (ONLY) this function carries on playing (works in
	  the background)
SeeAlso: #02961

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8221" name="2F8221"><b>2F8221</b></a> - INT 2F - MODRES - INSTALLATION CHECK<br />
<pre>
INT 2F - MODRES - INSTALLATION CHECK
	AX = 8221h
Return: AX = status
	    5722h successful
	    other MODRES not installed
	BX = BCD version number (BH = major, BL = minor)
	DX:CX -&gt; Output Device structure (read-only) (see #02961)
SeeAlso: AX=8220h,AX=8222h,AX=8225h,AX=8227h

Format of Output Device structure [array]:
Offset	Size	Description	(Table 02961)
 00h 20 BYTEs	ASCIZ name of the output device
		(end of list if first char is FFh)
 14h	WORD	apparently always FFFFh
 16h	WORD	0000h if output device not available
		else first I/O port for the output device
 18h	WORD	second I/O port for the output device (for example
		  if it is stereo)
		000oh if only one port used or device is not available
 1Ah  7 BYTEs	???
SeeAlso: #02960,#02962

(Table 02962)
Values for MODRES v1.52 output device index:
 00h	PC speaker
 01h	D/A Converter on LPT1
 02h	D/A Converter on LPT2
 03h	D/A Converter on LPT3
 04h	D/A Converter on LPT4
 05h	D/A Converter on LPT1&LPT2 (stereo)
 06h	D/A Converter on LPT1&LPT2 (mono)
 07h	Sound Blaster (port 02x0h)
 08h	User Defined D/A (mono)
 09h	User Defined D/A (stereo)
 0Ah	Stereo-on-1
 0Bh	Disney SS su LPT1
 0Ch	Disney SS su LPT2
 0Dh	Disney SS su LPT3
 0Eh	Disney SS su LPT4
Note:	this list may vary between versions of MODRES

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8222" name="2F8222"><b>2F8222</b></a> - INT 2F - MODRES - UNINSTALL<br />
<pre>
INT 2F - MODRES - UNINSTALL
	AX = 8222h
Return: AX = code segment of the program
Note:	this function does not release the TSRs memory; the caller must do so
SeeAlso: AX=8220h,AX=8221h,AX=8223h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8223" name="2F8223"><b>2F8223</b></a> - INT 2F - MODRES - PLAY SAMPLE<br />
<pre>
INT 2F - MODRES - PLAY SAMPLE
	AX = 8223h
	DX:CX -&gt; SAMPARM structure (see #02963)
Return: AX = status
	    5722h succesful
	    2000h parameters out of range
	    other MODRES not installed
SeeAlso: AX=8221h,AX=8224h,AX=8225h,AX=8226h

Format of SAMPARM Structure:
Offset	Size	Description	(Table 02963)
 00h	WORD	signature 5053h ("SP" = SAMPARM)
 02h	WORD	segment of start of sample to play
 04h	WORD	length of sample (IN WORD)
 06h	BYTE	output device (see #02962 at INT 2F/AX=8221h)
 07h	WORD	pitch to play (see #02964)
 09h	BYTE	volume (from 00h to 40h)
 0Ah	WORD	loop start
 0Ch	WORD	loop length
 0Eh	BYTE	machine speed (see INT 2F/AX=8220h)
SeeAlso: #02960

(Table 02964)
Values for Pitch to play::
 C 0 is	06B0h
 C#0 is	06B0h / 2^(1/12)
 D 0 is	(06B0h / 2^(1/12)) / 2^(1/12)
 ...
Note:	C 1 is	06B0h / 2
	C 2 is	06B0h / 4
	etc.
SeeAlso: #02963

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8224" name="2F8224"><b>2F8224</b></a> - INT 2F - MODRES - ???<br />
<pre>
INT 2F - MODRES - ???
	AX = 8224h
	DX:CX -&gt; ???
Return: ???
SeeAlso: AX=8221h,AX=8223h,AX=8224h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8225" name="2F8225"><b>2F8225</b></a> - INT 2F - MODRES v2.00+ - GET LOCATION IN MOD<br />
<pre>
INT 2F - MODRES v2.00+ - GET LOCATION IN MOD
	AX = 8225h
Return: AL = status
	   00h playing
	   01h reached end or stopped
	AH = speed of MOD
	BX = position within pattern 0000h-0400h
	CL = position within the song (track number)
SeeAlso: AX=8220h,AX=8221h,AX=8223h,AX=8226h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8226" name="2F8226"><b>2F8226</b></a> - INT 2F - MODRES v2.00+ - STOP PLAYING<br />
<pre>
INT 2F - MODRES v2.00+ - STOP PLAYING
	AX = 8226h
Return: AX = status
	    5722h succesful
	    other MODRES not installed
Desc:	stops playing the MOD file before performing critical operations such
	  as disk accesses
SeeAlso: AX=8220h,AX=8221h,AX=8223h,AX=8225h,AX=8227h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8227" name="2F8227"><b>2F8227</b></a> - INT 2F - MODRES - CONFIGURE<br />
<pre>
INT 2F - MODRES - CONFIGURE
	AX = 8227h
	BX = function
	    0001h set default playing speed (06h)
	    0002h select output device
		CL = output device (see #02962 at INT 2F/AX=8221h)
Return: AX = status
	    5722h succesful
	    2000h parameters out of range
	    other MODRES not installed
Note:	function 0001h should be called every time a new module is loaded
SeeAlso: AX=8220h,AX=8221h,AX=8222h,AX=8223h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F86" name="2F86"><b>2F86</b></a> - INT 2F U - ???<br />
<pre>
INT 2F U - ???
	AH = 86h
	AL = function (at least 06h and 07h)
	???
Return: ???
Note:	called by Codeview for Windows
SeeAlso: AH=44h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8900" name="2F8900"><b>2F8900</b></a> - INT 2F - WHOA!.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - WHOA!.COM - INSTALLATION CHECK
	AX = 8900h
Return: AL = state
	    00h not installed
	    FFh installed
Program: WHOA!.COM is a system slow-down utility by Brad D Crandall
SeeAlso: AX=8901h,AX=8902h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8901" name="2F8901"><b>2F8901</b></a> - INT 2F - WHOA!.COM - UNINSTALL<br />
<pre>
INT 2F - WHOA!.COM - UNINSTALL
	AX = 8901h
Return: AL = status
	    FDh successful
	    FEh error
SeeAlso: AX=8900h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F8902" name="2F8902"><b>2F8902</b></a> - INT 2F - WHOA!.COM - SET DELAY COUNT<br />
<pre>
INT 2F - WHOA!.COM - SET DELAY COUNT
	AX = 8902h
	BX = delay count (larger values slow system down more)
Return: AL = status
	    FDh successful
	    FEh error
Program: WHOA!.COM is a system slow-down utility by Brad D Crandall
SeeAlso: AX=8900h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9000" name="2F9000"><b>2F9000</b></a> - INT 2F U - RAID - INSTALLATION CHECK<br />
<pre>
INT 2F U - RAID - INSTALLATION CHECK
	AX = 9000h
Return: AL = FFh if installed
Program: RAID (Resident AID) is a TSR utility program by Ross Neilson
	  Wentworth that resides mostly in EMS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9001" name="2F9001"><b>2F9001</b></a> - INT 2F U - RAID - GET ???<br />
<pre>
INT 2F U - RAID - GET ???
	AX = 9001h
Return: DX:AX -&gt; ???
SeeAlso: AX=9000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9002" name="2F9002"><b>2F9002</b></a> - INT 2F U - RAID - GET RESIDENT SEGMENT<br />
<pre>
INT 2F U - RAID - GET RESIDENT SEGMENT
	AX = 9002h
Return: AX = segment of resident (conventional memory) portion
SeeAlso: AX=9000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9003" name="2F9003"><b>2F9003</b></a> - INT 2F U - RAID - UNINSTALL<br />
<pre>
INT 2F U - RAID - UNINSTALL
	AX = 9003h
Return: ???
SeeAlso: AX=9000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9004" name="2F9004"><b>2F9004</b></a> - INT 2F U - RAID - GET ???<br />
<pre>
INT 2F U - RAID - GET ???
	AX = 9004h
Return: AX = first available paragraph past end of resident portion???
	CX destroyed
SeeAlso: AX=9000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F92" name="2F92"><b>2F92</b></a> - INT 2F - Network Courier E-Mail - API<br />
<pre>
INT 2F - Network Courier E-Mail - API
	AH = 92h
	AL = function
	    00h installation check
	    01h uninstall
	    02h pop down MICRO.EXE notification window
	    03h ???
	    04h ???
	    05h ???
Return: ???
Program: The Network Courier is an electronic mail package by Consumers
	  Software of Vancouver, BC which was bought by Microsoft in 1991 and
	  renamed Microsoft Mail v3.0.
SeeAlso: AX=9400h,AX=9401h,AX=9402h,AH=9Ch
Index:	installation check;Network Courier E-Mail
Index:	uninstall;Network Courier E-Mail

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9200" name="2F9200"><b>2F9200</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - BUG<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - BUG
	AX = 9200h
Program: DRIVEMAP is a redirector which allows drives on computers connected
	  over the parallel or serial ports to appear as local drives
BUG:	jumps to data because jump table entry is 0000h
Note:	DRIVEMAP returns AX=FFFFh if not a valid function number in AL

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9201" name="2F9201"><b>2F9201</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - CHECK IF MAPPED DRIVE<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - CHECK IF MAPPED DRIVE
	AX = 9201h
	DL = drive number (01h = A:, etc.)
Return: AL = 92h if mapped drive
	AH may be destroyed (v8.0 DRIVEMAP returns AX=0000h if not mapped)
SeeAlso: AX=9204h,AX=920Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9202" name="2F9202"><b>2F9202</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - UNINSTALL<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - UNINSTALL
	AX = 9202h
	BX = caller's CS
Return: AX = status
	    0000h failed
	    nonzero successful
SeeAlso: AX=9204h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9203" name="2F9203"><b>2F9203</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET VERSION<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - GET VERSION
	AX = 9203h
Return: AH = major version
	AL = minor version
	CX = segment of resident code
Note:	the DRIVEMAP included with PC Tools v8.0 is version 1.00
SeeAlso: AX=9204h,INT 16/AX=FF70h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9204" name="2F9204"><b>2F9204</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - INSTALLATION CHECK<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - INSTALLATION CHECK
	AX = 9204h
Return: AX = 9200h if installed
	   BL = ???
	   CX = segment of resident code
Program: DRIVEMAP is a redirector which allows drives on computers connected
	  over the parallel or serial ports to appear as local drives
SeeAlso: AX=9201h,AX=9202h,AX=9203h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9205" name="2F9205"><b>2F9205</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - SET ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - SET ???
	AX = 9205h
	BX = ??? to set
Return: CX = new value of ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9206" name="2F9206"><b>2F9206</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 9206h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9207" name="2F9207"><b>2F9207</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???
	AX = 9207h
	???
Return: AX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9208" name="2F9208"><b>2F9208</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 9208h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9209" name="2F9209"><b>2F9209</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 9209h
	???
Return: AX = ???
	BX = ???
	CX = ???
	DX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F920A" name="2F920A"><b>2F920A</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 920Ah
	BX = ???
Return: AX = ??? or FFFBh on error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F920B" name="2F920B"><b>2F920B</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - SET DRIVE MAPPING<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - SET DRIVE MAPPING
	AX = 920Bh
	BL = drive letter (41h ['A'] = A:, etc)
	CX = ??? (0000h removes mapping)
Return: AX = ??? or FFF8h on error
SeeAlso: AX=9201h,AX=920Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F920C" name="2F920C"><b>2F920C</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 920Ch
	???
Return: AX = ??? (0002h)
	CX = ??? (0000h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F920D" name="2F920D"><b>2F920D</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET DRIVE TYPE<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - GET DRIVE TYPE
	AX = 920Dh
	BL = drive letter (41h ['A'] = A:, etc)
Return: AX = type flags
		bit 0: ???
		bit 1: available
		bit 5: local
	BX = ???
	CX = segment of resident code (apparently an unintended side effect)
Program: DRIVEMAP is a redirector which allows drives on computers connected
	  over the parallel or serial ports to appear as local drives
SeeAlso: AX=9218h,INT 16/AX=FF70h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F920E" name="2F920E"><b>2F920E</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - SET LPT MAPPING<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - SET LPT MAPPING
	AX = 920Eh
	BX = port number (0-2)
	CX = ??? (0000h to unmap)
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F920F" name="2F920F"><b>2F920F</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???
	AX = 920Fh
	ES:DI -&gt; 3-byte buffer for ???
Return: CX = 0000h
	ES:DI buffer filled

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9210" name="2F9210"><b>2F9210</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 9210h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9211" name="2F9211"><b>2F9211</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???
	AX = 9211h
	ES:DI -&gt; 8-word buffer for ???
Return: CX = 0000h
	ES:DI buffer filled

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9212" name="2F9212"><b>2F9212</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - CRITICAL SECTION???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - CRITICAL SECTION???
	AX = 9212h
	BX = phase
	    0000h leave critical section???
	    nonzero enter critical section???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9213" name="2F9213"><b>2F9213</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 9213h
	BX = function number (0000h-000Bh)
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9214" name="2F9214"><b>2F9214</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???
	AX = 9214h
	ES:DI -&gt; 6-word buffer for ???
Return: CX = 0000h
	AX = ???
	ES:DI buffer filled

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9215" name="2F9215"><b>2F9215</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???
	AX = 9215h
	ES:DI -&gt; 100-word buffer for ???
Return: CX = 0000h
	ES:DI buffer filled

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9216" name="2F9216"><b>2F9216</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 9216h
	ES:DI -&gt; ???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9217" name="2F9217"><b>2F9217</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 9217h
	DS:SI -&gt; 25-word buffer containing ???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9218" name="2F9218"><b>2F9218</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET LPT TYPE???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - GET LPT TYPE???
	AX = 9218h
	BX = port number???
Return: AX = ???
	BX = ??? (0000h)
	CX = ??? (0000h)
Program: DRIVEMAP is a redirector which allows drives on computers connected
	  over the parallel or serial ports to appear as local drives

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9219" name="2F9219"><b>2F9219</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 9219h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F921A" name="2F921A"><b>2F921A</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 921Ah
	???
Return: AH = ???
	AL = ???
	BX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F921B" name="2F921B"><b>2F921B</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 921Bh
	???
Return: AX = ???
	CX = segment of resident code (apparently an unintended side effect)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F921C" name="2F921C"><b>2F921C</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 921Ch
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F921D" name="2F921D"><b>2F921D</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - GET ???
	AX = 921Dh
Return: AX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F921E" name="2F921E"><b>2F921E</b></a> - INT 2F U - PC Tools v8.0 DRIVEMAP - ???<br />
<pre>
INT 2F U - PC Tools v8.0 DRIVEMAP - ???
	AX = 921Eh
	???
Return: ???
Program: DRIVEMAP is a redirector which allows drives on computers connected
	  over the parallel or serial ports to appear as local drives
Note:	this function sets two variables to 24h each
SeeAlso: INT 16/AX=FF70h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F93" name="2F93"><b>2F93</b></a> - INT 2F - InnerMission v1.7+ - INSTALLATION CHECK<br />
<pre>
INT 2F - InnerMission v1.7+ - INSTALLATION CHECK
	AH = 93h
	BX = CX = AX
Return: AL = state
	    FFh if installed and BX=CX=AX on entry
		BX = segment of resident code
	    01h if installed but BX or CX differ from AX (multiplex number not
		  available)
Program: InnerMission is a shareware graphical screen blanker by Kevin Stokes
SeeAlso: INT 14/AX=AA01h,INT 2F/AX=6400h
Index:	screen saver;InnerMission

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9400" name="2F9400"><b>2F9400</b></a> - INT 2F - MICRO.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F - MICRO.EXE - INSTALLATION CHECK
	AX = 9400h
Return: AL = 07h or 08h if installed
Program: MICRO.EXE is a TSR of the Microsoft Mail part of Workgroup Connection
SeeAlso: AH=92h"Network Courier",AX=9401h,AX=9402h,AX=9403h,AX=9404h
SeeAlso: INT 21/AH=3Fh"WORKGRP.SYS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9401" name="2F9401"><b>2F9401</b></a> - INT 2F - MICRO.EXE - SET ??? FLAG<br />
<pre>
INT 2F - MICRO.EXE - SET ??? FLAG
	AX = 9401h
SeeAlso: AX=9400h,AX=9403h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9402" name="2F9402"><b>2F9402</b></a> - INT 2F - MICRO.EXE - ???<br />
<pre>
INT 2F - MICRO.EXE - ???
	AX = 9402h
	???
Return: ???
SeeAlso: AX=9400h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9403" name="2F9403"><b>2F9403</b></a> - INT 2F - MICRO.EXE - SET ??? FLAG<br />
<pre>
INT 2F - MICRO.EXE - SET ??? FLAG
	AX = 9403h
SeeAlso: AX=9400h,AX=9404h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9404" name="2F9404"><b>2F9404</b></a> - INT 2F - MICRO.EXE - CLEAR ??? FLAG<br />
<pre>
INT 2F - MICRO.EXE - CLEAR ??? FLAG
	AX = 9404h
	ES:DI -&gt; name of executable from which MICRO.EXE was started
Note:	if the specified name is identical to the name of the program file
	  from which MICRO was started, the ??? flag is cleared; otherwise,
	  it is left unchanged
SeeAlso: AX=9400h,AX=9403h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F96C7" name="2F96C7"><b>2F96C7</b></a> - INT 2F U - STRETCH - INSTALLATION CHECK<br />
<pre>
INT 2F U - STRETCH - INSTALLATION CHECK
	AX = 96C7h
Return: AX = AAAAh if installed
Program: stretch.exe is a TSR for Toshiba Laptops with WD90C24 video chip
	  to avoid blank screen areas in VGA text modes by increasing
	  inter-line spacing

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F97" name="2F97"><b>2F97</b></a> - INT 2F U - Micro Focus COBOL v3.1.31 internal - ???<br />
<pre>
INT 2F U - Micro Focus COBOL v3.1.31 internal - ???
	AH = 97h
	AL = function
	    00h installation check
		Return: AL = FFh if installed
	    08h get ???
		Return: AL = ???
			BX = ???
			DX = ???
			AH destroyed
	    20h get ???
		Return: AX:BX = far entry point of ???
			CX = segment of ???
	    80h ???
		Return: ???
Notes:	Micro Focus COBOL compiler v3.1.31 and companion programs supply
	  these functions for internal use; these programs call the
	  installation check at startup (before installing the INT 2F
	  handler) and crash the system if a not authorized program answers
	  with AL=FFh
	the handler checks AL only if an internal flag is 1, otherwise ???
SeeAlso: AH=98h"COBOL",AH=99h"COBOL",AH=9Ah"COBOL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F98" name="2F98"><b>2F98</b></a> - INT 2F U - Micro Focus COBOL v3.1.31 internal - ???<br />
<pre>
INT 2F U - Micro Focus COBOL v3.1.31 internal - ???
	AH = 98h
	AL = function
	    00h installation check
		Return: AL = FFh if installed
	    10h get ???
		Return: AX = ???
	    18h get segment of ???
		Return: AX = segment of ???
	    19h get pointer to ???
		Return: AX:BX -&gt; ???
Notes:	Micro Focus COBOL compiler v3.1.31 and companion programs supply
	  these functions for internal use; these programs call the
	  installation check at startup (before installing the INT 2F
	  handler) and crash the system if a not authorized program answers
	  with AL=FFh
	the handler checks AL only if an internal flag is 0, otherwise ???
SeeAlso: AH=97h"COBOL",AH=99h"COBOL",AH=9Ah"COBOL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9800" name="2F9800"><b>2F9800</b></a> - INT 2F U - S3RMDRV.SYS - INSTALLATION CHECK / VERSION CHECK<br />
<pre>
INT 2F U - S3RMDRV.SYS - INSTALLATION CHECK / VERSION CHECK
	AX = 9800h
	BX = function
	    0000h installation check
		Return: AX = 524Dh ('RM') if installed
	    0001h get driver version
		Return: AX = driver version (AH=major, AL=BCD minor)
Program: S3RMDRV.SYS provides support for the S3 MPEG driver FMPDRV
SeeAlso: AX=9803h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9803" name="2F9803"><b>2F9803</b></a> - INT 2F U - S3RMDRV.SYS - COPY ??? INTO USER BUFFER<br />
<pre>
INT 2F U - S3RMDRV.SYS - COPY ??? INTO USER BUFFER
	AX = 9803h
	DX:BX -&gt; 116-byte buffer for ASCIZ ???
Return: AX = 0000h
	DX:BX buffer filled with string stored in driver from its parameter
	  list when it was loaded
Note:	the examined version of the driver returns CF set for any AL other
	  than 00h or 03h
SeeAlso: AX=9800h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F99" name="2F99"><b>2F99</b></a> - INT 2F U - Micro Focus COBOL v3.1.31 internal - ???<br />
<pre>
INT 2F U - Micro Focus COBOL v3.1.31 internal - ???
	AH = 99h
	???
Return: ???
Note:	used internally by Micro Focus COBOL compiler v3.1.31 and companion
	  programs
SeeAlso: AH=97h"COBOL",AH=98h"COBOL",AH=9Ah"COBOL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9900" name="2F9900"><b>2F9900</b></a> - INT 2F U - DOS Navigator II - INSTALLATION CHECK<br />
<pre>
INT 2F U - DOS Navigator II - INSTALLATION CHECK
	AX = 9900h
Return: BX = 444Eh ('DN') if installed
	    AX = number of DOS Navigator executions
	    CL = child process exit code
	    DX = version number (see #02965)
Notes:	old versions of DOS Navigator II always returned AH=1, while newer
	  ones return AH=0 and store AL in the DN.FLG file
Program: DOS Navigator is a multi-window shell for MS-DOS by RIT S.R.L.
	  DOS Navigator(TM) is a registered trademark of RIT S.R.L.
SeeAlso: AX=9901h,AX=9902h,AX=9903h,AX=9904h,AX=9905h,AX=9906h

(Table 02965)
Values for DOS Navigator II version code:
 2100h	version 1.35
 2138h	version 1.38
 2141h	version 1.41
 2150h	version 1.50

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9901" name="2F9901"><b>2F9901</b></a> - INT 2F U - DOS Navigator II - RETURN POINTER TO COMMAND LINE<br />
<pre>
INT 2F U - DOS Navigator II - RETURN POINTER TO COMMAND LINE
	AX = 9901h
Return: ES:BX -&gt; command line (terminated with 0Dh)
	AX = ES
SeeAlso: AX=9900h,AX=9902h,AX=9903h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9902" name="2F9902"><b>2F9902</b></a> - INT 2F U - DOS Navigator II - SET 'TRUE' EXIT CODE OF DN.PRG<br />
<pre>
INT 2F U - DOS Navigator II - SET 'TRUE' EXIT CODE OF DN.PRG
	AX = 9902h
	CL = exit code
Return: AX destroyed
SeeAlso: AX=9900h,AX=9901h,AX=9903h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9903" name="2F9903"><b>2F9903</b></a> - INT 2F U - DOS Navigator II - SPECIFY HOW TO EXECUTE COMMANDS<br />
<pre>
INT 2F U - DOS Navigator II - SPECIFY HOW TO EXECUTE COMMANDS
	AX = 9903h
	CL = 1 to use INT 2E
	CL &lt;&gt; 1 to use INT 21/AH=4Bh
SeeAlso: AX=9900h,AX=9901h,AX=9902h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9904" name="2F9904"><b>2F9904</b></a> - INT 2F U - DOS Navigator II v1.49 - SET ???<br />
<pre>
INT 2F U - DOS Navigator II v1.49 - SET ???
	AX = 9904h
	CX:DX = new value for ???
SeeAlso: AX=9900h,AX=9905h,AX=9906h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9905" name="2F9905"><b>2F9905</b></a> - INT 2F U - DOS Navigator II v1.49 - GET ???<br />
<pre>
INT 2F U - DOS Navigator II v1.49 - GET ???
	AX = 9905h
Return: CX:DX = current value of ??? (set by AX=9904h)
SeeAlso: AX=9900h,AX=9904h,AX=9906h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9906" name="2F9906"><b>2F9906</b></a> - INT 2F U - DOS Navigator II v1.49 - GET ???<br />
<pre>
INT 2F U - DOS Navigator II v1.49 - GET ???
	AX = 9906h
	DX = new value for ??? (bit 15 must be set, otherwise not changed)
Return: CX = previous value for ???
SeeAlso: AX=9900h,AX=9904h,AX=9905h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9A" name="2F9A"><b>2F9A</b></a> - INT 2F U - Micro Focus COBOL v3.1.31 internal - ???<br />
<pre>
INT 2F U - Micro Focus COBOL v3.1.31 internal - ???
	AH = 9Ah
	???
Return: ???
Note:	used internally by Micro Focus COBOL compiler v3.1.31 and companion
	  programs
SeeAlso: AH=97h"COBOL",AH=98h"COBOL",AH=99h"COBOL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9C" name="2F9C"><b>2F9C</b></a> - INT 2F - Network Courier E-Mail OPERATOR.EXE - API<br />
<pre>
INT 2F - Network Courier E-Mail OPERATOR.EXE - API
	AH = 9Ch
	AL = subfunction
	    01h uninstall
Return: ???
Program: The Network Courier is an electronic mail package by Consumers
	  Software of Vancouver, BC which was bought by Microsoft in 1991 and
	  renamed Microsoft Mail v3.0.
SeeAlso: AH=92h
Index:	uninstall;Network Courier E-Mail OPERATOR.EXE

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9E00" name="2F9E00"><b>2F9E00</b></a> - INT 2F U - INTMON v2.1 - INSTALLATION CHECK<br />
<pre>
INT 2F U - INTMON v2.1 - INSTALLATION CHECK
	AX = 9E00h
Return: AX = FFFFh if installed
	    BX = segment of resident code
Program: INTMON is a shareware interactive interrupt monitoring TSR for 386
	  and higher machines by Celso Minnitti, Jr.
SeeAlso: AX=9E01h,AX=9E02h,AX=9E03h,AX=9F00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9E01" name="2F9E01"><b>2F9E01</b></a> - INT 2F U - INTMON v2.1 - RESET<br />
<pre>
INT 2F U - INTMON v2.1 - RESET
	AX = 9E01h
Return: ???
Desc:	this function specifies that INTMON should assume that any interrupts
	  on which it is currently awaiting a return have completed (i.e.
	  interrupts which never return such as INT 20 and INT 27)
SeeAlso: AX=9E00h,AX=9E03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9E02" name="2F9E02"><b>2F9E02</b></a> - INT 2F U - INTMON v2.1 - DISPLAY CPU REGISTERS???<br />
<pre>
INT 2F U - INTMON v2.1 - DISPLAY CPU REGISTERS???
	AX = 9E02h
Return: ???
SeeAlso: AX=9E00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9E03" name="2F9E03"><b>2F9E03</b></a> - INT 2F U - INTMON v2.1 - HOOK INTERRUPT???<br />
<pre>
INT 2F U - INTMON v2.1 - HOOK INTERRUPT???
	AX = 9E03h
	BH = interrupt number???
Return: ???
Note:	if AL &gt; 03h on entry, INTMON 2.1 returns immediately
SeeAlso: AX=9E00h,AX=9E01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9F00" name="2F9F00"><b>2F9F00</b></a> - INT 2F U - INTCFG v2.1 - INSTALLATION CHECK<br />
<pre>
INT 2F U - INTCFG v2.1 - INSTALLATION CHECK
	AX = 9F00h
Return: AX = FFFFh if installed
Program: INTCFG is an optionally-resident control program for INTMON by Celso
	  Minnitti, Jr.
SeeAlso: AX=9E00h,AX=9F01h,AX=9F30h,AX=9F49h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9F01" name="2F9F01"><b>2F9F01</b></a> - INT 2F U - INTCFG v2.1 - ???<br />
<pre>
INT 2F U - INTCFG v2.1 - ???
	AX = 9F01h
	???
Return: ???
SeeAlso: AX=9F00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9F30" name="2F9F30"><b>2F9F30</b></a> - INT 2F U - INTCFG v2.1 - GET ???<br />
<pre>
INT 2F U - INTCFG v2.1 - GET ???
	AX = 9F30h
Return: AX = ??? (0002h)
SeeAlso: AX=9F00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F9F49" name="2F9F49"><b>2F9F49</b></a> - INT 2F U - INTCFG v2.1 - UNINSTALL<br />
<pre>
INT 2F U - INTCFG v2.1 - UNINSTALL
	AX = 9F49h
Return: AX,DX,DS,ES destroyed
SeeAlso: AX=9F00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FA1--BX0081" name="2FA1--BX0081"><b>2FA1--BX0081</b></a> - INT 2F - Ergo DOS extenders - INSTALLATION CHECK<br />
<pre>
INT 2F - Ergo DOS extenders - INSTALLATION CHECK
	AH = A1h
	BX = 0081h
	AL = which
	    FEh OS/286,OS/386
	    FFh HummingBoard DOS extender
	ES:DI -&gt; 16-byte buffer
Return: if installed, first four bytes of ES:DI buffer are "IABH"
Note:	since TKERNEL is a licensed version, it is likely that subfunctions
	  BX=0082h and BX=0084h are present and function identically to the
	  AX=FBA1h/BX=008xh calls
SeeAlso: AX=ED00h,AX=FBA1h/BX=0081h,INT 15/AX=BF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FA189" name="2FA189"><b>2FA189</b></a> - INT 2F U - Biologic HRAMDEV.SYS - API<br />
<pre>
INT 2F U - Biologic HRAMDEV.SYS - API
	AX = A189h
	BX = subfunction
	    0000h set ???
	    0001h remove ???
	    0002h get status ???
	    0003h enable ???
	    0004h disable ???
	    0005h set ??? flag
	    0006h clear ??? flag
	    0007h set ??? flag
	    0008h clear ??? flag
	    0009h set ???
	ES:DI -&gt; function-specific arguments
		if func 0000h: 20-byte buffer containing ???
		if func 0001h: 20-byte buffer for returned ???
		if func 0002h: 16-byte buffer for returned ???
		if func 0009h: WORD containing ???
Return: BX = A189h if installed
	AH = status
	    00h successful
	    FFh failed or invalid function number
Program: HRAMDEV.SYS is a part of the shareware package HRAM by Biologic which
	  provides improved high memory access under MS-DOS 5.0
Note:	functions 00h and 01h use a stack of four entries; function 01h always
	  removes the values stored with the most recent function 00h call
	  which has not yet been matched with a function 01h call.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FA4E0" name="2FA4E0"><b>2FA4E0</b></a> - INT 2F - Futurus Team - INSTALLATION CHECK<br />
<pre>
INT 2F - Futurus Team - INSTALLATION CHECK
	AX = A4E0h
Return: AL = 52h ("R") if installed
	    AH = major version plus 30h ("0")
	    ES:BX -&gt; ??? (INT A4 handler???)
Note:	older versions of Right Hand Man (from which Team evolved) store the
	  signature "RH" at offset 103h in the INT 2F handler's segment
SeeAlso: INT A4"Right Hand Man"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FA900" name="2FA900"><b>2FA900</b></a> - INT 2F - METZTSR.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - METZTSR.COM - INSTALLATION CHECK
	AX = A900h
	CF set
Return: CF clear if resident
	    AX = 97FFh
	CF set if not present
Notes:	METZTSR.COM prevents METZ applications (such as the MAGIC screen
	  saver) inactivity timeout while running a DOSapp under MS Windows.
	the default multiplex number is A9h, but may be set to any value from
	  80h to FFh with a commandline switch
SeeAlso: AX=A901h,AX=A902h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FA901" name="2FA901"><b>2FA901</b></a> - INT 2F - METZTSR.COM - GET TIME OF LAST KEYBOARD ACTIVITY<br />
<pre>
INT 2F - METZTSR.COM - GET TIME OF LAST KEYBOARD ACTIVITY
	AX = A901h
	CF set
Return: CF clear if successful
	    AX:DX = BIOS time at which INT 09 was last invoked
	CF set if not present
SeeAlso: INT 09,INT 1A/AH=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FA902" name="2FA902"><b>2FA902</b></a> - INT 2F - METZTSR.COM - SET METZ Ctrl-Alt-Del FLAG<br />
<pre>
INT 2F - METZTSR.COM - SET METZ Ctrl-Alt-Del FLAG
	AX = A902h
	BL = new value
	    00h Ctrl-Alt-Del not allowed
	    else Ctrl-Alt-Del allowed (startup default is 01h)
	CF set
Return: CF clear if successful
	    AX = 97FFh
	CF set if not resident
SeeAlso: AX=A903h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FA903" name="2FA903"><b>2FA903</b></a> - INT 2F - METZTSR.COM - GET METZ Ctrl-Alt-Del FLAG<br />
<pre>
INT 2F - METZTSR.COM - GET METZ Ctrl-Alt-Del FLAG
	AX = A903h
	CF set
Return: CF clear if successful
	    AX = 97FFh if Ctrl-Alt-Del allowed
	    AX = 0000h if Ctrl-Alt-Del not allowed
	CF set if not resident
SeeAlso: AX=A902h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAA" name="2FAA"><b>2FAA</b></a> - INT 2F - Player's Tool 3.996b+ - UNINSTALL<br />
<pre>
INT 2F - Player's Tool 3.996b+ - UNINSTALL
	AH = AAh
Return: AL = status
	    00h unloaded successfully
	    01h unable to unload: in DOS shell
Program: Player's Tool is a game cheater by Dima Yakunin & Andy Robinson
SeeAlso: AH=ABh"Player's Tool",AH=ACh"Player's Tool",INT 10/AH=AAh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAA00" name="2FAA00"><b>2FAA00</b></a> - INT 2F - VIDCLOCK.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - VIDCLOCK.COM - INSTALLATION CHECK
	AX = AA00h
Return: AL = 00h not installed
	     FFh installed
Program: VIDCLOCK.COM is a memory-resident clock by Thomas G. Hanlin III

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB" name="2FAB"><b>2FAB</b></a> - INT 2F - Player's Tool 3.996b+ - INSTALLATION CHECK<br />
<pre>
INT 2F - Player's Tool 3.996b+ - INSTALLATION CHECK
	AH = ABh
Return: BH = FFh if installed
	    BL = DOS shell state
		01h in DOS shell
		00h not in DOS shell
SeeAlso: AH=AAh"Player's Tool",AH=ACh"Player's Tool",INT 10/AH=ABh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB00" name="2FAB00"><b>2FAB00</b></a> - INT 2F - Btrieve Multi-User - INSTALLATION CHECK<br />
<pre>
INT 2F - Btrieve Multi-User - INSTALLATION CHECK
	AX = AB00h
Return: AL = 4Dh if installed
SeeAlso: AX=AB01h,AX=AB02h,INT 7B"Btrieve"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB00_0" name="2FAB00_0"><b>2FAB00</b></a> - INT 2F - SRSoft MODAL PC v2+ - INSTALLATION CHECK / GET VERSION<br />
<pre>
INT 2F - SRSoft MODAL PC v2+ - INSTALLATION CHECK / GET VERSION
	AX = AB00h
Return: AX = 5253h ('SR' byte-swapped) if installed
	    BX = MODAL PC version (BL = major, BH = minor)
Program: MODAL PC is an algorithm/real-system simulation package by SR Soft
	  using Petri-nets to describe simulated objects
SeeAlso: AX=AB01h"MODAL",AX=AB02h"MODAL",AX=AB06h"MODAL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB01" name="2FAB01"><b>2FAB01</b></a> - INT 2F - Btrieve Multi-User - EXECUTE Btrieve OPERATION<br />
<pre>
INT 2F - Btrieve Multi-User - EXECUTE Btrieve OPERATION
	AX = AB01h
	BX = process ID
	DS:DX -&gt; 38-byte parameter record (see #03840 at INT 7B"Btrieve")
Return: AL = status
	    00h OK
	    other retry after calling INT 7F/AX=0200h
SeeAlso: AX=AB00h"Btrieve",AX=AB02h"Btrieve",INT 7B"Btrieve",INT 7F/AX=0200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB01_0" name="2FAB01_0"><b>2FAB01</b></a> - INT 2F - SRSoft MODAL PC v2+ - GET PROCESS RUN PARAMETER<br />
<pre>
INT 2F - SRSoft MODAL PC v2+ - GET PROCESS RUN PARAMETER
	AX = AB01h
Return: AX = 5253h ('SR' byte-swapped) if installed
	BL = run parameter
	    00h normal process
	    01h run with tracing enabled
	    02h run initialization process (first thread of main task)
SeeAlso: AX=AB00h"MODAL",AX=AB02h"MODAL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB02" name="2FAB02"><b>2FAB02</b></a> - INT 2F - Btrieve Multi-User - GET NEW PROCESS ID<br />
<pre>
INT 2F - Btrieve Multi-User - GET NEW PROCESS ID
	AX = AB02h
Return: AL = 00h successful
	    BX = process ID
	AL &gt; 00h failed, retry after calling INT 7F/AX=0200h
SeeAlso: AX=AB00h,AX=AB01h,INT 7B"Btrieve",INT 7F/AX=0200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB02_0" name="2FAB02_0"><b>2FAB02</b></a> - INT 2F - SRSoft MODAL PC v2+ - SET PROCESS EXIT CODE<br />
<pre>
INT 2F - SRSoft MODAL PC v2+ - SET PROCESS EXIT CODE
	AX = AB02h
	BL = exit code
Return: AX = 5253h ('SR' byte-swapped) if installed
SeeAlso: AX=AB00h"MODAL",AX=AB01h"MODAL",AX=AB03h"MODAL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB03" name="2FAB03"><b>2FAB03</b></a> - INT 2F - SRSoft MODAL PC v2+ - ALLOCATE COMMON MEMORY<br />
<pre>
INT 2F - SRSoft MODAL PC v2+ - ALLOCATE COMMON MEMORY
	AX = AB03h
	BX = required size of common memory for variables/semaphores in bytes
Return: AX = 5253h ('SR' byte-swapped) if installed
SeeAlso: AX=AB00h"MODAL",AX=AB02h"MODAL",AX=AB04h"MODAL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB04" name="2FAB04"><b>2FAB04</b></a> - INT 2F - SRSoft MODAL PC v2+ - GET ALL COMMON VARIABLES AND SEMAPHORES<br />
<pre>
INT 2F - SRSoft MODAL PC v2+ - GET ALL COMMON VARIABLES AND SEMAPHORES
	AX = AB04h
	DS:DX -&gt; buffer for common data
Return: AX = 5253h ('SR' byte-swapped) if installed
	CF clear if successful
	CF set on error
SeeAlso: AX=AB00h"MODAL",AX=AB03h"MODAL",AX=AB05h"MODAL",AX=AB06h,AX=AB07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB05" name="2FAB05"><b>2FAB05</b></a> - INT 2F - SRSoft MODAL PC v2+ - SET ALL COMMON VARIABLES AND SEMAPHORES<br />
<pre>
INT 2F - SRSoft MODAL PC v2+ - SET ALL COMMON VARIABLES AND SEMAPHORES
	AX = AB05h
	DS:DX -&gt; buffer containing common data
Return: AX = 5253h ('SR' byte-swapped) if installed
	CF clear if successful
	CF set on error
SeeAlso: AX=AB00h"MODAL",AX=AB03h"MODAL",AX=AB04h"MODAL",AX=AB06h,AX=AB07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB06" name="2FAB06"><b>2FAB06</b></a> - INT 2F - SRSoft MODAL PC v2+ - GET A COMMON VARIABLE OR SEMAPHORE<br />
<pre>
INT 2F - SRSoft MODAL PC v2+ - GET A COMMON VARIABLE OR SEMAPHORE
	AX = AB06h
	BX = offset of variable or semaphore in common memory
	CX = variable/semaphore size in bytes
	DS:DX -&gt; buffer for variable or semaphore
Return: AX = 5253h ('SR' byte-swapped) if installed
	CF clear if successful
	CF set on error
SeeAlso: AX=AB00h"MODAL",AX=AB04h,AX=AB05h,AX=AB07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAB07" name="2FAB07"><b>2FAB07</b></a> - INT 2F - SRSoft MODAL PC v2+ - SET A COMMON VARIABLE OR SEMAPHORE<br />
<pre>
INT 2F - SRSoft MODAL PC v2+ - SET A COMMON VARIABLE OR SEMAPHORE
	AX = AB07h
	BX = offset of variable or semaphore in common memory
	CX = variable/semaphore size in bytes
	DS:DX -&gt; buffer containing variable or semaphore
Return: AX = 5253h ('SR' byte-swapped) if installed
	CF clear if successful
	CF set on error
SeeAlso: AX=AB00h"MODAL",AX=AB04h,AX=AB05h,AX=AB06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC" name="2FAC"><b>2FAC</b></a> - INT 2F u - Player's Tool 3.996b+ - POP UP<br />
<pre>
INT 2F u - Player's Tool 3.996b+ - POP UP
	AH = ACh
Return: AX = 1001h
SeeAlso: AH=AAh"Player's Tool",AH=ABh"Player's Tool"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC00" name="2FAC00"><b>2FAC00</b></a> - INT 2F - DOS 4.01+ GRAPHICS.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS 4.01+ GRAPHICS.COM - INSTALLATION CHECK
	AX = AC00h
Return: AX = FFFFh
	ES:DI -&gt; ??? (graphics data?) (not documented)
Note:	this installation check was moved here to avoid the conflict with the
	  CD-ROM extensions that occurred in DOS 4.00
SeeAlso: AX=1500h"GRAPHICS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC00DI1092" name="2FAC00DI1092"><b>2FAC00DI1092</b></a> - INT 2F - QRIP/TSR - GIVE CPU TO QRIP<br />
<pre>
INT 2F - QRIP/TSR - GIVE CPU TO QRIP
	AX = AC00h
	DI = 1092h
Return: nothing
Program: QRIP/TSR is a shareware TSR by Shane Hathaway implementing the Remote
	  Imaging Protocol (RIP, RIPscrip) used by several BBS systems to
	  provide a graphical user interface
Desc:	give QRIP some CPU time to update music and flashing timers
Notes:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
	this function should be called regularly whenever the terminal program
	  is otherwise idle; the updates are automatically performed on any
	  other QRIP call
SeeAlso: AX=AC01h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC01DI1092" name="2FAC01DI1092"><b>2FAC01DI1092</b></a> - INT 2F - QRIP/TSR - CHANGE INTERNAL FLAGS<br />
<pre>
INT 2F - QRIP/TSR - CHANGE INTERNAL FLAGS
	AX = AC01h
	DI = 1092h
	BX = flags to be turned on (see #02966)
	CX = flags to be turned off (see #02966)
Return: AX = 9142h if installed
	    DX = DOS-takeover flag (nonzero if QRIP able to take over DOS)
	    ---if DX nonzero---
	    BX = QRIP version number in hex (BH = major, BL = minor)
	    CX = new flags (see #02966)
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC00h/DI=1092h,AX=ACF0h

Bitfields for QRIP internal flags:
Bit(s)	Description	(Table 02966)
 0	ANSI emulation enabled (default on)
 1	RIP emulation enabled (default on)
 2	graphical commands allowed (default on)
 3	TTY text allowed (default on)
 4	disable @ variables (default off in TSR mode)
 5	wait for key on RIP "end scene" command (default off)
 6	anti-stripping (default off in TSR mode)
 7	sound enabled (default on)
 8	automatic message filter (default off in TSR mode)
 9	display-only mode (no user prompts)
 10	TTY text suppression (default off in TSR mode)
 11-15	reserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC02DI1092" name="2FAC02DI1092"><b>2FAC02DI1092</b></a> - INT 2F - QRIP/TSR - TURN OFF GRAPHICS SCREEN<br />
<pre>
INT 2F - QRIP/TSR - TURN OFF GRAPHICS SCREEN
	AX = AC02h
	DI = 1092h
Return: nothing
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC03h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC03DI1092" name="2FAC03DI1092"><b>2FAC03DI1092</b></a> - INT 2F - QRIP/TSR - TURN ON GRAPHICS SCREEN<br />
<pre>
INT 2F - QRIP/TSR - TURN ON GRAPHICS SCREEN
	AX = AC03h
	DI = 1092h
Return: nothing
Notes:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
	this function does not restore the contents of the screen (see AX=AC15h)
SeeAlso: AX=AC02h,AX=AC14h,AX=AC15h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC04DI1092" name="2FAC04DI1092"><b>2FAC04DI1092</b></a> - INT 2F - QRIP/TSR - OUTPUT STRING THROUGH QRIP<br />
<pre>
INT 2F - QRIP/TSR - OUTPUT STRING THROUGH QRIP
	AX = AC04h
	DI = 1092h
	DX:BX -&gt; string
	CX = length of string
Return: nothing
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC05h,AX=AC09h,AX=AC0Ah,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC05DI1092" name="2FAC05DI1092"><b>2FAC05DI1092</b></a> - INT 2F - QRIP/TSR - OUTPUT NULL-TERMINATED STRING THROUGH QRIP<br />
<pre>
INT 2F - QRIP/TSR - OUTPUT NULL-TERMINATED STRING THROUGH QRIP
	AX = AC05h
	DI = 1092h
	DX:BX -&gt; ASCIZ string
Return: nothing
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC04h,AX=AC06h,AX=AC09h,AX=AC0Ah,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC06DI1092" name="2FAC06DI1092"><b>2FAC06DI1092</b></a> - INT 2F - QRIP/TSR - RECEIVE CHARACTERS FROM QRIP<br />
<pre>
INT 2F - QRIP/TSR - RECEIVE CHARACTERS FROM QRIP
	AX = AC06h
	DI = 1092h
Return: AX = character to send to BBS (0001h-00FFh) or special code (see #02967)
	BX = string-waiting flag
	    0001h entire string waiting to be sent to terminal (call AX=AC0Ch)
	CX = DX = AX
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC04h,AX=AC05h,AX=AC0Ch,AX=AC16h,AX=AC18h,AX=AC1Ah

(Table 02967)
Values for QRIP special codes:
 0000h	if none
 0100h	wait for user keypress (must call AX=AC16h/BL=00h or AX=AC18h)
 0101h	both/middle mouse button pressed
 0102h	entering block mode (up/download) (call AX=AC1Ah)
 0103h	right mouse button pressed
 0104h	BBS requested status bar on
 0105h	BBS requested status bar off
 0106h	BBS requested VT-102 terminal emulation
	(keypad keys should send VT-102 escape codes)
 0107h	BBS requested VT-102 mode off
 0108h	BBS requested doorway mode (raw IBM keyboard ASCII/scan code pairs)
 0109h	BBS requested doorway mode off
 010Ah	hotkey mode on
 010Bh	hotkey mode off
 010Ch	BBS requested Tab-key button changing on
 010Dh	BBS requested Tab-key mode off
 010Eh	XOFF (use flow control to stop incoming characters)
 010Fh	XON (use flow control to resume incoming characters)
 0110h-0119h BBS requested application (0-9) be run
	application 0 should be a standard text editor
 01FFh	send ASCII 00h to BBS
Note:	for special codes 0104h to 010Dh, the terminal program should report
	  any mode changes it make in response by calling AX=AC16h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC07DI1092" name="2FAC07DI1092"><b>2FAC07DI1092</b></a> - INT 2F - QRIP/TSR - GET FONT DIRECTORY<br />
<pre>
INT 2F - QRIP/TSR - GET FONT DIRECTORY
	AX = AC07h
	DI = 1092h
Return: DX:BX -&gt; 80-byte internal buffer containing ASCIZ font directory name
Notes:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
	the application may change the font directory by overwriting the
	  returned buffer, ensuring that it does not exceed 80 bytes incl. NUL
	if changed, the new path will not become effective until the graphics
	  screen is reinitialized
SeeAlso: AX=AC08h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC08DI1092" name="2FAC08DI1092"><b>2FAC08DI1092</b></a> - INT 2F - QRIP/TSR - GET ICON DIRECTORY<br />
<pre>
INT 2F - QRIP/TSR - GET ICON DIRECTORY
	AX = AC08h
	DI = 1092h
Return: DX:BX -&gt; 80-byte internal buffer containing ASCIZ icon directory name
Notes:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
	the application may change the icon directory by overwriting the
	  returned buffer, ensuring that it does not exceed 80 bytes incl. NUL,
	  and includes a trailing backslash
	if changed, the new path becomes effective immediately
SeeAlso: AX=AC07h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC09DI1092" name="2FAC09DI1092"><b>2FAC09DI1092</b></a> - INT 2F - QRIP/TSR - OUTPUT STRING THROUGH QRIP<br />
<pre>
INT 2F - QRIP/TSR - OUTPUT STRING THROUGH QRIP
	AX = AC09h
	DI = 1092h
	DX:BX -&gt; string
	CX = length of string
Return: AX = character to send to BBS (0001h-00FFh) or special code (see #02967)
	BX = string-waiting flag
	    0001h entire string waiting to be sent to terminal (call AX=AC0Ch)
	CX = DX = AX
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC04h,AX=AC06h,AX=AC0Ah,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC0ADI1092" name="2FAC0ADI1092"><b>2FAC0ADI1092</b></a> - INT 2F - QRIP/TSR - OUTPUT NULL-TERMINATED STRING THROUGH QRIP<br />
<pre>
INT 2F - QRIP/TSR - OUTPUT NULL-TERMINATED STRING THROUGH QRIP
	AX = AC0Ah
	DI = 1092h
	DX:BX -&gt; ASCIZ string
Return: AX = character to send to BBS (0001h-00FFh) or special code (see #02967)
	BX = string-waiting flag
	    0001h entire string waiting to be sent to terminal (call AX=AC0Ch)
	CX = DX = AX
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC05h,AX=AC06h,AX=AC09h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC0BDI1092" name="2FAC0BDI1092"><b>2FAC0BDI1092</b></a> - INT 2F - QRIP/TSR - EXECUTE RIP "END SCENE" COMMAND<br />
<pre>
INT 2F - QRIP/TSR - EXECUTE RIP "END SCENE" COMMAND
	AX = AC0Bh
	DI = 1092h
Return: nothing
Notes:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
	enables all mouse buttons and cancels the RIP timeout
SeeAlso: AX=AC01h,AX=AC04h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC0CDI1092" name="2FAC0CDI1092"><b>2FAC0CDI1092</b></a> - INT 2F - QRIP/TSR - GET STRING TO BE SENT TO BBS<br />
<pre>
INT 2F - QRIP/TSR - GET STRING TO BE SENT TO BBS
	AX = AC0Ch
	DI = 1092h
Return: AX = status
	    0000h nothing to be sent
	    0001h a string is waiting to be sent
		DX:BX -&gt; string to be sent (may contain NULs)
		CX = length of string
	    0002h special code waiting (call AX=AC06h)
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC06h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC0DDI1092" name="2FAC0DDI1092"><b>2FAC0DDI1092</b></a> - INT 2F - QRIP/TSR - SET PROTECTED SCREEN AREA<br />
<pre>
INT 2F - QRIP/TSR - SET PROTECTED SCREEN AREA
	AX = AC0Dh
	DI = 1092h
	CL = number of text lines at bottom of screen to protect (00h = off)
	BL = attribute with which to fill area (bit 7 = high-int. background)
Return: nothing
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC0Eh,AX=AC0Fh,AX=AC10h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC0EDI1092" name="2FAC0EDI1092"><b>2FAC0EDI1092</b></a> - INT 2F - QRIP/TSR - WRITE ASCIZ STRING IN PROTECTED AREA<br />
<pre>
INT 2F - QRIP/TSR - WRITE ASCIZ STRING IN PROTECTED AREA
	AX = AC0Eh
	DI = 1092h
	DX:BX -&gt; ASCIZ string to be written
	CL = column at which to begin writing
	CH = row number within protected area (00h = first line)
Return: nothing
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC0Dh,AX=AC0Fh,AX=AC10h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC0FDI1092" name="2FAC0FDI1092"><b>2FAC0FDI1092</b></a> - INT 2F - QRIP/TSR - SCROLL PROTECTED AREA<br />
<pre>
INT 2F - QRIP/TSR - SCROLL PROTECTED AREA
	AX = AC0Fh
	DI = 1092h
	BH,BL = row,column of upper-left corner in protected area
	DH,DL = row,column of lower-right corner
	CL = number of lines to scroll up
Return: nothing
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC0Dh,AX=AC0Eh,AX=AC10h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC10DI1092" name="2FAC10DI1092"><b>2FAC10DI1092</b></a> - INT 2F - QRIP/TSR - SET OUTPUT COLOR FOR PROTECTED AREA<br />
<pre>
INT 2F - QRIP/TSR - SET OUTPUT COLOR FOR PROTECTED AREA
	AX = AC10h
	DI = 1092h
	BL = new attribute (bit 7 set for high-intensity background)
Return: nothing
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC0Dh,AX=AC0Eh,AX=AC0Fh,AX=AC11h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC11DI1092" name="2FAC11DI1092"><b>2FAC11DI1092</b></a> - INT 2F - QRIP/TSR - CONVERT PROTECTED AREA TO ENTIRE SCREEN<br />
<pre>
INT 2F - QRIP/TSR - CONVERT PROTECTED AREA TO ENTIRE SCREEN
	AX = AC11h
	DI = 1092h
	BX = mode (0000h = normal protect, 0001h = allow full-screen access)
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC0Dh,AX=AC0Eh,AX=AC0Fh,AX=AC10h,AX=AC12h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC12DI1092" name="2FAC12DI1092"><b>2FAC12DI1092</b></a> - INT 2F - QRIP/TSR - BEGIN POPUP-WINDOW MODE<br />
<pre>
INT 2F - QRIP/TSR - BEGIN POPUP-WINDOW MODE
	AX = AC12h
	DI = 1092h
Return: nothing
Notes:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
	while popup-mode is in effect, the terminal program can write to the
	  screen (and easily restore it) by outputting a RIP file with AX=AC04h
	  or AX=AC05h
	QRIP will automatically drop out of popup-window mode if the terminal
	  program invokes RIP pick-lists
	any changes to the protected area will be restored when popup-window
	  mode is cancelled
SeeAlso: AX=AC04h,AX=AC11h,AX=AC13h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC13DI1092" name="2FAC13DI1092"><b>2FAC13DI1092</b></a> - INT 2F - QRIP/TSR - END POPUP-WINDOW MODE<br />
<pre>
INT 2F - QRIP/TSR - END POPUP-WINDOW MODE
	AX = AC13h
	DI = 1092h
Return: nothing
Notes:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
	restores screen
SeeAlso: AX=AC12h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC14DI1092" name="2FAC14DI1092"><b>2FAC14DI1092</b></a> - INT 2F - QRIP/TSR - SAVE GRAPHICS SCREEN AND SWITCH TO TEXT MODE<br />
<pre>
INT 2F - QRIP/TSR - SAVE GRAPHICS SCREEN AND SWITCH TO TEXT MODE
	AX = AC14h
	DI = 1092h
Return: nothing
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC03h,AX=AC15h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC15DI1092" name="2FAC15DI1092"><b>2FAC15DI1092</b></a> - INT 2F - QRIP/TSR - RESTORE GRAPHICS SCREEN<br />
<pre>
INT 2F - QRIP/TSR - RESTORE GRAPHICS SCREEN
	AX = AC15h
	DI = 1092h
Return: nothing
Desc:	restores the graphics screen saved by the last call to AX=AC14h
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC03h,AX=AC14h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC16DI1092" name="2FAC16DI1092"><b>2FAC16DI1092</b></a> - INT 2F - QRIP/TSR - REPORT MODE CHANGE TO QRIP<br />
<pre>
INT 2F - QRIP/TSR - REPORT MODE CHANGE TO QRIP
	AX = AC16h
	DI = 1092h
	BL = new mode
	    00h terminate key wait
	    01h status bar on
	    02h status bar off
	    03h VT-102 mode on
	    04h VT-102 mode off
	    05h doorway mode on
	    06h doorway mode off
	    07h hotkeys mode on
	    08h hotkeys mode off
	    09h tabkey mode on
	    0Ah tabkey mode off
Return: nothing
Notes:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
	all modes default to OFF when QRIP is first installed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC17DI1092" name="2FAC17DI1092"><b>2FAC17DI1092</b></a> - INT 2F - QRIP/TSR - CALL (EXECUTE) A RIP FILE<br />
<pre>
INT 2F - QRIP/TSR - CALL (EXECUTE) A RIP FILE
	AX = AC17h
	DI = 1092h
	DX:BX -&gt; ASCIZ filename for RIP file to be executed
Return: nothing
Notes:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
	the specified file may be in the current icon directory, the QRIP
	  startup directory, or the current directory; any pathnames specified
	  with the filename are ignored

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC18DI1092" name="2FAC18DI1092"><b>2FAC18DI1092</b></a> - INT 2F - QRIP/TSR - SEND USER KEY TO QRIP<br />
<pre>
INT 2F - QRIP/TSR - SEND USER KEY TO QRIP
	AX = AC18h
	DI = 1092h
	BX = key (00xxh is normal ASCII, xx00h is an extended key)
Return: nothing
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC06h,AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC19DI1092" name="2FAC19DI1092"><b>2FAC19DI1092</b></a> - INT 2F - QRIP/TSR - HANGUP<br />
<pre>
INT 2F - QRIP/TSR - HANGUP
	AX = AC19h
	DI = 1092h
Return: nothing
Desc:	inform QRIP that carrier has been lost
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC1ADI1092" name="2FAC1ADI1092"><b>2FAC1ADI1092</b></a> - INT 2F - QRIP/TSR - GET RIP_ENTER_BLOCK_MODE INFORMATION<br />
<pre>
INT 2F - QRIP/TSR - GET RIP_ENTER_BLOCK_MODE INFORMATION
	AX = AC1Ah
	DI = 1092h
Return: AH = requested protocol (see #02968)
	AL = file type (see #02969)
	DX:BX -&gt; ASCIZ filename or 0000h:0000h
	CX = length of filename
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=ACF0h

(Table 02968)
Values for QRIP protocol identifier:
 00h	Xmodem (checksum)
 01h	Xmodem-CRC
 02h	Xmodem-1K
 03h	Xmodem-1K-G
 04h	Kermit
 05h	Ymodem
 06h	Ymodem-G
 07h	Zmodem with crash recovery
 08h-0Fh same as 00h-07h, but for uploading instead of downloading
SeeAlso: #02969

(Table 02969)
Values for QRIP file type:
 00h	RIP file sequence to be displayed
 01h	RIP file sequence to be stored in icon directory
 02h	ICN file sequence to be stored in icon directory
 03h	HLP file sequence to be stored, then auto-loaded if needed
 04h	COMPOSITE DYNAMIC file sequence (batch protocols only)
 05h	ACTIVE DYNAMIC file sequence (batch protocols only)
Note:	for file types 04h and 05h, any .RIP or .ICN files are stored in
	  the icon directory; in mode 05h, any .RIP files are also played
	  back as they are received
SeeAlso: #02968

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAC1BDI1092" name="2FAC1BDI1092"><b>2FAC1BDI1092</b></a> - INT 2F - QRIP/TSR - SET SYSTEM FONT SIZE<br />
<pre>
INT 2F - QRIP/TSR - SET SYSTEM FONT SIZE
	AX = AC1Bh
	DI = 1092h
	BX = font size (see #02970)
Return: nothing
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC04h,AX=ACF0h

(Table 02970)
Values for QRIP font size specifier:
 00h	8x8 font, 80x43 screen
 01h	7x8 font, 90x43 screen
 02h	8x14 font, 80x25 screen
 03h	7x14 font, 90x25 screen
 04h	16x14 font, 40x25 screen

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FACF0DI1092" name="2FACF0DI1092"><b>2FACF0DI1092</b></a> - INT 2F - QRIP/TSR - INSTALLATION CHECK<br />
<pre>
INT 2F - QRIP/TSR - INSTALLATION CHECK
	AX = ACF0h
	DI = 1092h
Return: AX = 9142h if installed
	    DX = DOS-takeover flag (nonzero if QRIP able to take over DOS)
	    ---if DX nonzero---
	    BX = QRIP version number in hex (BH = major, BL = minor)
	    CX = current flags (see AX=AC01h)
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=AC00h/DI=1092h,AX=AC01h,AX=AC04h,AX=AC06h,AX=AC1Ah,AX=ACFFh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FACFFDI1092" name="2FACFFDI1092"><b>2FACFFDI1092</b></a> - INT 2F - QRIP/TSR - UNINSTALL<br />
<pre>
INT 2F - QRIP/TSR - UNINSTALL
	AX = ACFFh
	DI = 1092h
Return: AX = status
	    0000h unable to remove (interrupt vector hooked by another prog)
	    0001h successful
	    0002h unable to take over DOS at this time (retry uninstall)
Note:	if DI &lt;&gt; 1092h on entry, QRIP chains the call
SeeAlso: AX=ACF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD00" name="2FAD00"><b>2FAD00</b></a> - INT 2F U - DOS 3.3+ DISPLAY.SYS internal - INSTALLATION CHECK<br />
<pre>
INT 2F U - DOS 3.3+ DISPLAY.SYS internal - INSTALLATION CHECK
	AX = AD00h
Return: AL = FFh if installed
	    BX = ??? (0100h for MS-DOS 3.3+)
Note:	DOS 5+ DISPLAY.SYS chains to previous handler if AL is not one of the
	  subfunctions listed here
SeeAlso: AX=AD01h"DISPLAY",AX=AD02h"DISPLAY"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD00_0" name="2FAD00_0"><b>2FAD00</b></a> - INT 2F U - DR DOS 3.41-5.0, Novell DOS 7 KEYB - INSTALLATION CHECK<br />
<pre>
INT 2F U - DR DOS 3.41-5.0, Novell DOS 7 KEYB - INSTALLATION CHECK
	AX = AD00h
Return: AX = FFFFh if installed
	flags destroyed
Note:	the Novell DOS 7 KEYB driver only checks AL to determine whether it
	  is already installed
SeeAlso: AX=AD80h"Novell"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD01" name="2FAD01"><b>2FAD01</b></a> - INT 2F U - DOS 3.3+ DISPLAY.SYS internal - SET ACTIVE CODE PAGE<br />
<pre>
INT 2F U - DOS 3.3+ DISPLAY.SYS internal - SET ACTIVE CODE PAGE
	AX = AD01h
	BX = new code page (see #01757 at INT 21/AX=6602h)
Return: CF clear if successful
	    AX = 0001h
	CF set on error (unsupported code page)
	    AX = 0000h
SeeAlso: AX=AD02h"DISPLAY"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD01_0" name="2FAD01_0"><b>2FAD01</b></a> - INT 2F U - DR DOS 3.41,5.0 KEYB - GET CONFIGURATION<br />
<pre>
INT 2F U - DR DOS 3.41,5.0 KEYB - GET CONFIGURATION
	AX = AD01h
Return: BX = current code page (see #01757 at INT 21/AX=6602h)
	CX = current keyboard layout (0100h = US, 0102h = foreign)
	ES = resident code segment
SeeAlso: AX=AD01h"Novell",AX=AD00h"KEYB",AX=AD02h"KEYB",AX=AD83h"KEYB"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD01_1" name="2FAD01_1"><b>2FAD01</b></a> - INT 2F U - Novell DOS 7 KEYB - GET/SET??? CONFIGURATION<br />
<pre>
INT 2F U - Novell DOS 7 KEYB - GET/SET??? CONFIGURATION
	AX = AD01h
	CX = ??? (0000h)
Return: AX = FFFFh if Novell DOS 7 KEYB installed
	BX = current code page (see #01757 at INT 21/AX=6602h)
	CX = current keyboard layout (0100h = US, 0102h = foreign)
	ES = resident code segment
SeeAlso: AX=AD01h"DR DOS",AX=AD00h"KEYB",AX=AD02h"KEYB",AX=AD83h"KEYB"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD02" name="2FAD02"><b>2FAD02</b></a> - INT 2F U - DOS 3.3+ DISPLAY.SYS internal - GET ACTIVE CODE PAGE<br />
<pre>
INT 2F U - DOS 3.3+ DISPLAY.SYS internal - GET ACTIVE CODE PAGE
	AX = AD02h
Return: CF set if code page never set
	    AX = 0001h
	    BX = FFFFh (assume first hardware code page)
	CF clear if successful
	    BX = current code page (see #01757 at INT 21/AX=6602h)
SeeAlso: AX=AD01h"DISPLAY",AX=AD03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD02_0" name="2FAD02_0"><b>2FAD02</b></a> - INT 2F U - Novell DOS 7 KEYB - ???<br />
<pre>
INT 2F U - Novell DOS 7 KEYB - ???
	AX = AD02h
	DX = ??? (0000h)
Return: AX = FFFFh if installed
	flags destroyed
SeeAlso: AX=AD01h"KEYB"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD03" name="2FAD03"><b>2FAD03</b></a> - INT 2F U - DOS 3.3+ DISPLAY.SYS internal - GET CODE PAGE INFORMATION<br />
<pre>
INT 2F U - DOS 3.3+ DISPLAY.SYS internal - GET CODE PAGE INFORMATION
	AX = AD03h
	ES:DI -&gt; buffer for code page information (see #02971)
	CX = size of buffer in bytes
Return: CF set if buffer too small
	CF clear if successful
	    ES:DI buffer filled
SeeAlso: AX=AD01h,AX=AD02h

Format of DOS 5.0-6.0 DISPLAY.SYS code page information:
Offset	Size	Description	(Table 02971)
 00h	WORD	number of software code pages
 02h	WORD	??? (0003h)
 04h	WORD	number of hardware code pages
 06h  N WORDs	hardware code page numbers (see #01757 at INT 21/AX=6602h)
      N WORDs	software (prepared) code pages (FFFFh if not yet prepared)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD04" name="2FAD04"><b>2FAD04</b></a> - INT 2F U - DOS 4.x only DISPLAY.SYS internal - ???<br />
<pre>
INT 2F U - DOS 4.x only DISPLAY.SYS internal - ???
	AX = AD04h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD10" name="2FAD10"><b>2FAD10</b></a> - INT 2F U - DOS 4.x DISPLAY.SYS internal - INSTALLATION CHECK???<br />
<pre>
INT 2F U - DOS 4.x DISPLAY.SYS internal - INSTALLATION CHECK???
	AX = AD10h
	???
Return: AX = FFFFh
	BX = ??? (0100h in PC-DOS 4.01)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD10_0" name="2FAD10_0"><b>2FAD10</b></a> - INT 2F U - DOS 5+ DISPLAY.SYS internal - ???<br />
<pre>
INT 2F U - DOS 5+ DISPLAY.SYS internal - ???
	AX = AD10h
	???
Return: CF clear if successful
	CF set on error
Note:	this function is a NOP if the active code page has never been set
	  (AX=AD02h returns BX=FFFFh); its purpose otherwise is not known

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD40" name="2FAD40"><b>2FAD40</b></a> - INT 2F - DOS 4.0+ - ???<br />
<pre>
INT 2F - DOS 4.0+ - ???
	AX = AD40h
	DX = ???
	???
Return: ???
Note:	called by PC-DOS 4.01 PRINT.COM

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD41" name="2FAD41"><b>2FAD41</b></a> - INT 2F - Arabic/Hebrew DOS 5.0???+ - GET CURRENT FONTPAGE<br />
<pre>
INT 2F - Arabic/Hebrew DOS 5.0???+ - GET CURRENT FONTPAGE
	AX = AD41h
	(CX = 0000h)
Return: CX = current fontpage
Notes:	Called by Arabic/Hebrew MS-DOS 5.0 CODEPAGE.COM immediately before
	  a call to INT21h/6601h to get the current codepage.
	The function is probably implemented in the ARABIC.COM/HEBREW.COM
	  driver.
	The CX = 0 on call is not actually a requirement, but it should be
	  initialized this way to receive a fontpage 0 if ARABIC.COM/
	  HEBREW.COM is not loaded. A fontpage 0 indicated no fontpage
	  support. At least this is what CODEPAGE.COM assumes (by using
	  the CX=0 init status of a .COM program, when not being loaded
	  in DEBUG.)
	Some European clones have code page 850 as their hardware font instead
	  of code page 437
	!!!more details to follow
SeeAlso: AX=AD42h,AX=AD43h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD42" name="2FAD42"><b>2FAD42</b></a> - INT 2F - Arabic/Hebrew DOS 5.0???+ SET CURRENT FONTPAGE<br />
<pre>
INT 2F - Arabic/Hebrew DOS 5.0???+ SET CURRENT FONTPAGE
	AX = AD42h
	CX = fontpage (&gt; 0)
Return: ???
Note:	called by Arabic/Hebrew MS-DOS 5.0 CODEPAGE.COM almost immediately
	  before a call to INT21h/6602h to set the current codepage
	  (without checking any possible error codes returned from the call).
	The function is probably implemented in the ARABIC.COM/HEBREW.COM
	  driver.
SeeAlso: AX=AD41h,AX=AD43h,INT 21/AX=6601h,INT 21/AX=6602h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD43" name="2FAD43"><b>2FAD43</b></a> - INT 2F - Arabic/Hebrew DOS 5.0???+ - GET FONTPAGE STATUS???<br />
<pre>
INT 2F - Arabic/Hebrew DOS 5.0???+ - GET FONTPAGE STATUS???
	AX = AD43h
Return: AL = status
	    00h successful
	    01h-0Ah codepage info not found
	    0Bh bad codepage info file
	    0Ch font page not found or not available with codepage
	    else device prepare error
Note:	called by Arabic/Hebrew MS-DOS 5.0 CODEPAGE.COM when the sequence
	  INT 2F/AX=AD42h & INT 21/AX=6602h to set fontpage & codepage returned
	  with CF set and AX &lt;&gt; 2, and the following INT 21/AH=59h returned
	  error code 41h (65) (that is, the codepage was prepared, but could
	  not be set).
SeeAlso: AX=AD41h,AX=AD42h,INT 21/AX=6601h,INT 21/AX=6602h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD80" name="2FAD80"><b>2FAD80</b></a> - INT 2F u - MS-DOS 3.3+ KEYB.COM internal - INSTALLATION CHECK<br />
<pre>
INT 2F u - MS-DOS 3.3+ KEYB.COM internal - INSTALLATION CHECK
	AX = AD80h
Return: AL = FFh if installed
	    BX = version number (BH = major, BL = minor)
	    ES:DI -&gt; internal data (see #02972)
	    AH destroyed (set to FFh by some implementations/versions)
Notes:	MS-DOS 3.30, PC-DOS 4.01, MS-DOS 5.00, and MS-DOS 6.22 all report
	  version 1.00.
	this function was undocumented prior to the release of DOS 5.0
	most versions of KEYB completely replace the BIOS INT 09 handler, but
	  Novell DOS's KEYB partially uses the BIOS code and thus continues
	  to chain to the original INT 09 at times
	some utilities check for AX=FFFFh on return
SeeAlso: AX=AD80h"Novell",AX=AD81h,AX=AD82h,AX=AD83h

Format of KEYB internal data:
Offset	Size	Description	(Table 02972)
 00h	DWORD	original INT 09
 04h	DWORD	original INT 2F
 08h	DWORD	unused (0) original INT 16 in older KEYB versions???
 0Ch	WORD	flags A (see #02973)
 0Eh	WORD	flags B (see #02974)
 10h	BYTE	flags??? (bit1 used)
 11h	BYTE	???
 12h  4 BYTEs	???
 16h  2 BYTEs	country ID letters, default is "US"
 18h	WORD	current code page (see #01757 at INT 21/AX=6602h)
---DOS 3.3---
 1Ah	WORD	pointer to first item in list of code page tables???
 1Ch	WORD	pointer to ??? item in list of code page tables
 1Eh  2 BYTEs	unused???
 20h	WORD	pointer to key translation data (see #02976)
 22h	WORD	pointer to last item in code page table list (see #02975)
 24h  9 BYTEs	???
---DOS 4.01---
 1Ah  2 BYTEs	???
 1Ch	WORD	pointer to first item in list of code page tables???
 1Eh	WORD	pointer to ??? item in list of code page tables
 20h 2 BYTEs	unused???
 22h	WORD	pointer to key translation data (see #02976)
 24h	WORD	pointer to last item in code page table list (see #02975)
 26h  9 BYTEs	???
---DOS 6.22--- (checked out with 6.22, but might be earlier)
 1Ah  2 BYTEs	???
 1Ch	WORD	pointer to current (first???) item in list of code page tables
		(corresponding to codepage indicated at offset 18h)
		(initial value is FFFFh)
 1Eh	WORD	pointer to (entry to) list of code page tables (see #02975)
		If not FFFFh, INT 2F/AX=AD81h scans this list of code page
		  tables until the requested code page was found in list or
		  end of table was reached (FFFFh). If found, offsets 18h and
		  1Ch will be changed to requested new code page. If not found,
		  it returns with AX=0001h 'code page not supported').
 20h	WORD	unused??? (initial value: FFFFh)
 22h	WORD	pointer to key translation data (see #02455)
 24h	WORD	pointer to last item in code page table list (see #02454)
 26h	WORD	CAPSLock/ShiftLock management flags??? (0)
		Note:	It appears that none of the bits is ever set inside
			  KEYBs code!
			  The following is guesswork:
		bit15: =1: With country specific keyboard mapping (&lt;Ctrl&gt;+
			  &lt;Alt&gt;+&lt;F2&gt;) active, &lt;CapsLock&gt; works as CAPSLock
			  instead of ShiftLock??? Pressing a key in first row
			  resets CapsLock???
			  (Effective only on PC Convertible or with Enhanced
			  keyboard).
		bit14-10:  unused (0)
		bit 9: =1: With country specific keyboard mapping active:
			  some kind of temporary (table) shift???
		bit 8-0: unused (0)
 28h	BYTE	unused (0)
 29h	BYTE	make code xx for &lt;Ctrl&gt;+&lt;Alt&gt;+&lt;xx&gt; to set keyboard mapping
		  to US-layout (default is 3Bh=&lt;F1&gt;???)
		  (see INT 2F/AX=AD82h,INT 2F/AX=AD83h)
 2Ah	BYTE	make code yy for &lt;Ctrl&gt;+&lt;Alt&gt;+&lt;yy&gt; to set keyboard mapping
		  to country specific layout (default is 3Ch=&lt;F2&gt;???),
		  (see INT 2F/AX=AD82h,INT 2F/AX=AD83h)
 2Bh 16 BYTEs	unused (0) ???
Note:	at least in MS-DOS v6.22, the signature "SHARED DATA" immediately
	  precedes this structure

Bitfields for MS-DOS v6.22 KEYB flags A:
Bit(s)	Description	(Table 02973)
 15	unused??? (0)
 14	set on machine with BIOS machine type FBh or FEh/FFh without enh kbd
 13	not FAh: ???
 12	set on start of machine detection, cleared on machine types F9h, FBh,
	  FEh, FFh
 11	not FAh: ???
	(on ATs: override bit12 NOT to set NumLock on)
 10	set on machine type F9h
 9	unused??? (0)
 8	unused??? (0)
 7	used by INT 09, but never set!
	=1: after keyboard self test resulting AAh, INT 09 handler will (re)set
	      keyboard code-set 1 and temporarily disable a PS/2 mouseport.
 6	used by INT09, but never set!
	=1: after keyboard self test resulting AAh, INT 09 handler will (re)set
	      keyboard code-set 1 and temporarily disable a PS/2 mouseport.
 5	set for JP, KO, PR, TA layouts during installation???
	=1: some special codepage (&gt;932???) management???
 4-0	unused??? (0)
SeeAlso: #02974,MEM F000h:FFFEh,INT 15/AH=C0h

Bitfields for MS-DOS v6.22 KEYB flags B:
Bit(s)	Description	(Table 02974)
 15	INT 16/AH=1xh supported (INT 16h/AH=92h call returns AH&lt;=80h)
	if clear, extended keyboard scan codes are immediately discarded
 14	INT 16/AH=2xh supported (INT 16h/AH=A2h call returns AH&lt;=80h)
 13	unused (0)
 12	network installed (INT 2F/AX=B800h)
 11	original IBM PC (BIOS date 1981)
 10	PC or PC/XT (BIOS machine type byte of FBh or FEh)
 9	PC Convertible (BIOS machine type byte of F9h); use INT 15/AX=4104h
 8	unused (0)
 7	IBM PS/2 model 30 (BIOS machine type byte of FAh)
 6	IBM AT (BIOS machine type FCh)
 5	IBM PS/2 (BIOS machine type F8h)
 4	PS/2 and unknown only: non-standard 8042 reported by INT 15/AH=C0h
	=1: after keyboard self test resulting AAh, INT 09 handler will (re)set
	      keyboard code-set 1 and temporarily disable a PS/2 mouseport.
 3	temporary flag???
 2-0	???
SeeAlso: #02972,#02973

Format of code page table list entries:
Offset	Size	Description	(Table 02975)
 00h	WORD	pointer to next item, FFFFh = last
 02h	WORD	code page (see #01757 at INT 21/AX=6602h)
 04h  2 BYTEs	???

Format of KEYB translation data:
Offset	Size	Description	(Table 02976)
 00h	WORD	size of data in bytes, including this word
 02h N-2 BYTEs	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD80_0" name="2FAD80_0"><b>2FAD80</b></a> - INT 2F u - Novell DOS 7 KEYB.COM - INSTALLATION CHECK<br />
<pre>
INT 2F u - Novell DOS 7 KEYB.COM - INSTALLATION CHECK
	AX = AD80h
Return: AX = FFFFh if installed
	    CX = Novell DOS KEYB version number (CL = major, CH = minor)
	    DX = current keyboard codepage
	    ES:DI -&gt; internal data and tables (ES=FFFEh if KEYB in HMA)
	flags destroyed
Notes:	versions: v2.08 (original ship 4/94), v2.09 (Update 10, 11/18/94),
	  v2.10 (Update 12, 2/22/95), v2.11 (Update 13, 5/8/95),
	  v2.12 (Update 14, 7/31/95)
	although the installation check is via this INT 2F call, Novell DOS 7's
	  KEYB has no known INT 2F entry point!	 Presumably, the handler is
	  either coded in the kernel or reached via a FAR JMP from the kernel
SeeAlso: AX=AD80h"MS-DOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD81" name="2FAD81"><b>2FAD81</b></a> - INT 2F - DOS 3.3+ KEYB.COM - SET KEYBOARD CODE PAGE<br />
<pre>
INT 2F - DOS 3.3+ KEYB.COM - SET KEYBOARD CODE PAGE
	AX = AD81h
	BX = code page (see #01757 at INT 21/AX=6601h)
Return: CF set on error
	    AX = 0001h (code page not available)
	CF clear if successful
Notes:	called by DISPLAY.SYS
	this function was undocumented prior to the release of DOS 5.0
SeeAlso: AX=AD80h,AX=AD82h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD82" name="2FAD82"><b>2FAD82</b></a> - INT 2F - DOS 3.3+ KEYB.COM - SET KEYBOARD MAPPING<br />
<pre>
INT 2F - DOS 3.3+ KEYB.COM - SET KEYBOARD MAPPING
	AX = AD82h
	BL = new state
	    00h US keyboard (Control-Alt-F1)
	    FFh foreign keyboard (Control-Alt-F2)
Return: CF set on error (BL not 00h or FFh)
	CF clear if successful
Notes:	this function was undocumented prior to the release of DOS 5.0
	the states 00h and FFh correspond with the byte stored at offset +02h
	  in KEYBs INT 09h handler
SeeAlso: AX=AD80h,AX=AD81h,AX=AD83h,AX=AD84h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD83" name="2FAD83"><b>2FAD83</b></a> - INT 2F - DOS 5+ KEYB.COM - GET KEYBOARD MAPPING<br />
<pre>
INT 2F - DOS 5+ KEYB.COM - GET KEYBOARD MAPPING
	AX = AD83h
Return: BL = current state
	    00h US keyboard
	    FFh foreign keyboard
Note:	the states 00h and FFh correspond with the byte stored at offset +02h
	  in KEYBs INT 09h handler
SeeAlso: AX=AD82h,AX=AD85h,INT 09

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD84" name="2FAD84"><b>2FAD84</b></a> - INT 2F - PC DOS 5.0+ KEYB.COM - SET KEYBOARD SUB-MAPPING<br />
<pre>
INT 2F - PC DOS 5.0+ KEYB.COM - SET KEYBOARD SUB-MAPPING
	AX = AD84h
Return: if KEYB is in foreign mode:
	    AL = current layout
		00h primary layout
		01h secondary layout
Note:	This function is not supported by MS-DOS 5 - 7.10.
SeeAlso: AX=AD85h,AX=AD82h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD85" name="2FAD85"><b>2FAD85</b></a> - INT 2F - PC DOS 5.0+ KEYB.COM - GET KEYBOARD SUB-MAPPING<br />
<pre>
INT 2F - PC DOS 5.0+ KEYB.COM - GET KEYBOARD SUB-MAPPING
	AX = AD85h
	BL = new layout
	    00h primary layout
	    01h secondary layout
Note:	This function is not supported by MS-DOS 5.0 - 7.10.
SeeAlso: AX=AD84h,AX=AD83h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FADC1" name="2FADC1"><b>2FADC1</b></a> - INT 2F U - DOS 4.0+ SELECT - DISPLAY FORMAT DISK PROMPT<br />
<pre>
INT 2F U - DOS 4.0+ SELECT - DISPLAY FORMAT DISK PROMPT
	AX = ADC1h
Return:	AX destroyed???
Note:	This function is called by DOS 4.0+ FORMAT utility just as it prompts
	  for a disk to be formatted.  It is only issued when the undocumented
	  /SELECT option was specified and is intercepted by SELECT displaying
	  the prompt.  However, the callout is still present in DOS 6.0 at
	  least.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAE00" name="2FAE00"><b>2FAE00</b></a> - INT 2F U - DOS 3.3+ internal - INSTALLABLE COMMAND - INSTALLATION CHECK<br />
<pre>
INT 2F U - DOS 3.3+ internal - INSTALLABLE COMMAND - INSTALLATION CHECK
	AX = AE00h
	DX = magic value FFFFh
	CH = FFh
	CL = length of command line tail (4DOS v4.0)
	DS:BX -&gt; command line buffer (see #02977)
	DS:SI -&gt; command name buffer (see #02978)
	DI = 0000h (4DOS v4.0)
Return: AL = FFh if this command is a TSR extension to COMMAND.COM
	AL = 00h if the command should be executed as usual
Notes:	This call provides a mechanism for TSRs to install permanent
	  extensions to the command repertoire of COMMAND.COM.	It appears
	  that COMMAND.COM makes this call before executing the current
	  command line, and does not execute it itself if the return is FFh.
	APPEND hooks this call, to allow subsequent APPEND commands to
	  execute without re-running APPEND
SeeAlso: AX=AE01h

Format of COMMAND.COM command line buffer:
Offset	Size	Description	(Table 02977)
 00h	BYTE	max length of command line, as in INT 21/AH=0Ah
 01h	BYTE	count of bytes to follow, excluding terminating 0Dh
      N BYTEs	command line text, terminated by 0Dh

Format of command name buffer:
Offset	Size	Description	(Table 02978)
 00h	BYTE	length of command name
 01h  N BYTEs	uppercased command name (blank-padded to 11 chars by 4DOS v4)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAE01" name="2FAE01"><b>2FAE01</b></a> - INT 2F U - DOS 3.3+ internal - INSTALLABLE COMMAND - EXECUTE<br />
<pre>
INT 2F U - DOS 3.3+ internal - INSTALLABLE COMMAND - EXECUTE
	AX = AE01h
	DX = magic value FFFFh
	CH = 00h
	CL = length of command name (4DOS v4.0)
	DS:BX -&gt; command line buffer (see #02977)
	DS:SI -&gt; command name buffer (see #02978)
Return: DS:SI buffer updated
	  if length byte is nonzero, the following bytes contain the uppercase
	  internal command to execute and the command line buffer contains the
	  command's parameters (the first DS:[SI] bytes are ignored)
Notes:	this call requests execution of the command which a previous call to
	  AX=AE00h indicated was resident
	APPEND hooks this call
BUG:	Novell DOS 7.0's COMMAND.COM (prior to Update 12) will attempt to run
	  a disk program with the indicated name even if the returned length
	  byte is zero, because the register used to flag this case is
	  clobbered without first checking it.	The workaround is to set the
	  command name buffer to "REM" followed by enough blanks to pad out
	  the original command's length, which will also work with MS-DOS 6.
	  (from padgett@tccslr.dnet.mmc.com)
SeeAlso: AX=AE00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF00" name="2FAF00"><b>2FAF00</b></a> - INT 2F - WinDOS v2.11 - INSTALLATION CHECK<br />
<pre>
INT 2F - WinDOS v2.11 - INSTALLATION CHECK
	AX = AF00h
Return: AL = FFh if installed
Program: WinDOS is a DOS clone (claimed to be mostly MS-DOS 5.0 API compatible)
	  written by Heiko Goemann
SeeAlso: AX=AF01h"WinDOS",INT 21/AH=30h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF00_0" name="2FAF00_0"><b>2FAF00</b></a> - INT 2F U - ???<br />
<pre>
INT 2F U - ???
	AX = AF00h
	???
Return: AX = 0000h if interface supported
SeeAlso: AX=AF02h,AX=AF03h,AX=AF04h,AX=AF13h,AX=AF30h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF01" name="2FAF01"><b>2FAF01</b></a> - INT 2F - WinDOS v2.11 - TURN ON ONLINE MODE<br />
<pre>
INT 2F - WinDOS v2.11 - TURN ON ONLINE MODE
	AX = AF01h
Return: nothing
Desc:	indicate that the user will not exchange floppy disks, allowing WinDOS
	  to cache disk sectors in memory and avoid writing modified sectors
	  back out to the floppy disk
SeeAlso: AX=AF00h"WinDOS",AX=AF02h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF02" name="2FAF02"><b>2FAF02</b></a> - INT 2F - WinDOS v2.11 - TURN OFF ONLINE MODE<br />
<pre>
INT 2F - WinDOS v2.11 - TURN OFF ONLINE MODE
	AX = AF02h
Return: nothing
Desc:	indicate that the floppy disk may be removed, and that WinDOS should
	  write all buffered sectors out to the floppy disk
SeeAlso: AX=AF00h"WinDOS",AX=AF01h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF02_0" name="2FAF02_0"><b>2FAF02</b></a> - INT 2F U - ???<br />
<pre>
INT 2F U - ???
	AX = AF02h
	???
Return: ES = ???
SeeAlso: AX=AF00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF03" name="2FAF03"><b>2FAF03</b></a> - INT 2F - WinDOS v2.11 - TURN VIDMEM ON<br />
<pre>
INT 2F - WinDOS v2.11 - TURN VIDMEM ON
	AX = AF03h
Return: AX = status
	    0000h successful
	    0001h CPU not in mode set by DOS386=On
	    0002h video adapter in graphics mode
	    0003h memory chain corrupted
SeeAlso: AX=AF00h"WinDOS",AX=AF04h"WinDOS",AX=AF05h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF03_0" name="2FAF03_0"><b>2FAF03</b></a> - INT 2F U - ???<br />
<pre>
INT 2F U - ???
	AX = AF03h
	???
Return: DX = ???
SeeAlso: AX=AF00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF04" name="2FAF04"><b>2FAF04</b></a> - INT 2F - WinDOS v2.11 - TURN VIDMEM OFF<br />
<pre>
INT 2F - WinDOS v2.11 - TURN VIDMEM OFF
	AX = AF04h
Return: AX = status
	    0000h successful
	    0001h video memory is in use
SeeAlso: AX=AF00h"WinDOS",AX=AF03h"WinDOS",AX=AF05h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF04_0" name="2FAF04_0"><b>2FAF04</b></a> - INT 2F U - ???<br />
<pre>
INT 2F U - ???
	AX = AF04h
	???
Return: ???
SeeAlso: AX=AF00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF05" name="2FAF05"><b>2FAF05</b></a> - INT 2F - WinDOS v2.11 - GET VIDMEM STATE<br />
<pre>
INT 2F - WinDOS v2.11 - GET VIDMEM STATE
	AX = AF05h
Return: AX = status (0000h off, 0001h on)
SeeAlso: AX=AF00h"WinDOS",AX=AF03h"WinDOS",AX=AF04h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF05_0" name="2FAF05_0"><b>2FAF05</b></a> - INT 2F U - ???<br />
<pre>
INT 2F U - ???
	AX = AF05h
	???
Return: ???
SeeAlso: AX=AF00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF06" name="2FAF06"><b>2FAF06</b></a> - INT 2F - WinDOS v2.11 - MAKE PROGRAM UNBREAKABLE<br />
<pre>
INT 2F - WinDOS v2.11 - MAKE PROGRAM UNBREAKABLE
	AX = AF06h
	DS:DX -&gt; break handler
	DI:BX = stack to use for break handler
Return: nothing
Desc:	set a handler which should be invoked when Ctrl-C is pressed instead of
	  aborting the program
SeeAlso: AX=AF00h"WinDOS",AX=AF0Ah"WinDOS",AX=AF0Ch"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF07" name="2FAF07"><b>2FAF07</b></a> - INT 2F - WinDOS v2.11 - SIGNAL FATAL OVERLAY FAULT<br />
<pre>
INT 2F - WinDOS v2.11 - SIGNAL FATAL OVERLAY FAULT
	AX = AF07h
Return: never -- system reset
Desc:	pop up a window indicating that the system overlay file can not be
	  loaded
SeeAlso: AX=AF00h"WinDOS",AX=AF08h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF08" name="2FAF08"><b>2FAF08</b></a> - INT 2F - WinDOS v2.11 - SIGNAL RECOVERABLE OVERLAY FAULT<br />
<pre>
INT 2F - WinDOS v2.11 - SIGNAL RECOVERABLE OVERLAY FAULT
	AX = AF08h
Return: nothing
Desc:	pop up a window requesting that a disk containing SH.OVL be inserted
SeeAlso: AX=AF00h"WinDOS",AX=AF07h"WinDOS",AX=AF0Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF09" name="2FAF09"><b>2FAF09</b></a> - INT 2F - WinDOS v2.11 - GET TERMINATED PSP<br />
<pre>
INT 2F - WinDOS v2.11 - GET TERMINATED PSP
	AX = AF09h
Return: DS = PSP segment of most recently ended TSR
SeeAlso: AX=AF00h"WinDOS",AX=AF0Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0A" name="2FAF0A"><b>2FAF0A</b></a> - INT 2F - WinDOS v2.11 - GET MAIN SHELL PSP<br />
<pre>
INT 2F - WinDOS v2.11 - GET MAIN SHELL PSP
	AX = AF0Ah
Return: AX = shell's PSP (same as DS on last call to AX=AF06h)
Desc:	get the PSP address of the last program to call AX=AF06h (normally
	  the main command interpreter)
SeeAlso: AX=AF00h"WinDOS",AX=AF06h"WinDOS",AX=AF09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0B" name="2FAF0B"><b>2FAF0B</b></a> - INT 2F - WinDOS v2.11 - SIGNAL FATAL ERROR<br />
<pre>
INT 2F - WinDOS v2.11 - SIGNAL FATAL ERROR
	AX = AF0Bh
Return: never -- system reset
Desc:	pop up a window indicating a terminal system error
SeeAlso: AX=AF00h"WinDOS",AX=AF07h,AX=AF08h,AX=AF15h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0C" name="2FAF0C"><b>2FAF0C</b></a> - INT 2F - WinDOS v2.11 - GET OTHER MAIN SHELL PARAMETERS<br />
<pre>
INT 2F - WinDOS v2.11 - GET OTHER MAIN SHELL PARAMETERS
	AX = AF0Ch
Return: DI:AX = stack
	SI = offset of break handler
Desc:	retrieve the parameters last set by AX=AF06h (normally by the main
	  command interpreter)
SeeAlso: AX=AF00h"WinDOS",AX=AF06h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0D" name="2FAF0D"><b>2FAF0D</b></a> - INT 2F - WinDOS v2.11 - GET CURRENT PARAMETER<br />
<pre>
INT 2F - WinDOS v2.11 - GET CURRENT PARAMETER
	AX = AF0Dh
	BX = offset of desired parameter in global data area
Return: AX = current value of parameter (AH undefined if byte value)
SeeAlso: AX=AF00h"WinDOS",AX=AF0Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0E" name="2FAF0E"><b>2FAF0E</b></a> - INT 2F - WinDOS v2.11 - SET CURRENT PARAMETER BYTE VALUE<br />
<pre>
INT 2F - WinDOS v2.11 - SET CURRENT PARAMETER BYTE VALUE
	AX = AF0Eh
	BX = offset of desired parameter in global data area
	DL = new value of parameter
Return: nothing
SeeAlso: AX=AF00h"WinDOS",AX=AF0Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0F" name="2FAF0F"><b>2FAF0F</b></a> - INT 2F - WinDOS v2.11 - GET HISTORY SEGMENT<br />
<pre>
INT 2F - WinDOS v2.11 - GET HISTORY SEGMENT
	AX = AF0Fh
Return: AX = segment of buffer for input history, or 0000h if none
SeeAlso: AX=AF00h"WinDOS",AX=AF10h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF10" name="2FAF10"><b>2FAF10</b></a> - INT 2F - WinDOS v2.11 - SET HISTORY SEGMENT<br />
<pre>
INT 2F - WinDOS v2.11 - SET HISTORY SEGMENT
	AX = AF10h
	BX = segment of new buffer for input history
Return: nothing
Note:	the buffer must have been allocated with INT 21/AH=48h
SeeAlso: AX=AF00h"WinDOS",AX=AF0Fh"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF11" name="2FAF11"><b>2FAF11</b></a> - INT 2F - WinDOS v2.11 - FREE XMS BLOCKS<br />
<pre>
INT 2F - WinDOS v2.11 - FREE XMS BLOCKS
	AX = AF11h
Return: nothing
Desc:	free all XMS blocks whose XMS identification value (see AX=AF12h)
	  equals the current PSP
SeeAlso: AX=AF00h"WinDOS",AX=AF12h"WinDOS",INT 21/AH=50h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF12" name="2FAF12"><b>2FAF12</b></a> - INT 2F - WinDOS v2.11 - SET XMS IDENTIFICATION VALUE<br />
<pre>
INT 2F - WinDOS v2.11 - SET XMS IDENTIFICATION VALUE
	AX = AF12h
	DS = new XMS identification value (normally caller's PSP segment)
Return: nothing
SeeAlso: AX=AF00h"WinDOS",AX=AF11h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF12_0" name="2FAF12_0"><b>2FAF12</b></a> - INT 2F U - ???<br />
<pre>
INT 2F U - ???
	AX = AF12h
	???
Return: ES = ???
SeeAlso: AX=AF00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF13" name="2FAF13"><b>2FAF13</b></a> - INT 2F - WinDOS v2.11 - SET ASSIGN VALUE<br />
<pre>
INT 2F - WinDOS v2.11 - SET ASSIGN VALUE
	AX = AF13h
	BL = number of drive to remap (00h = A:)
	DL = number of drive to be accessed via drive number BL
Return: nothing
Desc:	remap a drive letter
Note:	the remapping can be canceled by specifying DL=BL
SeeAlso: AX=AF00h"WinDOS",AX=AF14h"WinDOS",AX=0601h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF13_0" name="2FAF13_0"><b>2FAF13</b></a> - INT 2F U - ???<br />
<pre>
INT 2F U - ???
	AX = AF13h
	???
Return: ???
SeeAlso: AX=AF00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF14" name="2FAF14"><b>2FAF14</b></a> - INT 2F - WinDOS v2.11 - GET ASSIGN VALUE<br />
<pre>
INT 2F - WinDOS v2.11 - GET ASSIGN VALUE
	AX = AF14h
	BL = drive number (00h = A:)
Return: DL = drive number which is actually accessed by drive number BL
Desc:	determine the current mapping for a drive
SeeAlso: AX=AF00h"WinDOS",AX=AF13h"WinDOS",AX=0601h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF15" name="2FAF15"><b>2FAF15</b></a> - INT 2F - WinDOS v2.11 - SIGNAL STACK ERROR<br />
<pre>
INT 2F - WinDOS v2.11 - SIGNAL STACK ERROR
	AX = AF15h
Return: never -- system reset
Desc:	pop up a window indicating a stack overflow
SeeAlso: AX=AF00h"WinDOS",AX=AF0Bh"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF16" name="2FAF16"><b>2FAF16</b></a> - INT 2F - WinDOS v2.11 - GET SIMPLE TRUENAME<br />
<pre>
INT 2F - WinDOS v2.11 - GET SIMPLE TRUENAME
	AX = AF16h
	DS:SI -&gt; path to be canonicalized
	ES:DI -&gt; buffer for canonicalized filename/pathname
Return: CF clear if successful
	    AX = 0000h
	CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
Desc:	partially canonicalize a path, omitting SUBST, JOIN, ASSIGN, and
	  network redirections
SeeAlso: AX=AF00h"WinDOS",INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF17" name="2FAF17"><b>2FAF17</b></a> - INT 2F - WinDOS v2.11 - QUERY FOR NEW CURRENT DRIVE<br />
<pre>
INT 2F - WinDOS v2.11 - QUERY FOR NEW CURRENT DRIVE
	AX = AF17h
Return: nothing
Desc:	pop up a dialog allowing the user to select a new default drive
SeeAlso: AX=AF00h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF18" name="2FAF18"><b>2FAF18</b></a> - INT 2F - WinDOS v2.11 - SET CTRL-C/CTRL-BREAK DISABLE FLAG<br />
<pre>
INT 2F - WinDOS v2.11 - SET CTRL-C/CTRL-BREAK DISABLE FLAG
	AX = AF18h
	DL = new break-checking state (00h enabled, 01h disabled)
Return: nothing
SeeAlso: AX=AF00h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF19" name="2FAF19"><b>2FAF19</b></a> - INT 2F - WinDOS v2.11 - SET HEAD SETTLE FLAG<br />
<pre>
INT 2F - WinDOS v2.11 - SET HEAD SETTLE FLAG
	AX = AF19h
	DL = new state
	    00h diskette head settling time reset to 15ms before each access
	    01h no additional head settling time used between accesses
Return: nothing
SeeAlso: AX=AF00h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF1A" name="2FAF1A"><b>2FAF1A</b></a> - INT 2F - WinDOS v2.11 - SEARCH FOR NON-FRAGMENTED DISK AREA<br />
<pre>
INT 2F - WinDOS v2.11 - SEARCH FOR NON-FRAGMENTED DISK AREA
	AX = AF1Ah
	BL = drive (00h = current, 01h = A:, etc.)
	CX = number of clusters desired
Return: CF clear if successful
	    DI = first free cluster on logical drive
	    BP = first cluster of contiguous free area
	    AX destroyed
	CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
Desc:	attempt to find an area of the disk containing the specified number
	  of contiguous unallocated clusters
SeeAlso: AX=AF00h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF30" name="2FAF30"><b>2FAF30</b></a> - INT 2F U - ???<br />
<pre>
INT 2F U - ???
	AX = AF30h
	???
Return: ???
SeeAlso: AX=AF00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAFDE" name="2FAFDE"><b>2FAFDE</b></a> - INT 2F - Disk-Emu - INSTALLATION CHECK / GET VERSION<br />
<pre>
INT 2F - Disk-Emu - INSTALLATION CHECK / GET VERSION
	AX = AFDEh
	ES:DI -&gt; 14-byte buffer for data (see #02979)
Return: AX = CFDEh (Carlos Fernandez Disk-Emu) if installed
	    BX = version (BH = major, BL = minor)

Format of Disk-Emu information data:
Offset	Size	Description	(Table 02979)
 00h	BYTE	number of tracks
 01h	BYTE	sectors per track
 02h	WORD	bytes per sector
 04h	BYTE	number of heads
 05h	BYTE	flag: 00h inactive, 01h active
 06h	BYTE	write protection (00h none, 01h full, 02h pseudo)
 07h	BYTE	saved (00h some unsaved data, 01h all data saved)
 08h	BYTE	disk in memory (00h no, 01h yes)
 09h	WORD	EMS handle
 0Bh	WORD	XMS handle
 0Dh	BYTE	memory type used for disk (00h XMS, 01h EMS)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB000" name="2FB000"><b>2FB000</b></a> - INT 2F - DOS 3.3+ GRAFTABL.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS 3.3+ GRAFTABL.COM - INSTALLATION CHECK
	AX = B000h
Return: AL = status
	    00h not installed, OK to install
	    01h not installed, not OK to install
	    FFh installed
Notes:	called by DISPLAY.SYS
	documented for DOS 5.0, but undocumented in prior versions
SeeAlso: AX=2300h,AX=2E00h,AX=B001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB001" name="2FB001"><b>2FB001</b></a> - INT 2F - DOS 3.3+ GRAFTABL.COM - GET GRAPHICS FONT TABLE<br />
<pre>
INT 2F - DOS 3.3+ GRAFTABL.COM - GET GRAPHICS FONT TABLE
	AX = B001h
	DS:BX -&gt; DWORD buffer for address of 8x8 font table
Return: buffer filled
	AL = FFh
Note:	PC-DOS 3.30/4.01 and MS-DOS 6.0 set the font table offset to 0130h,
	  MS-DOS 3.30 sets it to 0030h
SeeAlso: AH=2Eh"GRAFTABL",AX=B000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB400" name="2FB400"><b>2FB400</b></a> - INT 2F - IBM PC3270 EMULATION PROG v3 - INSTALLATION CHECK<br />
<pre>
INT 2F - IBM PC3270 EMULATION PROG v3 - INSTALLATION CHECK
	AX = B400h
Return: AL = FFh if installed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB401" name="2FB401"><b>2FB401</b></a> - INT 2F - IBM PC3270 EMULATION PROG v3 - GET HOST BUFFER ADDRESS<br />
<pre>
INT 2F - IBM PC3270 EMULATION PROG v3 - GET HOST BUFFER ADDRESS
	AX = B401h
Return: ES -&gt; host screen buffer (PC ASCII format)
	ES unchanged if communications not started

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB402" name="2FB402"><b>2FB402</b></a> - INT 2F - IBM PC3270 EMULATION PROG v3 - ???<br />
<pre>
INT 2F - IBM PC3270 EMULATION PROG v3 - ???
	AX = B402h
	BX = ???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB403" name="2FB403"><b>2FB403</b></a> - INT 2F - IBM PC3270 EMULATION PROG v3 - ???<br />
<pre>
INT 2F - IBM PC3270 EMULATION PROG v3 - ???
	AX = B403h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB404" name="2FB404"><b>2FB404</b></a> - INT 2F - IBM PC3270 EMULATION PROG v3 - ???<br />
<pre>
INT 2F - IBM PC3270 EMULATION PROG v3 - ???
	AX = B404h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB405" name="2FB405"><b>2FB405</b></a> - INT 2F - IBM PC3270 EMULATION PROG v3 - ???<br />
<pre>
INT 2F - IBM PC3270 EMULATION PROG v3 - ???
	AX = B405h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB700" name="2FB700"><b>2FB700</b></a> - INT 2F - APPEND - INSTALLATION CHECK<br />
<pre>
INT 2F - APPEND - INSTALLATION CHECK
	AX = B700h
Return: AL = status
	    00h not installed
	    FFh installed
Note:	MS-DOS 3.30 APPEND refuses to install itself when run inside TopView or
	  a TopView-compatible environment
SeeAlso: AX=B702h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB701" name="2FB701"><b>2FB701</b></a> - INT 2F U - APPEND v3.21 only - GET APPEND PATH<br />
<pre>
INT 2F U - APPEND v3.21 only - GET APPEND PATH
	AX = B701h
Return: ES:DI -&gt; active APPEND path
Notes:	the only version of APPEND known to support this call is the APPEND
	  shipped with Microtek MS-DOS 3.21; MS-DOS 3.30-6.00 APPEND displays
	  "Incorrect APPEND Version" and aborts the caller
	use AX=B704h first, and only call this function if that one is not
	  supported
SeeAlso: AX=B700h,AX=B704h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB702" name="2FB702"><b>2FB702</b></a> - INT 2F - APPEND - GET VERSION<br />
<pre>
INT 2F - APPEND - GET VERSION
	AX = B702h
Return: AX = FFFFh if not DOS 4.0 APPEND (also if DOS 5.0 APPEND)
	AL = major version number
	AH = minor version number, otherwise
SeeAlso: AX=B700h,AX=B710h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB703" name="2FB703"><b>2FB703</b></a> - INT 2F U - DOS 3.3, DOS 5.0 APPEND - HOOK INT 21<br />
<pre>
INT 2F U - DOS 3.3, DOS 5.0 APPEND - HOOK INT 21
	AX = B703h
	ES:DI -&gt; INT 21 handler APPEND should chain to
Return: ES:DI -&gt; APPEND's INT 21 handler
Note:	each invocation of this function toggles a flag which APPEND uses to
	  determine whether to chain to the user handler or the original
	  INT 21
SeeAlso: AX=B700h,AX=B706h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB704" name="2FB704"><b>2FB704</b></a> - INT 2F - DOS 3.3+ APPEND - GET APPEND PATH<br />
<pre>
INT 2F - DOS 3.3+ APPEND - GET APPEND PATH
	AX = B704h
Return: ES:DI -&gt; active APPEND path (128 bytes max)
Note:	some versions of append do not support this call, and return ES
	  unchanged; in this case, you should call AX=B701h to get the APPEND
	  path
SeeAlso: AX=B701h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB706" name="2FB706"><b>2FB706</b></a> - INT 2F - DOS 4.0+ APPEND - GET APPEND FUNCTION STATE<br />
<pre>
INT 2F - DOS 4.0+ APPEND - GET APPEND FUNCTION STATE
	AX = B706h
Return: BX = APPEND state (see #02980)
SeeAlso: AX=B700h,AX=B707h

Bitfields for APPEND state:
Bit(s)	Description	(Table 02980)
 0	set if APPEND enabled
 1-11	reserved
 12	(DOS 5.0) set if APPEND applies directory search even if a drive has
	  been specified
 13	set if /PATH flag active
 14	set if /E flag active (environment var APPEND exists)
 15	set if /X flag active

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB707" name="2FB707"><b>2FB707</b></a> - INT 2F - DOS 4.0+ APPEND - SET APPEND FUNCTION STATE<br />
<pre>
INT 2F - DOS 4.0+ APPEND - SET APPEND FUNCTION STATE
	AX = B707h
	BX = APPEND state bits (see #02980)
SeeAlso: AX=B700h,AX=B706h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB710" name="2FB710"><b>2FB710</b></a> - INT 2F U - DOS 3.3+ APPEND - GET VERSION INFO<br />
<pre>
INT 2F U - DOS 3.3+ APPEND - GET VERSION INFO
	AX = B710h
Return: AX = current APPEND state (see #02980)
	BX = ??? (0000h in MS-DOS 3.30 and 5.00)
	CX = ??? (0000h in MS-DOS 3.30 and 5.00)
	DL = major version
	DH = minor version
SeeAlso: AX=B700h,AX=B702h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB711" name="2FB711"><b>2FB711</b></a> - INT 2F - DOS 4.0+ APPEND - SET RETURN FOUND NAME STATE<br />
<pre>
INT 2F - DOS 4.0+ APPEND - SET RETURN FOUND NAME STATE
	AX = B711h
Note:	if the next INT 21h call (and ONLY the next) is function 3Dh, 43h, or
	  6Ch (also 4B03h and 4Eh if /X active), the fully qualified filename
	  is written over top of the filename passed to the INT 21h call.  The
	  application must provide a sufficiently large buffer.	 This state is
	  reset after the next INT 21h call processed by APPEND.
	APPEND uses the byte at offset 3Dh in the PSP
	  (see #01378 at INT 21/AH=26h) to store the flag telling it to
	  overwrite the filename
BUG:	DOS 4.0 APPEND reportedly overwrites DS:DX instead of DS:SI for
	  INT 21/AH=6Ch
SeeAlso: INT 21/AH=26h,INT 21/AH=4Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB800" name="2FB800"><b>2FB800</b></a> - INT 2F - NETWORK - INSTALLATION CHECK<br />
<pre>
INT 2F - NETWORK - INSTALLATION CHECK
	AX = B800h
Return: AL = status
	    00h	    not installed
	    nonzero installed
	      BX = installed component flags (test in this order!)
		   bit 6   server
		   bit 2   messenger
		   bit 7   receiver
		   bit 3   redirector
		   bit 1   LANPUP (LANtastic 4.0)
Notes:	this function is supported by PC LAN Program, LAN Manager, LANtastic,
	  NetWare Lite, SilverNET, 10NET, etc.
	LANtastic and NetWare Lite use only BL for the return value, preserving
	  BH; LAN Manager and DOS LAN Requester return BH=00h.	This permits
	  differentiation between those two groups by setting BH to a nonzero
	  value before the call and checking its value on return.
SeeAlso: AX=4E53h,AX=B809h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB800CXF041" name="2FB800CXF041"><b>2FB800CXF041</b></a> - INT 2F - 10NET - INSTALLATION CHECK<br />
<pre>
INT 2F - 10NET - INSTALLATION CHECK
	AX = B800h
	CX = F041h
Return: AL = status
	    00h	    not installed
	    nonzero installed
		BX = installed component flags (test in this order!)
		   bit 6   server
		   bit 2   messenger
		   bit 7   receiver
		   bit 3   redirector
		   bit 1   LANPUP (LANtastic 4.0)
		CX = 10Net data segment
		CX:DX -&gt; 10Net Configuration Table
			  (see #01691 at INT 21/AX=5E01h"10NET")
Note:	if CX &lt;&gt; F041h on entry, neither CX nor DX will be changed, and this
	  call becomes identical to the standard installation check above
SeeAlso: AX=B800h"network",INT 21/AX=5E01h"10NET"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB803" name="2FB803"><b>2FB803</b></a> - INT 2F - NETWORK - GET NETWORK EVENT POST HANDLER<br />
<pre>
INT 2F - NETWORK - GET NETWORK EVENT POST HANDLER
	AX = B803h
Return: ES:BX -&gt; current event post handler (see AX=B804h)
Note:	this function is supported by PC LAN Program, 10NET v5.0,
	  NetSoft DOS-NET v1.20+
SeeAlso: AX=B800h,AX=B804h,AX=B903h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB804" name="2FB804"><b>2FB804</b></a> - INT 2F - NETWORK - SET NETWORK EVENT POST HANDLER<br />
<pre>
INT 2F - NETWORK - SET NETWORK EVENT POST HANDLER
	AX = B804h
	CX = (10NET) 0370h if 10Windows is hooking post handler
	ES:BX -&gt; new event post handler (see #02981)
Notes:	used in conjunction with AX=B803h to hook into the network event post
	  routine
	this function is supported by PC LAN Program, 10NET v5.0,
	  NetSoft DOS-NET v1.20+
	The specified handler is called on any network event.  Two events are
	  defined: message received and critical network error.
SeeAlso: AX=B800h,AX=B803h,AX=B904h

(Table 02981)
Values network post routine is called with:
	AX = 0000h single block message
	    DS:SI -&gt; ASCIZ originator name
	    DS:DI -&gt; ASCIZ destination name
	    ES:BX -&gt; text header (see #02982)
	AX = 0001h start multiple message block
	    CX = block group ID
	    DS:SI -&gt; ASCIZ originator name
	    DS:DI -&gt; ASCIZ destination name
	AX = 0002h multiple block text
	    CX = block group ID
	    ES:BX -&gt; text header (see #02982)
	AX = 0003h end multiple block message
	    CX = block group ID
	AX = 0004h message aborted due to error
	    CX = block group ID
	AX = 0101h server received badly formatted network request
	    Return: AX = FFFFh (PC LAN will process error)
	AX = 0102h unexpected network error
	    ES:BX -&gt; NCB (see #03249 at INT 5C"NetBIOS")
	AX = 0103h server received INT 24 error
	    other registers as for INT 24, except AH is in BH
	    Return: as below, but only 0000h and FFFFh allowed
Return: AX = response code
	    0000h user post routine processed message
	    0001h PC LAN will process message, but message window not displayed
	    FFFFh PC LAN will process message

Format of text header:
Offset	Size	Description	(Table 02982)
 00h	WORD	length of text (maximum 512 bytes)
 02h  N BYTEs	text of message
Note:	all CRLF sequences in message text are replaced by 14h; all other
	  values below 20h (space) are reserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB807" name="2FB807"><b>2FB807</b></a> - INT 2F - NETWORK - GET NetBIOS NAME NUMBER OF MACHINE NAME<br />
<pre>
INT 2F - NETWORK - GET NetBIOS NAME NUMBER OF MACHINE NAME
	AX = B807h
Return: CH = NetBIOS name number of the machine name
SeeAlso: INT 21/AX=5E00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB808" name="2FB808"><b>2FB808</b></a> - INT 2F U - NETWORK - RELINK KEYBOARD HANDLER<br />
<pre>
INT 2F U - NETWORK - RELINK KEYBOARD HANDLER
	AX = B808h
	ES:BX -&gt; INT 09 handler network should call after it finishes INT 09
Notes:	this call replaces the address to which the network software chains on
	  an INT 09 without preserving the original value.  This allows a prior
	  handler to unlink, but does not allow a new handler to be added
	  such that the network gets the INT 09 first unless the new handler
	  completely takes over INT 09 and never chains.
	this function is called by the DOS 3.2 KEYBxx.COM and DOS 3.3+ KEYB.COM
SeeAlso: AX=B908h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB809" name="2FB809"><b>2FB809</b></a> - INT 2F - NETWORK - LANtastic, NetWare Lite - GET VERSION<br />
<pre>
INT 2F - NETWORK - LANtastic, NetWare Lite - GET VERSION
	AX = B809h
Return: AH = major version
	AL = minor version (decimal)
Notes:	this function is supported in this form by LANtastic, NetWare Lite,
	  SilverNET, ...
	NetWare Lite returns its own version number rather than a PC LAN
	  compatibility version
SeeAlso: AX=4E53h,AX=B800h,AX=B809h"PC LAN Program"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB809_0" name="2FB809_0"><b>2FB809</b></a> - INT 2F - NETWORK - PC LAN Program, Microsoft Networking - GET VERSION<br />
<pre>
INT 2F - NETWORK - PC LAN Program, Microsoft Networking - GET VERSION
	AX = B809h
Return: AH = minor version (decimal)
	AL = major version
Notes:	this function is supported in this form by PC LAN Program, LAN Manager,
	  the DOS LAN Requester, 10NET v5.0, and Microsoft Networking under
	  WfWg 3.11
	10NET returns version 1.10 (AX=0A01h) for compatibility
SeeAlso: AX=4E53h,AX=B800h,AX=B809h"LANtastic"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB80A" name="2FB80A"><b>2FB80A</b></a> - INT 2F u - PC Network 1.00 - ???<br />
<pre>
INT 2F u - PC Network 1.00 - ???
	AX = B80Ah
	???
Return: ???
Program: PC Network is an early networking package which was renamed the
	  IBM PC Local Area Network Program (PC LAN Program) as of v1.10
Note:	called by RECEIVER (equivalent to NetWare Lite SERVER)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB80E" name="2FB80E"><b>2FB80E</b></a> - INT 2F U - DOS LAN Requester - GET XSI2 ADDRESS / DATA<br />
<pre>
INT 2F U - DOS LAN Requester - GET XSI2 ADDRESS / DATA
	AX = B80Eh
Return: DS:DI -&gt; XSI2 TSR's resident data (see #02983)
Note:	this function is used by NET.COM to locate the USERID and DOMAIN of
	  the logged-in user (which may differ from the NET START domain
	  name from DOSLAN.INI which is returned by AX=B80Fh)
SeeAlso: AX=B800h,AX=B80Fh

Format of XSI2 resident data:
Offset	Size	Description	(Table 02983)
 00h 254 BYTEs	???
 FEh 10 BYTEs	user ID 1
108h 10 BYTEs	user ID 2
112h 10 BYTEs	domain name 1
11Ch 10 BYTEs	domain name 2
126h  ? BYTEs	domain controller

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB80F" name="2FB80F"><b>2FB80F</b></a> - INT 2F - DOS LAN Requester - GET START PARAMETERS<br />
<pre>
INT 2F - DOS LAN Requester - GET START PARAMETERS
	AX = B80Fh
	CX = size of return data buffer
	ES:DI -&gt; return data buffer (see #02984)
Return: AX = status
	     00h     network started
	     nonzero network not started
	CX = number of bytes returned in buffer
	ES:DI buffer filled
SeeAlso: AX=B809h"PC LAN Program",AX=B80Eh

Format of DOS LAN Requester return data buffer:
Offset	Size	Description	(Table 02984)
 00h	BYTE	major version
 01h	BYTE	minor version
 02h	WORD	configuration flags given when network was started (see #02985)
 04h 15 BYTEs	NET START machine name (space padded)
 13h	BYTE	00h
 14h 9	BYTEs	NET START domain name (NULL padded)
 1Dh	BYTE	00h
 1Eh 32 BYTEs	/WRK heuristics string (space padded, not terminated)
 3Eh	WORD	/SRV value
 40h	WORD	/ASG value
 42h	WORD	/NBC value
 44h	WORD	/NBS value
 46h	WORD	/BBC value
 48h	WORD	/BBS value
 4Ah	WORD	/PBC value
 4Ch	WORD	/PBS value
 4Eh	WORD	/PFS value
 50h	WORD	/PFT value
 52h	WORD	/PWT value
 54h	WORD	/KUC value
 56h	WORD	/KST value
 58h	WORD	/NVS value
 5Ah	WORD	/NMS value
 5Ch	WORD	/NDB value
 5Eh	WORD	/MBI value
 60h	BYTE	NetBIOS name number for machine name
 61h	BYTE	NetBIOS name number for domain name
 62h	WORD	NetBIOS sessions required for configuration
 64h	WORD	NetBIOS commands required for configuration
 66h	WORD	NetBIOS names required for configuration
 68h 128 BYTEs	NET START path (LANROOT)
 E8h	BYTE	00h

Bitfields for configuration flags:
Bit(s)	Description	(Table 02985)
 0	/NVS nonzero
 1	/NMS nonzero
 2	/API
 3	/HIM
 4	/LIM
 5	/ENC
 6	/POP
 7	/EMS
 8	/RPL
 9-12	reserved
 13	RDR started
 14	RCV started
 15	User is currently logged on

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB900" name="2FB900"><b>2FB900</b></a> - INT 2F - PC Network RECEIVER.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - PC Network RECEIVER.COM - INSTALLATION CHECK
	AX = B900h
Return: AL = state
	    00h if not installed
	    FFh if installed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB901" name="2FB901"><b>2FB901</b></a> - INT 2F - PC Network RECEIVER.COM - GET RECEIVER.COM INT 2F HANDLER ADDRESS<br />
<pre>
INT 2F - PC Network RECEIVER.COM - GET RECEIVER.COM INT 2F HANDLER ADDRESS
	AX = B901h
Return: AL = ???
	ES:BX -&gt; RECEIVER.COM INT 2F handler
Desc:	allows more efficient execution by letting the caller bypass any other
	  INT 2F handlers which have been added since RECEIVER.COM was
	  installed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB903" name="2FB903"><b>2FB903</b></a> - INT 2F - PC Network RECEIVER.COM - GET RECEIVER.COM POST ADDRESS<br />
<pre>
INT 2F - PC Network RECEIVER.COM - GET RECEIVER.COM POST ADDRESS
	AX = B903h
Return: ES:BX -&gt; POST handler
SeeAlso: AX=B803h,AX=B904h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB904" name="2FB904"><b>2FB904</b></a> - INT 2F - PC Network RECEIVER.COM - SET RECEIVER.COM POST ADDRESS<br />
<pre>
INT 2F - PC Network RECEIVER.COM - SET RECEIVER.COM POST ADDRESS
	AX = B904h
	ES:BX -&gt; new POST handler
SeeAlso: AX=B804h,AX=B903h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB905" name="2FB905"><b>2FB905</b></a> - INT 2F - PC Network RECEIVER.COM - GET FILENAME<br />
<pre>
INT 2F - PC Network RECEIVER.COM - GET FILENAME
	AX = B905h
	DS:BX -&gt; 128-byte buffer for filename 1
	DS:DX -&gt; 128-byte buffer for filename 2
Return: buffers filled from RECEIVER.COM internal buffers
Note:	use of filenames is unknown, but one appears to be for storing messages
SeeAlso: AX=B906h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB906" name="2FB906"><b>2FB906</b></a> - INT 2F - PC Network RECEIVER.COM - SET FILENAME<br />
<pre>
INT 2F - PC Network RECEIVER.COM - SET FILENAME
	AX = B906h
	DS:BX -&gt; 128-byte buffer for filename 1
	DS:DX -&gt; 128-byte buffer for filename 2
Return: RECEIVER.COM internal buffers filled from user buffers
Note:	use of filenames is unknown, but one appears to be for storing messages
SeeAlso: AX=B905h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FB908" name="2FB908"><b>2FB908</b></a> - INT 2F - PC Network RECEIVER.COM - UNLINK KEYBOARD HANDLER<br />
<pre>
INT 2F - PC Network RECEIVER.COM - UNLINK KEYBOARD HANDLER
	AX = B908h
	ES:BX -&gt; INT 09 handler RECEIVER should call after it finishes INT 09
Note:	this call replaces the address to which RECEIVER.COM chains on an
	  INT 09 without preserving the original value.	 This allows a prior
	  handler to unlink, but does not allow a new handler to be added
	  such that RECEIVER gets the INT 09 first.
SeeAlso: AX=B808h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBB00BX0000" name="2FBB00BX0000"><b>2FBB00BX0000</b></a> - INT 2F - CATC USB4DOS Host Controller - INSTALLATION CHECK<br />
<pre>
INT 2F - CATC USB4DOS Host Controller - INSTALLATION CHECK
	AX = BB00h
	BX = 0000h
Return: AX = 0001h if installed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBB00BX0001" name="2FBB00BX0001"><b>2FBB00BX0001</b></a> - INT 2F - CATC USB4DOS Host Controller - GET ???<br />
<pre>
INT 2F - CATC USB4DOS Host Controller - GET ???
	AX = BB00h
	BX = 0001h
Return: AX = 0000h
	CX:BX -&gt; ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBB00BX0002" name="2FBB00BX0002"><b>2FBB00BX0002</b></a> - INT 2F - CATC USB4DOS Host Controller - EXECUTE USB REQUEST<br />
<pre>
INT 2F - CATC USB4DOS Host Controller - EXECUTE USB REQUEST
	AX = BB00h
	BX = 0002h
	CX:DX -&gt; request packet (see #04097)
Return: AX = destroyed

Format of USB4DOS Host Controller request packet:
Offset	Size	Description	(Table 04097)
 00h	WORD	command number
 02h	WORD	(ret) major status
 04h	WORD	(ret) minor status
 06h	DWORD	-&gt; callback function
 0Ah 25 BYTEs	data for command (varies by command number)
 23h 12 BYTEs	reserved for future use

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBB00BX0003" name="2FBB00BX0003"><b>2FBB00BX0003</b></a> - INT 2F - CATC USB4DOS Host Controller - ??? (POLLS VARIOUS I/O PORTS)<br />
<pre>
INT 2F - CATC USB4DOS Host Controller - ??? (POLLS VARIOUS I/O PORTS)
	AX = BB00h
	BX = 0003h
Return: AX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBB00" name="2FBB00"><b>2FBB00</b></a> - INT 2F - CATC USB4DOS Host Controller - INVALID FUNCTION<br />
<pre>
INT 2F - CATC USB4DOS Host Controller - INVALID FUNCTION
	AX = BB00h
	BX &gt; 0003h
Return: AX = FFFFh (invalid function)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC00" name="2FBC00"><b>2FBC00</b></a> - INT 2F - Windows 3.0, DOS 5+ EGA.SYS - INSTALLATION CHECK<br />
<pre>
INT 2F - Windows 3.0, DOS 5+ EGA.SYS - INSTALLATION CHECK
	AX = BC00h
Return: AL = state
	    00h not installed, OK to install
	    01h not installed, not OK to install
	    FFh installed
		BX = 5456h ("TV")
Range:	AH=80h to AH=FFh, selected by commandline switch
SeeAlso: AX=BC06h"EGA",INT 10/AH=FAh"EGA"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC00BL00" name="2FBC00BL00"><b>2FBC00BL00</b></a> - INT 2F - CATC USB4DOS Device Manager - INSTALLATION CHECK<br />
<pre>
INT 2F - CATC USB4DOS Device Manager - INSTALLATION CHECK
	AX = BC00h
	BL = 00h
Return: AX = installation state
	    0000h not installed
	    0001h installed
	    BC00h not installed
SeeAlso: AX=BC00h/BL=01h,AX=BC00h/BL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC00BL01" name="2FBC00BL01"><b>2FBC00BL01</b></a> - INT 2F - CATC USB4DOS Device Manager - REGISTER DEVICE<br />
<pre>
INT 2F - CATC USB4DOS Device Manager - REGISTER DEVICE
	AX = BC00h
	BL = 01h
	CX:DX -&gt; client_info structure (see #04096)
Return: AX = client number, 0000h on failure
SeeAlso: AX=BC00h/BL=02h,AX=BC00h/BL=00h

Format of CATC USB4DOS client_info structure:
Offset	Size	Description	(Table 04096)
 00h	DWORD	-&gt; Attach() worker function
 04h	DWORD	-&gt; Detach() worker function

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC00BL02" name="2FBC00BL02"><b>2FBC00BL02</b></a> - INT 2F - CATC USB4DOS Device Manager - UNLOAD DEVICE<br />
<pre>
INT 2F - CATC USB4DOS Device Manager - UNLOAD DEVICE
	AX = BC00h
	BL = 02h
	CX = client number
Return: AX destroyed
SeeAlso: AX=BC00h/BL=01h,AX=BC00h/BL=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC00BL03" name="2FBC00BL03"><b>2FBC00BL03</b></a> - INT 2F - CATC USB4DOS Device Manager - HUB DEVICE ATTACHED<br />
<pre>
INT 2F - CATC USB4DOS Device Manager - HUB DEVICE ATTACHED
	AX = BC00h
	BL = 03h
	BH = address and device type
	    bits 7-1: USB address of hub
	    bit 0: device speed
		=0 low-speed device
		=1 full-speed device
	CX:DX -&gt; callback function
Return: AX = USB address of attached device, or 0000h on failure
SeeAlso: AX=BC00h/BL=04h,AX=BC00h/BL=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC00BL04" name="2FBC00BL04"><b>2FBC00BL04</b></a> - INT 2F - CATC USB4DOS Device Manager - HUB DEVICE DETACHED<br />
<pre>
INT 2F - CATC USB4DOS Device Manager - HUB DEVICE DETACHED
	AX = BC00h
	BL = 04h
	BH = USB address of detached device (may be the hub itself)
Return: AX destroyed
SeeAlso: AX=BC00h/BL=03h,AX=BC00h/BL=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC00BX3F3F" name="2FBC00BX3F3F"><b>2FBC00BX3F3F</b></a> - INT 2F - MediaVision MVSOUND.SYS - INSTALLATION CHECK<br />
<pre>
INT 2F - MediaVision MVSOUND.SYS - INSTALLATION CHECK
	AX = BC00h
	BX = 3F3Fh ('??')
	CX = 0000h
	DX = 0000h
Return: if installed, BX XOR CX XOR DX = 4D56h ('MV')
Program: MVSOUND.SYS is a driver for the MediaVision ProAudio Spectrum family
	  of sound boards; its primary programmer was Bryan Crane
SeeAlso: AX=BC01h"MVSOUND",AX=BC02h,AX=BC03h,AX=BC04h,AX=BC06h"MVSOUND"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC01" name="2FBC01"><b>2FBC01</b></a> - INT 2F - MediaVision MVSOUND.SYS - GET VERSION<br />
<pre>
INT 2F - MediaVision MVSOUND.SYS - GET VERSION
	AX = BC01h
	BX = magic value 6D20h ('m ')
	CX = magic value 2076h (' v')
	DX = magic value 2020h ('  ')
Return: BX = ASCII major version (leading zeros significant)
	CX = ASCII minor version (leading zeros significant)
SeeAlso: AX=BC00h/BX=3F3Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC02" name="2FBC02"><b>2FBC02</b></a> - INT 2F - MediaVision MVSOUND.SYS - GET STATE TABLE POINTER<br />
<pre>
INT 2F - MediaVision MVSOUND.SYS - GET STATE TABLE POINTER
	AX = BC02h
Return: AX = 4D56h ('MV')
	BX:DX -&gt; state table
SeeAlso: AX=BC00h/BX=3F3Fh,AX=BC03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC03" name="2FBC03"><b>2FBC03</b></a> - INT 2F - MediaVision MVSOUND.SYS - GET FUNCTION TABLE POINTER<br />
<pre>
INT 2F - MediaVision MVSOUND.SYS - GET FUNCTION TABLE POINTER
	AX = BC03h
Return: AX = 4D56h ('MV')
	BX:DX -&gt; function table
	CX = ??? (000Eh)
SeeAlso: AX=BC00h/BX=3F3Fh,AX=BC02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC04" name="2FBC04"><b>2FBC04</b></a> - INT 2F - MediaVision MVSOUND.SYS - GET DMA AND IRQ CHANNELS<br />
<pre>
INT 2F - MediaVision MVSOUND.SYS - GET DMA AND IRQ CHANNELS
	AX = BC04h
Return: AX = 4D56h ('MV')
	BL = DMA channel
	CL = IRQ number
SeeAlso: AX=BC00h/BX=3F3Fh,AX=BC01h"MVSOUND"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC06" name="2FBC06"><b>2FBC06</b></a> - INT 2F U - MS Windows 3.0, DOS 5+ EGA.SYS - GET VERSION INFO<br />
<pre>
INT 2F U - MS Windows 3.0, DOS 5+ EGA.SYS - GET VERSION INFO
	AX = BC06h
Return: BX = 5456h ("TV")
	CH = major version
	CL = minor version
	DL = revision
SeeAlso: AX=BC00h"EGA",INT 10/AH=FAh"EGA"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC06_0" name="2FBC06_0"><b>2FBC06</b></a> - INT 2F - MediaVision MVSOUND.SYS - GET STATUS STRING<br />
<pre>
INT 2F - MediaVision MVSOUND.SYS - GET STATUS STRING
	AX = BC06h
Return: AX = 4D56h ('MV')
	DX:BX -&gt; status string (first byte 0Ch if no status message to display)
SeeAlso: AX=BC00h/BX=3F3Fh,AX=BC01h"MVSOUND",AX=BC0Bh"MVSOUND"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC0B" name="2FBC0B"><b>2FBC0B</b></a> - INT 2F - MediaVision MVSOUND.SYS - GET EXECUTABLE PATH<br />
<pre>
INT 2F - MediaVision MVSOUND.SYS - GET EXECUTABLE PATH
	AX = BC0Bh
Return: BX:DX -&gt; ASCIZ path for MVPROAS.EXE, 0000h:0000h if not available
SeeAlso: AX=BC00h/BX=3F3Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBC0E" name="2FBC0E"><b>2FBC0E</b></a> - INT 2F - MediaVision MVSOUND.SYS - RE-INITIALIZE INT 09 HANDLER<br />
<pre>
INT 2F - MediaVision MVSOUND.SYS - RE-INITIALIZE INT 09 HANDLER
	AX = BC0Eh
Return: BX = status
	    0000h on failure
		AX = 0000h
	    FFFFh if successful
		DX:AX -&gt; prior INT 09 handler
Desc:	re-initialize INT 09 handler to re-enable hotkeys (e.g. after loading
	  KEYB)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBE00" name="2FBE00"><b>2FBE00</b></a> - INT 2F - REDVIEW - INSTALLATION CHECK<br />
<pre>
INT 2F - REDVIEW - INSTALLATION CHECK
	AX = BE00h
Return: AL = FFh if installed
Program: REDVIEW is a public-domain TSR by Alexandr Novy and Petr Horak which
	  copies data sent to standard output to standard error when the
	  former has been redirected to a file, thus allowing the data to
	  be seen on the screen at the same time it is captured in a file

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBF00" name="2FBF00"><b>2FBF00</b></a> - INT 2F - PC LAN PROGRAM REDIRIFS.EXE internal - INSTALLATION CHECK<br />
<pre>
INT 2F - PC LAN PROGRAM REDIRIFS.EXE internal - INSTALLATION CHECK
	AX = BF00h
Return: AL = FFh if installed
Note:	this function is also supported by NetSoft's DOS-NET v1.20+; however,
	  none of the remaining BFxxh calls are supported
SeeAlso: AX=BF01h,AX=BF80h,INT 2A/AX=4147h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBF01" name="2FBF01"><b>2FBF01</b></a> - INT 2F U - PC LAN PROGRAM REDIRIFS.EXE internal - ???<br />
<pre>
INT 2F U - PC LAN PROGRAM REDIRIFS.EXE internal - ???
	AX = BF01h
	???
Return: ???
SeeAlso: AX=BF00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FBF80" name="2FBF80"><b>2FBF80</b></a> - INT 2F - PC LAN PROG REDIR.SYS internal - SET REDIRIFS ENTRY POINT<br />
<pre>
INT 2F - PC LAN PROG REDIR.SYS internal - SET REDIRIFS ENTRY POINT
	AX = BF80h
	ES:DI -&gt; FAR entry point to IFS handler in REDIRIFS
Return: AL = FFh if installed
	    ES:DI -&gt; internal workspace
Note:	all future IFS calls to REDIR.SYS are passed to the ES:DI entry point
SeeAlso: AX=BF00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC0" name="2FC0"><b>2FC0</b></a> - INT 2F - METZ XpressFax Hardware TSR (CLASS2) - API<br />
<pre>
INT 2F - METZ XpressFax Hardware TSR (CLASS2) - API
	AH = C0h
	AL = function code (01h to 15h)
Return: ???
SeeAlso: AX=C000h/BX=444Bh,AX=CB00h/BX=4D53h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000" name="2FC000"><b>2FC000</b></a> - INT 2F - Novell ODI Link Support Layer (LSL.COM) - INSTALLATION CHECK<br />
<pre>
INT 2F - Novell ODI Link Support Layer (LSL.COM) - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	    DX:BX -&gt; FAR entry point (see #02986,#02987,#02988)
	    ES:SI -&gt; signature string "LINKSUP$"
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
Note:	on return, ES = DX for LSL v1.10 and v2.05; LSL makes use of this in
	  its search for a previous installation
SeeAlso: AX=5100h,AX=C000h"NESL"

(Table 02986)
Call LSL function "Request MLID Registration" with:
	BX = 0001h
	ES:SI -&gt; registration??? record (see #02990)
	DS:DI -&gt; buffer for LSL information block (see #02991)
Return: AX = completion code (0000h,8001h) (see #02989)
	DS:DI buffer filled if successful
	BX,CX corrupted
Note:	see "Novell LAN Driver Developer's Guide, Volume III" for more details

(Table 02987)
Call LSL function "get support entry points" with:
	BX = 0002h
	ES:SI -&gt; buffer for entry point record (see #02992)
Return: ES:SI buffer filled

(Table 02988)
Call LSL function "Request MLID API entry point" with:
	BX = 0003h
Return: ES:SI -&gt; MLID (Multiple Link Interface Driver) API entry point
		(call with BX=function 00h-10h, not range-checked)
Note:	LSL v1.10 and v2.05 execute BX=0003h for BX=0000h and any BX &gt;= 0003h

(Table 02989)
Values for LSL completion code:
 0000h	successful
 8001h	out of resources
 8002h	bad parameter
 8003h	no more items
 8004h	item not present
 8005h	failed
 8006h	receive overflow
 8007h	canceled
 8008h	bad command
 8009h	duplicate entry
 800Ah	no such handler
 800Bh	no such driver

Format of LSL registration record:
Offset	Size	Description	(Table 02990)
 00h	DWORD	-&gt; ??? FAR function (to be called with ES:SI -&gt; ??? and
		  returning AX = completion code)
 04h	DWORD	-&gt; ???
 08h	DWORD	-&gt; ??? data (at least 3Eh bytes)

Format of LSL information block:
Offset	Size	Description	(Table 02991)
 00h	DWORD	-&gt; ??? entry point (called with BX=function 00h-11h)
 04h	WORD	???
 06h	WORD	???
Note:	due to a fencepost error, LSL v2.05 (distributed with Novell DOS 7)
	  will crash if the above entry point is called with BX=0012h

Format of entry point record:
Offset	Size	Description	(Table 02992)
 00h	DWORD	pointer to protocol support entry point in LSL (see #02993)
 04h	DWORD	pointer to general support entry point in LSL (see #02994)

(Table 02993)
Call protocol support entry point with:
	BX = function number
	    0000h ???
	    0001h ???
	    0002h ???
	    0003h "ScheduleAESEvent"
		ES:SI -&gt; AES ECB to be scheduled (see #02997)
		Return: ES,SI preserved
	    0004h "CancelAESEvent"
		ES:SI -&gt; ECB to be cancelled (see #02997)
		Return: ES,SI preserved
	    0005h "GetIntervalMarker"
		Return: DX:AX = current interval marker in milliseconds
			all other registers preserved
	    0006h "RegisterStack"
		AX = logical board number
		ES:SI -&gt; bound stack info structure (see #03007)
		Return: BX = assigned Stack ID if AX=0000h
	    0007h "DeRegisterStack"
		AX = protocol stack's assigned Stack ID
	    0008h "RegisterDefaultStack"
		AX = logical board number
		ES:SI -&gt; stack info structure (see #03008)
	    0009h "DeRegisterDefaultStack"
		AX = logical board number
	    000Ah "RegisterPrescanStack"
		AX = logical board number
		ES:SI -&gt; stack info structure (see #03008)
	    000Bh "DeRegisterPrescanStack"
		AX = logical board number
	    000Ch "SendPacket"
		ES:SI -&gt; send ECB
		Return: interrupts disabled
	    000Dh ???
	    000Eh ???
	    000Fh ???
	    0010h "GetStackIDFromName"
		ES:SI -&gt; counted NUL-terminated protocol name (max 15 chars)
		Return: BX = Stack ID if AX=0000h
	    0011h "GetPIDFromStackIDBoard"
		AX = Stack ID for protocol
		CX = logical board number
		ES:SI -&gt; 6-byte buffer for protocol ID
	    0012h "GetMLIDControlEntry"
		AX = logical board number
		Return: ES:SI -&gt; MLID control handler (see #02995) if AX=0000h
	    0013h "GetProtocolControlEntry"
		AX = Stack ID or
			FFFEh Prescan stack
			    CX = logical board number
			FFFFh default protocol
			    CX = logical board number
		Return: ES:SI -&gt; protocol stack control entry point if AX=0000h
				  (see #02996)
	    0014h "GetLSLStatistics"
		Return: AX = 0000h (successful)
			ZF set
			ES:SI -&gt; LSL statistics table (see #02999)
	    0015h "BindStack"
		AX = protocol stack's assigned Stack ID
		CX = logical board number
	    0016h "UnbindStack"
		AX = protocol stack's assigned Stack ID
		CX = logical board number
	    0017h "AddProtocolID"
		AX = frame type ID code
		ES:SI -&gt; 6-byte protocol ID
		CX:DI -&gt; counted NUL-terminated short protocol name (max 15 ch)
	    0018h "RelinquishControl"
		Return: after LSL performs any necessary background processing
	    0019h "GetLSLConfiguration"
		Return: AX = 0000h (successful)
			ZF set
			ES:SI -&gt; LSL configuration table (see #02998)
	    001Ah "GetTickMarker"
		Return: AX = number of 55ms ticks since LSL loaded
			BX destroyed
Return: AX = completion code (see #02989)
	ZF set if successful
	SS:SP, DS, BP preserved; most other registers may be destroyed

(Table 02994)
Call general support entry point with:
	BX = function number
	    0000h "Allocate Memory" (obsolete)
		 always returns AX=8008h (BAD_COMMAND)
	    0001h "Free Memory" (obsolete)
		 always returns AX=8008h (BAD_COMMAND)
	    0002h "Realloc Memory" (obsolete)
		 always returns AX=8008h (BAD_COMMAND)
	    0003h "Memory Statistics" (obsolete)
		 always returns AX=8008h (BAD_COMMAND)
	    0004h "Add Memory To Pool" (obsolete)
		 always returns AX=8008h (BAD_COMMAND)
	    0005h "AddGeneralService"
		ES:SI -&gt; General Service Control Block (see #03009)
	    0006h "RemoveGeneralService"
		ES:SI -&gt; General Service Control Block (see #03009)
	    0007h "GetNETcfgPath"
		Return: AX = 0000h (successful)
			DS:DX -&gt; ASCIZ pathname for NET.CFG
	    0008h U ???	 (in LSL 1.10)
		Return: AX = 0000h
			ES:SI -&gt; ??? (a 22-byte data area)
	    000Ah "GetCriticalSectionStatus"
		Return: BX = total outstanding calls to "StartCriticalSection"
	    000Bh "ServiceEvents"
		interrupts disabled
		Return: interrupts disabled
	    0010h "GetStackECB"
		DS:DI -&gt; Lookahead structure (see #03010)
		interrupts disabled
		Return: ES:SI -&gt; ECB if successful (AX=0000h,ZF set)
			interrupts disabled
	    8000h-FFFFh reserved for user general service providers
Return: AX = completion code (see #02989)
	ZF set if successful
	SS:SP, DS, BP preserved

(Table 02995)
Call MLID control handler with:
	AX = logical board number
	BX = function number
	    0000h "GetMLIDConfiguration"
		Return: ES:SI -&gt; MLID's configuration table if successful
				  (see #03002 for format)
	    0001h "GetMLIDStatistics"
		Return: ES:SI -&gt; MLID's statistics table if successful
				  (see #03002 for format)
	    0002h "AddMulticastAddress"
		ES:SI -&gt; 6-byte multicast address to add
	    0003h "DeleteMulticastAddress"
		ES:SI -&gt; 6-byte multicast address to delete
	    0005h "MLIDShutdown"
		CX = type
		    0000h permanent (also deregisters from LSL)
		    other temporary (shutdown hardware only)
	    0006h "MLIDReset" reinitialize board / restart from temp shutdown
	    0007h "Create Connection" (obsolete?)
		???
	    0008h "Delete Connection" (obsolete?)
		???
	    0009h "SetLookAheadSize"
		CX = requested lookahead size (00h-80h)
	    000Ah "PromiscuousChange"
		CX = what to receive promiscuously
		    bit 0: MAC frames
		    bit 1: non-MAC frames
	    000Bh "RegisterReceiveMonitor"
		CX = subfunction
		    0000h disable receive monitoring
		    else  enable receive monitoring
		ES:SI -&gt; monitor receive routine
		ES:DI -&gt; monitor transmit routine
	    000Ch "Driver Poll" (obsolete?)
		???
Return: AX = completion code (see #02989)
	ZF set if successful
Note:	not all boards/MLIDs support function 0010h; see bit 13 in the MLID
	  mode flags field of the MLID's configuration table

(Table 02996)
Call protocol stack control entry point with:
	BX = function number
	    0000h "GetProtocolStackConfiguration"
		Return: ES:SI -&gt; protocol stack's configuration table
				   (see #03001)
	    0001h "GetProtocolStackStatistics"
		Return: ES:SI -&gt; protocol stack's statistics table (see #03000)
	    0002h "BindToMLID"
		CX = board number to bind to
		ES:SI -&gt; implementation-dependant parameter string
	    0003h "UnBindFromMLID"
		CX = board number from which protocol should unbind
		ES:SI -&gt; optional implementation-dependant parameter string
	    0004h "MLIDDeRegistered"
		CX = board number that has de-registered from LSL
Return: AX = status
	    0000h successful
	    else implementation-dependant error codes
	ZF set if successful
	SS:SP, DS, BP preserved

Format of AES ECB:
Offset	Size	Description	(Table 02997)
 00h	DWORD	"AESLink" pointer used by LSL for list management
 04h	DWORD	number of milliseconds to wait
 08h	DWORD	"AESStatus" (is set to 00000000h when AES ESR is invoked)
 0Ch	DWORD	-&gt; function to be invoked when time expires
		ES:SI will point to this structure on entry,
		DS, BP, and SS:SP must be preserved.
SeeAlso: #03011

Format of LSL Configuration Table:
Offset	Size	Description	(Table 02998)
 00h	BYTE	major version of configuration table
 01h	BYTE	minor version of configuration table (decimal, 0-99)
 02h  8 BYTEs	reserved
 0Ah	BYTE	LSL major version (decimal)
 0Bh	BYTE	LSL minor version (decimal, 0-99)
---LSL 1.0x ---
 0Ch 14 BYTEs	reserved
---LSL 1.10+ ---
 0Ch	WORD	maximum number of boards which LSL can handle
 0Eh	WORD	maximum number of protocol IDs which LSL can handle
 10h 12 BYTEs	reserved

Format of LSL Statistics Table:
Offset	Size	Description	(Table 02999)
 00h	BYTE	major version of statistics table format
 01h	BYTE	minor version of statistics table format (decimal, 0-99)
 02h	WORD	"GenericCounters" number of counters in static portion of
		  table
 04h	DWORD	"ValidCountersMask" bit mask indicating which generic
		  counters are actually used.  Bit 31 = TotalTxPackets, bit 30
		  is the next field, etc.
 08h	DWORD	"TotalTxPackets" total SendPacket requests made
 0Ch	DWORD	reserved
 10h	DWORD	reserved
 14h	DWORD	"AESEventsCount" number of completed AES events
 18h	DWORD	"PostponedEvents" number of events postponed due to critical
		  sections inside the MLIDs
 1Ch	DWORD	"CancelAESFailures" number of times CancelAESEvent failed
 20h	DWORD	reserved
 24h	DWORD	reserved
 28h	DWORD	"TotalRxPackets" total number of GetStackECB requests
 2Ch	DWORD	"UnclaimedPackets" total number of packets not consumed by a
		  protocol stack
 30h	WORD	"NumberCustom" number of custom variables that follow
 32h  N DWORDs	custom counters
      N DWORDs	-&gt; CustomCounterStrN (one per custom counter)
	var	length-prepended and NULL terminated string for Counter 0
	...
	var	length-prepended and NULL terminated string for Counter N-1
SeeAlso: #03000,#03006

Format of Protocol Stack Statistics Table:
Offset	Size	Description	(Table 03000)
 00h	BYTE	statistics table major version
 01h	BYTE	statistics table minor version (decimal, 0-99)
 02h	WORD	number of generic counters following
 04h	DWORD	"ValidCountersMask" (bitmask, bit 31 is TotalTxPackets)
 08h	DWORD	TotalTxPackets
 0Ch	DWORD	TotalRxPackets
 10h	DWORD	IgnoredRxPackets
 14h	WORD	number of custom counters
 16h  N DWORDs	custom counters
      N DWORDs	-&gt; CustomCounterStrN (one per custom counter)
	var	length-prepended and NULL terminated string for Counter 0
	...
	var	length-prepended and NULL terminated string for Counter N-1
SeeAlso: #02999,#03006

Format of Protocol Stack Configuration Table:
Offset	Size	Description	(Table 03001)
 00h	BYTE	configuration table major version
 01h	BYTE	configuration table minor version (decimal, 0-99)
 02h	DWORD	-&gt; counted NUL-terminated long descriptive name for protocol
 06h	DWORD	-&gt; counted NUL-terminated short name for protocol (15 chars)
 0Ah	BYTE	protocol stack major version
 0Bh	BYTE	protocol stack minor version (decimal, 0-99)
 0Ch 16 BYTEs	reserved for future use

Format of MLID Configuration Table:
Offset	Size	Description	(Table 03002)
 00h 26 BYTEs	signature 'HardwareDriverMLID	     ' (8 spaces on end)
 1Ah	BYTE	configuration table major version
 1Bh	BYTE	configuration table minor version (decimal, 0-99)
 1Ch  6 BYTEs	node address
 22h	WORD	MLID mode flags (see #03003)
 24h	WORD	board number
 26h	WORD	board instance (if more than one of same board installed)
 28h	WORD	maximum packet size
 2Ah	WORD	BestDataSize
 2Ch	WORD	WorstDataSize
 2Eh	DWORD	-&gt; counted NUL-terminated long name for NIC
 32h	DWORD	-&gt; counted NUL-terminated short name for NIC (8 chars max)
 36h	DWORD	-&gt; counted NUL-terminated Frame and Media type
 3Ah	WORD	reserved (0000h)
 3Ch	WORD	frame type ID
 3Eh	WORD	TransportTime (milliseconds)
 40h	DWORD	-&gt; SourceRouteHandler for TokenRing. (Used by ROUTE.COM)
 44h	WORD	lookahead size
 46h	WORD	line speed (Mbps if high bit clear, else Kbps)
 48h	WORD	QueueDepth
 4Ah  6 BYTEs	reserved (0)
 50h	BYTE	driver major version
 51h	BYTE	driver minor version (decimal, 0-99)
 52h	WORD	bus/multicast flags (see #03004)
 54h	WORD	send retries
 56h	DWORD	ConfigTableLink
 5Ah	WORD	MLID sharing flags (see #03005)
 5Ch	WORD	slot number
 5Eh	WORD	I/O address 1
 60h	WORD	I/O range 1
 62h	WORD	I/O address 2
 64h	WORD	I/O range 2
 66h	DWORD	memory address 1
 6Ah	WORD	memory size 1
 6Ch	DWORD	memory address 2
 70h	WORD	memory size 2
 72h	BYTE	interrupt line 1
 73h	BYTE	interrupt line 2
 74h	BYTE	DMA line 1
 75h	BYTE	DMA line 2

Bitfields for MLID mode flags:
Bit(s)	Description	(Table 03003)
 15	MLID supports Octet Reversal
 14	node address is non-canonical
 13	promiscuous mode is supported
 12-8	reserved
 7	LDataSize field in LookAhead structure supported
 6	raw send supported
 5	MLID needs to be polled by LSL
 4	reserved (0)
 3	multicasting is supported
 2	not currently used by DOS ODI, set to 0.
 1	network card uses DMA.
 0	RealDriverBit, always set to 1.

Bitfields for bus/multicast flags:
Bit(s)	Description	(Table 03004)
 10-9	specialized multicast support
	00 = Group addressing is default for medium
	01 = Invalid
	10 = Filter group address in MLID.
	11 = Adapter filters group address.
 2	supports Micro Channel cards
 1	supports ISA cards
 0	supports EISA cards

Bitfields for MLID sharing flags:
Bit(s)	Description	(Table 03005)
 8	NIC can share DMA2
 7	NIC can share DMA1
 6	NIC can share IRQ2
 5	NIC can share IRQ1
 4	NIC can share Memory2
 3	NIC can share Memory1
 2	NIC can share IO2
 1	NIC can share IO1
 0	MLID is currently shut down

Format of MLID Statistics Table:
Offset	Size	Description	(Table 03006)
 00h	BYTE	driver statistics table major version
 01h	BYTE	driver statistics table minor version (decimal, 0-99)
 02h	WORD	number of generic counters (typically 13)
 04h	DWORD	"ValidCountersMask" (bit mask, bit 31 is TotalTxCount)
 08h	DWORD	TotalTxCount
 0Ch	DWORD	TotalRxCount
 10h	DWORD	NoECBAvailableCount
 14h	DWORD	TxTooBigCount
 18h	DWORD	TxTooSmallCount
 1Ch	DWORD	RxOverflowCount
 20h	DWORD	RxTooBigCount
 24h	DWORD	RxTooSmallCount
 28h	DWORD	TxMiscCount
 2Ch	DWORD	RxMiscCount
 30h	DWORD	TxRetryCount
 34h	DWORD	RxChecksumErrorCount
 38h	DWORD	RxMismatchCount
 3Ch	WORD	number of custom counters
 3Eh  N DWORDs	custom counters
      N DWORDs	-&gt; CustomCounterStrN (one per custom counter)
	var	length-prepended and NULL terminated string for Counter 0
	...
	var	length-prepended and NULL terminated string for Counter N-1
SeeAlso: #02999,#03000

Format of bound stack info structure:
Offset	Size	Description	(Table 03007)
 00h	DWORD	-&gt; protocol stack's short name (counted, NUL-terminated)
 04h	DWORD	-&gt; receive handler
 08h	DWORD	-&gt; control handler

Format of stack info structure:
Offset	Size	Description	(Table 03008)
 00h	DWORD	-&gt; receive handler
 04h	DWORD	-&gt; control handler

Format of General Service Control Block:
Offset	Size	Description	(Table 03009)
 00h	DWORD	-&gt; next GSCB (maintained internally by LSL)
 04h	DWORD	-&gt; entry point for general service handler
 08h	WORD	command code for this general service (8000h-FFFFh)
Note:	the control block must not be altered or deallocated until the general
	  service is removed

Format of Lookahead structure:
Offset	Size	Description	(Table 03010)
 00h	DWORD	-&gt; Media header
 04h	DWORD	-&gt; lookahead buffer
 08h	WORD	length of lookahead buffer
 0Ah  6 BYTEs	protocol ID
 10h	WORD	logical board number
 12h	WORD	lookahead size

Format of ODI ECB:
Offset	Size	Description	(Table 03011)
 00h	DWORD	link to next ECB
 04h	DWORD	link to previous ECB
 08h	WORD	general status
		0000h received successfully
		8006h packet overflow
		8007h reception aborted (data not valid)
 0Ah	DWORD	-&gt; event service routine or RETF (never 0000h:0000h)(see #03012)
 0Eh	WORD	protocol stack identifier
 10h  6 BYTEs	protocol ID (sending only)
 16h	WORD	MLID board number (sending only)
 18h  6 BYTEs	MAC destination address
 1Eh  4 BYTEs	driver workspace
 22h  8 BYTEs	protocol workspace
 2Ah	WORD	total length of sent buffer
 2Ch	WORD	fragment count
 2Eh  2 WORDs	segment,offset of first fragment buffer
 32h	WORD	length of first fragment buffer
	...
SeeAlso: #02997

(Table 03012)
Values event service routine is called with:
	ES:SI -&gt; associated ODI ECB (see #03011)
	interrupts disabled
Return: DS,BP,SS,SP preserved
	interrupt disabled
Notes:	the service routine may invoke any IPX/ODI function except CloseSocket
	it is safe to send a packet and wait for completion if enough stack
	  space is available

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_0" name="2FC000_0"><b>2FC000</b></a> - INT 2F - Novell NetWare Event Service Layer (NESL) 1.0 - INSTALLATION CHECK<br />
<pre>
INT 2F - Novell NetWare Event Service Layer (NESL) 1.0 - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	    DX:BX -&gt; FAR entry point (see #03013,#03014,#03015,#03016,#03017,#03018)
	    ES:SI -&gt; signature string "NESL_EVENTS"
Program: NESL is a generic interface for event handling in ODI drivers and
	  other NetWare-oriented modules.  Primarily intended to support
	  power management and "hot swapping" of PCMCIA cards, but it is not
	  limited to this.
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"Link Support Layer",AX=C000h"NETWARN"

(Table 03013)
Call NESL function GetNESLConfigPointer with:
	BX = 0000h
Return: AX = completion code (0000h,8008h) (see #03019)
	ES:SI -&gt; NESL configuration table if successful (see #03020)
	BP,DS,STACK preserved
Desc:	Obtain a pointer to the NESL Configuration Table
SeeAlso: #03014,#03017

(Table 03014)
Call NESL function RegisterEventProducer with:
	BX = 0001h
	ES:SI -&gt; Producer Event Control Block (PECB) (see #03021)
Return: AX = completion code (0000h, 8005h, 8008h) (see #03019)
	ES:SI -&gt; still points to PECB
	BP,DS,STACK preserved
Desc:	Allows a module to register as a producer of a given event class
Note:	PECB_ClassName and PECB_Flags must be filled in on entry
SeeAlso: #02870,#03015,#03016,#03017

(Table 03015)
Call NESL function DeRegisterEventProducer with:
	BX = 0002h
	ES:SI -&gt; PECB previously passed to RegisterEventProducer (see #03021)
Return: AX = completion code (0000h, 8002h, 8008h) (see #03019)
	ES:SI -&gt; still points to PECB
	BP,DS,STACK preserved
Desc:	Allows a module to de-register as a producer of a given event class
SeeAlso: #03014,#03018

(Table 03016)
Call NESL function EventNotification with:
	BX = 0003h
	ES:SI -&gt; PECB previously registered (see #03021)
Return: AX = completion code (0h, 8005h, 8008h) (see #03019)
	ES:SI -&gt; still points to PECB
	BP,DS,STACK preserved
Desc:	Allows a module to signal that an event has just occurred in a given
	  event class.
Notes:	Once called, NESL will generate corresponding callouts for this
	  event, as described in Table #03023.
	on entry, the PECB_DataPtr must point at an Event Parameter Block (EPB)
	  (see #03024) filled in to match the desired event
SeeAlso: #03014

(Table 03017)
Call NESL function RegisterEventConsumer with:
	BX = 0004h
	ES:SI -&gt; Consumer Event Control Block (CECB) (see #03022)
Return: AX = completion code (0h, 8005h, 8008h) (see #03019)
	ES:SI -&gt; still points to CECB
	BP,DS,STACK preserved
Desc:	Allows a module to register as a consumer of a given event class
Note:	on entry, the CECB_ClassName, CECB_NotifProc and CECB_OSILevel must be
	  filled in.
SeeAlso: #03014,#03018

(Table 03018)
Call NESL function DeRegisterEventConsumer with:
	BX = 0005h
	ES:SI -&gt; CECB previously passed to RegisterEventConsumer (see #03022)
Return: AX = completion code (0h, 8002h, 8008h) (see #03019)
	ES:SI -&gt; still points to CECB
	BP,DS,STACK preserved
Desc:	Allows a module to de-register as a consumer of a given event class
SeeAlso: #03015,#03017

(Table 03019)
Values for NESL Error code:
 0000h	Successful
 8002h	Bad Parameter
 8005h	Fail
 8008h	Bad Command

Format of NESL Configuration Table:
Offset	Size	Description	(Table 03020)
 00h	WORD	NESL_Cfg_MajVer	 Major Version of this table (=1)
 02h	WORD	NESL_Cfg_MinVer	 Minor Version of this table (=0)
 04h	DWORD	NESL_Cfg_ModLName   -&gt; ASCIZ long name of NESL module
		(typically -&gt; "NetWare Event Service Layer for 16-Bit DOS")
 08h	DWORD	NESL_Cfg_ModSName   -&gt; ASCIZ short name of NESL module
		(typically -&gt; "NESL")
 0Ch	WORD	NESL_Cfg_ModMajVer  Major Version of NESL itself (=1)
 0Eh	WORD	NESL_Cfg_ModMinVer  Minor Version of NESL itself (=0)

Format of NESL Producer Event Control Block (PECB):
Offset	Size	Description	(Table 03021)
 00h	WORD	PECB_MajVer  Major Version of this structure (=1)
 02h	WORD	PECB_MinVer  Minor Version of this structure (=0)
 04h	DWORD	PECB_NextProducer   -&gt; next PECB.  NULL if last.
 08h	DWORD	PECB_ClassName	    -&gt; ASCIZ string identifying event
					  class (see #03025)
 0Ch	DWORD	PECB_ConsumerList   -&gt; list of consumers for this event class
 10h	DWORD	PECB_DataPtr	    -&gt; points to additional data during events
 14h	DWORD	PECB_Flags
		Bit 0	=0  consumers should be called "top down" for this
			    event class.  (OSI level 7 down to OSI level 1)
			=1  consumers should be called "bottom up"
		Bits 1-31   Reserved =0
 18h  8 BYTEs	PECB_Reserved (all zeros)
Note:	Although the event producer provides the memory for the PECB, the
	  NESL module controls this memory until the event class is
	  de-registered.
	While owned by NESL, this structure should be treated as read-only,
	  except for the PECB_DataPtr field.

Format of NESL Consumer Event Control Block (CECB):
Offset	Size	Description	(Table 03022)
 00h	WORD	CECB_MajVer  Major Version of this structure (=1)
 02h	WORD	CECB_MinVer  Minor Version of this structure (=0)
 04h	DWORD	CECB_NextConsumer   -&gt; next CECB.  NULL if last.
 08h	DWORD	CECB_ClassName	    -&gt; ASCIZ string identifying event
					  class (see #03025)
 0Ch	DWORD	CECB_NotifProc	    -&gt; FAR CALL event handler (see #03023)
 10h	WORD	CECB_OSILevel
		Bits 4-7 = OSI Layer of this module (1 through 7)
		Bits 0-3 = relative ordering with other modules on same layer
 13h 14 BYTEs	CECB_Reserved (all zeros)
Note:	Although the event consumer provides the memory for the CECB, the
	  NESL module controls this memory until the consumer is de-registered.
	While owned by NESL, this structure should be treated as read-only,

(Table 03023)
Values NESL Consumer Notification Procedure is called with:
	ES:SI -&gt; Event Parameter Block (EPB) (see #03024)
Return: AX = completion code (0000h, 8005h) (see #03019)
	ES:SI -&gt; still points to EPB
Desc:	Called by NESL to notify the consumer when an event has occurred in
	  an event class for which it has registered.
SeeAlso: #03022

Format of NESL Event Parameter Block (EPB):
Offset	Size	Description	(Table 03024)
 00h	WORD	EPB_MajVer  Major Version of this structure (=1)
 02h	WORD	EPB_MinVer  Minor Version of this structure (=0)
 04h	DWORD	EPB_ClassName  -&gt; ASCIZ string identifying event class
				  (see #03025)
 08h	DWORD	EPB_EventName  -&gt; ASCIZ string identifying event within
				  class (see #03026)
 0Ch	DWORD	EPB_ModuleName -&gt; ASCIZ string identifying module
				  producing event
 10h	DWORD	EPB_DataPtr0   -&gt; event-defined data or NULL if not used
 14h	DWORD	EPB_DataPtr1   -&gt; event-defined data or NULL if not used
 18h  8 BYTEs	EPB_Reserved (all zeros)

(Table 03025)
Values for NESL Event Class Names:
 Event Class		Description
 -------------------	-----------------------------------------
 Service Suspend	Suspension of a service.  Called top-down.
 Service Resume		Resumption/availability of a service. Called bottom-up.
 Service/Status Change	Change in status or level of service.  Called top-down.
 Suspend Request	Request to suspend a service.  Called bottom-up.
Note:	Contact Novell Labs to register new event classes.

(Table 03026)
Values for NESL Event Names:
 Event Name			Class		    Description
 --------------------------	-------------	    ---------------------------
 MLID Cable Disconnect		Service Suspend	    Cable disconnected from NIC
 MLID Card Removal		Service Suspend	    PCMCIA card removed
 MLID Hardware Failure		Service Suspend	    Serious hardware
							  failure in NIC
 MLID Not In Range		Service Suspend	    Wireless access point
							  is out of range
 MLID Shutdown			Service Suspend	    MLID was shut down
 MLID Media Access Denied	Service Suspend	    Access to physical
							  medium unsuccessful
 MLID Cable Reconnect		Service Resume	    Cable re-connected to NIC
 MLID Card Insertion Complete	Service Resume	    PCMCIA card inserted
 MLID In Range			Service Resume	    Wireless access point
							  in range
 MLID Reset			Service Resume	    MLID was just reset
 MLID Access Point Change	Serv/Status Change  Station has moved to
							  new access point
 MLID Speed Change		Serv/Status Change  Change in communic. speed
Note:	Contact Novell Labs to register new event names.
	For all predefined events above, EPB_DataPtr0 (see #03024) points
	  to the MLID Configuration table (see AX=C000h"ODI") for the
	  affected MLID.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_1" name="2FC000_1"><b>2FC000</b></a> - INT 2F - Novell NetWare Connect NETWARN - INSTALLATION CHECK<br />
<pre>
INT 2F - Novell NetWare Connect NETWARN - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	    SI = segment of resident portion
Program: NETWARN is a utility supplied with NetWare Connect to warn a
	  remote dialup user when programs are about to be loaded slowly over
	  the modem link.
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
Note:	on return, verify that it is NETWARN responding by examining signature
	  at in NETWARN's data table in the resident segment (see #03027)
SeeAlso: AX=C000h"ODI",AX=C000h"NESL"

Format of NETWARN Configuration structure:
Offset	Size	Description	(Table 03027)
 103h 7 BYTEs	signature string "NETWARN"
 10Ah	BYTE	major version in ASCII (="1")
 10Bh	BYTE	minor version in ASCII (="0")
 10Ch	DWORD	minimum size of EXE cared about in bytes (/S=xxxx)
 110h	WORD	same value in kilobytes (see #03028 [bit 4])
 112h	BYTE	multiplex code (AH value) actually being used
 113h	WORD	options (see #03028)
 115h	DWORD	INT 21h vector before NETWARN loaded
 119h	DWORD	INT 2Fh vector before NETWARN loaded
 11Dh 16 BYTEs	ASCIIZ local name of last device which was checked
 12Dh 128 BYTEs ASCIIZ remote name of last device which was checked
Note:	the specified offsets are from the start of the resident segment

Bitfields for NETWARN options:
Bit(s)	Description	(Table 03028)
 0	??? (=0)
 1	/U (Unload) selected (never in resident)
 2	/E (Enabled) Will trap & check EXEC's
 3	/D (Disabled) No EXEC checking done
 4	/S (Size) was set (see #03027 [offsets 010Ch and 0110h])
 5	/P (Path shown)
 6	/H or /? (Help) (never in resident)
SeeAlso: #03027

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_2" name="2FC000_2"><b>2FC000</b></a> - INT 2F - FN32 32 character filename utilities - INSTALLATION CHECK<br />
<pre>
INT 2F - FN32 32 character filename utilities - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	   ES:DI -&gt; signature string "FN32 32CHAR TSR"
Program: FN32 is a TSR which supports 32 character filenames under PC/MS-DOS
Note:	the TSR intercepts INT 21 calls and performs filename substitution by
	  managing dictionary files in each directory which contains long
	  filenames

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_3" name="2FC000_3"><b>2FC000</b></a> - INT 2F - QMR - INSTALLATION CHECK<br />
<pre>
INT 2F - QMR - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	    ES:DI -&gt; signature string "QMR1!"
Program: QMR (Cove Software, Quick Mouse Reset) monitors the mouse
	  service interrupt (int 33h) and substitutes a fast software
	  reset (mouse fn 21h) for the slow hardware reset (mouse fn 0).
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C001h"QMR",AX=C002h"QMR",AX=C003h"QMR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_4" name="2FC000_4"><b>2FC000</b></a> - INT 2F - VGAsave v1.93 - INSTALLATION CHECK<br />
<pre>
INT 2F - VGAsave v1.93 - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	    BX = segment of resident code
Program: VGAsave is a freeware VGA-specific, mouse-aware screenblanker by Bill
	  Javurek
Range:	AH=C0h to AH=FFh, selected by scanning for a free multiplex number
Note:	the transient portion of VGAsave compares the first 38 bytes of the
	  resident code (addressed through BX) against its own copy of the
	  resident code to complete the installation check
SeeAlso: INT 14/AX=AA01h,INT 2F/AH=93h
Index:	screen saver;VGAsave

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_5" name="2FC000_5"><b>2FC000</b></a> - INT 2F - AD-DOS - INSTALLATION CHECK<br />
<pre>
INT 2F - AD-DOS - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	    BX = 4144h ('AD')
	    CX = 2D44h ('-D')
	    DX = 4F53h ('OS')
Program: AD-DOS is the DOS version of the After Dark screen blanker for
	  MS Windows
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C001h"AD-DOS",AX=C003h"AD-DOS",AX=C005h"AD-DOS",AX=C007h"AD-DOS"
SeeAlso: AX=C009h"AD-DOS",AX=C020h"AD-DOS",INT 14/AX=AA01h
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_6" name="2FC000_6"><b>2FC000</b></a> - INT 2F U - WANG_ER.COM - INSTALLATION CHECK<br />
<pre>
INT 2F U - WANG_ER.COM - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	    ES = segment of resident code
Program: WANG_ER is a TSR from Compaq which permits Compaq systems equipped
	  with 3-mode floppy drives to read Wang document diskettes
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
Note:	The installation check is completed by comparing the resident code
	  with the copy in the transient program

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_7" name="2FC000_7"><b>2FC000</b></a> - INT 2F O - ASPIHOOK.SYS - INSTALLATION CHECK<br />
<pre>
INT 2F O - ASPIHOOK.SYS - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if multiplex number in use
	    ES:DI -&gt; ASCIZ signature "ASPIHOOK" if ASPIHOOK.SYS installed
Program: ASPIHOOK is a device driver for monitoring SCSI activity through an
	  ASPI host manager; it is part of the Personal Measure system
	  activity monitor from Spirit of Performance, Inc.
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"PMEASURE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_8" name="2FC000_8"><b>2FC000</b></a> - INT 2F - PMEASURE.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F - PMEASURE.EXE - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if multiplex number in use
	    ES:DI -&gt; ASCIZ signature "PMEASURE.EXE" if PMEASURE.EXE installed
Program: PMEASURE.EXE is a TSR for monitoring system hardware activity which
	  is part of the Personal Measure system activity monitor from Spirit
	  of Performance, Inc.
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
Note:	If a Personal Measure Hook Module, such as ASPIHOOK.SYS, is already
	  installed, PMEASURE.EXE uses the next highest free multiplex number.
SeeAlso: AX=C000h"ASPIHOOK",AX=C000h"PERSONAL MEASURE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_9" name="2FC000_9"><b>2FC000</b></a> - INT 2F - PERSONAL MEASURE - HOOK MODULE INSTALLATION CHECK<br />
<pre>
INT 2F - PERSONAL MEASURE - HOOK MODULE INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	ES:DI -&gt; signature string "PMEASUREHOOK"
	AX = C000 if not installed, per mux id conventions
	DH = major release number (binary)
	DL = minor release number (binary)
Program: The Personal Measure system activity monitor from Spirit of
	  Performance, Inc. uses an extensible series of modules to hook
	  into various operating system interfaces and monitor system calls.
	  Current hook modules are ASPIHOOK.SYS for ASPI device activity
	  and CDRHOOK.SYS for non-ASPI CD-ROM activity.	 All hook modules
	  share the same mux id.
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"PMEASURE.EXE",AX=C001h"PERSONAL MEASURE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_10" name="2FC000_10"><b>2FC000</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	    SI = signature value 20D6h
	    DI = signature value 8761h
	    ES:BX -&gt; configuration table (see #03029)
	    CX = ??? (0300h)
	    DX = ??? (0020h)
Program: PCACHE is the resident print spooler portion of PrintCache by
	  LaserTools; it may use either memory or disk space to spool output
Range:	AH=C0h to AH=FFh, selected by commandline switch
SeeAlso: AX=0100h/SI=20D6h,AX=C001h"PCACHE"

Format of PrintCache configuration table:
Offset	Size	Description	(Table 03029)
 00h 26 BYTEs	ASCIZ signature string "TORQ Configuration Table: "
 1Ah  2 BYTEs	???
 1Ch	DWORD	-&gt; data table (see #03030)
 20h  4 BYTEs	ASCIZ version string ("3.1" for v3.1)
 24h  5 BYTEs	???
 29h 12 BYTEs	ASCIZ version date string ("Aug 31 1993" for v3.1)
 35h	WORD	buffered port type (01h = LPT, 02h = COM)
 37h	WORD	buffered port BIOS port number
 39h  5 BYTEs	ASCIZ buffered port name ("LPTn" or "COMn")
 3Eh	WORD	physical port type (01h = LPT, 02h = COM)
 40h	WORD	physical port BIOS port number
 42h  5 BYTEs	ASCIZ physical port name ("LPTn" or "COMn")
 47h	BYTE	port driver IRQ
 48h 21 BYTEs	???
 5Dh	WORD	buffer size in K
 5Fh 27 BYTEs	???
 7Ah	BYTE	popup hotkey shift states (see #00582 at INT 16/AH=02h)
 7Bh	BYTE	popup hotkey scan code (see #00006 at INT 09"IRQ1")
 7Ch  4 BYTEs	???
 80h 20 BYTEs	ASCIZ printer type name
	???

Format of PrintCache data table:
Offset	Size	Description	(Table 03030)
 00h  2 BYTEs	???
 02h	DWORD	-&gt; ??? entry point
	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_11" name="2FC000_11"><b>2FC000</b></a> - INT 2F - Frank Kintrup TSR Utilities - INSTALLATION CHECK<br />
<pre>
INT 2F - Frank Kintrup TSR Utilities - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	    BX = program ID (see #03031)
	    CX = 464Bh (signature "FK")
	    DX = revision number (DH = major, DL = minor)
	    ES = resident segment of TSR
Range:	AH=C0h to AH=FFh, selected by searching for a free multiplex number
SeeAlso: AX=C001h"Kintrup",AX=C002h"Kintrup"

(Table 03031)
Values for Frank Kintrup TSR program ID:
 4153h	"AS"	ASCII.COM	ASCII table with paste function
 434Ch	"CL"	CLOCK.COM	clock with date/time display and alarm
 5043h	"PC"	PCALC.COM	programmer's calculator with paste function
 5343h	"SC"	SCRSAVE.COM	screen saver with mouse support and hotkey
 5544h	"UD"	UNDEL.COM	undelete program like SMARTCAN or DPROTECT

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_12" name="2FC000_12"><b>2FC000</b></a> - INT 2F U - HP 100LX/200LX - PUSHKEYS - INSTALLATION CHECK<br />
<pre>
INT 2F U - HP 100LX/200LX - PUSHKEYS - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if possibly installed
Range:	AH=C0h to AH=FFh, selected by scanning for signature with AL=AEh
SeeAlso: AX=C001h"HP 100LX",AX=C0AEh"HP 100LX",AX=C0AFh"HP 100LX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_13" name="2FC000_13"><b>2FC000</b></a> - INT 2F - DIMWIT - INSTALLATION CHECK<br />
<pre>
INT 2F - DIMWIT - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if installed
	    ES:DI -&gt; signature string "DIMDOS" or "DIMWIN"
Program: DIMWIT is a freeware Windows-aware screen blanker by Larry Board
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"AD-DOS",AX=C001h"DIMWIT"
Index:	screen saver;DIMWIT

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000BX444B" name="2FC000BX444B"><b>2FC000BX444B</b></a> - INT 2F - METZ XpressFax Hardware TSR (CLASS2) - INSTALLATION CHECK<br />
<pre>
INT 2F - METZ XpressFax Hardware TSR (CLASS2) - INSTALLATION CHECK
	AX = C000h
	BX = 444Bh ('DK')
	CX = 4A4Eh ('AN')
Return: AL = status
	    00h not installed, OK to install
	    FFh installed
		BX = 646Bh ('dk')
		CX = 6A6Eh ('an')
Range:	AH=C0h to AH=FFh, selected automatically
SeeAlso: AH=C0h"METZ"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_14" name="2FC000_14"><b>2FC000</b></a> - INT 2F U - TSENGP.COM - INSTALLATION CHECK<br />
<pre>
INT 2F U - TSENGP.COM - INSTALLATION CHECK
	AX = C000h
Return: AL = status
	    00h not installed, OK to install
	    FFh installed
		DS = segment of resident code
Program: TSENGP.COM is a TSR supplied by Compaq to fix an incompatibility
	  between some applications and Tseng ET4000-based video adapters
Range:	AH=C0h to AH=FFh, selected automatically
Note:	the installation check is completed by comparing the first eleven
	  bytes at DS:005Fh against the TSR's code (80h FCh 06h 74h 0Ah
	  80h FCh 07h 74h 05h EAh)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC000_15" name="2FC000_15"><b>2FC000</b></a> - INT 2F U - LapLink RemoteAccess (LLRA) - INSTALLATION CHECK<br />
<pre>
INT 2F U - LapLink RemoteAccess (LLRA) - INSTALLATION CHECK
	AX = C000h
Return: AL = FFh if one of the components is installed
	CX:BX -&gt; signature within LLRA component:
	    "TSI_LapLinkCore" for LLRA1.EXE
	    "TSI_Blackbird"   for LLRA2.EXE
	    "TSI_Redirector"  for LLRA3.EXE
	    "TSI_Compression" for LLRA4.EXE
	DL = major version number
	DH = minor version number
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
Note:	LapLink components are installed in the order listed above, but not
	  necessarily all four; each gets its own multiplex number (default
	  C0h-C3h)
SeeAlso: AX=C002h"LapLink",AX=C205h"LapLink",AX=C2F0h"LapLink"
SeeAlso: AX=C2F1h"LapLink",AX=C301h"LapLink",AX=C3F0h"LapLink"
SeeAlso: AX=C3F1h"LapLink"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC001" name="2FC001"><b>2FC001</b></a> - INT 2F - QMR - REQUEST HARDWARE RESET<br />
<pre>
INT 2F - QMR - REQUEST HARDWARE RESET
	AX = C001h
Return: ES = QMR code segment
	AL destroyed
Desc:	this function is used to force a full mouse reset when QMR is installed
SeeAlso: AX=C000h"QMR",AX=C002h"QMR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC001_0" name="2FC001_0"><b>2FC001</b></a> - INT 2F - DIMWIT - GET CONFIGURATION DATA<br />
<pre>
INT 2F - DIMWIT - GET CONFIGURATION DATA
	AX = C001h
Return: ES:DI -&gt; TSR configuration data (see #03032)
Program: DIMWIT is a freeware Windows-aware screen blanker by Larry Board
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"DIMWIT",AX=C001h"AD-DOS"
Index:	screen saver;DIMWIT

Format of DIMWIT TSR configuration data:
Offset	Size	Description	(Table 03032)
 00h	WORD	blanking delay in clock ticks
 02h	BYTE	instant-blanking hotkey scan code (see #00006)
		Ctrl and Alt must also be pressed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC001ES0000" name="2FC001ES0000"><b>2FC001ES0000</b></a> - INT 2F - AD-DOS - GET RESIDENT CODE SEGMENT<br />
<pre>
INT 2F - AD-DOS - GET RESIDENT CODE SEGMENT
	AX = C001h
	ES = 0000h
Return: AL = 00h if successful
	    ES = AD-DOS TSR Code Segment
SeeAlso: AX=C000h"AD-DOS",AX=C001h"DIMWIT"
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC001_1" name="2FC001_1"><b>2FC001</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ENTRY POINTS<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ENTRY POINTS
	AX = C001h
Return: AL = FFh if installed
	    ES:BX -&gt; ???
	    ES:DX -&gt; ???
	    ES:SI -&gt; ???
	    ES:DI -&gt; ??? (equivalent to AX=C002h)
SeeAlso: AX=C000h"PCACHE",AX=C002h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC001_2" name="2FC001_2"><b>2FC001</b></a> - INT 2F - Frank Kintrup TSR Utilities - CLOCK - DISABLE DISPLAY UPDATE<br />
<pre>
INT 2F - Frank Kintrup TSR Utilities - CLOCK - DISABLE DISPLAY UPDATE
	AX = C001h
Range:	AH=C0h to AH=FFh, selected by searching for a free multiplex number
SeeAlso: AX=C000h"Kintrup",AX=C002h"Kintrup"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC001CX03FB" name="2FC001CX03FB"><b>2FC001CX03FB</b></a> - INT 2F U - HP 100LX/200LX - PUSHKEYS - INTERNAL - UNINSTALL<br />
<pre>
INT 2F U - HP 100LX/200LX - PUSHKEYS - INTERNAL - UNINSTALL
	AX = C001h
	CX = 03FBh return address to continue uninstall if possible
Return: program uninstalled
Range:	AH=C0h to AH=FFh, selected by scanning for signature with AL=AEh
SeeAlso: AX=C000h"HP 100LX",AX=C0AEh"HP 100LX",AX=C0AFh"HP 100LX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC001_3" name="2FC001_3"><b>2FC001</b></a> - INT 2F - PERSONAL MEASURE - PASS PARAMETERS TO HOOK MODULE(S)<br />
<pre>
INT 2F - PERSONAL MEASURE - PASS PARAMETERS TO HOOK MODULE(S)
	AX = C001h
	DX = segment of PMEASURE.EXE or 0000h
	BX = offset in PMEASURE.EXE or 0000h
	CX = offset in PMEASURE.EXE or 0000h
Return: None
Program: PMEASURE.EXE is a TSR for monitoring system hardware activity which
	  is part of the Personal Measure system activity monitor from Spirit
	  of Performance, Inc.	PMEASURE uses this call to inform its hook
	  modules whether or not it is running and to pass information about
	  shared data and procedures.
Warning: This information documents a function that is private to Personal
	  Measure and is provided as information only.	It should NOT be called
	  by any software other than Personal Measure.
SeeAlso: AX=C000h"PERSONAL MEASURE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC002" name="2FC002"><b>2FC002</b></a> - INT 2F - AD-DOS - CHECK FOR NEW INPUT<br />
<pre>
INT 2F - AD-DOS - CHECK FOR NEW INPUT
	AX = C002h
Return: AL = 00h if successful
	    BX = status
		0000h no input since last check
		0001h new input available
Note:	this call also resets the new-input flag
SeeAlso: AX=C000h"AD-DOS",AX=C004h
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC002_0" name="2FC002_0"><b>2FC002</b></a> - INT 2F - QMR - DISABLE QMR<br />
<pre>
INT 2F - QMR - DISABLE QMR
	AX = C002h
Return: ES = QMR code segment
	AL destroyed
Desc:	this call temporarily disables QMR
SeeAlso: AX=C000h"QMR",AX=C003h"QMR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC002_1" name="2FC002_1"><b>2FC002</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET BUFFER SIZE<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - GET BUFFER SIZE
	AX = C002h
Return: AX = ??? in K
	BX = size of print buffer in K
Program: PCACHE is the resident print spooler portion of PrintCache by
	  LaserTools; it may use either memory or disk space to spool output
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC002_2" name="2FC002_2"><b>2FC002</b></a> - INT 2F - Frank Kintrup TSR Utilities - CLOCK - ENABLE DISPLAY UPDATE<br />
<pre>
INT 2F - Frank Kintrup TSR Utilities - CLOCK - ENABLE DISPLAY UPDATE
	AX = C002h
Range:	AH=C0h to AH=FFh, selected by searching for a free multiplex number
SeeAlso: AX=C000h"Kintrup",AX=C002h"Kintrup"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC002_3" name="2FC002_3"><b>2FC002</b></a> - INT 2F U - LapLink RemoteAccess (LLRA) - Core - ???<br />
<pre>
INT 2F U - LapLink RemoteAccess (LLRA) - Core - ???
	AX = C002h
	details not yet available
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"LapLink",AX=C002h"LapLink",AX=C2F0h"LapLink"
SeeAlso: AX=C2F1h"LapLink",AX=C301h"LapLink"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC003" name="2FC003"><b>2FC003</b></a> - INT 2F - AD-DOS - SET MINUTES TO WAIT<br />
<pre>
INT 2F - AD-DOS - SET MINUTES TO WAIT
	AX = C003h
	BX = minutes to wait before blanking screen
Return: AL = 00h if successful
Program: AD-DOS is the DOS version of the After Dark screen blanker for
	  MS Windows
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
Note:	this call also resets the delay timer
SeeAlso: AX=C000h"AD-DOS",AX=C004h
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC003_0" name="2FC003_0"><b>2FC003</b></a> - INT 2F - QMR - ENABLE QMR<br />
<pre>
INT 2F - QMR - ENABLE QMR
	AX = C003h
Return: ES = QMR code segment
	AL destroyed
Desc:	this call enables QMR after it has been disabled
SeeAlso: AX=C000h"QMR",AX=C002h"QMR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC003_1" name="2FC003_1"><b>2FC003</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ??? FLAG<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ??? FLAG
	AX = C003h
Return: BX destroyed
SeeAlso: AX=C004h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC004" name="2FC004"><b>2FC004</b></a> - INT 2F - AD-DOS - GET MINUTES TO WAIT<br />
<pre>
INT 2F - AD-DOS - GET MINUTES TO WAIT
	AX = C004h
Return: AL = 00h if successful
	    BX = minutes to wait before blanking screen
SeeAlso: AX=C000h"AD-DOS",AX=C003h"AD-DOS"
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC004_0" name="2FC004_0"><b>2FC004</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - CLEAR ??? FLAG<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - CLEAR ??? FLAG
	AX = C004h
Return: BX destroyed
SeeAlso: AX=C003h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC005" name="2FC005"><b>2FC005</b></a> - INT 2F - AD-DOS - SET BLANKER STATUS<br />
<pre>
INT 2F - AD-DOS - SET BLANKER STATUS
	AX = C005h
	BX = new state (0000h inactive, 0001h active) (default 0001h)
Return: AL = 00h if successful
SeeAlso: AX=C006h"AD-DOS"
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC005_0" name="2FC005_0"><b>2FC005</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - ???
	AX = C005h
	???
Return: BX destroyed
	???
Program: PCACHE is the resident print spooler portion of PrintCache by
	  LaserTools; it may use either memory or disk space to spool output
Range:	AH=C0h to AH=FFh, selected by commandline switch
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC006" name="2FC006"><b>2FC006</b></a> - INT 2F - AD-DOS - GET BLANKER STATUS<br />
<pre>
INT 2F - AD-DOS - GET BLANKER STATUS
	AX = C006h
Return: AL = 00h if successful
	    BX = current state of screen blanker (0000h inactive, 0001h active)
Program: AD-DOS is the DOS version of the After Dark screen blanker for
	  MS Windows
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"AD-DOS",AX=C005h"AD-DOS"
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC006_0" name="2FC006_0"><b>2FC006</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - ???
	AX = C006h
	???
Return: BX destroyed
	???
Note:	this function appears to be identical to AX=C007h
SeeAlso: AX=C000h"PCACHE",AX=C007h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC007" name="2FC007"><b>2FC007</b></a> - INT 2F - AD-DOS - SET HOT KEY<br />
<pre>
INT 2F - AD-DOS - SET HOT KEY
	AX = C007h
	BX = hot key
	CL = hot key shift status
Return: AL = 00h if successful
SeeAlso: AX=C008h"AD-DOS"
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC007_0" name="2FC007_0"><b>2FC007</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - ???
	AX = C007h
	???
Return: BX destroyed
	???
Note:	this function appears to be identical to AX=C006h
SeeAlso: AX=C000h"PCACHE",AX=C006h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC008" name="2FC008"><b>2FC008</b></a> - INT 2F - AD-DOS - GET CURRENT HOT KEY<br />
<pre>
INT 2F - AD-DOS - GET CURRENT HOT KEY
	AX = C008h
Return: AX = status
	    0000h successful
		BX = Hot Key
		CL = Hot Key Shift Status
	    0008h otherwise
SeeAlso: AX=C000h"AD-DOS",AX=C007h"AD-DOS"
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC008_0" name="2FC008_0"><b>2FC008</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - CLEAR ??? FLAG<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - CLEAR ??? FLAG
	AX = C008h
Return: BX destroyed
SeeAlso: AX=C000h"PCACHE",AX=C009h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC009" name="2FC009"><b>2FC009</b></a> - INT 2F - AD-DOS - UNBLANK MONITOR<br />
<pre>
INT 2F - AD-DOS - UNBLANK MONITOR
	AX = C009h
Return: AL = 00h if successful
Program: AD-DOS is the DOS version of the After Dark screen blanker for
	  MS Windows
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
Note:	this function works by simulating keyboard activity
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC009_0" name="2FC009_0"><b>2FC009</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ??? FLAG<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ??? FLAG
	AX = C009h
Return: BX destroyed
Program: PCACHE is the resident print spooler portion of PrintCache by
	  LaserTools; it may use either memory or disk space to spool output
Range:	AH=C0h to AH=FFh, selected by commandline switch
SeeAlso: AX=C000h"PCACHE",AX=C008h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC00A" name="2FC00A"><b>2FC00A</b></a> - INT 2F - AD-DOS - ???<br />
<pre>
INT 2F - AD-DOS - ???
	AX = C00Ah
Return: AX = status
	    0000h successful
		BH = ??
		BL = ??
	    000Ah failed
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC00A_0" name="2FC00A_0"><b>2FC00A</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - ???
	AX = C00Ah
	???
Return: AH = bit flags
	    bit 5: ???
	AL = bit flags
	    bit 4: ???
	    bit 3: ???
	BX destroyed
	???
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC00B" name="2FC00B"><b>2FC00B</b></a> - INT 2F - AD-DOS - ???<br />
<pre>
INT 2F - AD-DOS - ???
	AX = C00Bh
Return: AX = status
	    0000h successful
	    000Bh failed
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC00B_0" name="2FC00B_0"><b>2FC00B</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - NOP<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - NOP
	AX = C00Bh
Return: BX destroyed
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC00C" name="2FC00C"><b>2FC00C</b></a> - INT 2F - AD-DOS - SET ??? INTERNAL FLAG TO 01h<br />
<pre>
INT 2F - AD-DOS - SET ??? INTERNAL FLAG TO 01h
	AX = C00Ch
Return: AX = status
	    0000h successful
	    000Ch failed
Program: AD-DOS is the DOS version of the After Dark screen blanker for
	  MS Windows
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC00C_0" name="2FC00C_0"><b>2FC00C</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???
	AX = C00Ch
Return: AX = ??? (0000h)
	BX = ??? (0000h)
	CX = ??? (0100h)
	DL = ???
	DH = ???
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC00D" name="2FC00D"><b>2FC00D</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ???
	AX = C00Dh
	DL = ???
Return: BX destroyed
Program: PCACHE is the resident print spooler portion of PrintCache by
	  LaserTools; it may use either memory or disk space to spool output
Range:	AH=C0h to AH=FFh, selected by commandline switch
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC00E" name="2FC00E"><b>2FC00E</b></a> - INT 2F - AD-DOS - SET PASSWORD STATUS<br />
<pre>
INT 2F - AD-DOS - SET PASSWORD STATUS
	AX = C00Eh
	BX = new state (0000h disabled, 0001h enabled)
Return: ???
SeeAlso: AX=C000h"AD-DOS",AX=C00Fh"AD-DOS"
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC00E_0" name="2FC00E_0"><b>2FC00E</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - INSTALL ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - INSTALL ???
	AX = C00Eh
	ES:DX -&gt; ???
Return: BX destroyed
Note:	ES:DX is stored internally if the variable is currently 0000h:0000h,
	  but ignored if already set; a counter is incremented
SeeAlso: AX=C000h"PCACHE",AX=C00Fh"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC00F" name="2FC00F"><b>2FC00F</b></a> - INT 2F - AD-DOS - GET PASSWORD STATUS<br />
<pre>
INT 2F - AD-DOS - GET PASSWORD STATUS
	AX = C00Fh
Return: BX = current state (0000h disabled, 0001h enabled)
SeeAlso: AX=C00Eh"AD-DOS"
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC00F_0" name="2FC00F_0"><b>2FC00F</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - REMOVE ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - REMOVE ???
	AX = C00Fh
Return: BX destroyed
Note:	this function decrements the counter used by AX=C00Eh, and clears the
	  internal pointer variable to 0000h:0000h when it reaches zero
SeeAlso: AX=C000h"PCACHE",AX=C00Eh"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC010" name="2FC010"><b>2FC010</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???
	AX = C010h
	CX = index of ??? table (00h-02h, others treated as 00h)
	SI = offset into data table
Return: AL = byte at specified offset into table
	BX destroyed
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC011" name="2FC011"><b>2FC011</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???
	AX = C011h
Return: AX = ??? (0007h)
	BX = ??? (0001h)
	CH = ???
	CL = ???
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC012" name="2FC012"><b>2FC012</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - GET ???
	AX = C012h
Return: AX = ???
	BX = ???
	CX = ???
	DX = ???
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC013" name="2FC013"><b>2FC013</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - ???
	AX = C013h
	???
Return: BX destroyed
	???
Program: PCACHE is the resident print spooler portion of PrintCache by
	  LaserTools; it may use either memory or disk space to spool output
Range:	AH=C0h to AH=FFh, selected by commandline switch
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC014" name="2FC014"><b>2FC014</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - ???
	AX = C014h
	???
Return: BX destroyed
	???
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC015" name="2FC015"><b>2FC015</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - ???
	AX = C015h
	???
Return: BX destroyed
	???
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC016" name="2FC016"><b>2FC016</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - INCREMENT ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - INCREMENT ???
	AX = C016h
Return: BX destroyed
SeeAlso: AX=C000h"PCACHE",AX=C017h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC017" name="2FC017"><b>2FC017</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - DECREMENT ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - DECREMENT ???
	AX = C017h
Return: BX destroyed
SeeAlso: AX=C000h"PCACHE",AX=C016h"PCACH"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC018" name="2FC018"><b>2FC018</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - ???
	AX = C018h
	???
Return: BX destroyed
	???
Note:	the first instruction of this function is an indirect jump which points
	  at a RET by default
SeeAlso: AX=C000h"PCACHE",AX=C019h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC019" name="2FC019"><b>2FC019</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - ???
	AX = C019h
	???
Return: BX destroyed
	???
Note:	the first instruction of this function is an indirect jump which points
	  at a RET by default
SeeAlso: AX=C000h"PCACHE",AX=C018h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC01A" name="2FC01A"><b>2FC01A</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - CLEAR ??? FLAG<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - CLEAR ??? FLAG
	AX = C01Ah
Return: BX destroyed
SeeAlso: AX=C000h"PCACHE",AX=C01Bh"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC01B" name="2FC01B"><b>2FC01B</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ??? FLAG<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - SET ??? FLAG
	AX = C01Bh
Return: BX destroyed
SeeAlso: AX=C000h"PCACHE",AX=C01Ah"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC01C" name="2FC01C"><b>2FC01C</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - ???<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - ???
	AX = C01Ch
	???
Return: AX = ???
	BX destroyed
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC01D" name="2FC01D"><b>2FC01D</b></a> - INT 2F U - PrintCache v3.1 PCACHE.EXE - NOP<br />
<pre>
INT 2F U - PrintCache v3.1 PCACHE.EXE - NOP
	AX = C01Dh to C01Fh
Return: BX destroyed
Program: PCACHE is the resident print spooler portion of PrintCache by
	  LaserTools; it may use either memory or disk space to spool output
Range:	AH=C0h to AH=FFh, selected by commandline switch
SeeAlso: AX=C000h"PCACHE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC020" name="2FC020"><b>2FC020</b></a> - INT 2F - AD-DOS - GET AND RESET VxD API STATUS<br />
<pre>
INT 2F - AD-DOS - GET AND RESET VxD API STATUS
	AX = C020h
Return: AL = 00h if successful
	    BX = VxD API Status
		0000h no error
		0001h error
		0100h neither Windows 3.X enhanced mode nor Windows/386 2.x
			  is running
		0200h VM API entry point not found (VxD not installed)
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
Note:	this call resets the VxD API Status to zero
SeeAlso: AX=1602h,AX=1607h"CALL OUT API"
Index:	screen saver;AD-DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC04E" name="2FC04E"><b>2FC04E</b></a> - INT 2F - Explosiv v2.00+ - NON-TSR EXECUTING CHECK<br />
<pre>
INT 2F - Explosiv v2.00+ - NON-TSR EXECUTING CHECK
	AX = C04Eh
Return: AL = 4Fh if Explosiv is running but not memory-resident
Program: Explosiv is a shareware animated screen blanker for DOS and Windows 3
	  by H&G Software (Reidar Gresseth and Chris Hook)
Range:	AH=C0h to AH=C9h, selected by configuration
SeeAlso: AX=C050h
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC050" name="2FC050"><b>2FC050</b></a> - INT 2F - Explosiv v2.00+ - INSTALLATION CHECK<br />
<pre>
INT 2F - Explosiv v2.00+ - INSTALLATION CHECK
	AX = C050h
Return: AL = 51h if installed
	---v3.0+ ---
	    BX = interval in clock ticks
	    CH = animation display color (00h mono, 01h tinge, 02h color)
	    CL = animation delay factor
	    DH = animation parameters
	    DL = INT 10 checking (00h on, 01h off)
	    SI = number of bytes available for animation code
	    DI = display type (00h VGA, 01h EGA, 02h CGA, 03h HGC, 04h MDA)
Program: Explosiv is a shareware animated screen blanker for DOS and Windows 3
	  by H&G Software (Reidar Gresseth and Chris Hook)
Range:	AH=C0h to AH=C9h, selected by configuration
SeeAlso: AH=93h,AX=C000h"AD-DOS",AX=C04Eh,AX=C052h,AX=C054h"v3"
SeeAlso: INT 14/AX=AA01h
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC052" name="2FC052"><b>2FC052</b></a> - INT 2F - Explosiv v2.00+ - UNINSTALL<br />
<pre>
INT 2F - Explosiv v2.00+ - UNINSTALL
	AX = C052h
	DX:BX = address to return to on successful uninstall
Return: at specified address if successful
	AL = 53h on error
Note:	specified return address must have the segment of the caller's PSP
SeeAlso: AX=C050h
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC054" name="2FC054"><b>2FC054</b></a> - INT 2F - Explosiv v2.x - GET ANIMATION DELAY FACTOR<br />
<pre>
INT 2F - Explosiv v2.x - GET ANIMATION DELAY FACTOR
	AX = C054h
Return: AL = delay factor
SeeAlso: AX=C057h
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC054_0" name="2FC054_0"><b>2FC054</b></a> - INT 2F - Explosiv v3.0+ - UPDATE PARAMETERS<br />
<pre>
INT 2F - Explosiv v3.0+ - UPDATE PARAMETERS
	AX = C054h
	BX = new interval in clock ticks
	CH = animation display color (00h mono, 01h tinge, 02h color)
	CL = animation delay factor
	DH = animation parameters
	DL = INT 10 checking (00h on, 01h off)
SeeAlso: AX=C050h
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC055" name="2FC055"><b>2FC055</b></a> - INT 2F - Explosiv v2.x - SET BLANKING INTERVAL<br />
<pre>
INT 2F - Explosiv v2.x - SET BLANKING INTERVAL
	AX = C055h
	BX = new interval in clock ticks
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC056" name="2FC056"><b>2FC056</b></a> - INT 2F - Explosiv v2.x - SET ANIMATION DISPLAY TYPE<br />
<pre>
INT 2F - Explosiv v2.x - SET ANIMATION DISPLAY TYPE
	AX = C056h
	BL = animated display type (00h mono, 01h color)
SeeAlso: AX=C058h"v2.x"
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC056_0" name="2FC056_0"><b>2FC056</b></a> - INT 2F - Explosiv v3.0+ - ENABLE/DISABLE EXPLOSIV<br />
<pre>
INT 2F - Explosiv v3.0+ - ENABLE/DISABLE EXPLOSIV
	AX = C056h
	BX = new state
	    0000h disabled
	    0100h enabled
	    0101h enabled, but never blank
	    0102h enabled, always blank

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC057" name="2FC057"><b>2FC057</b></a> - INT 2F - Explosiv v2.x - SET ANIMATION DELAY FACTOR<br />
<pre>
INT 2F - Explosiv v2.x - SET ANIMATION DELAY FACTOR
	AX = C057h
	BL = delay factor
SeeAlso: AX=C054h"v2.x"
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC058" name="2FC058"><b>2FC058</b></a> - INT 2F - Explosiv v2.x - SET ANIMATION PARAMETER<br />
<pre>
INT 2F - Explosiv v2.x - SET ANIMATION PARAMETER
	AX = C058h
	BL = animation parameter
Note:	the animation parameter has different interpretations for each display
SeeAlso: AX=C056h"v2.x"
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC058_0" name="2FC058_0"><b>2FC058</b></a> - INT 2F - Explosiv v3.0+ - LOAD NEW ANIMATION DISPLAY CODE<br />
<pre>
INT 2F - Explosiv v3.0+ - LOAD NEW ANIMATION DISPLAY CODE
	AX = C058h
	BX = file handle for file containing display code
	CX = number of bytes to load
	DX = offset at which animation code should be loaded
Return: AL = status (see #03033)
Note:	if AL=00h-03h on return, the file will be closed
Index:	screen saver;Explosiv

(Table 03033)
Values for Explosiv function status:
 00h	successful
 01h	code too large to available space
 02h	no data read, load aborted
 03h	incomplete load, default blanking display loaded instead
 58h	unexpected offset in DX

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC059" name="2FC059"><b>2FC059</b></a> - INT 2F - Explosiv v2.x - DISABLE EXPLOSIV<br />
<pre>
INT 2F - Explosiv v2.x - DISABLE EXPLOSIV
	AX = C059h
Note:	clears flag set by AX=C05Ah
SeeAlso: AX=C05Ah
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC05A" name="2FC05A"><b>2FC05A</b></a> - INT 2F u - Explosiv v2.x - ENABLE EXPLOSIV<br />
<pre>
INT 2F u - Explosiv v2.x - ENABLE EXPLOSIV
	AX = C05Ah
	BL = ???
Note:	sets flag cleared by AX=C059h then stores BL
SeeAlso: AX=C059h,AX=C05Bh
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC05B" name="2FC05B"><b>2FC05B</b></a> - INT 2F - Explosiv v2.x - CHANGE ANIMATION DISPLAY<br />
<pre>
INT 2F - Explosiv v2.x - CHANGE ANIMATION DISPLAY
	AX = C05Bh
	BL = animation display
Note:	this function fails silently if the requested display is not in memory
SeeAlso: AX=C05Ah,AX=C05Ch
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC05C" name="2FC05C"><b>2FC05C</b></a> - INT 2F - Explosiv v2.x - SET INT 10 CHECKING<br />
<pre>
INT 2F - Explosiv v2.x - SET INT 10 CHECKING
	AX = C05Ch
	BL = new state of INT 10 checking (00h enabled, 01h disabled)
SeeAlso: AX=C05Bh
Index:	screen saver;Explosiv

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC080" name="2FC080"><b>2FC080</b></a> - INT 2F U - AMI IAM.SYS - INSTALL ??? CALLBACK<br />
<pre>
INT 2F U - AMI IAM.SYS - INSTALL ??? CALLBACK
	AX = C080h
	CX:DX -&gt; ??? callback
	DI = segment of ??? buffer (first WORD copied into IAM.SYS)
Program: IAM.SYS is the Illegal Activity Monitor portion of American
	  Megatrends, Inc.'s PC-Defender anti-virus product
Note:	also sets ??? flag
SeeAlso: AX=C081h

Format of IAM.SYS buffer:
Offset	Size	Description	(Table 03034)
 00h	BYTE	???
 01h	BYTE	???
 02h  N BYTEs	??? (ASCIZ strings)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC081" name="2FC081"><b>2FC081</b></a> - INT 2F U - AMI IAM.SYS - CLEAR ???<br />
<pre>
INT 2F U - AMI IAM.SYS - CLEAR ???
	AX = C081h
Desc:	clears the ??? flag that AX=C080h sets
SeeAlso: AX=C080h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC0AE" name="2FC0AE"><b>2FC0AE</b></a> - INT 2F U - HP 100LX/200LX - PUSHKEYS - INSTALLATION CHECK<br />
<pre>
INT 2F U - HP 100LX/200LX - PUSHKEYS - INSTALLATION CHECK
	AX = C0AEh
Return: AX = 4453h if installed
	CX = 5259h if installed
Range:	AH=C0h to AH=FFh, selected by scanning for signature
SeeAlso: AX=C000h"HP 100LX",AX=C001h"HP 100LX",AX=C0AFh"HP 100LX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC0AF" name="2FC0AF"><b>2FC0AF</b></a> - INT 2F U - HP 100LX/200LX - PUSHKEYS - INTERNAL - GET BUFFER ADDRESS<br />
<pre>
INT 2F U - HP 100LX/200LX - PUSHKEYS - INTERNAL - GET BUFFER ADDRESS
	AX = C0AFh
Return: ES:DI -&gt; buffer (behind code)
Range:	AH=C0h to AH=FFh, selected by scanning for signature with AL=AEh
SeeAlso: AX=C000h"HP 100LX",AX=C001h"HP 100LX",AX=C0AEh"HP 100LX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC100" name="2FC100"><b>2FC100</b></a> - INT 2F U - Personal NetWare - STPIPX v1.00 - INSTALLATION CHECK<br />
<pre>
INT 2F U - Personal NetWare - STPIPX v1.00 - INSTALLATION CHECK
	AX = C100h
Return: AL = FFh if installed
	    ES:SI -&gt; signature string "STP-IPX$"
	    BX = version??? (0001h for v1.00)
	    DI corrupted
Note:	AH=C1h is the default value; STPIPX probably scans a range of
	  multiplex numbers to find a free one, as LSL does
SeeAlso: AX=C000h"LSL",AX=C101h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC101" name="2FC101"><b>2FC101</b></a> - INT 2F U - Personal NetWare - STPIPX v1.00 - UNINSTALL<br />
<pre>
INT 2F U - Personal NetWare - STPIPX v1.00 - UNINSTALL
	AX = C101h
Return: AL = status???
	BX corrupted
SeeAlso: AX=C101h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC205" name="2FC205"><b>2FC205</b></a> - INT 2F U - LapLink RemoteAccess (LLRA) - Redirector - ???<br />
<pre>
INT 2F U - LapLink RemoteAccess (LLRA) - Redirector - ???
	AX = C205h
	details not yet available
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"LapLink",AX=C002h"LapLink",AX=C2F0h"LapLink"
SeeAlso: AX=C2F1h"LapLink",AX=C301h"LapLink"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC2F0" name="2FC2F0"><b>2FC2F0</b></a> - INT 2F U - LapLink RemoteAccess (LLRA) - Redirector - ???<br />
<pre>
INT 2F U - LapLink RemoteAccess (LLRA) - Redirector - ???
	AX = C2F0h
	details not yet available
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"LapLink",AX=C002h"LapLink",AX=C205h"LapLink"
SeeAlso: AX=C2F1h"LapLink",AX=C301h"LapLink"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC2F1" name="2FC2F1"><b>2FC2F1</b></a> - INT 2F U - LapLink RemoteAccess (LLRA) - Redirector - ???<br />
<pre>
INT 2F U - LapLink RemoteAccess (LLRA) - Redirector - ???
	AX = C2F1h
	details not yet available
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"LapLink",AX=C002h"LapLink",AX=C205h"LapLink"
SeeAlso: AX=C2F0h"LapLink",AX=C301h"LapLink"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC300" name="2FC300"><b>2FC300</b></a> - INT 2F - SETWPR.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - SETWPR.COM - INSTALLATION CHECK
	AX = C300h
Return: AL = FFh if installed
Program: SETWPR is a hard-disk write-protection TSR by Jaroslaw Rafa
SeeAlso: AX=C302h"SETWPR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC300DX0000" name="2FC300DX0000"><b>2FC300DX0000</b></a> - INT 2F U - SpaceManager - INSTALLATION CHECK<br />
<pre>
INT 2F U - SpaceManager - INSTALLATION CHECK
	AX = C300h
	DX = 0000h
Return: AL = FFh if any SpaceManager programs installed
	    BX = 6F73h
	    CX = 6F68h
Program: SpaceManager is an enhancement for MS-DOS DoubleSpace by Vertisoft
	  Systems, Inc.
Range:	AH=C3h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C300h/BX=4F53h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC300BX4F53" name="2FC300BX4F53"><b>2FC300BX4F53</b></a> - INT 2F U - SpaceManager - INSTALLATION VERIFICATION<br />
<pre>
INT 2F U - SpaceManager - INSTALLATION VERIFICATION
	AX = C300h
	BX = 4F53h ('OS')
	CX = 4F48h ('OH')
	DX = program identifier (see #03035) or 0666h for any SpaceManager prog
Return: AL = FFh if BX/CX as specified and specified program installed
	    BX = 6F73h ('os')
	    CX = 6F68h ('oh')
Range:	AH=C3h to AH=FFh, selected by scanning for first free multiplex number
Note:	this call is chained if BX,CX, or DX are not as specified above
SeeAlso: AX=C300h/DX=0000h

(Table 03035)
Values for SpaceManager program identifier:
 9000h	SMOUNT (SuperMount)
 9001h	SELECTC (SelectCompress)
 9002h	SUPERX (SuperExchange)
 9003h	FORTUNE (FortuneTeller)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC301" name="2FC301"><b>2FC301</b></a> - INT 2F U - SpaceManager - ???<br />
<pre>
INT 2F U - SpaceManager - ???
	AX = C301h
	DX = program identifier (9000h,9001h,9003h) (see #03035)
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC301_0" name="2FC301_0"><b>2FC301</b></a> - INT 2F U - LapLink RemoteAccess (LLRA) - Compression - ???<br />
<pre>
INT 2F U - LapLink RemoteAccess (LLRA) - Compression - ???
	AX = C301h
	details not yet available
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"LapLink",AX=C002h"LapLink",AX=C205h"LapLink"
SeeAlso: AX=C2F0h"LapLink",AX=C3F0h"LapLink",AX=C3F1h"LapLink"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC302" name="2FC302"><b>2FC302</b></a> - INT 2F U - SpaceManager - ENABLE PROGRAM<br />
<pre>
INT 2F U - SpaceManager - ENABLE PROGRAM
	AX = C302h
	DX = program identifier (9000h,9001h,9003h) (see #03035)
Return: AX destroyed
SeeAlso: AX=C303h,AX=C306h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC302_0" name="2FC302_0"><b>2FC302</b></a> - INT 2F - SETWPR.COM - SET WRITE-PROTECTION STATE<br />
<pre>
INT 2F - SETWPR.COM - SET WRITE-PROTECTION STATE
	AX = C302h
	BL = new state
	    00h disk may be written
	    01h disk write-protected
Return: AL = FFh if installed
Program: SETWPR is a hard-disk write-protection TSR by Jaroslaw Rafa
SeeAlso: AX=C300h"SETWPR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC303" name="2FC303"><b>2FC303</b></a> - INT 2F U - SpaceManager - DISABLE PROGRAM<br />
<pre>
INT 2F U - SpaceManager - DISABLE PROGRAM
	AX = C303h
	DX = program identifier (9000h,9001h,9003h) (see #03035)
Return: AX destroyed
SeeAlso: AX=C302h,AX=C306h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC304" name="2FC304"><b>2FC304</b></a> - INT 2F U - SpaceManager - GET PER-DRIVE ENABLEMENT TABLE<br />
<pre>
INT 2F U - SpaceManager - GET PER-DRIVE ENABLEMENT TABLE
	AX = C304h
	DX = program identifier (9000h,9001h,9003h) (see #03035)
Return: ES:BX -&gt; 26-byte drive table (00h disabled for drive, 01h enabled)
	AX destroyed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC305DX9003" name="2FC305DX9003"><b>2FC305DX9003</b></a> - INT 2F U - SpaceManager - FORTUNE.EXE - NOP<br />
<pre>
INT 2F U - SpaceManager - FORTUNE.EXE - NOP
	AX = C305h
	DX = 9003h
Return: AX destroyed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC305" name="2FC305"><b>2FC305</b></a> - INT 2F U - SpaceManager - ???<br />
<pre>
INT 2F U - SpaceManager - ???
	AX = C305h
	DX = program identifier (9000h,9001h) (see #03035)
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC306" name="2FC306"><b>2FC306</b></a> - INT 2F U - SpaceManager - CHECK WHETHER PROGRAM ENABLED<br />
<pre>
INT 2F U - SpaceManager - CHECK WHETHER PROGRAM ENABLED
	AX = C306h
	DX = program identifier (9000h,9001h,9003h) (see #03035)
Return: AL = current state (00h disabled, FAh enabled)
	AH destroyed
SeeAlso: AX=C302h,AX=C303h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC307DX9001" name="2FC307DX9001"><b>2FC307DX9001</b></a> - INT 2F U - SpaceManager - SELECTC - ???<br />
<pre>
INT 2F U - SpaceManager - SELECTC - ???
	AX = C307h
	DX = 9001h
	BX = ???
	CX = ???
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC308DX9001" name="2FC308DX9001"><b>2FC308DX9001</b></a> - INT 2F U - SpaceManager - SELECTC - ???<br />
<pre>
INT 2F U - SpaceManager - SELECTC - ???
	AX = C308h
	DX = 9001h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC3F0" name="2FC3F0"><b>2FC3F0</b></a> - INT 2F U - LapLink RemoteAccess (LLRA) - Compression - ???<br />
<pre>
INT 2F U - LapLink RemoteAccess (LLRA) - Compression - ???
	AX = C3F0h
	details not yet available
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"LapLink",AX=C002h"LapLink",AX=C205h"LapLink"
SeeAlso: AX=C2F0h"LapLink",AX=C301h"LapLink",AX=C3F1h"LapLink"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC3F1" name="2FC3F1"><b>2FC3F1</b></a> - INT 2F U - LapLink RemoteAccess (LLRA) - Compression - ???<br />
<pre>
INT 2F U - LapLink RemoteAccess (LLRA) - Compression - ???
	AX = C3F1h
	details not yet available
Range:	AH=C0h to AH=FFh, selected by scanning for first free multiplex number
SeeAlso: AX=C000h"LapLink",AX=C002h"LapLink",AX=C205h"LapLink"
SeeAlso: AX=C2F0h"LapLink",AX=C301h"LapLink",AX=C3F0h"LapLink"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC500" name="2FC500"><b>2FC500</b></a> - INT 2F - PC-DOS Econet v1.05 - INSTALLATION CHECK<br />
<pre>
INT 2F - PC-DOS Econet v1.05 - INSTALLATION CHECK
	AX = C500h
Return: AL = status
	    00h not installed, OK to install
	    01h not installed, can't install
	    FFh installed
Note:	the interrupt-enable state will be preserved, but interrupts may be
	  enabled during processing of this function
SeeAlso: AX=C501h,AX=C508h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC501" name="2FC501"><b>2FC501</b></a> - INT 2F - PC-DOS Econet v1.05 - RESET BOARD AND DRIVER<br />
<pre>
INT 2F - PC-DOS Econet v1.05 - RESET BOARD AND DRIVER
	AX = C501h
Return:	AX = return code (see #03037)
Desc:	reset both the network board and the driver software
Notes:	use this function with caution, as it will affect any other resident
	  software using the network board
	the interrupt-enable state will be preserved, but interrupts may be
	  enabled during processing of this function
SeeAlso: AX=C500h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC502" name="2FC502"><b>2FC502</b></a> - INT 2F - PC-DOS Econet v1.05 - PERFORM NETWORK OPERATION<br />
<pre>
INT 2F - PC-DOS Econet v1.05 - PERFORM NETWORK OPERATION
	AX = C502h
	DS:DX -&gt; control block (see #03036)
Return: AX = return code (see #03037) (same as returned in control block)
Note:	the interrupt-enable state will be preserved, but interrupts may be
	  enabled during processing of this function
SeeAlso: AX=C500h

Format of Econet control block:
Offset	Size	Description	(Table 03036)
 00h	DWORD	-&gt; command block (see #03038)
 04h	WORD	length of transmit data block
 06h	DWORD	-&gt; transmit data block
 0Ah	WORD	length of reply block (set to 0000h prior to call)
 0Ch	DWORD	-&gt; reply block
 10h	WORD	return code (set to 0000h prior to call) (see #03037)
 12h	DWORD	reserved for Econet use

(Table 03037)
Values for Econet return code:
 0000h	successful
 0001h	bad command in command block
 0002h	no handles left
 0003h	bad handle
 0004h	bad argument in command
 0005h	buffer too small
 0006h	kill condition failed
 0007h	control block in use
 007Fh	command aborted
 01xxh	retryable board error XXh
 02xxh	fatal board error XXh
 0300h	invalid subfunction number in AL
 0301h	timeout
 03xxh	other driver errors
SeeAlso: #03036

Format of Econet command block:
Offset	Size	Description	(Table 03038)
 00h	BYTE	command code (see #03039)
---command 00h---
 01h	BYTE	direction (00h = read initialization data, 01h = set init data)
 02h	WORD	"TxCB" transmit control block size
 04h	WORD	"RxCB" receive control block size
		Notes:	TxCB and RxCB are always the same size in v1.05,
			  permitting any CB to be used for either receive
			  or transmit
			this command should not be used by applications to
			  set the buffer sizes
 06h  6 BYTEs	padding (0)
---command 01h---
 01h	BYTE	port number (00h = receive on all ports)
		if the RxCB is opened for RPC, the port number indicates the
		  allowable RPC (see #03040)
 02h	WORD	station number (FEFFh = broadcast)
 04h	BYTE	RPC flags
		bit 7: CB is open for RPCs only
		bit 6: restrict to RPC number given in next field
 05h	WORD	RPC number
 07h	BYTE	timeout in 1/2-second units (00h = never)
		if a timeout occurs, the RxCB can still receive data, and may
		  generate another event after the timeout unless it is
		  explicitly killed
 08h  4 BYTEs	padding (0)
---command 02h---
 01h	BYTE	control byte
 02h	BYTE	port number
 03h	WORD	station number
 05h	BYTE	number of retries
 06h	WORD	length of data to be sent (bits 14-0), 0000h allowed
		if bit 15 is set, no data will be transferred, but this field
		  will be updated (needed for peeking)
 08h	DWORD	-&gt; destination address on remote machine
---command 03h---
 01h	BYTE	Control Block Handle
		FEh first filled-in RxCB
		FFh first TxCB which has been sent
 02h 10 BYTEs	padding (0)
---command 04h---
 01h	BYTE	Control Block Handle
 02h	BYTE	kill condition
		00h always
		01h kill only if bit7 of control byte is clear
		81h kill only if bit7 of control byte is set
 03h  9 BYTEs	padding (0)
		Notes:	control blocks are not freed until explicitly killed
			because all TxCBs for a given destination are stored
			  on a separate subchain, it is necessary to kill all
			  failed TxCBs to a given destination before any new
			  ones are opened to that destination
---command 06h---
 01h	BYTE	Control Block Handle
 02h	WORD	starting byte within CB to read
 04h	WORD	number of bytes
		if 0000h or greater than remaining bytes in CB, return all
		  bytes from starting byte to end of CB
 06h  6 BYTEs	padding (0)
---command 07h---
 01h	BYTE	subfunction
		00h-0Fh get/set M/C type (bit N=1 indicates to set byte N)
			four data bytes
		10h get station number
		11h set station number
		12h get Tx pause in 5ms units (default 20)
		13h set Tx pause
		14h get software version numbers
		16h get event enable mask
		17h set event enable mask
		18h get number of non-volatile bytes available
		80h+2N get non-volatile byte N
		81h+2N set non-volatile byte N
 02h	var	new data
Note:	all command blocks should be padded to twelve bytes with zeros if
	  needed
SeeAlso: #03036

(Table 03039)
Values for Econet command code:
 00h	initialize
 01h	open receive
 02h	open transmit
 03h	poll
 04h	kill
 06h	read
 07h	get/set system parameters
SeeAlso: #03038

(Table 03040)
Values for Econet RPC type:
 00h	all
 81h	peek
 82h	poke
 83h	remote JSR
 84h	remote procedure call
 85h	OS procedure
 86h	Halt
 87h	Continue
SeeAlso: #03038

Format of Econet Reply Block (command 00h):
Offset	Size	Description	(Table 03041)
 00h	WORD	TxCB size (default is 0500h, the maximum Econet packet length)
 02h	WORD	RxCB size
 04h	BYTE	number of TxCBs allocated	
 05h	BYTE	number of RxCBs allocated	
SeeAlso: #03036,#03042,#03044

Format of Econet Reply Block (commands 01h,02h):
Offset	Size	Description	(Table 03042)
 00h	BYTE	control block handle
SeeAlso: #03036,#03041,#03045

Format of Econet Reply Block (command 03h):
Offset	Size	Description	(Table 03043)
 00h	BYTE	CB number (when wildcard specified for poll)
 01h	BYTE	control
		(RxCB) 00h until received, then Sent Control byte
		(TxCB) transmit status
		    bit 7: transmission pending
		    bit 6: transmission failed
		    bits 3-0: error number
 02h	BYTE	Port number
 03h	WORD	station number
 05h	WORD	length
 07h	WORD	0000h
SeeAlso: #03036,#03041,#03044

Format of Econet Reply Block (command 06h):
Offset	Size	Description	(Table 03044)
 00h  N BYTEs	data read from network
SeeAlso: #03036,#03043,#03045

Format of Econet Reply Block (command 07h):
Offset	Size	Description	(Table 03045)
 00h  N BYTEs	returned information
SeeAlso: #03036,#03044

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC503" name="2FC503"><b>2FC503</b></a> - INT 2F - PC-DOS Econet v1.05 - ADD EVENT HANDLER<br />
<pre>
INT 2F - PC-DOS Econet v1.05 - ADD EVENT HANDLER
	AX = C503h
	DS:DX -&gt; event handler (see #03046)
Return: AX = return code (see #03037)
Note:	the interrupt-enable state will be preserved, but interrupts may be
	  enabled during processing of this function
SeeAlso: AX=C500h,AX=C504h,AX=C505h,AX=C508h

Format of Econet event handler:
Offset	Size	Description	(Table 03046)
 00h	DWORD	-&gt; next handler's code (at offset 8, filled in by Econet)
 04h	DWORD	-&gt; previous event handler (filled in by Econet)
 08h	var	entry point (executable code called on event) (see #03047)

(Table 03047)
Values Econet event handler is called with:
	AL = event number
	AH = timeout flag (01h if timeout, else 00h)
Return:	all registers preserved
	if event trapped by this handler, issue RETF
	if event not trapped, jump to address stored at offset 0
SeeAlso: #03046

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC504" name="2FC504"><b>2FC504</b></a> - INT 2F - PC-DOS Econet v1.05 - REMOVE EVENT HANDLER<br />
<pre>
INT 2F - PC-DOS Econet v1.05 - REMOVE EVENT HANDLER
	AX = C504h
	DS:DX -&gt; event handler
Return: AX = return code (see #03037)
Note:	the interrupt-enable state will be preserved, but interrupts may be
	  enabled during processing of this function
SeeAlso: AX=C500h,AX=C503h,AX=C506h,AX=C508h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC505" name="2FC505"><b>2FC505</b></a> - INT 2F - PC-DOS Econet v1.05 - SET DEFAULT EVENT ACTION<br />
<pre>
INT 2F - PC-DOS Econet v1.05 - SET DEFAULT EVENT ACTION
	AX = C505h
	DL = new default action
	    00h disable event handling (ignore incoming events)
	    01h enable (call event handler chain)
	    02h store until enabled or disabled (default)
Return: AX = return code (see #03037)
Note:	the interrupt-enable state will be preserved, but interrupts may be
	  enabled during processing of this function
SeeAlso: AX=C500h,AX=C503h,AX=C506h,AX=C508h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC506" name="2FC506"><b>2FC506</b></a> - INT 2F - PC-DOS Econet v1.05 - SET INDIVIDUAL EVENT ACTION<br />
<pre>
INT 2F - PC-DOS Econet v1.05 - SET INDIVIDUAL EVENT ACTION
	AX = C506h
	DH = event number
	DL = new default action
	    00h disable event handling (ignore incoming events)
	    01h enable (call event handler chain)
	    02h store until enabled or disabled (default)
Return: AX = return code (see #03037)
Note:	the interrupt-enable state will be preserved, but interrupts may be
	  enabled during processing of this function
SeeAlso: AX=C500h,AX=C504h,AX=C505h,AX=C507h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC507" name="2FC507"><b>2FC507</b></a> - INT 2F - PC-DOS Econet v1.05 - TEST/CLEAR EVENT STATUS<br />
<pre>
INT 2F - PC-DOS Econet v1.05 - TEST/CLEAR EVENT STATUS
	AX = C507h
	DH = event number (FFh = first event in queue)
	DL = disposition (00h test only, 01h test and clear)
Return: AX = return code (see #03037)
	DH = event number if one is pending, 00h if none
Note:	the interrupt-enable state will be preserved, but interrupts may be
	  enabled during processing of this function
SeeAlso: AX=C500h,AX=C503h,AX=C506h,AX=C508h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC508" name="2FC508"><b>2FC508</b></a> - INT 2F - PC-DOS Econet v1.05 - ENABLE/DISABLE EVENT SCHEDULER<br />
<pre>
INT 2F - PC-DOS Econet v1.05 - ENABLE/DISABLE EVENT SCHEDULER
	AX = C508h
	DL = new state of scheduler (01h enabled, 02h disabled)
Return: AX = return code (see #03037)
	DL = previous state
Notes:	the interrupt-enable state will be preserved, but interrupts may be
	  enabled during processing of this function
	while the scheduler is disabled, all events are queued until the
	  scheduler is re-enabled
SeeAlso: AX=C500h,AX=C503h,AX=C504h,AX=C506h,AX=C507h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC64CBX5553" name="2FC64CBX5553"><b>2FC64CBX5553</b></a> - INT 2F U - Smart Prompt - INSTALLATION CHECK<br />
<pre>
INT 2F U - Smart Prompt - INSTALLATION CHECK
	AX = C64Ch
	BX = 5553h
Return: AX = 4CC6h if installed
	BX = 5355h if installed
Program: Smart Prompt (SMARTPMT) is a freeware TSR by Steve Gibson which
	  forces an immediate flush of SmartDrive's (and compatible caches')
	  buffers on returning to the DOS prompt

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC700CX434C" name="2FC700CX434C"><b>2FC700CX434C</b></a> - INT 2F u - COLAP - INSTALLATION CHECK<br />
<pre>
INT 2F u - COLAP - INSTALLATION CHECK
	AX = C700h
	CX = 434Ch  "CL"
Return: AL = FFh if installed
Program: colap.com is a freeware TSR by Eric Meyer which controls contrast
	  and brightness of color laptops by changing the VGA palette colors;
	  for Toshiba laptops there are more hotkeys for shutting off display
	  and harddisk.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC900BP0000" name="2FC900BP0000"><b>2FC900BP0000</b></a> - INT 2F U - ThunderByte??? - INSTALLATION CHECK<br />
<pre>
INT 2F U - ThunderByte??? - INSTALLATION CHECK
	AX = C900h
	BP = 0000h
Return: AL = FFh if installed
	    BP &gt;= 0014h
Note:	called by TBSCANX
SeeAlso: AX=C987h,AX=CA00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC987" name="2FC987"><b>2FC987</b></a> - INT 2F U - ThunderByte??? - DISINFECT FILE???<br />
<pre>
INT 2F U - ThunderByte??? - DISINFECT FILE???
	AX = C987h
	BX:DX -&gt; filename
	BX:CX -&gt; virus name
Return: AX = status
	    0000h successful???
Note:	called by TBSCANX
SeeAlso: AX=CA00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC9FD" name="2FC9FD"><b>2FC9FD</b></a> - INT 2F - ThunderByte TBLOG - WRITE STRING TO LOG<br />
<pre>
INT 2F - ThunderByte TBLOG - WRITE STRING TO LOG
	AX = C9FDh
	DS:SI -&gt; ASCIZ string (max 110 chars)
Return: AH = 00h
	AL = last character in string
	CX = number of unused characters in string
	SI,DI destroyed
Notes:	The string can also be terminated with a '%'-character.
	This function is never called within ThunderBYTE Anti-Virus.
SeeAlso: AX=C900h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FC9FF" name="2FC9FF"><b>2FC9FF</b></a> - INT 2F C - StackMan - INSTALLATION BROADCAST<br />
<pre>
INT 2F C - StackMan - INSTALLATION BROADCAST
	AX = C9FFh
	BL = BCD version number
	CX = number of stacks
	DX = stack size in bytes
Program: StackMan is a freeware stack manager by Franz Veldman of ESaSS B.V.
	  which functions as a replacement for the DOS STACK= command as well
	  as permitting multiple TSRs to share a pool of stack space
InstallCheck:	test for the string "STACKXXX" at offset 0Ah from the INT B4
	  handler
Note:	called by StackMan when it goes resident to inform interested TSRs that
	  its API is available
SeeAlso: INT B4"StackMan",INT B5"StackMan"
Index:	installation check;STACKMAN|broadcasts;STACKMAN installation

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCA" name="2FCA"><b>2FCA</b></a> - INT 2F - FAXPLUS - FAX TSR<br />
<pre>
INT 2F - FAXPLUS - FAX TSR
	AH = CAh
	???
Return: ???
Program: FAXTSR is a resident FAX send/receive module for FAXPLUS by Frans
	  Veldman
SeeAlso: AH=2Ah"Gammafax"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCA00BX5442" name="2FCA00BX5442"><b>2FCA00BX5442</b></a> - INT 2F - TBSCANX - INSTALLATION CHECK<br />
<pre>
INT 2F - TBSCANX - INSTALLATION CHECK
	AX = CA00h
	BX = 5442h ('TB')
Return: AL = state
	    00h not installed
	    FFh installed
		BX = 7462h ('tb') if BX was 5442h on entry
Program: TBSCANX is a resident virus scanning module by Frans Veldman.
Notes:	programs may perform virus checks on themselves, other program files,
	  or their data files by invoking the TBSCANX API.
	current versions of TBScanX don't actually check the value of BX
SeeAlso: AX=4653h/CX=0002h,AX=4653h/CX=0007h,AX=C900h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCA01" name="2FCA01"><b>2FCA01</b></a> - INT 2F - TBSCANX - GET STATUS<br />
<pre>
INT 2F - TBSCANX - GET STATUS
	AX = CA01h
Return: AH = BCD version number (v2.2+)
	    CAh for versions before 2.2
	AL = state (00h = disabled, 01h = enabled)
	CX = number of signatures which will be searched
---v2.0---
	BX = EMS handle, 0000h if not using EMS
---v2.3+---
	BX = segment of swap area, 0000h if not swapped
	DX = EMS or XMS handle (XMS handle if BX=0000h), FFFFh if not using EMS
SeeAlso: AX=CA02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCA02" name="2FCA02"><b>2FCA02</b></a> - INT 2F - TBSCANX - SET STATE<br />
<pre>
INT 2F - TBSCANX - SET STATE
	AX = CA02h
	BL = new state (00h = disabled, 01h = enabled)
SeeAlso: AX=CA01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCA03" name="2FCA03"><b>2FCA03</b></a> - INT 2F - TBSCANX - SCAN BUFFER<br />
<pre>
INT 2F - TBSCANX - SCAN BUFFER
	AX = CA03h
	CX = size of buffer
	DS:DX -&gt; buffer containing data to scan
Return: CF clear if no virus signatures found
	    BX,ES destroyed
	CF set if signature found
	    ES:BX -&gt; ASCIZ virus name (v2.3+)
	    DS:DX -&gt; ASCIZ virus name (v2.0)
	AX,CX,DX destroyed (v2.3+)
	all other registers except CS:IP and SS:SP destroyed (v2.0)
SeeAlso: AX=CA04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCA04" name="2FCA04"><b>2FCA04</b></a> - INT 2F - TBSCANX - SCAN FILE<br />
<pre>
INT 2F - TBSCANX - SCAN FILE
	AX = CA04h
	DS:DX -&gt; filename
Return: CF clear if no virus signatures found
	    BX,SI,DI,ES destroyed
	CF set if signature found
	    ES:BX -&gt; ASCIZ virus name
	AX,CX,DX destroyed
Note:	this function requires at least 4K free memory
SeeAlso: AX=CA03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCAFEBX0000" name="2FCAFEBX0000"><b>2FCAFEBX0000</b></a> - INT 2F U - THELP v3.0 - INSTALLATION CHECK<br />
<pre>
INT 2F U - THELP v3.0 - INSTALLATION CHECK
	AX = CAFEh
	BX = 0000h
Return: BX = segment of resident code if installed
	    0000h if not installed
SeeAlso: AX=5453h,INT 2D"AMIS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB00" name="2FCB00"><b>2FCB00</b></a> - INT 2F - Communicating Applications Specification - INSTALLATION CHECK<br />
<pre>
INT 2F - Communicating Applications Specification - INSTALLATION CHECK
	AX = CB00h
Return: AL = status
	    00h not installed, OK to install
	    01h not installed, not OK to install
	    FFh installed
Note:	AH = CBh is the default identifier, but may be reconfigured
SeeAlso: AH=2Ah,AX=8000h"FaxBIOS",AX=CB0Eh,AX=CBDCh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB00BX4D53" name="2FCB00BX4D53"><b>2FCB00BX4D53</b></a> - INT 2F - METZ XpressFax CASMGR - INSTALLATION CHECK<br />
<pre>
INT 2F - METZ XpressFax CASMGR - INSTALLATION CHECK
	AX = CB00h
	BX = 4D53h ('MS')
	CX = 4949h ('II')
Return: AL = status
	    00h not installed, OK to install
	    01h not installed, not OK to install
	    FFh installed
		BX = 6D73h ('ms')
		CX = 6969h ('ii')
Note:	this function is equivalent to the standard CASMGR installation check,
	  but uses the additional magic values to identify which CAS is
	  installed
SeeAlso: AH=2Ah,AX=8000h"FaxBIOS",AX=C000h/BX=444Bh,AX=CB0Eh,AX=CB16h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB01" name="2FCB01"><b>2FCB01</b></a> - INT 2F - Communicating Applications Specification - SUBMIT A TASK<br />
<pre>
INT 2F - Communicating Applications Specification - SUBMIT A TASK
	AX = CB01h
	DS:DX -&gt; ASCIZ name of task control file
Return: AX &gt;= 0: event handle
	AX &lt; 0: two's complement of error code (see #03048)
Note:	files needed for an event must be kept until task is complete or error
SeeAlso: AX=CB0Bh,AX=CB15h

(Table 03048)
Values for CAS error code:
  (AH = class, AL = subcode, value passed back is 2's complement)
  Class 00h	--- FAX warnings
	Subcode 00h	no error
		02h	bad scanline count
		03h	page sent with errors, could not retransmit
		04h	received data lost
		05h	invalid or missing logo file
		06h	filename does not match nonstandard format (NSF) header
		07h	file size does not match NSF header
  Class 01h	--- DOS warnings (data was sent)
	Subcode 01h	invalid function
		05h	access denied
		06h	invalid handle
		others	see #01680 at INT 21/AH=59h/BX=0000h
  Class 02h	--- fatal errors (data not sent)
	Subcode 00h	multiplex handler failed
		01h	unknown command
		02h	bad event handle
		03h	FIND NEXT attempted before FIND FIRST
		04h	no more events
		07h	invalid queue type
		08h	bad control file
		09h	communication board busy
		0Ah	invalid command parameter
		0Bh	can't uninstall resident code
		0Ch	file exists
		80h	unknown task type
		81h	bad phone number
		82h	bad .PCX file header
		83h	unexpected EOF
		84h	unexpected disconnect
		85h	too many dialing retries
		86h	no file specified for send
		87h	communication board timeout
		88h	received too many pages (&gt;1023) of data
		89h	manual connect initiated too long ago
		8Ah	hardware command set error
		8Bh	bad NonStandard Format (NSF) header file
  Class 03h	--- fatal DOS errors
	Subcode 02h	file not found
		03h	path not found
		others	see #01680 at INT 21/AH=59h/BX=0000h
  Class 04h	--- FAX errors
	Subcode 01h	remote unit not Group 3 compatible
		02h	remote unit did not send capabilities
		03h	other FAX machine incompatible
		04h	other FAX incapable of file transfers
		05h	exceeded retrain or FAX resend limit
		06h	line noise or failure to agree on bit rate
		07h	remote disconnected after receiving data
		08h	no response from remote after sending data
		09h	remote's capabilities incompatible
		0Ah	no dial tone (v1.2+)
		0Bh	invalid response from remote unit after sending data
		0Dh	phone line dead or remote unit disconnected
		0Eh	timeout while waiting for secondary dial tone (v1.2+)
		11h	invalid command from remote after receiving data
		15h	tried to receive from incompatible hardware
		5Ch	received data overflowed input buffer
		5Dh	remote unexpectedly stopped sending data
		5Eh	other FAX machine jammed (no data sent)
		5Fh	remote took too long to send fax scan line
		63h	can't get through to remote unit
		64h	user canceled event
  Class 05h	--- application-specific (v1.2+)
  ---Intel FAXPOP.EXE
	Subcode 00h	tried to send while in graphics mode
		01h	insufficient disk space
		02h	internal buffer overflow
  Class 06h	--- CAS implementation-specific (v1.2+)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB02" name="2FCB02"><b>2FCB02</b></a> - INT 2F - Communicating Applications Specification - ABORT CURRENT EVENT<br />
<pre>
INT 2F - Communicating Applications Specification - ABORT CURRENT EVENT
	AX = CB02h
Return: AX &gt;= 0: event handle of aborted event
	AX &lt; 0: error code (see #03048)
Note:	termination could take up to 30 seconds
SeeAlso: AX=CB08h,AX=CB10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB05" name="2FCB05"><b>2FCB05</b></a> - INT 2F - Communicating Applications Specification - FIND FIRST QUEUE ENTRY<br />
<pre>
INT 2F - Communicating Applications Specification - FIND FIRST QUEUE ENTRY
	AX = CB05h
	CX = status of events to find
	    0000h successful completion
	    0001h waiting to be processed
	    0002h number has been dialed
	    0003h connection established, sending
	    0004h connection established, receiving
	    0005h event aborted
	    FFFFh find any event, regardless of status
	    other negative values, match error code
	DH = direction
	    00h chronological order, earliest to latest
	    01h reverse chronological order, latest to earliest
	DL = queue to search
	    00h task queue
	    01h receive queue
	    02h log queue
Return: AX = 0000h successful
	    BX = event handle for found event
	AX &lt; 0	   error code (see #03048)
SeeAlso: AX=CB06h,AX=CB07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB06" name="2FCB06"><b>2FCB06</b></a> - INT 2F - Communicating Applications Specification - FIND NEXT QUEUE ENTRY<br />
<pre>
INT 2F - Communicating Applications Specification - FIND NEXT QUEUE ENTRY
	AX = CB06h
	DL = queue to search
	    00h task queue
	    01h receive queue
	    02h log queue
Return: AX = 0000h successful
	    BX = event handle for found event
	AX &lt; 0	   error code (see #03048)
Note:	direction of search is same as preceding FIND FIRST call
SeeAlso: AX=CB05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB07" name="2FCB07"><b>2FCB07</b></a> - INT 2F - Communicating Applications Specification - OPEN FILE<br />
<pre>
INT 2F - Communicating Applications Specification - OPEN FILE
	AX = CB07h
	BX = event handle from find (AL=05h,06h) or submit task (AL=01h)
	CX = receive file number (ignored for task queue and log queue)
	    0000h  open receive control file
	    N	   open Nth received data file
	DL = queue
	    00h task queue
	    01h receive queue control file or received file, as given by CX
	    02h log queue
	    03h group file in task queue (v1.2+)
	    04h group file in log queue (v1.2+)
Return: AX = 0000h successful
	    BX = DOS file handle for requested file
	AX &lt; 0	   error code (see #03048)
Note:	the returned file handle has been opened in read-only mode and should
	  be closed with INT 21/AH=3Eh after use
SeeAlso: AX=CB01h,AX=CB05h,AX=CB14h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB08" name="2FCB08"><b>2FCB08</b></a> - INT 2F - Communicating Applications Specification - DELETE FILE<br />
<pre>
INT 2F - Communicating Applications Specification - DELETE FILE
	AX = CB08h
	BX = event handle
	CX = receive file number
	    0000h delete ALL received files and receive control file
	    N	  delete Nth received file
	DL = queue
	    00h delete control file in task queue and corresponding group file
		  if it exists
	    01h delete file in receive queue, as given by CX
	    02h delete control file in log queue (individual deletions not
		  recommended, to maintain integrity of log) and corresponding
		  group file if it exists
Return: AX = 0000h successful
	AX &lt; 0	   error code (see #03048)
SeeAlso: AX=CB02h,AX=CB09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB09" name="2FCB09"><b>2FCB09</b></a> - INT 2F - Communicating Applications Specification - DELETE ALL FILES IN Q<br />
<pre>
INT 2F - Communicating Applications Specification - DELETE ALL FILES IN Q
	AX = CB09h
	DL = queue
	    00h delete all control files in task queue, including all group
		  files
	    01h delete all files in receive queue
	    02h delete all control files in log queue, including all group
		  files
Return: AX = 0000h successful
	AX &lt; 0	   error code (see #03048)
SeeAlso: AX=CB08h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB0A" name="2FCB0A"><b>2FCB0A</b></a> - INT 2F - Communicating Applications Specification - GET EVENT DATE<br />
<pre>
INT 2F - Communicating Applications Specification - GET EVENT DATE
	AX = CB0Ah
	BX = event handle
	DL = queue
	    00h task queue
	    01h receive queue
	    02h log queue
Return: AX = 0000h successful
	    CX = year
	    DH = month
	    DL = day
	AX &lt; 0	   error code (see #03048)
SeeAlso: AX=CB0Bh,AX=CB0Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB0B" name="2FCB0B"><b>2FCB0B</b></a> - INT 2F - Communicating Applications Specification - SET TASK DATE<br />
<pre>
INT 2F - Communicating Applications Specification - SET TASK DATE
	AX = CB0Bh
	BX = event handle (task event only)
	CX = year
	DH = month
	DL = day
Return: AX = 0000h successful
	AX &lt; 0	   error code (see #03048)
Note:	setting a task's date and time to before the current date and time
	  causes it to execute immediately
SeeAlso: AX=CB01h,AX=CB0Ah,AX=CB0Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB0C" name="2FCB0C"><b>2FCB0C</b></a> - INT 2F - Communicating Applications Specification - GET EVENT TIME<br />
<pre>
INT 2F - Communicating Applications Specification - GET EVENT TIME
	AX = CB0Ch
	BX = event handle
	DL = queue
	    00h task queue
	    01h receive queue
	    02h log queue
Return: AX = 0000h successful
	    CH = hour
	    CL = minute
	    DH = second
	    DL = 00h
	AX &lt; 0	   error code (see #03048)
SeeAlso: AX=CB0Ah,AX=CB0Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB0D" name="2FCB0D"><b>2FCB0D</b></a> - INT 2F - Communicating Applications Specification - SET TASK TIME<br />
<pre>
INT 2F - Communicating Applications Specification - SET TASK TIME
	AX = CB0Dh
	BX = event handle (task events only)
	CH = hour
	CL = minute
	DH = second
	DL unused
Return: AX = 0000h successful
	AX &lt; 0	   error code (see #03048)
Note:	setting a task's date and time to before the current date and time
	  causes it to execute immediately
SeeAlso: AX=CB0Bh,AX=CB0Ch,AX=CB10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB0E" name="2FCB0E"><b>2FCB0E</b></a> - INT 2F - Communicating Applications Specification - GET EXTERNAL DATA BLOCK<br />
<pre>
INT 2F - Communicating Applications Specification - GET EXTERNAL DATA BLOCK
	AX = CB0Eh
	DS:DX -&gt; 256-byte buffer for external data block (see #03049)
Return: AX = 0000h successful
	    DS:DX buffer filled
	AX &lt; 0	   error code (see #03048)

Format of CAS external data block:
Offset	Size	Description	(Table 03049)
 00h	BYTE	CAS major version
 01h	BYTE	CAS minor version
 02h 68 BYTEs	ASCIZ path to directory containing CAS software, ends in slash
 46h 13 BYTEs	ASCIZ name of current phonebook (in CAS directory)
 53h 13 BYTEs	ASCIZ name of current logo file (in CAS directory)
 60h 32 BYTEs	ASCIZ default sender name
 80h 21 BYTEs	ASCIZ CCITT identification of fax device
 95h 107 BYTEs	reserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB0F" name="2FCB0F"><b>2FCB0F</b></a> - INT 2F - Communicating Applications Specification - GET/SET AUTORECEIVE<br />
<pre>
INT 2F - Communicating Applications Specification - GET/SET AUTORECEIVE
	AX = CB0Fh
	DL = subfunction
	    00h get current autoreceive state
	    01h set autoreceive state
		DH = number of rings before answer, 00h = never
Return: AX = 0000h autoreceive disabled
	AX = N	   number of rings before answer
	AX &lt; 0	   error code (see #03048)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB10" name="2FCB10"><b>2FCB10</b></a> - INT 2F - Communicating Applications Specification - GET CURRENT EVENT STATUS<br />
<pre>
INT 2F - Communicating Applications Specification - GET CURRENT EVENT STATUS
	AX = CB10h
	DS:DX -&gt; 512-byte buffer for status area (see #03051)
Return: AX = 0000h successful
		BX = event handle of current event or negative error code if
		      no current event
		buffer filled
	AX &lt; 0	   error code (see #03048)
SeeAlso: AX=CB02h,AX=CB0Dh

(Table 03050)
Values for CAS event type:
 00h	send
 01h	receive
 02h	polled send
 03h	polled receive
 04h to 7Fh reserved
 FFh	serious hardware error

Format of CAS status area:
Offset	Size	Description	(Table 03051)
 00h	BYTE	event type (see #03050)
 01h	BYTE	transfer type
		00h 200x200 dpi, FAX mode
		01h 100x200 dpi, FAX mode
		02h file transfer mode
		03h to 7Fh reserved
 02h	WORD	event status (see #03052)
 04h	WORD	event time (packed DOS time format, see INT 21/AX=5700h)
 06h	WORD	event date (packed DOS date format, see INT 21/AX=5700h)
 08h	WORD	number of files to transfer, max 7FFFh
 0Ah	WORD	offset of file transfer record
 0Ch 47 BYTEs	ASCIZ phone number to call
 3Bh 64 BYTEs	ASCIZ application-specific tag string
 7Bh	BYTE	reserved (00h)
 7Ch	BYTE	connect time, seconds
 7Dh	BYTE	connect time, minutes
 7Eh	BYTE	connect time, hours
 7Fh	DWORD	total number of pages in all files
 83h	DWORD	pages already transmitted
 87h	WORD	number of files already transmitted
 89h	BYTE	cover page flag
		00h don't transmit cover page
		01h transmit cover page
		02h to 7Fh reserved
 8Ah	WORD	total number of transmission errors
 8Ch 78 BYTEs	reserved (zeros)
 DAh 21 BYTEs	ASCIZ remote FAX's CCITT identification
 EFH 32 BYTEs	ASCIZ destination name
10Fh 32 BYTEs	ASCIZ sender name
12Fh 80 BYTEs	filename of PCX logo file (max 1780x800 pixels)
17Fh 128 BYTEs	file transfer record for current event (see #03053)

(Table 03052)
Values for CAS event status:
 0000h	completed successfully
 0001h	waiting
 0002h	number dialed
 0003h	connected, sending
 0004h	connected, receiving
 0005h	aborted
 0006h to 007Fh reserved
 0080h to 7FFFh application-specific events
 8000h to FFFFh error codes

Format of CAS file transfer record:
Offset	Size	Description	(Table 03053)
 00h	BYTE	file type (ignored unless FAX)
		00h ASCII
		01h PCX
		02h DCX
		03h to 7Fh reserved
 01h	BYTE	text size for ASCII FAX file
		00h = 80 columns by 66 lines (11 inches)
		01h = 132 columns by 88 lines (11 inches)
		02h to 7Fh reserved
 02h	BYTE	status of file
		00h untouched
		01h opened
		02h moved
		03h deleted
		04h not yet received
		05h to 7Fh reserved
 03h	DWORD	bytes already transmitted
 07h	DWORD	file size in bytes
 0Bh	WORD	pages alread transmitted
 0Dh	WORD	number of pages in file
 0Fh 80 BYTEs	ASCIZ filename
 5Fh	BYTE	1/8 inch page length
		if page length below set to 01h through 7Fh, this value
		  specifies additional 1/8 inch increments to page length
 60h	BYTE	page length
		00h = 11 inches
		01h to 7Fh = page length is this number of inches plus value of
			  1/8 inch field above
		80h to FEh reserved
		FFh = ASCII pages ending with formfeed
 61h 31 BYTEs	reserved (zeros)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB11" name="2FCB11"><b>2FCB11</b></a> - INT 2F - Communicating Applications Specification - GET QUEUE STATUS<br />
<pre>
INT 2F - Communicating Applications Specification - GET QUEUE STATUS
	AX = CB11h
	DL = queue to get status of
	    00h task queue
	    01h receive queue
	    02h log queue
	    03h send events (v1.2+)
	    04h receive events (v1.2+)
Return: AX &gt;= 0	 total number of changes made to queue, modulo 32768
	    BX = number of control files currently in queue
	    CX = number of received files (zero for task and log queues)
	AX &lt; 0	error code (see #03048)
SeeAlso: AX=CB12h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB11DL03" name="2FCB11DL03"><b>2FCB11DL03</b></a> - INT 2F - Communicating Applications Spec v1.2+ - GET NUMBER OF SEND EVENTS<br />
<pre>
INT 2F - Communicating Applications Spec v1.2+ - GET NUMBER OF SEND EVENTS
	AX = CB11h
	DL = 03h
Return: AX = number of successful sends since resident manager started
	BX = number of unsuccessful sends, including warnings
SeeAlso: AX=CB11h/DL=04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB11DL04" name="2FCB11DL04"><b>2FCB11DL04</b></a> - INT 2F - Communicating Applications Spec v1.2+ - GET NUMBER OF RECEIVE EVENTS<br />
<pre>
INT 2F - Communicating Applications Spec v1.2+ - GET NUMBER OF RECEIVE EVENTS
	AX = CB11h
	DL = 04h
Return: AX = number of received file events since resident manager started
	BX = number of received FAX events
SeeAlso: AX=CB11h/DL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB12" name="2FCB12"><b>2FCB12</b></a> - INT 2F - Communicating Applications Specification - GET HARDWARE STATUS<br />
<pre>
INT 2F - Communicating Applications Specification - GET HARDWARE STATUS
	AX = CB12h
	DS:DX -&gt; 128-byte status buffer (see #03054,#03056)
Return: AX = 0000h successful
	    DS:DX buffer filled with hardware-dependent status information
	   &lt; 0	   error code (see #03048)
SeeAlso: AX=CB10h,AX=CB11h

Format of status buffer for Intel Connection CoProcessor:
Offset	Size	Description	(Table 03054)
 00h	BYTE	Connection CoProcessor connection status flags (see #03057)
 01h	BYTE	number of kilobytes of free buffer space
 02h	BYTE	page buffer status
		bit 7: Connection CoProcessor has documents to send
		bits 6-0: number of pages in buffer
 03h	BYTE	number of retries left for dialing number
 04h	BYTE	page number to retransmit
 05h	BYTE	communications status (see #03058)
 06h	BYTE	baud rate (see #03055)
 07h  3 BYTEs	reserved
 0Ah	BYTE	Connection CoProcessor hardware status (see #03059)
 0Bh	BYTE	Connection CoProcessor switch states (see #03060)
 0Ch	BYTE	communications flags (see #03061)
 0Dh	BYTE	reserved
 0Eh	WORD	error count (only valid while busy, reset when idle)
 10h	DWORD	size of nonstandard format (NSF) file in bytes
 14h	BYTE	'A' if Connection CoProcessor board present
 15h  9 BYTEs	reserved
 1Eh 21 BYTEs	ASCIZ CCITT identification
 33h 77 BYTEs	reserved
Note:	the Intel Connection CoProcessor and SatisFAXtion may be distinguished
	  by examining the byte at offset 14h

Bitfields for Connection CoProcessor baud rate:
Bit(s)	Description	(Table 03055)
 7	reserved
 6-4	baud rate
	000 = 300 baud	(V.21 SDLC or HDLC mode)
	100 = 2400 baud (V.27 ter)
	101 = 4800 baud (V.27 ter)
	110 = 7200 baud (V.29)
	111 = 9600 baud (V.29)
 3-0	reserved, should be 0110

Format of status buffer for Intel SatisFAXtion board:
Offset	Size	Description	(Table 03056)
 00h	BYTE	SatisFAXtion connection status flags (see #03062)
 01h	BYTE	SatisFAXtion board state (see #03063)
 02h	BYTE	number of KB free in buffer
 03h	BYTE	number of pages or files in buffer
 04h	BYTE	number of redials remaining on current number
 05h	BYTE	FAX page number to retransmit
 06h	BYTE	current page/file in block transfer
 07h	BYTE	number of rings received (only if auto-answer enabled)
 08h	WORD	error count
 0Ah	DWORD	length of file being transferred
 0Eh  6 BYTEs	reserved
 14h	BYTE	'B' if SatisFAXtion board present
 15h 13 BYTEs	ASCIZ transfer agent name
 22h  5 BYTEs	ASCIZ transfer agent version number
 27h 13 BYTEs	ASCIZ resident loader name
 34h  5 BYTEs	ASCIZ resident loader version number
 39h 21 BYTEs	ASCIZ remote CSID
 4Eh 13 BYTEs	ASCIZ resident manager name
 5Bh  5 BYTEs	ASCIZ resident manager version number
 60h 32 BYTEs	reserved
Note:	the Intel Connection CoProcessor and SatisFAXtion may be distinguished
	  by examining the byte at offset 14h

Bitfields for Connection CoProcessor connection status flags:
Bit(s)	Description	(Table 03057)
 7	hardware busy sending or receiving
 6	last page of data
 5	no data on current page
 4	retransmit request for current page being transmitted
 3	NSF (nonstandard file) mode active
 2-0	reserved

Bitfields for communications status:
Bit(s)	Description	(Table 03058)
 7	originating call
 6	FAX message to be sent
 5	on line
 4	ring detected and receive enabled
 3	buffer dumped on receive
 2-0	hardware sequence state
	000 idle
	001 dial
	010 answer
	011 transmit
	100 receive
	101 pre-message
	110 post-message
	111 disconnect

Bitfields for Connection CoProcessor hardware status:
Bit(s)	Description	(Table 03059)
 7	modem option installed
 6	Connection CoProcessor has control of DAA (not latched)
 5	on line (not latched)
 4	ring detected (not latched)
 3	data in command buffer (not latched)
 2	set if using DMA channel 1, clear if using DMA channel 3
 1	line length compensation 1 set (not latched)
 0	line length compensation 0 set (not latched)

Bitfields for Connection CoProcessor switch states:
Bit(s)	Description	(Table 03060)
 7	reserved
 6	unused
 5	spare switch open
 4	FAX ADR1 switch open
 3	FAX ADR0 switch open
 2	alternate interrupt switch open
 1	COM SEL 1 switch open
 0	COM SEL 0 switch open
Note:	valid combinations of 0-2 are
	000  COM2 IRQ3 IObase 2F8h
	001  COM1 IRQ4 IObase 3F8h
	010  COM4 IRQ3 IObase 2E8h
	011  COM3 IRQ4 IObase 3E8h
	110  COM4 IRQ2 IObase 2E8h
	111  COM3 IRQ5 IObase 3E8h

Bitfields for communications flags:
Bit(s)	Description	(Table 03061)
 7	reserved
 6	auxiliary relay forced ON
 5	modem select relay forced ON
 4	offhook relay forced ON
 3	9600 bps enabled
 2	7200 bps enabled
 1	4800 bps enabled
 0	2400 bps enabled

Bitfields for SatisFAXtion connection status flags:
Bit(s)	Description	(Table 03062)
 7	busy in T.30 CCITT fax protocol
 6	data on current page/file (only used for block xfers)
 5	retransmission of last page requested
 4	in file transfer mode
 3	data in buffer
 2	data buffer dumped on receive
 1	200x100 dpi resolution instead of 200x200 dpi
 0	data modem in use, FAX image modem not available

Bitfields for SatisFAXtion board state:
Bit(s)	Description	(Table 03063)
 7	reserved
 6	handset jack active, data and FAX modems not available
 5-3	current rate
	000  300 bps (V.21 HDLC)
	100 2400 bps (V.27 ter)
	101 4800 bps (V.27 ter)
	110 7200 bps (V.29)
	111 9600 bps (V.29)
 2-0	T.30 CCITT protocol state
	000 idle
	001 dialing
	010 answering
	011 transmitting
	100 receiving
	101 pre-message
	110 post-message
	111 disconnect

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB13DL00" name="2FCB13DL00"><b>2FCB13DL00</b></a> - INT 2F - Communicating Applications Specification - GET DIAGNOSTICS RESULTS<br />
<pre>
INT 2F - Communicating Applications Specification - GET DIAGNOSTICS RESULTS
	AX = CB13h
	DL = 00h
Return: AX = 0040h in progress
	   &gt;= 0	   passed
	   &lt; 0	   hardware-dependent failure code (see #03064,#03065)
SeeAlso: AX=CB13h/DL=01h

Bitfields for Intel Connection CoProcessor failure codes:
Bit(s)	Description	(Table 03064)
 3	9600 bps FAX modem module failed
 2	SDLC chip failed
 1	RAM failed
 0	ROM checksum failed

Bitfields for Intel SatisFAXtion failure codes:
Bit(s)	Description	(Table 03065)
 1	2400 bps data modem failed
 0	9600 bps FAX modem failed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB13DL01" name="2FCB13DL01"><b>2FCB13DL01</b></a> - INT 2F - Communicating Applications Specification - START DIAGNOSTICS<br />
<pre>
INT 2F - Communicating Applications Specification - START DIAGNOSTICS
	AX = CB13h
	DL = 01h
Return: AX = 0000h successfully started
	AX &lt; 0	   error code (see #03048)
SeeAlso: AX=CB13h/DL=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB14" name="2FCB14"><b>2FCB14</b></a> - INT 2F - Communicating Applications Specification - MOVE RECEIVED FILE<br />
<pre>
INT 2F - Communicating Applications Specification - MOVE RECEIVED FILE
	AX = CB14h
	BX = event handle
	CX = receive file number
	    0001h first received file
	    N	  Nth received file
	DS:DX -&gt; ASCIZ string specifying new name for file (must not exist)
Return: AX = 0000h successful
	AX &lt; 0	   error code (see #03048)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB15" name="2FCB15"><b>2FCB15</b></a> - INT 2F - Communicating Applications Specification - SUBMIT FILE TO SEND<br />
<pre>
INT 2F - Communicating Applications Specification - SUBMIT FILE TO SEND
	AX = CB15h
	DS:DX -&gt; variable-length data area (see #03066)
Return: AX &gt;= 0 event handle
	AX &lt; 0	error code (see #03048)
SeeAlso: AX=CB01h

Format of CAS file submission data area:
Offset	Size	Description	(Table 03066)
 00h	BYTE	transfer type
		00h = 200x200 dpi, fax mode
		01h = 100x200 dpi, fax mode
		02h = file transfer mode
		03h to 7Fh reserved
 01h	BYTE	text size
		00h = 80 columns
		01h = 132 columns
		02h to 7Fh reserved
 02h	WORD	time to send (DOS packed time, see #01665 at INT 21/AX=5700h)
 04h	WORD	date to send (DOS packed date, see #01666 at INT 21/AX=5700h)
 06h 32 BYTEs	ASCIZ destination name
 26h 80 BYTEs	ASCIZ name of file to send
 76h 47 BYTEs	ASCIZ phone number to dial
 A5h 64 BYTEs	ASCIZ application-specific tag string
 E5h	BYTE	reserved (00h)
 E6h	BYTE	cover page
		00h don't send cover page
		01h send cover page
		02h to 7Fh reserved
 E7h 23 BYTEs	reserved (zeros)
 FEh variable	ASCIZ string containing text of cover page (if cover page flag
		set to 01h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB16BX1234" name="2FCB16BX1234"><b>2FCB16BX1234</b></a> - INT 2F - Communicating Applications Spec v1.2+ - UNLOAD RESIDENT MANAGER<br />
<pre>
INT 2F - Communicating Applications Spec v1.2+ - UNLOAD RESIDENT MANAGER
	AX = CB16h
	BX = 1234h
	CX = 5678h
	DX = 9ABCh
Return: AX = 0000h successful
	AX &lt; 0	   error code
Note:	the METZ XpressFax CASMGR ignores the values in BX,CX, and DX
SeeAlso: AX=C000h/BX=444Bh,AX=CB00h
Index:	uninstall;CAS Manager

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB17" name="2FCB17"><b>2FCB17</b></a> - INT 2F - Communicating Applications Spec v1.2+ - SET COVER PAGE STATUS<br />
<pre>
INT 2F - Communicating Applications Spec v1.2+ - SET COVER PAGE STATUS
	AX = CB17h
	BX = event handle
	CL = cover page status
	    00h not read
	    01h read by user
Return: AX = 0000h successful
	AX &lt; 0	   error code

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB80" name="2FCB80"><b>2FCB80</b></a> - INT 2F - Intel SatisFAXtion CASMGR - ???<br />
<pre>
INT 2F - Intel SatisFAXtion CASMGR - ???
	AX = CB80h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB81" name="2FCB81"><b>2FCB81</b></a> - INT 2F - Intel SatisFAXtion CASMGR - ???<br />
<pre>
INT 2F - Intel SatisFAXtion CASMGR - ???
	AX = CB81h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCB82" name="2FCB82"><b>2FCB82</b></a> - INT 2F - Intel SatisFAXtion CASMGR - ???<br />
<pre>
INT 2F - Intel SatisFAXtion CASMGR - ???
	AX = CB82h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCBDCBL56" name="2FCBDCBL56"><b>2FCBDCBL56</b></a> - INT 2F - Comwave Microfax Specification - GET STATUS ARRAY<br />
<pre>
INT 2F - Comwave Microfax Specification - GET STATUS ARRAY
	AX = CBDCh
	BL = 56h
	BH = line number (starts with 1)
	CX:DX -&gt; 32-byte status buffer or 80 character string
Return: AX = number of cards installed, or FFFFh on error
Program: Comwave manufacturers the Microfax line of fax cards which are a
	  high-performance multi-card FAX solution for OEMs.
Note:	defaults to AH=CBh but can be changed
SeeAlso: AX=CBDDh,AX=DA00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCBDDBL56" name="2FCBDDBL56"><b>2FCBDDBL56</b></a> - INT 2F - Comwave Microfax Specification - COMMAND SUBMISSION<br />
<pre>
INT 2F - Comwave Microfax Specification - COMMAND SUBMISSION
	AX = CBDDh
	BL = 56h
	BH = ?
	CX:DX -&gt; command to execute
Return: AX = status
	    0000h success
	    FFFFh on error
SeeAlso: AH=2Ah,AX=CBDCh,AX=80FBh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCC--SI5453" name="2FCC--SI5453"><b>2FCC--SI5453</b></a> - INT 2F U - PC-Kwik Programs - API<br />
<pre>
INT 2F U - PC-Kwik Programs - API
	AH = CCh
	SI = 5453h or 7473h
	AL = function number (at least 00h,01h,04h,05h,07h,80h)
	DL = program identifier (see #03067)
Return: SI = 7473h
	other registers vary by function
Note:	Qualitas Qcache v4.00 is an OEM version of Super PC-Kwik v4.00, and
	  thus supports this call
SeeAlso: INT 21/AH=2Bh/CX=4358h

(Table 03067)
Values for PC-Kwik program identifier:
 00h	all installed PowerPak programs
 01h	SUPERPCK/SUPER/QCACHE v4.00+ (disk cache)
 02h	PCKSPL (print spooler)
 04h	PCKSCRN (screen accelerator)
 05h	PCKKEY (keyboard enhancer)
 06h	PCKRAMD (RAM disk)
 08h	PCKWIK.SYS
 10h	PCKCDROM (CD-ROM support for SUPERPCK)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCC00" name="2FCC00"><b>2FCC00</b></a> - INT 2F - Tsoft NFSDRVR - INSTALLATION CHECK<br />
<pre>
INT 2F - Tsoft NFSDRVR - INSTALLATION CHECK
	AX = CC00h
Return: AX = 7777h
	BX = ???
	CX = ???
	DX = ???
	ES = data segment of resident portion
SeeAlso: AX=CC01h,AX=CC06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCC01" name="2FCC01"><b>2FCC01</b></a> - INT 2F - Tsoft NFSDRVR - ???<br />
<pre>
INT 2F - Tsoft NFSDRVR - ???
	AX = CC01h
	???
Return: ???
SeeAlso: AX=CC00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCC02" name="2FCC02"><b>2FCC02</b></a> - INT 2F - Tsoft NFSDRVR - ???<br />
<pre>
INT 2F - Tsoft NFSDRVR - ???
	AX = CC02h
	???
Return: ???
SeeAlso: AX=CC00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCC03" name="2FCC03"><b>2FCC03</b></a> - INT 2F - Tsoft NFSDRVR - ???<br />
<pre>
INT 2F - Tsoft NFSDRVR - ???
	AX = CC03h
	???
Return: ???
SeeAlso: AX=CC00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCC04" name="2FCC04"><b>2FCC04</b></a> - INT 2F - Tsoft NFSDRVR - ???<br />
<pre>
INT 2F - Tsoft NFSDRVR - ???
	AX = CC04h
	???
Return: ???
SeeAlso: AX=CC00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCC05" name="2FCC05"><b>2FCC05</b></a> - INT 2F - Tsoft NFSDRVR - ???<br />
<pre>
INT 2F - Tsoft NFSDRVR - ???
	AX = CC05h
	???
Return: ???
SeeAlso: AX=CC00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCC06" name="2FCC06"><b>2FCC06</b></a> - INT 2F - Tsoft NFSDRVR - ???<br />
<pre>
INT 2F - Tsoft NFSDRVR - ???
	AX = CC06h
	???
Return: ???
SeeAlso: AX=CC00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD00" name="2FCD00"><b>2FCD00</b></a> - INT 2F - Intel Image Processing Interface - INSTALLATION CHECK<br />
<pre>
INT 2F - Intel Image Processing Interface - INSTALLATION CHECK
	AX = CD00h
Return: AL = state
	    00h not installed, OK to install
	    01h not installed, not OK to install
	    FFh installed
SeeAlso: AX=CD02h"Image"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD00_0" name="2FCD00_0"><b>2FCD00</b></a> - INT 2F - LaserPort Interface - INSTALLATION CHECK<br />
<pre>
INT 2F - LaserPort Interface - INSTALLATION CHECK
	AX = CD00h
Return: AL = status
	    FFh installed
SeeAlso: AX=CD0Fh"LaserPort"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD00_1" name="2FCD00_1"><b>2FCD00</b></a> - INT 2F - SWELL.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F - SWELL.EXE - INSTALLATION CHECK
	AX = CD00h
Return: AX = 00FFh installed
	    BH = major version
	    BL = minor version
Program: SWELL.EXE is a TSR which swaps programs to disk when they EXEC a
	  child process with INT 21/AH=4Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD00BX464F" name="2FCD00BX464F"><b>2FCD00BX464F</b></a> - INT 2F - Forte/Gravis ULTRAMID - INSTALLATION CHECK<br />
<pre>
INT 2F - Forte/Gravis ULTRAMID - INSTALLATION CHECK
	AX = CD00h
	BX = 464Fh ('FO')
	CX = 5254h ('RT')
	DX = 4520h ('E ')
Return: AL = FFh if installed
	    BX = 4155h ('AU')
	    CX = 4449h ('DI')
	    DX = 4F20h ('O ')
	    ES:SI -&gt; program ID string
Program: ULTRAMID is a MIDI driver for the Gravis UltraSound which allows use
	  of AIL drivers with other software
Range:	AH=CDh-ECh, selected by scanning for an available multiplex number
SeeAlso: INT 21/AX=FD12h,AX=CD00h/DX=4957h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD00DX4957" name="2FCD00DX4957"><b>2FCD00DX4957</b></a> - INT 2F R - InterWave Game API - INSTALLATION CHECK<br />
<pre>
INT 2F R - InterWave Game API - INSTALLATION CHECK
	AX = CD00h
	DX = 4957h ('IW')
	SI = 5645h ('VE')
Return: AL = FFh if installed
	    DX = 4554h ('ET')
	    SI = 454Bh ('EK')
Range:	AH=CDh-ECh, selected by scanning for an available multiplex number
SeeAlso: AX=CD00h/BX=464Fh,AX=CD01h"InterWave",AX=CD21h"InterWave"
SeeAlso: AX=CD80h"InterWave"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD01" name="2FCD01"><b>2FCD01</b></a> - INT 2F - Intel Image Processing Interface - SET DEVICE NAME<br />
<pre>
INT 2F - Intel Image Processing Interface - SET DEVICE NAME
	AX = CD01h
	CX:BX -&gt; ASCIZ character device name ("LPTn", "COMn", "PRN")
Return: AL = status
	    00h successful
		CX:BX -&gt; internal character device name
	    80h error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD01_0" name="2FCD01_0"><b>2FCD01</b></a> - INT 2F - SWELL.EXE - SUSPEND ONCE<br />
<pre>
INT 2F - SWELL.EXE - SUSPEND ONCE
	AX = CD01h
Return: AX = 0000h
SeeAlso: AX=CD02h"SWELL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD01BX0000" name="2FCD01BX0000"><b>2FCD01BX0000</b></a> - INT 2F R - InterWave Game API - GET NUMBER OF INTERWAVE PROGRAMS / PROGRAM ID<br />
<pre>
INT 2F R - InterWave Game API - GET NUMBER OF INTERWAVE PROGRAMS / PROGRAM ID
	AX = CD01h
	BX = 0000h
Return: BX = number of programs currently installed on the Game API
Desc:	get the number of programs supporting the InterWave Game API which are
	  currently installed in memory, which also forms the next program ID
	  number if the caller wishes to go resident on the API
Range:	AH=CDh-ECh, selected by scanning for an available multiplex number
Notes:	the first program to install on the IW Game API must use ID 00h
	the AMD-recommended implementation is for the handler to increment
	  BX and chain to the previous handler (if any), but this will fail
	  if TSRs are unloaded out-of-order
SeeAlso: AX=CD00h"InterWave",AX=CD02h"InterWave",AX=CD03h"InterWave"
SeeAlso: AX=CD05h"InterWave",AX=CD21h"InterWave",AX=CD80h"InterWave"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD02" name="2FCD02"><b>2FCD02</b></a> - INT 2F - Intel Image Processing Interface - GET VERSION NUMBER<br />
<pre>
INT 2F - Intel Image Processing Interface - GET VERSION NUMBER
	AX = CD02h
Return: AL = status
	    00h/01h successful
		BH = major version number (BCD)
		BL = minor version number (BCD)
	    80h error
Note:	if return AL = 01h, the IPI supports network redirection
SeeAlso: AX=CD00h"Image"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD02_0" name="2FCD02_0"><b>2FCD02</b></a> - INT 2F - SWELL.EXE - SUSPEND<br />
<pre>
INT 2F - SWELL.EXE - SUSPEND
	AX = CD02h
Return: AX = 0000h
SeeAlso: AX=CD03h"SWELL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD02_1" name="2FCD02_1"><b>2FCD02</b></a> - INT 2F R - InterWave Game API - GET PROGRAM STATUS AND INFORMATION<br />
<pre>
INT 2F R - InterWave Game API - GET PROGRAM STATUS AND INFORMATION
	AX = CD02h
	BX = program identifier
Return: CX = program status
	    bit 0: using synthesizer
	    bit 1: using Codec
	    bit 2: supports at least one Game Device (see AX=CD21h,AX=CD22h)
	BX = supported API version (BCD, BH=major, BL=minor) if CX bit 2 set
	ES:DI -&gt; ASCIZ identification string
Range:	AH=CDh-ECh, selected by scanning for an available multiplex number
Note:	ordinarily, an application will loop through all valid program
	  identifiers (as returned by AX=CD01h); if any of the installed
	  programs conflicts with the use the caller wishes to make of the
	  InterWave chip, it should be disabled with AX=CD03h first
SeeAlso: AX=CD00h"InterWave",AX=CD01h"InterWave",AX=CD03h"InterWave"
SeeAlso: AX=CD05h"InterWave",AX=CD21h"InterWave",AX=CD80h"InterWave"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD03" name="2FCD03"><b>2FCD03</b></a> - INT 2F - Intel Image Processing Interface - SELECT SCAN LINE<br />
<pre>
INT 2F - Intel Image Processing Interface - SELECT SCAN LINE
	AX = CD03h
	BX = scan line
	CX = requested density in dots per inch (300, 600, or 1200)
Return: AL = status (see also AX=CD04h"Image")
	    00h successful
		CX = density at which scan line was mapped
		ES:DI -&gt; start of scan line
	    80h unsuccessful
	    81h scan line out of range
	    82h unsupported scan line density
	    83h out of memory
SeeAlso: AX=CD04h"Image"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD03_0" name="2FCD03_0"><b>2FCD03</b></a> - INT 2F - SWELL.EXE - ACTIVATE<br />
<pre>
INT 2F - SWELL.EXE - ACTIVATE
	AX = CD03h
Return: AX = 0000h
SeeAlso: AX=CD02h"SWELL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD03_1" name="2FCD03_1"><b>2FCD03</b></a> - INT 2F R - InterWave Game API - SUSPEND PROGRAM<br />
<pre>
INT 2F R - InterWave Game API - SUSPEND PROGRAM
	AX = CD03h
	BX = installed program identifier
	CX = InterWave section to be released
	    0000h all
	    0001h synthesizer
	    0002h Codec
Return: AL = status
	    00h successful
		BX = base port
		CL = IRQ
		CH = DMA channel (Codec only)
	    else failed
SeeAlso: AX=CD00h"InterWave",AX=CD01h"InterWave",AX=CD02h"InterWave"
SeeAlso: AX=CD04h"InterWave",AX=CD21h"InterWave",AX=CD80h"InterWave"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD04" name="2FCD04"><b>2FCD04</b></a> - INT 2F - Intel Image Processing Interface - MOVE BITMAP TO SCANLINE<br />
<pre>
INT 2F - Intel Image Processing Interface - MOVE BITMAP TO SCANLINE
	AX = CD04h
	CX:BX -&gt; structure (see #03069)
Return: AL = status (see #03068)
SeeAlso: AX=CD03h"Image"

(Table 03068)
Values for IPI function status:
 00h	successful
 80h	unsuccessful
 81h	scan line out of range
 82h	unsupported scan line density
 83h	out of memory
 84h	unrecognized source
 85h	initialization error

Format of structure:
Offset	Size	Description	(Table 03069)
 00h	WORD	image source (0 = conventional memory, 1 = expanded memory)
 02h	DWORD	pointer to image data
 06h	WORD	scan line on which to place
 08h	WORD	bit offset from start of scan line at which to place
 0Ah	WORD	density of bitmap data (300, 600, or 1200 dpi)
 0Ch	WORD	width in bits of data
 0Eh	WORD	source logical page number
 10h	WORD	source handle (only if source in expanded memory)
 12h	WORD	source offset (only if source in expanded memory)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD04_0" name="2FCD04_0"><b>2FCD04</b></a> - INT 2F - SWELL.EXE - TURN OFF VERBOSE MODE<br />
<pre>
INT 2F - SWELL.EXE - TURN OFF VERBOSE MODE
	AX = CD04h
Return: AX = 0000h
SeeAlso: AX=CD05h"SWELL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD04_1" name="2FCD04_1"><b>2FCD04</b></a> - INT 2F R - InterWave Game API - WAKE PROGRAM<br />
<pre>
INT 2F R - InterWave Game API - WAKE PROGRAM
	AX = CD04h
	BX = installed program identifier
Return: AL = status
	    00h successful
	    else failed
Note:	this function should only be called after the program has been
	  suspended with AX=CD03h
SeeAlso: AX=CD00h"InterWave",AX=CD01h"InterWave",AX=CD03h"InterWave"
SeeAlso: AX=CD05h"InterWave",AX=CD21h"InterWave",AX=CD80h"InterWave"
SeeAlso: INT 7E/AL=84h"IWSBSDRV"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD05" name="2FCD05"><b>2FCD05</b></a> - INT 2F - Intel Image Processing Interface - PRINT PAGE<br />
<pre>
INT 2F - Intel Image Processing Interface - PRINT PAGE
	AX = CD05h
Return: AL = status (00h,80h) (see #03068)
Note:	page image is retained, so multiple calls will print multiple copies of
	  the page
SeeAlso: AX=CD06h"Image"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD05_0" name="2FCD05_0"><b>2FCD05</b></a> - INT 2F - SWELL.EXE - TURN ON VERBOSE MODE<br />
<pre>
INT 2F - SWELL.EXE - TURN ON VERBOSE MODE
	AX = CD05h
Return: AX = 0000h
SeeAlso: AX=CD04h"SWELL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD05_1" name="2FCD05_1"><b>2FCD05</b></a> - INT 2F R - InterWave Game API - UNINSTALL RESIDENT DEVICE DRIVER<br />
<pre>
INT 2F R - InterWave Game API - UNINSTALL RESIDENT DEVICE DRIVER
	AX = CD05h
	BX = installed program identifier
Return: AL = status
	    00h successful
	    else failed
SeeAlso: AX=CD00h"InterWave",AX=CD01h"InterWave",AX=CD02h"InterWave"
SeeAlso: AX=CD03h"InterWave",AX=CD21h"InterWave",AX=CD80h"InterWave"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD06" name="2FCD06"><b>2FCD06</b></a> - INT 2F - Intel Image Processing Interface - CLEAR PAGE<br />
<pre>
INT 2F - Intel Image Processing Interface - CLEAR PAGE
	AX = CD06h
Return: AL = status (00h,80h) (see #03068)
Note:	palette is reset to default
SeeAlso: AX=CD09h"Image"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD06_0" name="2FCD06_0"><b>2FCD06</b></a> - INT 2F - SWELL.EXE - UNINSTALL<br />
<pre>
INT 2F - SWELL.EXE - UNINSTALL
	AX = CD06h
Return: AX = status
	    0000h uninstalled
	    8002h programs still swapped, not uninstalled

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD07" name="2FCD07"><b>2FCD07</b></a> - INT 2F - Intel Image Processing Interface - reserved<br />
<pre>
INT 2F - Intel Image Processing Interface - reserved
	AX = CD07h
SeeAlso: AX=CD00h"Image"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD07_0" name="2FCD07_0"><b>2FCD07</b></a> - INT 2F - SWELL.EXE - GET INFO<br />
<pre>
INT 2F - SWELL.EXE - GET INFO
	AX = CD07h
	ES:BX -&gt; 32-byte buffer for info (see #03070)
Return: AX = status
	    0000h successful
		ES:BX buffer filled
	    8001h buffer wrong size

Format of SWELL.EXE info buffer:
Offset	Size	Description	(Table 03070)
 00h	WORD	20h  (total size of buffer)
 02h	BYTE	suspend-once mode active if nonzero
 03h	BYTE	00h active, 01h suspended
 04h	BYTE	00h quiet, 01h verbose
 05h	BYTE	"Borland support" (allowing INT 21/AX=4B01h) on if nonzero
 06h 26 BYTEs	unused???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD08" name="2FCD08"><b>2FCD08</b></a> - INT 2F - Intel Image Processing Interface - SCREEN IMAGE<br />
<pre>
INT 2F - Intel Image Processing Interface - SCREEN IMAGE
	AX = CD08h
	CX:BX -&gt; structure (see #03071)
Return: AL = status (00h,80h-85h) (see #03068)
SeeAlso: AX=CD05h"Image",AX=CD09h"Image"

Format of IPI screen image structure:
Offset	Size	Description	(Table 03071)
 00h	WORD	image source (0 = conventional memory, 1 = expanded memory)
 02h	DWORD	pointer to image data
 06h	WORD	horizontal position on paper of left edge (in 1200 dpi units)
 08h	WORD	vertical position on paper of top edge (in 1200 dpi units)
 0Ah	WORD	left cropping (currently must be zero)
 0Ch	WORD	top cropping (currently must be zero)
 0Eh	WORD	width (currently must be 8000h)
 10h	WORD	height (currently must be 8000h)
 12h	WORD	horizontal size of image in 1200 dpi units
 14h	WORD	vertical size of image in 1200 dpi units
 16h	WORD	aspect ratio (currently reserved)
 18h	WORD	initialization flag (if 01h, initialization is performed)
 1Ah	WORD	pixels per line of source data
 1Ch	WORD	number of scan lines in source data
 1Eh	WORD	number of scan lines in packet
 20h	WORD	bits per pixel (1,2,4,6, or 8)
 22h	WORD	pixels per byte (1,2,4, or 8)
 24h	WORD	compression type (currently only 00h [uncompressed] supported)
 26h	WORD	source page number (if in expanded memory)
 28h	WORD	source handle (if in expanded memory)
 2Ah	WORD	source offset (if in expanded memory)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD08_0" name="2FCD08_0"><b>2FCD08</b></a> - INT 2F - SWELL.EXE - UNUSED<br />
<pre>
INT 2F - SWELL.EXE - UNUSED
	AX = CD08h
Return: AX = FFFFh (error)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD09" name="2FCD09"><b>2FCD09</b></a> - INT 2F - Intel Image Processing Interface - LOAD SCREEN<br />
<pre>
INT 2F - Intel Image Processing Interface - LOAD SCREEN
	AX = CD09h
	CX:BX -&gt; structure (see #03072)
Return: AL = status (00h,80h) (see #03068)
SeeAlso: AX=CD06h"Image Processing",AX=CD0Ah"Image Processing"

Format of IPI load screen structure:
Offset	Size	Description	(Table 03072)
 00h	BYTE	style
		44h ('D') diamond style
		4Ch ('L') line style
 01h	BYTE	reserved (00h)
 02h	WORD	frequency in lines per inch [sic]
		currently, coerced to nearest of 50, 60, 68, 70, 75, 85, or 100
 04h	WORD	screen angle in degrees (-360 to 360)
		currently coerced to nearest of -45, 0, 45, or 90

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD09_0" name="2FCD09_0"><b>2FCD09</b></a> - INT 2F - SWELL.EXE - TURN OFF "BORLAND SUPPORT"<br />
<pre>
INT 2F - SWELL.EXE - TURN OFF "BORLAND SUPPORT"
	AX = CD09h
Return: AX = 0000h
SeeAlso: AX=CD0Ah"SWELL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD0A" name="2FCD0A"><b>2FCD0A</b></a> - INT 2F - Intel Image Processing Interface - LOAD PALETTE<br />
<pre>
INT 2F - Intel Image Processing Interface - LOAD PALETTE
	AX = CD0Ah
	CX:BX -&gt; palette structure (see #03073)
Return: AL = status (00h,80h) (see #03068)
SeeAlso: AX=CD09h"Image Processing"

Format of IPI palette structure:
Offset	Size	Description	(Table 03073)
 00h	BYTE	bits per pixel for which palette is to be used (1,2,4,6, or 8)
 01h	2**N	palette translation values, one per possible pixel value

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD0A_0" name="2FCD0A_0"><b>2FCD0A</b></a> - INT 2F - SWELL.EXE - TURN ON "BORLAND SUPPORT"<br />
<pre>
INT 2F - SWELL.EXE - TURN ON "BORLAND SUPPORT"
	AX = CD0Ah
Return: AX = 0000h
SeeAlso: AX=CD09h"SWELL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD0F" name="2FCD0F"><b>2FCD0F</b></a> - INT 2F - LaserPort Interface - EXECUTE FUNCTION<br />
<pre>
INT 2F - LaserPort Interface - EXECUTE FUNCTION
	AX = CD0Fh
	BL = function
		01h enable
		02h disable
		03h ???
Return: AL = status
	    00h success
SeeAlso: AX=CD00h"LaserPort"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD21" name="2FCD21"><b>2FCD21</b></a> - INT 2F R - InterWave Game API - OPEN GAME DEVICE<br />
<pre>
INT 2F R - InterWave Game API - OPEN GAME DEVICE
	AX = CD21h
	BX = installed program identifier
	ES:DI -&gt; ASCIZ device name
	    "MIDISIMPLE"
	    "MIDICOMPLEX"
	    "DIRECTCODEC"
Return: AL = status
	    00h successful
		DX = device handle
		---MIDISIMPLE and MIDICOMPLEX---
		BX = real-mode interrupt number (see #03074,#03075)
		---DIRECTCODEC---
		BX = base port
		CL = IRQ
		CH = DMA channel (04h = no DMA)
		SI = size of FIFO in bytes (0000h = use DMA)
	    nonzero failed (not supported or already in use)
	AH may be destroyed
Range:	AH=CDh-ECh, selected by scanning for an available multiplex number
SeeAlso: AX=CD00h"InterWave",AX=CD01h"InterWave",AX=CD02h"InterWave"
SeeAlso: AX=CD05h"InterWave",AX=CD22h"InterWave",AX=CD80h"InterWave"

(Table 03074)
Call MIDISIMPLE with:
	EAX = function number
	    0001h MIDI byte out
		BL = MIDI byte to send
	    0002h MIDI string out
		ECX = length of MIDI string in bytes
		ES:EDI -&gt; MIDI string to send (should not include timing info)
	DX = device handle
	INT xxh (as returned by AX=CD21h)
Return: EAX = status
	    00000000h if successful
	    FFFFFFFFh on error (bad handle)
SeeAlso: #03075,INT 7E/AX=0001h"IWSBSDRV",INT 7E/AX=0002h"IWSBSDRV"

(Table 03075)
Call MIDICOMPLEX with:
	EAX = function number
	    ??? (specification is still in development)
	DX = device handle
	INT xxh (as returned by AX=CD21h)
Return: EAX = status
	    00000000h if successful
	    FFFFFFFFh on error (bad handle)
SeeAlso: #03074

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD22" name="2FCD22"><b>2FCD22</b></a> - INT 2F R - InterWave Game API - CLOSE GAME DEVICE<br />
<pre>
INT 2F R - InterWave Game API - CLOSE GAME DEVICE
	AX = CD22h
	BX = installed program identifier
	DX = device handle (from AX=CD21h)
Return: AL = status
	    00h successful
	    FFh inavlid handle or device is not open
Range:	AH=CDh-ECh, selected by scanning for an available multiplex number
SeeAlso: AX=CD00h"InterWave",AX=CD01h"InterWave",AX=CD02h"InterWave"
SeeAlso: AX=CD05h"InterWave",AX=CD21h"InterWave",AX=CD80h"InterWave"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCD80" name="2FCD80"><b>2FCD80</b></a> - INT 2F RC - InterWave Game API - MIXER SETTINGS CHANGED BROADCAST<br />
<pre>
INT 2F RC - InterWave Game API - MIXER SETTINGS CHANGED BROADCAST
	AX = CD80h
Return: nothing
Desc:	called by an application controlling the InterWave chip's mixer
	  whenever the mixer's settings are changed
Range:	AH=CDh-ECh, selected by scanning for an available multiplex number
Note:	when an application intercepts this function call, it must read the
	  new mixer settings from the InterWave chip
SeeAlso: AX=CD00h"InterWave",AX=CD01h"InterWave",AX=CD02h"InterWave"
SeeAlso: AX=CD05h"InterWave",AX=CD21h"InterWave",AX=CD22h"InterWave"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FCF00" name="2FCF00"><b>2FCF00</b></a> - INT 2F - TEMPLEXX 1.0 - INSTALLATION CHECK<br />
<pre>
INT 2F - TEMPLEXX 1.0 - INSTALLATION CHECK
	AX = CF00h
Return: AL = FFh if installed
Program: TEMPLEXX is a popup keyboard template by Henson Scientific, Inc.
Note:	values in AL other than 00h cause an immediate return without modifying
	  any registers

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD000" name="2FD000"><b>2FD000</b></a> - INT 2F C - MDEBUG display driver - GET DRIVER STATUS<br />
<pre>
INT 2F C - MDEBUG display driver - GET DRIVER STATUS
	AX = D000h
Return: CF set on error
	    all other registers must be unchanged)
	CF clear if successful
	    AL = FFh
	    AH = driver semaphor
		00h driver is not active
		01h driver is active
	    BX = CS of the driver
	    CX = driver version (CH = major, CL = minor, must be &gt;= 013Ch)
	    DL = buffer semaphor
		00h driver is not pending
		01h driver is pending between functions 02h and 03h
	    DH = show semaphor
		00h driver is not pending
		01h driver is pending between functions 04h and 05h
Program: MDEBUG is a shareware memory-resident debugging tool by Bernd
	  Schemmer, including a memory monitor, an interpreter and a
	  disassembler
Range:	AH=C0h to AH=FFh, selected by switch or programmatically
Notes:	MDEBUG can use any two consecutive multiplex numbers between C0h and
	  FFh; the default is D0h for the display driver and D1h for the
	  command driver (call INT 60/AH=00h"MDEBUG" for the actual multiplex
	  numbers used)
	this function MUST be reentrant, as MDEBUG calls it after every popup
	  before any other actions.  The handler should not change any
	  registers if the display is in an unsupported mode or in a mode
	  MDEBUG supports itself, e.g. a normal text mode with at least 80x25
	  characters (i.e. 80x43 or 132x44 (v1.60+)). In this case MDEBUG will
	  not call any of the other functions for this popup session.
	MDEBUG will not call the other functions if the returned version is
	  less than the actual version of MDEBUG.
	if the driver is reentrant, DL and DH should be 00h
SeeAlso: AX=D001h,AX=D002h,AX=D003h,AX=D004h,AX=D005h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD000_0" name="2FD000_0"><b>2FD000</b></a> - INT 2F - ZWmous - INSTALLATION CHECK<br />
<pre>
INT 2F - ZWmous - INSTALLATION CHECK
	AX = D000h
Return: AX = 5A57h ("ZW") if installed
	    BX = segment of resident code
Program: ZWmous is a shareware TSR by Zen Wu which permits the use of a mouse
	  with many non-mouse applications by entering the letter under the
	  mouse cursor on button presses
SeeAlso: INT 33/AX=0003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD000_1" name="2FD000_1"><b>2FD000</b></a> - INT 2F - Lotus CD/Networker - INSTALLATION CHECK<br />
<pre>
INT 2F - Lotus CD/Networker - INSTALLATION CHECK
	AX = D000h
Return: AL = FFh if CD/Networker TSR is loaded
	BX = 4D44h ("MD") signature
	CX = Windows mode word (from INT 2F/AX=1600h) at time of TSR load
	DX = bitmap identifying all loaded CD/Networker TSRs.
Notes:	INT 2F/AH=D0h is used by CD/Networker to communicate between a
	  resident redirector TSR and a transient program that controls the
	  TSR's CD-ROM drive emulation (volume attachments, caching, etc).
	At present there is only one CD/Networker TSR; the bitmap always = 4.
SeeAlso: AX=D002h"Lotus",INT 2F/AX=1500h"CD-ROM"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD001" name="2FD001"><b>2FD001</b></a> - INT 2F C - MDEBUG display driver - INITIALIZE DRIVER<br />
<pre>
INT 2F C - MDEBUG display driver - INITIALIZE DRIVER
	AX = D001h
Return: CF set on error
	AL = driver semaphor
	AH = buffer semaphor
Range:	AH=C0h to AH=FFh, selected by switch or programmatically
Notes:	MDEBUG calls this function after every successful call of the function
	  00h. The function should reset all internal data and the status of
	  the driver. If this function returns an error, MDEBUG will not call
	  the other functions in this popup session.
	MDEBUG can use any two consecutive multiplex numbers between C0h and
	  FFh; the default is D0h for the display driver and D1h for the
	  command driver
SeeAlso: AX=D000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD002" name="2FD002"><b>2FD002</b></a> - INT 2F C - MDEBUG display driver - SAVE GRAPHIC DATA<br />
<pre>
INT 2F C - MDEBUG display driver - SAVE GRAPHIC DATA
	AX = D002h
Return: CF set on error
	CF clear if successful
	    display memory saved and display switched to one of the text modes
	      02h, 03h or 07h.
Note:	MDEBUG calls this function only once every popup session before
	  displaying its windows.
SeeAlso: AX=D000h,AX=D003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD002BX4D44" name="2FD002BX4D44"><b>2FD002BX4D44</b></a> - INT 2F - Multiplex - Lotus CD/Networker GET DATA AREA<br />
<pre>
INT 2F - Multiplex - Lotus CD/Networker GET DATA AREA
	AX = D002h
	BX = 4D44h
	DX = bitmap identifying one loaded CD/Networker TSR
Return: ES:DI -&gt; data area owned by TSR
Note:	the format of the data area changes with each minor revision, so it
	  cannot be counted on
SeeAlso: AX=D000h"Lotus"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD003" name="2FD003"><b>2FD003</b></a> - INT 2F C - MDEBUG display driver - RESTORE GRAPHIC DATA<br />
<pre>
INT 2F C - MDEBUG display driver - RESTORE GRAPHIC DATA
	AX = D003h
Return: CF set on error
	CF clear if successful
	    display restored to the mode it was in before calling AX=D002h and
	      the display memory is restored
Note:	MDEBUG calls this function only once every popup session just before
	 it exits to normal DOS.
SeeAlso: AX=D000h,AX=D002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD004" name="2FD004"><b>2FD004</b></a> - INT 2F - MDEBUG display driver - SHOW SAVED DATA<br />
<pre>
INT 2F - MDEBUG display driver - SHOW SAVED DATA
	AX = D004h
Return: CF set on error
	CF clear if successful
	    display switched to mode it was in before calling AX=D002h and the
	      display memory is restored
Note:	This function needn't save the display memory before changing it.
SeeAlso: AX=D000h,AX=D005h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD005" name="2FD005"><b>2FD005</b></a> - INT 2F - MDEBUG display driver - SWITCH BACK TO TEXT SCREEN<br />
<pre>
INT 2F - MDEBUG display driver - SWITCH BACK TO TEXT SCREEN
	AX = D005h
Return: CF set on error
	CF clear if successful
	    display restored to mode it was in before calling AX=D004h
Note:	This function needn't save or change the display memory
SeeAlso: AX=D000h,AX=D004h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD0" name="2FD0"><b>2FD0</b></a> - INT 2F - MDEBUG display driver - RESERVED FUNCTION NUMBERS<br />
<pre>
INT 2F - MDEBUG display driver - RESERVED FUNCTION NUMBERS
	AH = D0h
	AL = 06h-7Fh
Note:	these functions are reserved for future use

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD0_0" name="2FD0_0"><b>2FD0</b></a> - INT 2F - MDEBUG display driver - USER DEFINED FUNCTION NUMBERS<br />
<pre>
INT 2F - MDEBUG display driver - USER DEFINED FUNCTION NUMBERS
	AH = D0h
	AL = 80h-FFh
Note:	these functions numbers are reserved for user defined features (e.g.
	  communication between the transient und resident parts of the driver)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD100" name="2FD100"><b>2FD100</b></a> - INT 2F C - MDEBUG command driver - GET STATUS<br />
<pre>
INT 2F C - MDEBUG command driver - GET STATUS
	AX = D100h
	BX = version of MDEBUG (BH = major, BL = minor)
	CX = command driver counter
---v1.60+---
	DS:SI -&gt; MDEBUG identification table (see #03076)
	ES = segment of display memory used by MDEBUG
	DI = size of video mode used by MDEBUG
	    (high byte = lines, low byte = columns)
Return: DL = FFh
	BX = version number of the driver if it is less than the version in BX,
	      else unchanged
	CX incremented
Program: MDEBUG is a shareware memory-resident debugging tool by Bernd
	  Schemmer, including a memory monitor, an interpreter, and a
	  disassembler
Range:	AH=C0h to AH=FFh, selected by switch or programmatically
Notes:	called by MDEBUG at start of popup session; if the version number
	  returned in BX is less than 1.52 (1.60 for MDEBUG v1.70), MDEBUG will
	  not call any of the other functions during this popup session
	MDEBUG can use any two consecutive multiplex numbers between C0h and
	  FFh; the default is D0h for the display driver and D1h for the
	  command driver (call INT 60/AH=00h"MDEBUG" for the multiplex numbers
	  actually used)
	this function must end with a far call to the old INT 2F handler after
	  changing the registers
	this function MUST be reentrant
	command drivers must also declare the following data at the given
	  offsets in the code segment
		100h  3 BYTEs	JMP-command in .COM-files
		103h	BYTE	NOP-command (90h)
		104h 26 BYTEs	signature "Kommandotreiber fr MDEBUG"
		11Eh 12 BYTEs	name of driver, e.g. "MDHISDRV.COM"
				each driver must have a unique name
	MDEBUG will pass every key and command to the command driver(s) before
	  checking for a valid internal command
SeeAlso: AX=D000h,AX=D101h

Format of MDEBUG identification table:
Offset	Size	Description	(Table 03076)
 -2	WORD	entry offset
 00h	WORD	CS of MDEBUG
 02h	DWORD	old INT 08h vector
 06h	DWORD	old INT 09h vector
 0Ah	DWORD	address INT 16h routine used by MDEBUG
 0Eh	BYTE	length of version string
 0Fh  N BYTEs	version string

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD101" name="2FD101"><b>2FD101</b></a> - INT 2F - MDEBUG command driver - INITIALIZE DRIVER<br />
<pre>
INT 2F - MDEBUG command driver - INITIALIZE DRIVER
	AX = D101h
	CX = command driver counter
Return: DL = status
	    FFh if successful
		CX incremented
	    else error: all registers unchanged
Note:	this function must end with a  far call to the old INT 2F handler after
	  changing the registers
	this function must be reentrant

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD102" name="2FD102"><b>2FD102</b></a> - INT 2F - MDEBUG command driver - EXECUTE INTERPRETER COMMAND<br />
<pre>
INT 2F - MDEBUG command driver - EXECUTE INTERPRETER COMMAND
	AX = D102h
	BL = first character of the interpreter command
	BH = last character of the interpreter command (or blank)
	DS:SI -&gt; parameter for the interpreter command as ASCIZ string
	DS:DI -&gt; MDEBUG data structure (see #03078)
Return: AL = FFh
	CF set on error
	    AH = error number (see #03077)
	    DS:SI -&gt; ASCIZ error message (max 30 characters) if AH=0Ch
	CF clear if successful
	    AH = return code
		00h continue processing the command line
		01h leave MDEBUG popup session
		02h leave MDEBUG popup session and automatically popup again
		      if the InDOS flag is zero
		03h not used (same as 00h)
		04h not used (same as 00h)
		05h put new command line into the input buffer,
		    DS:SI -&gt; new command line (ASCIZ string, max 66 chars)
		06h process new command line
		    DS:SI -&gt; new command line (ASCIZ string, max 66 chars)
	       else unknown status, but continue processing commmand line
Note:	this function must end with a far call to the old INT 2F handler (with
	  registers unchanged) if the driver does not support the interpreter
	  command in BX.  Otherwise, the driver must not chain to the old
	  INT 2F.

(Table 03077)
Values for MDEBUG error number:
 01h	syntax error
 02h	first shell of the command.com is activ
 03h	Esc pressed
 04h	break pressed
 05h	DOS is busy
 06h	command ended
 07h	division by zero
 08h	invalid display driver
 09h	invalid command driver
 0Ah	error 8 and 9
 0Bh	unknown error
 0Ch	new error
 else	unknown error

Format of MDEBUG data structure:
Offset	Size	Description	(Table 03078)
 00h	WORD	register SE
 02h	WORD	register OF
 04h	WORD	register FS
 06h	WORD	register FO
 08h	WORD	register AX
 0Ah	WORD	register BX
 0Ch	WORD	register CX
 0Eh	WORD	register DX
 10h	WORD	register SI
 12h	WORD	register DI
 14h	WORD	register DS
 16h	WORD	register ES
 18h	WORD	register BP
 1Ah	WORD	register SS
 1Ch	WORD	register SP
 1Eh	WORD	register FL (flags)
 20h	WORD	register R0
 22h	WORD	register R1
 24h	WORD	register R2
 26h	WORD	register R3
 28h	WORD	register R4
 2Ah	WORD	register R5
 2Ch	WORD	register R6
 2Eh	WORD	register R7
 30h	WORD	register R8
 32h	WORD	register CS, return-address
 34h	WORD	register IP, return-address
 36h	DWORD	saved pointer to data for key &lt;F6&gt; (v1.60)
		saved monitor address (v1.70)
 3Ah 12 WORDs	saved register values on last popup entry (for &lt;F8&gt; key)
		(original register values at popup entry of MDEBUG)
		AX, BX, CX, DX, SI, DI, DS, ES, BP, SS, SP, flags
 52h 12 WORDs	saved register values on last popup exit (for &lt;SHIFT-F8&gt; key)
		AX, BX, CX, DX, SI, DI, DS, ES, BP, SS, SP, flags
 6Ah	DWORD	address of the DOS-invars-table
 6Eh	DWORD	address of the InDOS flag
 72h	WORD	offset of the register which is used for the segment of the
		  first monitor window
 74h	WORD	offset of the register which is used for the offset of the
		  first monitor window
 76h	WORD	name of the register which is used for the segment of the
		  first monitor segment
 78h	WORD	name of the register which is used for the offset of the first
		  monitor window
 7Ah	WORD	pseudo register 1
 7Ch	WORD	pseudo register 2

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD103" name="2FD103"><b>2FD103</b></a> - INT 2F - MDEBUG command driver - EXECUTE KEY IN THE MONITOR<br />
<pre>
INT 2F - MDEBUG command driver - EXECUTE KEY IN THE MONITOR
	AX = D103h
	BX = key code (like result of an interrupt 16h call)
	CX = cursor position
	    0000h in the ASCII column of the monitor
	    0001h in one of the hex fields of the monitor
	DS:SI -&gt; MDEBUG data structure (see #03078)
	ES:DI -&gt; actual byte in the monitor
Return: AL = FFh
	AH = return code
	    00h key processed, read next key
	    01h leave MDEBUG popup session
	    02h leave MDEBUG popup session and automatically popup again if DOS
		  is not busy
	    03h signal an error (beep)
	    04h driver has redefined the key, proceed with the new key
		BX = new key code
		MDEBUG will not pass the new key to the command driver(s)
	   else treat like code 00h
Note:	this function must end with a far call to the old INT 2F handler (with
	  registers unchanged) if the driver does not support the key in BX.
	  Otherwise, the driver must not chain to the old INT 2F.
SeeAlso: AX=D104h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD104" name="2FD104"><b>2FD104</b></a> - INT 2F - MDEBUG command driver - EXECUTE KEY IN THE INTERPRETER<br />
<pre>
INT 2F - MDEBUG command driver - EXECUTE KEY IN THE INTERPRETER
	AX = D104h
	DS:SI -&gt; MDEBUG data structure (see #03078)
Return: AL = FFh
	AH = return code
	    00h key processed, read next key
	    01h leave MDEBUG popup session
	    02h leave MDEBUG popup session and automactically popup again if
		  DOS is not busy
	    03h signal an error (beep)
	    04h driver has redefined the key, proceed with the new key
		BX = new key code
		MDEBUG won't pass the new key to the command driver(s)
	    05h put new command line into the input buffer
		DS:SI -&gt; new command line (ASCIZ string, max 66 chars)
	    06h process new command line
		DS:SI -&gt; new command line (ASCIZ string, max 66 chars)
	   else treat like code 00h
Note:	this function must end with a far call to the old INT 2F handler if the
	  driver does not support the key in BX.  Otherwise, the driver must
	  not chain to the old INT 2F.
SeeAlso: AX=D103h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD1" name="2FD1"><b>2FD1</b></a> - INT 2F - MDEBUG command driver - RESERVED FUNCTIONS<br />
<pre>
INT 2F - MDEBUG command driver - RESERVED FUNCTIONS
	AH = D1h
	AL = 05h-0Ah
Note:	these functions are reserved for future use

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD110" name="2FD110"><b>2FD110</b></a> - INT 2F - MDEBUG command driver - GET ADDRESS OF THE OLD INT 2F<br />
<pre>
INT 2F - MDEBUG command driver - GET ADDRESS OF THE OLD INT 2F
	AX = D110h
Return: DL = FFh
	ES:BX -&gt; next program in the chain for INT 2F
	CX = code segment of this driver
	DI = offset of driver identification table (see #03079) (v1.60+)
Notes:	only called by the transient part of the driver
	must be reentrant and the driver must not chain this function to the
	  old INT 2F

Format of the MDEBUG driver identification table:
Offset	Size	Description	(Table 03079)
 00h  26 BYTEs	 signature "Kommandotreiber fr MDEBUG"
					     ^- Note: ASCII 129,German U-umlaut
 27h  12 BYTEs	 name of driver, e.g. "MDHISDRV.COM"
		 each driver must have a unique name

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD111" name="2FD111"><b>2FD111</b></a> - INT 2F - MDEBUG command driver - START DRIVER<br />
<pre>
INT 2F - MDEBUG command driver - START DRIVER
	AX = D111h
Return: DL = FFh
Notes:	only called by the transient part of the driver to inform the resident
	  part that it is installed
	the function must be reentrant and the driver mustn't chain this
	  function to the old INT 2F
SeeAlso: AX=D101h,AX=D112h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD112" name="2FD112"><b>2FD112</b></a> - INT 2F - MDEBUG command driver - END DRIVER<br />
<pre>
INT 2F - MDEBUG command driver - END DRIVER
	AX = D112h
Return: DL = FFh
Notes:	only called by the transient part of the driver to inform the resident
	  part that it will be released after this function
	the function must be reentrant and the driver mustn't chain this
	  function to the old INT 2F
SeeAlso: AX=D101h,AX=D111h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD1_0" name="2FD1_0"><b>2FD1</b></a> - INT 2F - MDEBUG command driver - RESERVED FUNCTIONS<br />
<pre>
INT 2F - MDEBUG command driver - RESERVED FUNCTIONS
	AH = D1h
	AL = 13h-7Fh
Note:	these functions are reserved for future use

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD1_1" name="2FD1_1"><b>2FD1</b></a> - INT 2F - MDEBUG command driver - USER DEFINED FUNCTIONS<br />
<pre>
INT 2F - MDEBUG command driver - USER DEFINED FUNCTIONS
	AH = D1h
	AL = 80h-FFh
Note:	these functions are reserved for user defined features (e.g.
	  communication between the transient und resident parts of the driver)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD200" name="2FD200"><b>2FD200</b></a> - INT 2F - PCL-838.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F - PCL-838.EXE - INSTALLATION CHECK
	AX = D200h
Return: AL = FFh if installed??? (documented as AX = return value)
Program: PCL-838 is a resident utility for controlling a stepmotor adapter
	  board by Advantec
SeeAlso: AX=D201h"PCL-838",AX=D202h"PCL-838"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD200BX5144" name="2FD200BX5144"><b>2FD200BX5144</b></a> - INT 2F - Quarterdeck RPCI - INSTALLATION CHECK<br />
<pre>
INT 2F - Quarterdeck RPCI - INSTALLATION CHECK
	AX = D200h
	BX = 5144h ("QD")
	CX = 4D45h ("ME")
	DX = 4D30h ("M0")
Return: AL = FFh installed
	if BX,CX,DX registers were as specified on entry:
	    BX = 4D45h ("ME")
	    CX = 4D44h ("MD")
	    DX = 5652h ("VR")
Range:	AH=C0h to AH=FFh, selected by scanning AH=D2h-FFh, then AH=C0h-D1h
Notes:	the Quarterdeck RPCI (Resident Program Communication Interface) is
	  supported by QEMM v5.0+, QRAM, MANIFEST, VIDRAM, etc.
	for AL &lt;&gt; 0, if the BX/CX/DX values don't match the identifier of a
	  Quarterdeck product, it just chains to the previous INT 2F handler
SeeAlso: AX=D201h/BX=4849h,AX=D201h/BX=4D41h,AX=D201h/BX=4D45h
SeeAlso: AX=D201h/BX=5145h,AX=D201h/BX=5649h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD201" name="2FD201"><b>2FD201</b></a> - INT 2F - PCL-838.EXE - UNINSTALL<br />
<pre>
INT 2F - PCL-838.EXE - UNINSTALL
	AX = D201h
Return: AX = return value
SeeAlso: AX=D200h"PCL-838",AX=D202h"PCL-838"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD201BX4849" name="2FD201BX4849"><b>2FD201BX4849</b></a> - INT 2F - Quarterdeck RPCI - GET QD HIMEM PRESENCE<br />
<pre>
INT 2F - Quarterdeck RPCI - GET QD HIMEM PRESENCE
	AX = D201h
	BX = 4849h ("HI")
	CX = 4D45h ("ME")
	DX = 4D51h ("MQ")
Return: BX = 4F4Bh ("OK")
	ES:DI -&gt; HIMEM entry point
Range:	AH=C0h to AH=FFh, selected by scanning AH=D2h-FFh, then AH=C0h-D1h
SeeAlso: AX=D200h,AX=D201h/BX=5145h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD201BX4849_0" name="2FD201BX4849_0"><b>2FD201BX4849</b></a> - INT 2F - Quarterdeck RPCI - QEMM/QRAM v5.0+ - GET HIRAM MEMORY CHAIN<br />
<pre>
INT 2F - Quarterdeck RPCI - QEMM/QRAM v5.0+ - GET HIRAM MEMORY CHAIN
	AX = D201h
	BX = 4849h ("HI")
	CX = 5241h ("RA")
	DX = 4D30h ("M0")
Return: BX = 4F4Bh ("OK")
	CX = segment of start of HIRAM chain
	DX = reserved block owner (QEMM/QRAM code segment)
Range:	AH=C0h to AH=FFh, selected by scanning AH=D2h-FFh, then AH=C0h-D1h
Note:	the HIRAM memory chain has the same format as the regular DOS 4.0
	  memory chain (see #01628 at INT 21/AH=52h), except that XMS Upper
	  Memory Blocks have the block header program name field set to
	  "UMB"; blocks whose "owner" field is set to the reserved segment
	  returned in DX are locked-out regions such as video memory and ROMs.
SeeAlso: AX=12FFh/BX=0006h,AX=D200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD201BX4D41" name="2FD201BX4D41"><b>2FD201BX4D41</b></a> - INT 2F U - Quarterdeck RPCI - MANIFEST v1.0+ - INSTALLATION CHECK<br />
<pre>
INT 2F U - Quarterdeck RPCI - MANIFEST v1.0+ - INSTALLATION CHECK
	AX = D201h
	BX = 4D41h ("MA")
	CX = 4E49h ("NI")
	DX = 4645h ("FE")
Return: BX = 5354h ("ST") if installed
Range:	AH=C0h to AH=FFh, selected by scanning AH=D2h-FFh, then AH=C0h-D1h
SeeAlso: AX=D200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD201BX4D45" name="2FD201BX4D45"><b>2FD201BX4D45</b></a> - INT 2F U - Quarterdeck RPCI - DVDOS4GX.DVR - ???<br />
<pre>
INT 2F U - Quarterdeck RPCI - DVDOS4GX.DVR - ???
	AX = D201h
	BX = 4D45h ("ME")
	CX = 5155h ("QU")
	DX = 5044h ("PD")
Return: AL = FFh
	BX = 4F4Bh ("OK")
Range:	AH=C0h to AH=FFh, selected by scanning AH=D2h-FFh, then AH=C0h-D1h
Note:	this function is called by QEMM 6.03
	performs a variety of actions before setting return registers
SeeAlso: AX=D200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD201BX5145" name="2FD201BX5145"><b>2FD201BX5145</b></a> - INT 2F - Quarterdeck RPCI - QEMM v5.0+ - INSTALLATION CHECK<br />
<pre>
INT 2F - Quarterdeck RPCI - QEMM v5.0+ - INSTALLATION CHECK
	AX = D201h
	BX = 5145h ("QE")
	CX = 4D4Dh ("MM")
	DX = 3432h ("42")
Return: BX = 4F4Bh ("OK")
	ES:DI -&gt; QEMM API entry point (see INT 67/AH=3Fh)
Range:	AH=C0h to AH=FFh, selected by scanning AH=D2h-FFh, then AH=C0h-D1h
Note:	this call is not available under QEMM v6.00 unless Windows3 support
	  has been disabled with the NW3 switch to QEMM386.SYS
SeeAlso: AX=D200h,AX=D201h/BX=4849h,INT 67/AH=3Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD201BX5649" name="2FD201BX5649"><b>2FD201BX5649</b></a> - INT 2F u - Quarterdeck RPCI - VIDRAM v5.0+ - INSTALLATION CHECK<br />
<pre>
INT 2F u - Quarterdeck RPCI - VIDRAM v5.0+ - INSTALLATION CHECK
	AX = D201h
	BX = 5649h ("VI")
	CX = 4452h ("DR")
	DX = 414Dh ("AM")
Return: BX = 4F4Bh ("OK")
	ES:DI -&gt; VIDRAM entry point (see #03080)
Range:	AH=C0h to AH=FFh, selected by scanning AH=D2h-FFh, then AH=C0h-D1h
SeeAlso: AX=D200h

(Table 03080)
Call VIDRAM entry point with:
	AH = 00h get status
		Return: AL = VIDRAM state (see #03081)
			BL = extra RAM status (see #03082)
			BH = feature flags (see #03083)
			CL = current monitor (01h = mono, 80h = color)
			SI = current top of memory (paragraph)
			DI = segment of start of HiRAM chain
	AH = 01h setup
		AL = VIDRAM state (see #03081)
		BL = extra RAM status (see #03082)
		BH = feature flags (see #03083)
		CL = monitor (01h = monochrome, 80h = color)
		SI = new top of memory (paragraph)
		DI = segment of start of HiRAM chain
	AH = 02h get end address of VIDRAM code
		Return: ES:DI -&gt; VIDRAM partial map context (see #03084,#03085)
Return: CF set on error
	CF clear if successful

(Table 03081)
Values for VIDRAM state:
 00h	off
 01h	no EGA graphics
 02h	no graphics at all

(Table 03082)
Values for VIDRAM extra RAM status:
 00h	VIDRAM does not use extra RAM
 01h	VIDRAM uses EMS as extra RAM
 02h	VIDRAM uses EGA as extra RAM

Bitfields for VIDRAM feature flags:
Bit(s)	Description	(Table 03083)
 0	override enabled
 1	mapped memory detected in A000h-B000h range
 2	top of memory not at 640K
 3	MDA detected
 4	high RAM exists in video area
 5	mapped memory detected in video area
 6-7	reserved???

Format of VIDRAM partial map context (EMS 3.2):
Offset	Size	Description	(Table 03084)
 00h	BYTE	EMS version ID (32h)
 01h	WORD	EMM handle for this entry
 03h	BYTE	number of frames
 04h	BYTE	first page frame
 05h	WORD	offset from ES to previously saved map

Format of VIDRAM partial map context (EMS 4.0):
Offset	Size	Description	(Table 03085)
 00h	BYTE	EMS version ID (40h)
 01h	WORD	mappable segment count
 03h  N WORD	mappable segments
	WORD	offset to previously saved map???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD202" name="2FD202"><b>2FD202</b></a> - INT 2F - PCL-838.EXE - EXECUTE PCL838 COMMANDS<br />
<pre>
INT 2F - PCL-838.EXE - EXECUTE PCL838 COMMANDS
	AX = D202h
	CX:BX -&gt; parameter table
Return: AX = return value
SeeAlso: AX=D200h"PCL-838",AX=D201h"PCL-838"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD300BX4562" name="2FD300BX4562"><b>2FD300BX4562</b></a> - INT 2F U - TeleReplica - INSTALLATION CHECK<br />
<pre>
INT 2F U - TeleReplica - INSTALLATION CHECK
	AX = D300h
	BX = 4562h
	CX = 2745h
	DX = serial port I/O base address??? (03F8h for v3.9)
Return: SI = segment of resident code
	AX = 251Dh
	BX = DF21h
	CX = F321h
	DX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD3CB" name="2FD3CB"><b>2FD3CB</b></a> - INT 2F U - LapLink Quick Connect v6 - API<br />
<pre>
INT 2F U - LapLink Quick Connect v6 - API
	AX = D3CBh
	CX = function
	    0002h get ???
		Return: BX:AX -&gt; ???
			CL = ???
			CH = ???
			DX = ???
			DI = COM1 I/O port???
			SI = COM2 I/O port???
	    0003h initialization???
	    0004h ???
	    0005h initialization???
	    0006h reset/clear ???
		Return: AX = 0000h
			ES:DI -&gt; next byte after ??? cleared by this call
	    0007h initialization???
	    0008h uninstall
		Return: BX = status
			    0000h successful
			    FFFFh incomplete, stub remains in memory
Return: CX = 534Bh (except function 0002h)
Index:	uninstall;LapLink Quick Connect

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD3D3BH00" name="2FD3D3BH00"><b>2FD3D3BH00</b></a> - INT 2F - KDRIVE v2.x - INSTALLATION CHECK<br />
<pre>
INT 2F - KDRIVE v2.x - INSTALLATION CHECK
	AX = D3D3h
	BH = 00h
Return: BX = 3D3Dh if installed
	CF clear if installed
	    AX = driver ID??? (returns 0087h for KDRIVE.EXE and 0880h for
		  KDRIVOS2.EXE in one examined version)
Program: KDRIVE is a shareware extended German keyboard driver by Martin
	  Austermeier, originally based on K3 by Martin Gerdes as published
	  in c't magazine 7/1988

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD44D" name="2FD44D"><b>2FD44D</b></a> - INT 2F - 4DOS.COM v2.1+ - API<br />
<pre>
INT 2F - 4DOS.COM v2.1+ - API
	AX = D44Dh
	BH = function
	    00h installation check
		Return: AX = 44DDh
			BL = major version number
			BH = minor version number
			CX = PSP segment address for current invocation
			DL = 4DOS shell number (0 for the first (root) shell,
			      updated each time a new copy is loaded)
	    01h (internal, v2.1-3.03) terminate current copy of 4DOS
		Return: nothing
		(internal, v4.0+) ???
		Return: AX = 44DDh
			ES:BX -&gt; data area (see #03086)
	    02h ???
		DX = ???
		Note:	v5.52 signals "unrecoverable error" and then terminates
			  with INT 21/AH=4Ch or enters a deliberate infinite
			  loop if ???
	---v2.1-3.03 only---
	    03h EXEC program
		CX:DX -&gt; EXEC record (see #03087)
	    FEh deallocate shell number (passed through to root shell)
		???
	    FFh allocate shell number (passed through to root shell)
	---v5.52---
	    03h get ???
		BL = ??? (00h/01h)
		Return: DX = current value of ???
	    04h set ???
		BL = ??? (00h/01h)
		DX = new value for ???
Note:	a bug in v3.00 will crash the system if unrecognized value in BH
SeeAlso: AX=D44Eh,AX=D44Fh/BX=0000h,AX=E44Dh,INT 21/AX=4403h"DOS"
SeeAlso: INT 14/AX=7000h
Index:	installation check;4DOS|installation check;NDOS

Format of 4DOS v4.0 data area:
Offset	Size	Description	(Table 03086)
 00h  2 BYTEs	???
 06h	WORD	XMS handle for swapping
	???
SeeAlso: #03087

Format of 4DOS EXEC v2.1-v3.03 record:
Offset	Size	Description	(Table 03087)
 00h	WORD	offset of ASCIZ program name in same segment as EXEC record
 02h	WORD	offset of DOS commandline in same segment as EXEC record
 04h	WORD	segment of environment for child process (see INT 21/AH=26h)
SeeAlso: #03086

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD44E" name="2FD44E"><b>2FD44E</b></a> - INT 2F C - 4DOS v3.0+ - AWAITING USER INPUT<br />
<pre>
INT 2F C - 4DOS v3.0+ - AWAITING USER INPUT
	AX = D44Eh
---4DOS v3.01+---
	BX = condition
	    0000h 4DOS is ready to display prompt
	    0001h 4DOS has displayed the prompt, about to accept user input
Return: the handler must preserve SI, DI, BP, SP, DS, ES, and SS
Note:	v3.00 only makes the call corresponding to BX=0001h, does not set BX
SeeAlso: AX=D44Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD44FBX0000" name="2FD44FBX0000"><b>2FD44FBX0000</b></a> - INT 2F - 4DOS v4.0+ - KSTACK.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - 4DOS v4.0+ - KSTACK.COM - INSTALLATION CHECK
	AX = D44Fh
	BX = 0000h
Return: AX = 44DDh if installed
Note:	this function is also supported by ANSIPLUS v3.01+ and K3PLUS v6.20+,
	  which emulate the 4DOS and NDOS keystack
SeeAlso: AX=D44Dh,AX=D44Fh/BX=0001h,AX=E44Fh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD44FBX0001" name="2FD44FBX0001"><b>2FD44FBX0001</b></a> - INT 2F - 4DOS v4.0+ - KSTACK.COM - PLACE KEYSTROKES INTO KEYSTACK<br />
<pre>
INT 2F - 4DOS v4.0+ - KSTACK.COM - PLACE KEYSTROKES INTO KEYSTACK
	AX = D44Fh
	BX = 0001h
	CX = number of keystrokes (01h-FFh)
	DS:DX -&gt; keystroke list (one word per keystroke)
Return: AX = status
	    0000h successful
	    nonzero failed
	BX,CX,DX destroyed
Notes:	the keystrokes are the exact values to return from subsequent calls to
	  INT 16 with AH=00h,01h,10h, or 11h, with the following exceptions:
		0000h causes subfunctions 01h and 11h to indicate an empty
		      keyboard buffer
		FFFFh is followed by a word indicating the number of clock
		      ticks to delay before the next faked keystroke
	v4.00 KSTACK overwrites any unread keystrokes from the previous
	  invocation, and does not range-check CX; it will overwrite memory
	  following the resident portion if CX is greater than 100h.
	this function is also supported by ANSIPLUS v3.01+ and K3PLUS v6.20+,
	  which emulate the 4DOS and NDOS keystack
SeeAlso: AX=D44Dh,AX=D44Fh/BX=0000h,INT 16/AH=00h,INT 21/AX=4403h"DOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD600" name="2FD600"><b>2FD600</b></a> - INT 2F - HEART.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - HEART.COM - INSTALLATION CHECK
	AX = D600h
Return: AX = 0303h (two hearts) if installed
	    ES:DI -&gt; buffer (see #03088)
Program: HEART.COM is a CPU lock-up/critical indicator utility by Mitch Davis.
Notes:	Once the host program has identified the address of the data area, it
	  can change this to indicate safe/critical, alternate colours, etc.
	The entries for the color table are in char/attrib form.  Every two
	  entries form a pair which is alternated between 68 times a minute.
	  The first half of the table is for color videos, the second mono.
	  Within each half, the first half is for the safe chars, and the
	  second for the critical chars.

Format of HEART.COM buffer:
Offset	Size	Description	(Table 03088)
 00h  8 WORDs	table of colors/attributes (refer to notes above)
 10h	BYTE	flags
		bit 0: program is in critical section, so flash double
		      exclamation mark
		bit 1: program is in safe code, so flash the heart character
 11h	WORD	position of heartbeat on screen, normally 009Eh (last column
		of second line)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD600_0" name="2FD600_0"><b>2FD600</b></a> - INT 2F U - VEDIT VSWAP - INSTALLATION CHECK<br />
<pre>
INT 2F U - VEDIT VSWAP - INSTALLATION CHECK
	AX = D600h
Return: AL = D6h if installed
Program: VSWAP is the resident portion of VEDIT's "swapper" capability; VEDIT
	  is a programmer's text editor by Greenview Data.
SeeAlso: AX=D601h,AX=D602h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD601" name="2FD601"><b>2FD601</b></a> - INT 2F U - VEDIT VSWAP - ???<br />
<pre>
INT 2F U - VEDIT VSWAP - ???
	AX = D601h
	BL = subfunction number???
Return: BL = return code ???
	ES = resident portion's data??? segment
	DX = resident portion's code segment
SeeAlso: AX=D600h"VSWAP"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD602" name="2FD602"><b>2FD602</b></a> - INT 2F U - VEDIT VSWAP - EXEC PROGRAM WITH SWAP<br />
<pre>
INT 2F U - VEDIT VSWAP - EXEC PROGRAM WITH SWAP
	AX = D602h
	other registers set as for INT 21/AX=4B00h
Return: CF set on error
	    AL = error code
		82h = failure due to ???
	CF clear on success
SeeAlso: AX=D600h"VSWAP",INT 21/AH=4Bh"EXEC"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD701BX0000" name="2FD701BX0000"><b>2FD701BX0000</b></a> - INT 2F - Banyan VINES v4+ - GET BANV INTERRUPT NUMBER<br />
<pre>
INT 2F - Banyan VINES v4+ - GET BANV INTERRUPT NUMBER
	AX = D701h
	BX = 0000h
Return: AX = 0000h if installed
	    BX = interrupt number (60h to 66h)
	   nonzero not present
Note:	if AX is nonzero, VINES 3.x or earlier may be installed, thus it is
	  necessary to examine the four bytes preceding the handlers for
	  INT 60 through INT 66 for the string "BANV"
SeeAlso: AX=D702h,AX=D703h,AX=D704h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD702" name="2FD702"><b>2FD702</b></a> - INT 2F U - Banyan VINES v4+ - PCPRINT interface<br />
<pre>
INT 2F U - Banyan VINES v4+ - PCPRINT interface
	AX = D702h
	BX = function
	???
Return: ???
SeeAlso: AX=D701h,AX=D703h,INT 61/AX=0005h"Banyan"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD703" name="2FD703"><b>2FD703</b></a> - INT 2F U - Banyan VINES v4+ - MAIL interface<br />
<pre>
INT 2F U - Banyan VINES v4+ - MAIL interface
	AX = D703h
	BX = function
	???
Return: ???
SeeAlso: AX=D702h,AX=D704h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD704" name="2FD704"><b>2FD704</b></a> - INT 2F U - Banyan VINES v4+ - Streettalk Directory Assistance interface<br />
<pre>
INT 2F U - Banyan VINES v4+ - Streettalk Directory Assistance interface
	AX = D704h
	BX = function
	???
Return: ???
SeeAlso: AX=D703h,INT 61/AX=0007h/BX=0002h"Banyan",INT 61/AX=0007h/BX=0008h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD800" name="2FD800"><b>2FD800</b></a> - INT 2F U - Novell NetWare Lite - CLIENT.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F U - Novell NetWare Lite - CLIENT.EXE - INSTALLATION CHECK
	AX = D800h
Return: AL = FFh if installed
	    DX = version number (0100h for v1.0, 0101h for v1.1)
	    BX = data segment of resident copy
	    ES:DI -&gt; private API entry point (see #03089)
	    SI = segment of resident code
Note:	Microsoft assigned multiplex number D8h to Novell on 1991/05/21
SeeAlso: AX=7A00h,AX=D880h

(Table 03089)
Call CLIENT API entry point with:
	BX = function
	    0000h get ???
		Return: DX = CLIENT version??? (0101h for v1.1)
			ES:BX -&gt; ??? data
	    0001h ???
	    0002h ???
	    0003h ???
	    0004h ???
	    0005h ???
		DL = ???
		???
		Return: ???
	    0006h get module name???
		ES:DI -&gt; 16-byte buffer
		Return: CX = ???
			ES:DI filled with "NWLITE_CLIENT" 00h 00h 00h
	    0007h ???
		DX:CX = ???
		???
		Return: ???
	    0008h ???
	    0009h ???
		DL = ???
		ES:DI -&gt; 16-byte buffer for ???
		Return: CF clear if successful
			    AX = 0000h
			    CX = 0000h
			    SI,DI destroyed
			CF set on error
			    AX = error code 4903h
	    000Ah ???
		AH = subfunction
		    00h get ???
		    01h clear/set ??? flag
			AL = new state (00h cleared, 01h set)
		    02h set ???
			DX = new value of ???
		Return: DX = old value of ???
	    000Bh ???
		AX = ???
		???
		Return: ???
	    000Ch ???
		AX = ???
		???
		Return: ???
	    000Dh ???
		AX = ???
		???
		Return: ???
	    000Eh get original INT 17
		Return: CF clear
			ES:BX -&gt; original INT 17
	    000Fh ???
	    0010h ???
		AX = ???
		???
		Return: ???
	    0011h get ???
		Return: CF clear
			DL = ???
	    0012h get ???
		AL = index of ???
		ES:DI -&gt; 10-byte buffer for ???
		Return: CF clear if successful
			    ES:DI buffer filled
			    AX,CX destroyed
			CF set on error
			    AX = error code (4907h if AL out of range)
	    0013h get ???
		Return: CF clear
			DH = ???
			DL = ???
	    0014h ???
		DL = ???
		???
		Return: CF clear if successful
			    ???
			CF set on error
			    AX = error code 8056h
	    0015h ???
		DX = ???
		Return: ES:DI -&gt; ???
	    other
		Return: CF set
			AX = 0001h (invalid function)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD856" name="2FD856"><b>2FD856</b></a> - INT 2F U - Novell NetWare Lite v1.1 - SERVER - "VNWLSERV_INIT" - GET ???<br />
<pre>
INT 2F U - Novell NetWare Lite v1.1 - SERVER - "VNWLSERV_INIT" - GET ???
	AX = D856h
Return: AX = 0001h if supported???
	BX = ??? (0004h for v1.1)
	CX = ??? (0F20h for v1.1)
	DS = segment of resident code
	ES = data segment of resident copy
Note:	this function is also supported by Personal NetWare SERVER, bundled
	  with Novell DOS 7

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD880" name="2FD880"><b>2FD880</b></a> - INT 2F U - Novell NetWare Lite v1.0+ - SERVER - INSTALLATION CHECK<br />
<pre>
INT 2F U - Novell NetWare Lite v1.0+ - SERVER - INSTALLATION CHECK
	AX = D880h
Return: AL = FFh if installed
	    DX = version number (binary, DH = major, DL = minor)
	    BX = data segment of resident copy
	    CL = current state (00h SERVER is disabled, 01h SERVER is active)
	    ES:DI -&gt; private API entry point (see #03090)
	    SI = ??? (offset of configuration info?)
	    AH may be destroyed
Note:	this function is also supported by Personal NetWare SERVER, but DI is
	  not set; instead, ES:SI points at the API entry point
SeeAlso: AX=7A00h,AX=D800h,INT 2A/AX=D852h

(Table 03090)
Call SERVER API entry point with:
	BX = function
	    0000h shut down server
		???
		Return: ???
		Note: closes open files by calling INT 21/AH=3Eh
	    0001h get connection information
		DX = connection number (0001h-max connections)
		ES:DI -&gt; 28-byte buffer for connection information
		Return: CF clear if successful
			    ES:DI buffer filled
			CF set on error
			    AX = FFFFh
	---Personal NetWare only---
	    0002h ???
	    0003h ???
	    0004h ???
	    0005h ???
	    0006h get server info table
		  CX = size of buffer
		  ES:DI -&gt; buffer
		  AL = mode (02h = get current status)
	    0007h ???
	    other
		Return: CF set
			AX = 0001h (invalid function)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD8C0" name="2FD8C0"><b>2FD8C0</b></a> - INT 2F U - Novell NLCACHE,NWCACHE - INSTALLATION CHECK<br />
<pre>
INT 2F U - Novell NLCACHE,NWCACHE - INSTALLATION CHECK
	AX = D8C0h
Return: AL = FFh if installed
	    CL = memory type (01h NLCACHEC, 02h NLCACHEX, 03h NLCACHEM)
	    DH = major version (01h for v1.1)
	    DL = minor version (01h for v1.1)
	    ES:DI -&gt; private API entry point (see #03091)
Program: NWCACHE is the disk cache included with Personal NetWare,
	    Novell DOS 7, Caldera OpenDOS 7.01, DR-OpenDOS 7.02, DR-DOS 7.02,
	    and Caldera Thin Clients/Lineo DR-DOS 7.03.
Note:	This function is called by the NetWare Lite and Personal NetWare
	  SERVER.  It may also be called by future (post DR-DOS 7.03)
	  COMMAND.COM before it returns to the prompt.
BUG:	Some pre-BETA 17 (1993/09/28) versions of NWCACHE returned -1,0,1
	  instead of 1,2,3 for the memory type in CL.
SeeAlso: AX=D800h,AX=D880h

(Table 03091)
Call NLCACHE/NWCACHE "sideband function" API entry point with:
	BX = function
	    0000h flush request from server
		Return: CF clear if successful at flushing deferred writes
			    AX = 0000h
			CF set on error
			    AX = error code
	    0001h (NWCACHE only) get cache statistics
		ES:DI -&gt; buffer for statistics (see #04122)
		Return: CF clear if successful
			AX = 0000h
			ES:DI buffer filled
	    other
		Return: CF set
			AX = 0001h (invalid function)

Format of NWCACHE cache statistics:
Offset	Size	Description	(Table 04122)
 00h	WORD	version
 02h	BYTE	memory type
 03h	WORD	initial cache size in KB
 05h	WORD	current cache size in KB
 07h	DWORD	number of read requests
 0Bh	DWORD	number of physical reads performed
 0Fh	DWORD	number of write requests
 13h	DWORD	number of physical writes performed
 17h	BYTE	delay ticks for deferred write (0 if no deferral)
 18h	WORD	maximum number of sectors in lookahead buffer
 1Ah	WORD	number of disk errors
 1Ch	WORD	number of cache memory errors
SeeAlso: #03091

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDA00" name="2FDA00"><b>2FDA00</b></a> - INT 2F - ZyXEL ZFAX v1.x - INSTALLATION CHECK<br />
<pre>
INT 2F - ZyXEL ZFAX v1.x - INSTALLATION CHECK
	AX = DA00h
Return: AH = enabled state (00h = enabled, 01h = disabled)
	AL = 5Ah installed
Program: ZFAX is the bundled FAX software which comes with the ZyXEL model
	  fax modems.
Note:	This function, and the other DAxxh functions, may apply only to version
	  1 of the software; see AX=DB00h for the version 2 installation check
SeeAlso: AX=CBDCh,AX=DA01h,AX=DA02h,AX=DA03h,AX=DB00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDA01" name="2FDA01"><b>2FDA01</b></a> - INT 2F - ZyXEL ZFAX v1.x - UNINSTALL<br />
<pre>
INT 2F - ZyXEL ZFAX v1.x - UNINSTALL
	AX = DA01h
Return: AL = 00h Success
	     01h Failure
SeeAlso: AX=DA00h,AX=DB01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDA02" name="2FDA02"><b>2FDA02</b></a> - INT 2F - ZyXEL ZFAX v.1x - DISABLE<br />
<pre>
INT 2F - ZyXEL ZFAX v.1x - DISABLE
	AX = DA02h
Return: AL = 00h
SeeAlso: AX=DA03h,AX=DB02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDA03" name="2FDA03"><b>2FDA03</b></a> - INT 2F - ZyXEL ZFAX v1.x - ENABLE<br />
<pre>
INT 2F - ZyXEL ZFAX v1.x - ENABLE
	AX = DA03h
Return: AL = 00h
SeeAlso: AX=DA02h,AX=DB03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDA55" name="2FDA55"><b>2FDA55</b></a> - INT 2F U - TRAP.COM - INSTALLATION CHECK<br />
<pre>
INT 2F U - TRAP.COM - INSTALLATION CHECK
	AX = DA55h
	DL = interrupt number
	DH = ???
Return: if installed
	    AH = interrupt number
	    AL = ???
	    ES:BX -&gt; ???
Program: TRAP is an interrupt call tracer by Patrick Phillipot/Udo Chrosziel
Note:	a separate copy of TRAP is loaded for each interrupt to be traced; thus
	  the interrupt number is part of the installation check

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDAB2" name="2FDAB2"><b>2FDAB2</b></a> - INT 2F U - Beame&Whiteside BWSNMP - INSTALLATION CHECK<br />
<pre>
INT 2F U - Beame&Whiteside BWSNMP - INSTALLATION CHECK
	AX = DAB2h
Return: AX = 00FFh if installed
	    BX:CX -&gt; MIB table
Program: BWSNMP is part of the BW-NFS package
SeeAlso: INT 62/AH=00h"ETHDEV"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB00" name="2FDB00"><b>2FDB00</b></a> - INT 2F - ZyXEL ZFAX v2+ - INSTALLATION CHECK<br />
<pre>
INT 2F - ZyXEL ZFAX v2+ - INSTALLATION CHECK
	AX = DB00h
Return: AL = 5Bh if installed (v2.x)
	    ES:BX -&gt; configuration table???
	AX = 00DBh if installed (v3)
	    ES:BX -&gt; ZFAX configuration table (see #03092)
Program: ZFAX is the bundled FAX software which comes with the ZyXEL model
	  Fax modems.
SeeAlso: AX=CBDCh,AX=DA00h,AX=DB01h,AX=DB02h,AX=DB03h

Format of ZFAX Configuration Table:
Offset	Size	Description	(Table 03092)
 00h	WORD	table version number (0300h for v3.0-v4.01)
 02h	BYTE	reserved
 03h 70 BYTEs	ZFAX working path
 49h 128 BYTEs	path to external editor
 C9h 128 BYTEs	path to external terminal emulator
149h 128 BYTEs	path to Ring Shell
1C9h 128 BYTEs	path to DOS Shell
249h 128 BYTEs	path to Data Shell
2C9h 70 BYTEs	path to Chinese font
30Fh	BYTE	printer type (see #03093)
310h	BYTE	printer port (00h = LPT1, etc.)
311h	BYTE	type of graphics adapter
		(00h auto-detect, 01h VGA, 02h EGA, 03h CGA, 04h Hercules)
312h	BYTE	display type
		(00h auto-detect, 01h LCD, 02h color, 03h mono)
313h	BYTE	scan code for ZFAX hotkey (see #00006)
314h	BYTE	shift mask for ZFAX hotkey
315h	BYTE	tone/pulse dialing (00h tone, 01h pulse)
316h	BYTE	Caller ID (00h disabled, 01h enabled)
317h	BYTE	Distinctive Ring (00h disabled, 01h enabled)
318h	BYTE	normal ring answer type (see #03094)
319h	BYTE	Ring 1 answer type (see #03094)
31Ah	BYTE	Ring 2 answer type (see #03094)
31Bh	BYTE	Ring 3 answer type (see #03094)
31Ch	BYTE	COM port for modem
31Dh	BYTE	speaker volume (00h-07h)
31Eh	BYTE	modem dial timer, seconds
31Fh	WORD	user-defined COM port I/O address
321h	BYTE	user-defined COM port IRQ number
322h 81 BYTEs	dial prefix string
373h 79 BYTEs	dial postfix string
3C2h	BYTE	ring count until automatic answer
3C3h	BYTE	retry count on busy signal
3C4h	BYTE	redial delay in seconds
3C5h	WORD	system password
3C7h	BYTE	reserved
3C8h	BYTE	voice file compression format
		00h CELP at 9600bps
		01h two-bit ADPCM at 19200bps
		02h three-bit ADPCM at 28800bps
3C9h	BYTE	voice system: DTMF 0 action (see #03095)
3CAh	BYTE	voice system: DTMF 1 action
3CBh	BYTE	voice system: DTMF 2 action
3CCh	BYTE	voice system: DTMF 3 action
3CDh	BYTE	voice system: DTMF 4 action
3CEh	BYTE	voice system: DTMF 5 action
3CFh	BYTE	voice system: DTMF 6 action
3D0h	BYTE	voice system: DTMF 7 action
3D1h	BYTE	voice system: DTMF 8 action
3D2h	BYTE	voice system: DTMF 9 action (see #03095)
3D3h	WORD	reserved
3D5h 25 BYTEs	local FAX ID to display on page header
3EEh 20 BYTEs	local FAX ID sent to remote FAX
402h	BYTE	FAX page size
		00h A4 (210x297mm)
		01h B4 (250x353mm)
		02h A3 (297x420mm)
403h	BYTE	FAX resolution
		00h normal (3.85 pixels/mm)
		01h high (7.7 pixels/mm)
404h	BYTE	FAX coding scheme
		00h 1-D, modified Huffman coding
		01h 2-D, modified READ coding
405h	BYTE	left margin for text in millimeters
406h	BYTE	vertical insertion for text in mm (0-20)
407h	BYTE	horizontal insertion in mm (0-20)
408h	BYTE	maximum text lines per page
409h	BYTE	text type (00h ASCII, 01h WordStar-formatted)
40Ah	BYTE	PCX image resize (00h disabled, 01h enabled)
40Bh	BYTE	AutoPrint (00h disabled, 01h enabled)
40Ch	BYTE	cover page (00h disabled, 01h enabled)
40Dh 81 BYTEs	cover page logo filename
45Eh 65 BYTEs	cover page sender name
49Fh	BYTE	print capture (00h disabled, 01h enabled)
4A0h	BYTE	send immediately (00h disabled, 01h enabled)
4A1h	BYTE	print capture printer port
4A2h	BYTE	print capture timer in seconds
4A3h	BYTE	scan code for print capture hotkey (see #00006)
4A4h	BYTE	shift mask for print capture hotkey
4A5h	BYTE	DataShell type
		00h internal Zmodem, 01h Data Shell, 02h disable
4A6h	BYTE	video I/O type
		00h auto-detect, 01h use BIOS, 02h direct writes
4A7h	BYTE	call transfer digits (0-9)
4A8h	WORD	voice recorder maximum time in seconds (0-999)

(Table 03093)
Values for ZFAX printer type:
 00h	EPSON FX (9 pins)
 01h	EPSON LQ (24 pins)
 02h	HP Laser Jet II, letter size
 03h	HP Laser Jet II, legal size
 04h	HP Laser Jet II, A4 size
 05h	HP Laser Jet III, letter size
 06h	HP Laser Jet III, legal size
 07h	HP Laser Jet III, A4 size
SeeAlso: #03092

(Table 03094)
Values for Ring Answer Type:
 00h	voice system
 01h	FAX only
 02h	Data Shell
 03h	Ring Shell
 04h	DOS Shell
 05h	ignore
SeeAlso: #03092

(Table 03095)
Values for DTMF action:
 00h	none
 01h	page operator
 02h	FaxBack
 03h	announcement
 04h	call transfer
 05h	receive FAX
 06h	receive data
 07h	voice mailbox
 08h	DOS Shell Out
 09h	Data Shell Out
SeeAlso: #03092

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB00_0" name="2FDB00_0"><b>2FDB00</b></a> - INT 2F U - WINGO.COM - INSTALLATION CHECK<br />
<pre>
INT 2F U - WINGO.COM - INSTALLATION CHECK
	AX = DB00h
Return: AX = FFFFh if installed
	CX = 5749h ('WI') if installed
	DX = 4E47h ('NG') if installed
	    ES = segment of resident code
Program: WINGO.COM is TSR for starting Windows programs from DOS
	  prompt (together with companion Windows program
	  WINSTART.EXE) written by Douglas Boling, contributing editor of
	  PC Magazine
Range:	AH=DBh to AH=FFh, selected by scanning for a free multiplex number
SeeAlso: AX=DB01h"WINGO",AX=DB02h"WINGO",AX=DB03h"WINGO",AX=DB04h"WINGO"
SeeAlso: AX=DB05h"WINGO",AX=DB06h"WINGO"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB01" name="2FDB01"><b>2FDB01</b></a> - INT 2F - ZyXEL ZFAX v2+ - UNINSTALL<br />
<pre>
INT 2F - ZyXEL ZFAX v2+ - UNINSTALL
	AX = DB01h
Return: AX = status
	    0000h successful
	    0001h ZFAX is busy
	    0002h another program resident above ZFAX
Note:	this function unhooks the vectors taken by the ZFAX TSR if they have
	  not been hooked by other TSRs and releases the TSR's memory
	ZFAX v2.x crashes the contributor's machine when this function is
	  called
SeeAlso: AX=DA01h,AX=DB00h"ZFAX",AX=DB02h"ZFAX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB01_0" name="2FDB01_0"><b>2FDB01</b></a> - INT 2F U - WINGO.COM - SET CALLBACK FUNCTION POINTER<br />
<pre>
INT 2F U - WINGO.COM - SET CALLBACK FUNCTION POINTER
	AX = DB01h
	CX:DX -&gt; new callback function
Return: AX = 0000h
	CX:DX -&gt; end of resident code (stack ???)
Desc:	the callback function is used for WINGO &lt;-&gt; WINSTART communication
SeeAlso: AX=DB00h"WINGO",AX=DB02h"WINGO",AX=DB03h"WINGO",AX=DB04h"WINGO"
SeeAlso: AX=DB05h"WINGO",AX=DB06h"WINGO"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB02" name="2FDB02"><b>2FDB02</b></a> - INT 2F - ZyXEL ZFAX v2.x - DISABLE<br />
<pre>
INT 2F - ZyXEL ZFAX v2.x - DISABLE
	AX = DB02h
Return: AL = 00h
SeeAlso: AX=DA02h,AX=DB00h"ZFAX",AX=DB01h"ZFAX",AX=DB03h"ZFAX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB02_0" name="2FDB02_0"><b>2FDB02</b></a> - INT 2F U - WINGO.COM - RESET CALLBACK FUNCTION POINTER<br />
<pre>
INT 2F U - WINGO.COM - RESET CALLBACK FUNCTION POINTER
	AX = DB02h
Return: AX = 0000h
Desc:	the callback function is used for WINGO &lt;-&gt; WINSTART communication
SeeAlso: AX=DB00h"WINGO",AX=DB01h"WINGO",AX=DB03h"WINGO",AX=DB04h"WINGO"
SeeAlso: AX=DB05h"WINGO",AX=DB06h"WINGO"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB03" name="2FDB03"><b>2FDB03</b></a> - INT 2F - ZyXEL ZFAX v2.x - ENABLE<br />
<pre>
INT 2F - ZyXEL ZFAX v2.x - ENABLE
	AX = DB03h
Return: AL = 00h
SeeAlso: AX=DA03h,AX=DB00h"ZFAX",AX=DB02h"ZFAX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB03_0" name="2FDB03_0"><b>2FDB03</b></a> - INT 2F U - WINGO.COM - SET ??? FLAG<br />
<pre>
INT 2F U - WINGO.COM - SET ??? FLAG
	AX = DB03h
Return: AX = 0000h
SeeAlso: AX=DB00h"WINGO",AX=DB04h"WINGO",AX=DB05h"WINGO",AX=DB06h"WINGO"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB04" name="2FDB04"><b>2FDB04</b></a> - INT 2F U - WINGO.COM - RESET ??? FLAG<br />
<pre>
INT 2F U - WINGO.COM - RESET ??? FLAG
	AX = DB04h
Return: AX = 0000h
SeeAlso: AX=DB00h"WINGO",AX=DB03h"WINGO",AX=DB05h"WINGO",AX=DB06h"WINGO"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB05" name="2FDB05"><b>2FDB05</b></a> - INT 2F U - WINGO.COM - GET ??? FLAG<br />
<pre>
INT 2F U - WINGO.COM - GET ??? FLAG
	AX = DB05h
Return: AX = 0000h
	DX = unknown flag - 0 or 1
Program: WINGO.COM is TSR for starting Windows programs from DOS
	  prompt (together with companion Windows program
	  WINSTART.EXE) written by Douglas Boling, contributing editor of
	  PC Magazine
SeeAlso: AX=DB00h"WINGO",AX=DB03h"WINGO",AX=DB04h"WINGO"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB06" name="2FDB06"><b>2FDB06</b></a> - INT 2F U - WINGO.COM - CALL CALLBACK FUNCTION<br />
<pre>
INT 2F U - WINGO.COM - CALL CALLBACK FUNCTION
	AX = DB06h
Return: AX = return value of INT 2F/AX=1685h
Note:	uses Windows service INT 2F/AX=1685h (SWITCH VMs AND CALLBACK) to
	  call the callback function previously set by AX=DB01h
	used for WINGO &lt;-&gt; WINSTART communication
SeeAlso: AX=1685h, AX=DB00h"WINGO",AX=DB01h"WINGO",AX=DB02h"WINGO",
SeeAlso: AX=DB03h"WINGO",AX=DB04h"WINGO",AX=DB05h"WINGO"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB10" name="2FDB10"><b>2FDB10</b></a> - INT 2F - ZyXEL ZFAX v3+ - EXECUTE ZFAX MAIN MENU<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - EXECUTE ZFAX MAIN MENU
	AX = DB10h
SeeAlso: AX=DB00h"ZFAX",AX=DB11h"ZFAX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB11" name="2FDB11"><b>2FDB11</b></a> - INT 2F - ZyXEL ZFAX v3+ - SEND FAX<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - SEND FAX
	AX = DB11h
	DS:SI -&gt; filename including path (max 128 characters)
	DS:BX -&gt; remote FAX number
Return: AX = status (see #03096)
SeeAlso: AX=DB00h"ZFAX",AX=DB12h,AX=DB13h,AX=DB14h,AX=DB15h,AX=DB20h,AX=DB21h

(Table 03096)
Values for ZFAX status:
 00h	OK
 01h	invalid DOS function
 02h	file not found
 03h	path not found
 04h	no file handle available
 05h	access denied by DOS
 06h	invalid handle
 07h	disk full
 10h	printer error
 11h	no graphics font
 12h	no ZFAX font
 20h	DCD dropped while sending
 21h	not ZyXEL modem
 22h	busy
 23h	no response from COM port
 24h	no carrier
 25h	no dial tone
 26h	no answer
 27h	no response
 28h	failed to send FAX
 30h	user aborted
 40h	critical error on disk
 50h	parameter error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB12" name="2FDB12"><b>2FDB12</b></a> - INT 2F - ZyXEL ZFAX v3+ - PRINT FAX<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - PRINT FAX
	AX = DB12h
	DS:SI -&gt; filename, including path (max 128 characters)
Return: AX = status (see #03096)
SeeAlso: AX=DB11h,AX=DB13h,AX=DB14h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB13" name="2FDB13"><b>2FDB13</b></a> - INT 2F - ZyXEL ZFAX v3+ - CONVERT FAX<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - CONVERT FAX
	AX = DB13h
	DS:SI -&gt; source filename, including path (max 128 characters)
	DS:BX -&gt; destination filename, including path (max 80 characters)
	CX = destination file format
	    00h FAX, 01h PCX, 02h TIFF, 03h PRN
Return: AX = status (see #03096)
SeeAlso: AX=DB11h,AX=DB12h,AX=DB14h,AX=DB22h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB14" name="2FDB14"><b>2FDB14</b></a> - INT 2F - ZyXEL ZFAX v3+ - VIEW FAX<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - VIEW FAX
	AX = DB14h
	DS:SI -&gt; source filename, including path (max 128 characters)
Return: AX = status (see #03096)
SeeAlso: AX=DB11h,AX=DB12h,AX=DB14h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB15" name="2FDB15"><b>2FDB15</b></a> - INT 2F - ZyXEL ZFAX v4.01 - SEND FAX WITH LOGO AND SIGNATURE<br />
<pre>
INT 2F - ZyXEL ZFAX v4.01 - SEND FAX WITH LOGO AND SIGNATURE
	AX = DB15h
	DS:SI -&gt; source filename, including path (max 128 characters)
	DS:BX -&gt; remote FAX number
	DS:CX -&gt; Logo filename
	DS:DX -&gt; Signature filename
Return: AX = status (see #03096)
SeeAlso: AX=DB00h"ZFAX",AX=DB11h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB16" name="2FDB16"><b>2FDB16</b></a> - INT 2F - ZyXEL ZFAX v4.01 - QUOTE PREVIOUS STATUS<br />
<pre>
INT 2F - ZyXEL ZFAX v4.01 - QUOTE PREVIOUS STATUS
	AX = DB16h
Return: DX:AX -&gt; previous receive state transaction log (see #03097)
	BX = type (00h incoming FAX, 01h incoming data, 02h incoming voice)
SeeAlso: AX=DB00h"ZFAX",AX=DB11h,AX=DB17h

Format of ZFAX transaction log receive state:
Offset	Size	Description	(Table 03097)
 00h	WORD	year
 02h	WORD	date
 04h	WORD	time
 06h	WORD	extension number
 08h	WORD	type: 00h incoming FAX, 01h outgoing FAX, 02h voice message
 0Ah	WORD	status: 00h normal, 01h remote delete
 0Ch 125 BYTEs	filename
 89h 24 BYTEs	caller ID
 A1h 20 BYTEs	FAX number
 B5h 20 BYTEs	remote FAX ID
 C9h	WORD	error code
 CBh	WORD	connection direction (00h transmit, 01h receive)
 CDh	BYTE	connection time minutes
 CEh	BYTE	connection time seconds
 CFh	BYTE	???
 D0h	WORD	connection speed (24, 48, 72, 96, 12, 144)
 D2h	WORD	connection page size (A4, B4, A3)
 D4h	WORD	connection coding scheme (1-DN, 1-DH, 2-DN, 2-DH)
 D6h	WORD	page count

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB17" name="2FDB17"><b>2FDB17</b></a> - INT 2F - ZyXEL ZFAX v4.01 - BEGIN RECEIVING INCOMING CALL<br />
<pre>
INT 2F - ZyXEL ZFAX v4.01 - BEGIN RECEIVING INCOMING CALL
	AX = DB17h
Return: AX = status (0000h successful, 0001h unable to start at this time)
SeeAlso: AX=DB00h"ZFAX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB18" name="2FDB18"><b>2FDB18</b></a> - INT 2F - ZyXEL ZFAX v4.01 - SCHEDULE CALL<br />
<pre>
INT 2F - ZyXEL ZFAX v4.01 - SCHEDULE CALL
	AX = DB18h
	DS:SI -&gt; schedule data (see #03097)
Return: AX = status (see #03096)
SeeAlso: AX=DB00h"ZFAX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB20" name="2FDB20"><b>2FDB20</b></a> - INT 2F - ZyXEL ZFAX v3+ - POLL FAX<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - POLL FAX
	AX = DB20h
	DS:SI -&gt; remote FAX number
Return: AX = status (see #03096)
SeeAlso: AX=DB11h,AX=DB21h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB21" name="2FDB21"><b>2FDB21</b></a> - INT 2F - ZyXEL ZFAX v3+ - SEND VOICE<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - SEND VOICE
	AX = DB21h
	DS:SI -&gt; filename including path (max 128 characters)
	DS:BX -&gt; remote phone number
Return: AX = status (see #03096)
SeeAlso: AX=DB11h,AX=DB20h,AX=DB22h,AX=DB23h,AX=DB24h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB22" name="2FDB22"><b>2FDB22</b></a> - INT 2F - ZyXEL ZFAX v3+ - CONVERT VOICE FILE<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - CONVERT VOICE FILE
	AX = DB22h
	DS:SI -&gt; source filename, including path (max 128 characters)
	DS:BX -&gt; destination filename, including path (max 80 characters)
	CX = destination format
	    00h two-bit ADPCM, 01h three-bit ADPCM, 02h VOC
Return: AX = status (see #03096)
SeeAlso: AX=DB13h,AX=DB20h,AX=DB21h,AX=DB23h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB23" name="2FDB23"><b>2FDB23</b></a> - INT 2F - ZyXEL ZFAX v3+ - RECORD VOICE FILE<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - RECORD VOICE FILE
	AX = DB23h
	DS:SI -&gt; destination filename, including path (max 128 characters)
	CX = recording channel (0 = telephone line, 1 = microphone/speaker)
	DX = voice file format
	    00h CELP, 01h two-bit ADPCM, 02h three-bit ADPCM
Return: AX = status (see #03096)
SeeAlso: AX=DB21h,AX=DB22h,AX=DB24h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB24" name="2FDB24"><b>2FDB24</b></a> - INT 2F - ZyXEL ZFAX v3+ - PLAY VOICE FILE<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - PLAY VOICE FILE
	AX = DB24h
	DS:SI -&gt; name of voice file, including path (max 128 characters)
	CX = playback channel (0 = telephone line, 1 = microphone/speaker)
Return: AX = status (see #03096)
SeeAlso: AX=DB21h,AX=DB22h,AX=DB24h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB25" name="2FDB25"><b>2FDB25</b></a> - INT 2F - ZyXEL ZFAX v3+ - ANSWER MODEM WITH VOICE SYSTEM<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - ANSWER MODEM WITH VOICE SYSTEM
	AX = DB25h
Return: AX = status (see #03096)
SeeAlso: AX=DB21h,AX=DB22h,AX=DB26h,AX=DB27h,AX=DB28h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB26" name="2FDB26"><b>2FDB26</b></a> - INT 2F - ZyXEL ZFAX v3+ - DIAL PHONE<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - DIAL PHONE
	AX = DB26h
	DS:SI -&gt; remote phone number
Return: AX = status (see #03096)
SeeAlso: AX=DB25h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB27" name="2FDB27"><b>2FDB27</b></a> - INT 2F - ZyXEL ZFAX v3+ - RECEIVE FAX - ANSWER MODEM AND SET TO FAX MODE<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - RECEIVE FAX - ANSWER MODEM AND SET TO FAX MODE
	AX = DB27h
Return: AX = status (see #03096)
SeeAlso: AX=DB25h,AX=DB28h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB28" name="2FDB28"><b>2FDB28</b></a> - INT 2F - ZyXEL ZFAX v3+ - RECEIVE FAX DATA - ANSWER MODEM IN MULTI-AUDIO MODE<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - RECEIVE FAX DATA - ANSWER MODEM IN MULTI-AUDIO MODE
	AX = DB28h
Return: AX = status (see #03096)
SeeAlso: AX=DB25h,AX=DB27h,AX=DB41h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB40" name="2FDB40"><b>2FDB40</b></a> - INT 2F - ZyXEL ZFAX v3+ - INTERNAL TERMINAL<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - INTERNAL TERMINAL
	AX = DB40h
Return: AX = status (see #03096)
SeeAlso: AX=DB00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDB41" name="2FDB41"><b>2FDB41</b></a> - INT 2F - ZyXEL ZFAX v3+ - SEND DATA - DIAL NUMBER AND UPLOAD FILE WITH ZMODEM<br />
<pre>
INT 2F - ZyXEL ZFAX v3+ - SEND DATA - DIAL NUMBER AND UPLOAD FILE WITH ZMODEM
	AX = DB41h
	DS:SI -&gt; source file name, including path (max 128 characters)
	DS:BX -&gt; remote data number
Return: AX = status (see #03096)
SeeAlso: AX=DB00h,AX=DB28h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDC00" name="2FDC00"><b>2FDC00</b></a> - INT 2F - GOLD.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - GOLD.COM - INSTALLATION CHECK
	AX = DC00h
Return: AL = state
	    00h not installed
	    FFh installed
Program: GOLD is a TSR by Bob Eager which makes the NumLock key return the
	  code for F1; the purpose is to improve Kermit's VTxxx emulation

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDC01" name="2FDC01"><b>2FDC01</b></a> - INT 2F - GOLD.COM - GET STATE<br />
<pre>
INT 2F - GOLD.COM - GET STATE
	AX = DC01h
Return: AL = status
	    00h off
	    01h on
SeeAlso: AX=DC00h,AX=DC02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDC02" name="2FDC02"><b>2FDC02</b></a> - INT 2F - GOLD.COM - SET STATE<br />
<pre>
INT 2F - GOLD.COM - SET STATE
	AX = DC02h
	DL = new state
	    00h off
	    01h on
Return: AL = 00h (OK)
SeeAlso: AX=DC01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDD" name="2FDD"><b>2FDD</b></a> - INT 2F - CappaCom programs - API<br />
<pre>
INT 2F - CappaCom programs - API
	AH = DDh
	AL = 00h general installation check
	    Return: AL = FFh if any CappaCom programs are resident
	AL = FEh get info
	    Return: ES:BX -&gt; TSR info list (see #03098)
	AL = program identifier
	    BH = function
		FDh get version
		    Return: BX = version
		FFh installation check
		    Return: AL = FFh if installed
				BX = version
				ES = segment of resident code
		others vary by program
Return: AL = status
	    bit 7 set on error
	    AL = 81h unknown function
Note:	CappaCom was originally SoftCom but changed its name due to a trademark
	  conflict
Index:	installation check;SoftCom programs
Index:	installation check;CappaCom programs

Format of CappaCom TSR info list:
Offset	Size	Description	(Table 03098)
 00h  9 BYTEs	blank-padded ASCIZ program name
 09h	BYTE	program ID
 0Ah	WORD	program's PSP segment
 0Ch	WORD	program version (major in high byte)
 0Eh	DWORD	pointer to next item in info list or 0000h:0000h
 12h	BYTE	number of interrupts hooked
 13h  5 BYTEs	interrupt numbers hooked by program
 18h  8 BYTEs	reserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDD_0" name="2FDD_0"><b>2FDD</b></a> - INT 2F - MIXFIX.EXE - API<br />
<pre>
INT 2F - MIXFIX.EXE - API
	AH = DDh
	AL = function
	    00h installation check
		Return: AX = 00DDh if installed
			    BX = version (BH = major, BL = minor)
	    41h/61h get From: address
		Return: AX = 0001h
			ES:BX -&gt; ASCIZ 4d address of mail sender ("1:2/3.4")
	    49h/69h get To: address
		Return: AX = 0001h
			ES:BX -&gt; ASCIZ 4d address of recipient ("1:2/3.4")
	    4Ah/6Ah get subject of mail
		Return: AX = 0001h
			ES:BX -&gt; ASCIZ subject of handled mail
	    4Dh/6Dh get mail name
		Return: AX = 0001h
			ES:BX -&gt; ASCIZ full name of current mail file
	    4Eh/6Eh get From: field
		Return: AX = 0001h
			ES:BX -&gt; ASCIZ From: field of mail (mail sender's name)
Program: MIXFIX by "KIV without Co" is a FidoNet mail robot which may execute
	  other programs for mail handling.  The called programs may use the
	  services described here to retrieve information about the mail being
	  handled.
Index: installation check;MIXFIX.EXE

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDD--BX7844" name="2FDD--BX7844"><b>2FDD--BX7844</b></a> - INT 2F - xDISK v3.32+ - INSTALLATION CHECK<br />
<pre>
INT 2F - xDISK v3.32+ - INSTALLATION CHECK
	AH = DDh
	BX = 7844h ('xD')
	CX = 4953h ('IS')
	DX = 4B3Fh ('K?')
	AL = desired drive (01h-1Ah) or 00h to check for xDISK on any drive
	ES:DI -&gt; 25-byte data buffer (see #03099)
Return: AX = DDFFh if installed (on specified drive if AL nonzero on entry)
	   BX = 87BBh
	   DX = B4C0h
	   ES:DI buffer filled
	CX,CF destroyed
SeeAlso: INT 21/AX=4404h"xDISK",INT 21/AX=4405h"xDISK"

Format of xDISK data buffer:
Offset	Size	Description	(Table 03099)
 00h	DWORD	pointer to ASCIZ driver signature "xDISK unit: X"
 04h	BYTE	flag: 01h if disk linked to DOS, 00h if unlinked
 05h	BYTE	flag: 01h if write protected, 00h if not
 06h	BYTE	flag: 01h if root directory full, 00h if not
 07h	BYTE	flag: 01h if free space uncompacted, 00h if compacted
 08h	BYTE	resizing state: 00h not resizable, 01h resized, 80h resizable
 09h	BYTE	flag: 01h inelastic resizable disk, 00h elastic
 0Ah  2 BYTEs	reserved
 0Ch	BYTE	flag: 01h collapsed disk, 00h not collapsed
 0Dh	BYTE	flag: 01h using all EMS, 00h some EMS free
 0Eh	BYTE	flag: 01h password enabled, 00h disabled
 0Fh	BYTE	flag: 01h password audio feedback, 00h no feedback
 10h	BYTE	flag: 01h password video feedback, 00h no feedback
 11h	BYTE	flag: 01h confirm changes, 00h no confirmation
 12h	BYTE	flag: 01h terse display, 00h verbose display
 13h	BYTE	flag: 01h click speaker on disk access, 00h no click
 14h	BYTE	flag: 01h flash icon on disk access, 00h no icon flash
 15h	BYTE	FAT entry size: 00h 12-bit, FFh 16-bit
 16h	WORD	count of open files in RAM disk
 18h	BYTE	unused

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE00BL00" name="2FDE00BL00"><b>2FDE00BL00</b></a> - INT 2F U - Novell Netware - RPRINTER, NPRINTER - INSTALLATION CHECK<br />
<pre>
INT 2F U - Novell Netware - RPRINTER, NPRINTER - INSTALLATION CHECK
	AX = DE00h
	BL = 00h
Return: AL = FFh If Rprinter/Nprinter Installed
	BX -&gt; Program Segment Prefix N/Rprinter.exe

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE00BX4456" name="2FDE00BX4456"><b>2FDE00BX4456</b></a> - INT 2F - DESQview v2.26+ External Device Interface - INSTALLATION CHECK<br />
<pre>
INT 2F - DESQview v2.26+ External Device Interface - INSTALLATION CHECK
	AX = DE00h
	BX = 4456h ("DV")
	CX = 5844h ("XD")
	DX = 4931h ("I1")
Return: AL = FFh if installed (even if other registers do not match)
	if BX,CX, and DX were as specified on entry,
	    BX = 4845h ("HE")
	    CX = 5245h ("RE")
	    DX = 4456h ("DV")
Range:	AH=C0h to AH=FFh, selected by scanning AH=DEh-FFh, then AH=C0h-DDh
Note:	the XDI handler should not issue any DOS or BIOS calls, nor should it
	  issue DESQview API calls other than those allowed from hardware ints
SeeAlso: AX=DE02h,INT 15/AX=5400h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE01" name="2FDE01"><b>2FDE01</b></a> - INT 2F - DESQview v2.26+ External Device Interface - DRIVER CUSTOM SUBFUNCTION<br />
<pre>
INT 2F - DESQview v2.26+ External Device Interface - DRIVER CUSTOM SUBFUNCTION
	AX = DE01h
	BX = driver ID
	other registers as needed by driver
Notes:	XDI drivers should pass this call through to previous handler if ID
	  does not match
	DESQview never calls this function

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE01BX4450" name="2FDE01BX4450"><b>2FDE01BX4450</b></a> - INT 2F U - Quarterdeck QDPMI.SYS v1.0 - INSTALLATION CHECK<br />
<pre>
INT 2F U - Quarterdeck QDPMI.SYS v1.0 - INSTALLATION CHECK
	AX = DE01h
	BX = 4450h ("DP")
	CX = 4D49h ("MI")
	DX = 3039h ("09")
Return: AL = FFh if installed
	    BX = 4D42h ("MB")
	    CX = 4921h ("I!")
	    DX = 8F4Fh
	    ES:DI -&gt; filename of DPMI host overlay
InstallCheck:	test for the existence of the character device QDPMI$$$
SeeAlso: INT 2F/AX=1687h,INT 31/AX=0000h
Index:	installation check;QDPMI

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE01BX5242" name="2FDE01BX5242"><b>2FDE01BX5242</b></a> - INT 2F - DESQview v2.26+ XDI - CUSTOM SUBFUNCTION, Ralf Brown's XDI drivers<br />
<pre>
INT 2F - DESQview v2.26+ XDI - CUSTOM SUBFUNCTION, Ralf Brown's XDI drivers
	AX = DE01h
	BX = 5242h ("RB")
	CX:DX = program identifier
		656F7000h ("eop",0) for DVeop
Return: AX = 5242h ("RB") if installed
	    ES:BX -&gt; data or entry point (see #03100)
	    CX = version number (CH = major, CL = minor)

(Table 03100)
Call DVeop entry point with:
	ES:DI -&gt; callback address or 0000h:0000h to remove callback
Return: AX = status
	    0000h failed (callback table full or attempted to remove non-
		  existent callback)
	    0001h successful
		ES:DI -&gt; chaining address
	BX,CX,DX destroyed
Notes:	the callback function is called with a simulated interrupt when the
	  DESQview window containing it is closed; it should perform all
	  necessary cleanup and then perform a FAR jump to the chaining address
	  or an IRET if the chaining address is 0000h:0000h
	if the program wishes to remove itself before the window is closed, it
	  should call the DVeop entry point with the previously returned
	  chaining address and ignore the returned chaining address.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE01BX7474" name="2FDE01BX7474"><b>2FDE01BX7474</b></a> - INT 2F - DESQview v2.26+ XDI - CUSTOM SUBFUNCTION, DVTXDI.COM<br />
<pre>
INT 2F - DESQview v2.26+ XDI - CUSTOM SUBFUNCTION, DVTXDI.COM
	AX = DE01h
	BX = 7474h
	CL = function
	    00h installation check
		Return: AL = FFh
	    01h get process handle
		DX = keys on Open Window menu (DL = first, DH = second)
		Return: AX = process handle or 0000h if not running
	    02h (v1.3+) set TMAN handle
		DX = TMAN process handle
	    03h (v1.3+) set open keys to ignore on next CL=01h call
		DX = keys on Open Window menu (DL = first, DH = second)
Return: BX = 4F4Bh ("OK")
	DL destroyed
Note:	DVTXDI is distributed as part of the shareware products DVTree (DOS
	 shell/DESQview process manager) and DVTMAN by Mike Weaver
Index:	installation check;DVTXDI

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE01BX7575" name="2FDE01BX7575"><b>2FDE01BX7575</b></a> - INT 2F - DESQview v2.26+ XDI - CUSTOM SUBFUNCTION, DVSIXDI.COM<br />
<pre>
INT 2F - DESQview v2.26+ XDI - CUSTOM SUBFUNCTION, DVSIXDI.COM
	AX = DE01h
	BX = 7575h
	CX = function
	    0000h installation check
		Return: AX = 00FFh if installed
	    0001h turn on notification (currently unused)
		Return: AX = 0001h
	    0002h turn off notification (currently unused)
		Return: AX = 0001h
	    0003h get process information
		Return: AX = status
			    0000h failed
			    0001h successful
				BX = last instantaneous time slice
				    in 1/100s (v1.10)
				    in 1/18s (v1.11+)
				CX = number of processes
				DX = number of "(starting)" records (v2.00+)
				SI = number of records in process info array
				      (v2.00+) (always 15 for v1.x)
				ES:DI -&gt; process info array (see #03101,#03102)
	    0004h get version
		Return: AH = major version
			AL = minor version
	    0005h (v1.10+) get time since DESQview started
		Return: DX:AX = 1/100s since DV start (v1.10)
			DX:AX = 1/18s since DV start (v1.11+)
	    0006h (v1.10+) get number of task switches
		Return: DX:AX = total task switches
			CX = task switches in last instantaneous interval
Notes:	DVSIXDI is part of the DVSI (DESQview System Information) package by
	  Daniel J. Bodoh
	for v1.00, function 0003h allocates common memory, which the caller
	  must deallocate after reading the process information; only the
	  currently used records are placed in the buffer
	for v1.10+, function 0003h merely returns a pointer to the internal
	  array of process information; the caller should make a copy of the
	  array while inside a critical section (see INT 15/AX=101Bh).	Only
	  those records with bit 7 of the first byte set are valid.
Index:	installation check;DVSIXDI

Format of DVSIXDI v1.00 information for one process:
Offset	Size	Description	(Table 03101)
 00h	BYTE	flags
		bit 7: process slot is valid
 01h	WORD	offset into DESQVIEW.DVO of program's record if started from
		  Open Windows menu, else undefined
 03h	WORD	Switch Windows window number
 05h	WORD	segment of process handle
 07h	WORD	number of tasks owned by process
 09h	WORD	mapping context of process (see #00416 at INT 15/AX=1016h)
 0Bh	DWORD	hook for other programs

Format of DVSIXDI v1.10-v2.00 information for one process:
Offset	Size	Description	(Table 03102)
 00h	BYTE	process flags (see #03103)
 01h	WORD	Open Window keys
 03h	WORD	Switch Windows number
 05h	WORD	segment of process handle
 07h	WORD	number of tasks for process
 09h	WORD	process mapping context
 0Bh	DWORD	time process started (relative to start of DESQview)
 0Fh	DWORD	time process last got CPU (relative to start of DESQview)
 13h	DWORD	time process last gave up CPU (relative to start of DESQview)
 17h	DWORD	total CPU time since process started
 1Bh	DWORD	CPU time at start of current instantaneous interval
 1Fh	DWORD	CPU time in current instantaneous interval
 23h	DWORD	hook for other programs
Note:	all times are in 1/100s for v1.10, in 1/18s for v1.11+

Bitfields for DVSIXDI process flags:
Bit(s)	Description	(Table 03103)
 7	valid record
 6	(v2.00+) record is allocated; if bit 7 clear, process is "(starting)"
	  and only offsets 01h and 09h are valid
 5	(v2.00+) this app currently owns the CPU
 4	reserved (0)
 3	DESQview system task
 2	reserved (0)
 1	task has keyboard (currently unused)
 0	task swapped out (currently unused)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE01BXFFFE" name="2FDE01BXFFFE"><b>2FDE01BXFFFE</b></a> - INT 2F U - DESQview v2.26+ XDI - DVXMS.DVR - ???<br />
<pre>
INT 2F U - DESQview v2.26+ XDI - DVXMS.DVR - ???
	AX = DE01h
	BX = FFFEh
	CX = 4D47h ("MG")
	DX = 0052h (0,"R")
Return: AL = FFh
	DX = 584Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE02" name="2FDE02"><b>2FDE02</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - DV INITIALIZATION COMPLETE<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - DV INITIALIZATION COMPLETE
	AX = DE02h
	BX = mapping context of DESQview
	DX = handle of DESQview system task
Note:	driver should pass this call to previous handler after doing its work
SeeAlso: AX=DE03h,AX=DE0Fh,INT 15/AX=5400h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE03" name="2FDE03"><b>2FDE03</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - DV TERMINATION<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - DV TERMINATION
	AX = DE03h
	BX = mapping context of DESQview
	DX = handle of DESQview system task
Notes:	driver should pass this call to previous handler before doing its work
	DESQview makes this call when it is exiting, but before unhooking any
	  interrupt vectors
SeeAlso: AX=DE02h,AX=DE0Fh,INT 15/AX=5407h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE04" name="2FDE04"><b>2FDE04</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - ADD PROCESS<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - ADD PROCESS
	AX = DE04h
	BX = mapping context of new process (see #00416 at INT 15/AX=1016h)
	DX = handle of process
Return: nothing
Notes:	XMS XDI handler (installed by default) allocates a 22-byte record
	  (see #03104) from "common" memory to control access to XMS memory
	all DOS, BIOS, and DV API calls are valid in handler
	driver should pass this call to previous handler after processing it
SeeAlso: AX=DE05h,AX=DE06h,INT 15/AX=5401h

Format of XMS XDI structure:
Offset	Size	Description	(Table 03104)
 00h	DWORD	pointer to 10-byte record???
 04h	DWORD	pointer to next XMS XDI structure
 08h	WORD	mapping context
 0Ah	BYTE	???
 0Bh  5 BYTEs	XMS entry point to return for INT 2F/AX=4310h"XMS"
		(FAR jump to next field)
 10h  6 BYTEs	FAR handler for XMS driver entry point
		(consists of a FAR CALL followed by RETF)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE05" name="2FDE05"><b>2FDE05</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - REMOVE PROCESS<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - REMOVE PROCESS
	AX = DE05h
	BX = mapping context of process (see #00416 at INT 15/AX=1016h)
	DX = handle of last task in process
Return: nothing
Notes:	XMS XDI handler releases the structure allocated by AX=DE04h
	driver should pass this call to previous handler before processing it
	all DOS, BIOS, and DV API calls except those generating a task switch
	  are valid in handler
SeeAlso: AX=DE04h,AX=DE07h,INT 15/AX=5402h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE06" name="2FDE06"><b>2FDE06</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - CREATE TASK<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - CREATE TASK
	AX = DE06h
	BX = mapping context of process containing task
	DX = handle of new task
Notes:	driver should pass this call to previous handler after processing it
	all DOS, BIOS, and DV API calls are valid in handler

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE07" name="2FDE07"><b>2FDE07</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - TERMINATE TASK<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - TERMINATE TASK
	AX = DE07h
	BX = mapping context of process containing task
	DX = handle of task
Notes:	driver should pass this call to previous handler before processing it
	all DOS, BIOS, and DV API calls except those generating a task switch
	  are valid in handler
SeeAlso: AX=DE04h,AX=DE06h,AX=DE10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE08" name="2FDE08"><b>2FDE08</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - SAVE STATE<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - SAVE STATE
	AX = DE08h
	BX = mapping context of task being switched from
	      (see #00416 at INT 15/AX=1016h)
	DX = handle of task being switched from
Notes:	invoked prior to task swap, interrupts, etc
	driver should pass this call to previous handler after processing it
SeeAlso: AX=DE09h,INT 15/AX=5403h,INT 15/AX=DE27h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE09" name="2FDE09"><b>2FDE09</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - RESTORE STATE<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - RESTORE STATE
	AX = DE09h
	BX = mapping context of task being switched to
	      (see #00416 at INT 15/AX=1016h)
	DX = handle of task being switched to
Notes:	state is restored except for interrupts
	driver should pass this call to previous handler before processing it
SeeAlso: AX=DE08h,INT 15/AX=5404h,INT 15/AX=DE27h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0A" name="2FDE0A"><b>2FDE0A</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - CHANGE KEYBOARD FOCUS<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - CHANGE KEYBOARD FOCUS
	AX = DE0Ah
	BX = mapping context of task receiving focus
	DX = handle of running task
Notes:	driver should pass this call to previous handler before processing it
	this call often occurs inside a keyboard interrupt
	DV 2.42 does not provide this call to XDI handlers running inside a
	  window; instead, it directly calls the INT 2F handler which was
	  active at the time DV started
SeeAlso: INT 15/AX=DE26h,INT 15/AX=DE2Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0B" name="2FDE0B"><b>2FDE0B</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - DVP PROCESSING COMPLETE<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - DVP PROCESSING COMPLETE
	AX = DE0Bh
	BX = mapping context of DESQview system task
	CX = number of system memory paragraphs required for the use of all
	      XDI drivers (DV will add this to system memory in DVP buffer)
	DX = handle of DESQview system task
	SI = mapping context of new process if it starts
	ES:DI -&gt; DVP buffer
Return: CX incremented as needed
Notes:	once DV invokes this function, the DVP buffer contents may be changed
	driver should pass this call to previous handler before processing it

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0C" name="2FDE0C"><b>2FDE0C</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - SWAP OUT PROCESS<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - SWAP OUT PROCESS
	AX = DE0Ch
	BX = mapping context of task being swapped out
	      (see #00416 at INT 15/AX=1016h)
	DX = handle of DESQview system task
Note:	driver should pass this call to previous handler after processing it

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0D" name="2FDE0D"><b>2FDE0D</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - SWAP IN PROCESS<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - SWAP IN PROCESS
	AX = DE0Dh
	BX = mapping context of process just swapped in
	      (see #00416 at INT 15/AX=1016h)
	DX = handle of DESQview system task
Note:	driver should pass this call to previous handler before processing it

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0E" name="2FDE0E"><b>2FDE0E</b></a> - INT 2F C - DESQview v2.26+ External Dev Interface - DVP START FAILED<br />
<pre>
INT 2F C - DESQview v2.26+ External Dev Interface - DVP START FAILED
	AX = DE0Eh
	BX = mapping context of DESQview system task
	DX = handle of DESQview system task
	SI = mapping context of failed process (same as for call to AX=DE0Bh)
Note:	driver should pass this call to previous handler after processing it

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE0F" name="2FDE0F"><b>2FDE0F</b></a> - INT 2F C - DESQview v2.50+ External Dev Interface - INITIALIZE DV<br />
<pre>
INT 2F C - DESQview v2.50+ External Dev Interface - INITIALIZE DV
	AX = DE0Fh
Note:	DESQview 2.50+ calls this function just before it completes its
	  initialization.  At the time of the call, DESQview has not yet
	  changed any interrupt vectors
SeeAlso: AX=DE02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDE10" name="2FDE10"><b>2FDE10</b></a> - INT 2F C - DESQview v2.50+ External Dev Interface - FREE TASK<br />
<pre>
INT 2F C - DESQview v2.50+ External Dev Interface - FREE TASK
	AX = DE10h
	BX = mapping context of process (see #00416 at INT 15/AX=1016h)
	DX = task handle of process
Note:	DESQview 2.50+ calls this function before it frees the task; it is
	  similar to AX=DE07h but allows the XDI handler to make calls which
	  cause context switches
SeeAlso: AX=DE06h,AX=DE07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDF00" name="2FDF00"><b>2FDF00</b></a> - INT 2F - HyperWare programs - INSTALLATION CHECK<br />
<pre>
INT 2F - HyperWare programs - INSTALLATION CHECK
	AX = DF00h
	BX = product code (see #03105)
	CX = 0000h
	DX = 0000h
Return: AL = status
	    00h not installed
	    FFh multiplex number in use
		CX = 5948h ('YH') if selected product installed
		---HyperDisk---
		BX = code segment of resident portion
		DX = HyperDisk local data version
Program: HyperDisk is a shareware disk cache by HyperWare (Roger Cross)
Range:	AH=C0h to AH=FFh, selected by scanning AH=DFh, then AH=C0h-FFh
SeeAlso: INT 13/AX=8EEDh
Index:	installation check;HyperDisk|installation check;HyperStb
Index:	installation check;HyperKey|installation check;HyperScreen
Index:	HyperDisk;installation check|HyperStb;installation check
Index:	HyperKey;installation check|HyperScreen;installation check

(Table 03105)
Values for HyperWare product code:
 4248h	('BH') HyperStb
 4448h	('DH') HyperDisk v4.20+
 4B48h	('KH') HyperKey
 5348h	('SH') HyperScreen

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDF00BX5445" name="2FDF00BX5445"><b>2FDF00BX5445</b></a> - INT 2F U - Quarterdeck TELTSR.COM - INSTALLATION CHECK<br />
<pre>
INT 2F U - Quarterdeck TELTSR.COM - INSTALLATION CHECK
	AX = DF00h
	BX = 5445h ('TE')
	CX = 4C54h ('LT')
	DX = 5352h ('SR')
Return: BX = 5454h ('TT') if installed
	CX = 494Eh ('IN') if installed
	DX = 5454h ('ST') if installed
Program: TELTSR is a Telnet TSR included with Quarterdeck's DESQview/X v2.00
	  which provides an INT 14h interface to the network
Range:	AH=DEh to AH=FFh and AH=C0h to AH=DDh, selected by scanning
SeeAlso: AX=DF01h"TELTSR",AX=DF02h"TELTSR",INT 14/AH=56h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDF01BX0000" name="2FDF01BX0000"><b>2FDF01BX0000</b></a> - INT 2F U - MSG.COM - INSTALLATION CHECK<br />
<pre>
INT 2F U - MSG.COM - INSTALLATION CHECK
	AX = DF01h
	BX = 0000h
Return: AX = FDFFh if installed
	   BX = segment of resident code
Program: MSG.COM is a TSR for intercepting incoming Novell broadcast
	  messages written by Gary Dobbins (Dobbins@Arizona.Edu)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDF01BX4448" name="2FDF01BX4448"><b>2FDF01BX4448</b></a> - INT 2F - HyperDisk v4.50+ - GET CURRENT CACHE STATE<br />
<pre>
INT 2F - HyperDisk v4.50+ - GET CURRENT CACHE STATE
	AX = DF01h
	BX = 4448h ('DH')
Return: AX = 0000h if function supported
	    BX = number of cache buffers in use
	    CX = number of cache buffers which have been modified
	    DL = caching flags (see #03106)
Range:	AH=C0h to AH=FFh, selected by scanning AH=DFh, then AH=C0h-FFh
SeeAlso: AX=DF00h,AX=DF02h

Bitfields for HyperDisk caching flags:
Bit(s)	Description	(Table 03106)
 0	staged writes enabled for floppy disks
 1	staged writes enabled for hard disks
 2	writes verified on floppy disks
 3	writes verified on hard disks
 4	reserved (0)
 5	reserved (0)
 6	floppy caching enabled
 7	all caching functions enabled

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDF01" name="2FDF01"><b>2FDF01</b></a> - INT 2F U - Quarterdeck TELTSR.COM - CLOSE CONNECTION<br />
<pre>
INT 2F U - Quarterdeck TELTSR.COM - CLOSE CONNECTION
	AX = DF01h
Return: nothing???
Note:	invokes the DESQview/X socket API (see INT 15/AX=DE2Eh) function 0006h
	  to close the socket corresponding to the file handle set with
	  AX=DF02h; NOP if no file handle was ever set
SeeAlso: AX=DF00h"TELTSR",AX=DF02h"TELTSR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDF02BX4448" name="2FDF02BX4448"><b>2FDF02BX4448</b></a> - INT 2F - HyperDisk v4.50+ - SET CACHE STATE<br />
<pre>
INT 2F - HyperDisk v4.50+ - SET CACHE STATE
	AX = DF02h
	BX = 4448h ('DH')
	DL = new caching flags (see #03106)
Return: AX = 0000h if supported
	    BX = number of cache buffers in use
	    CX = number of cache buffers which have been modified
	    DL = previous caching flags (see #03106)
Program: HyperDisk is a shareware disk cache by HyperWare (Roger Cross)
Range:	AH=C0h to AH=FFh, selected by scanning AH=DFh, then AH=C0h-FFh
SeeAlso: AX=DF00h,AX=DF01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FDF02" name="2FDF02"><b>2FDF02</b></a> - INT 2F U - Quarterdeck TELTSR.COM - OPEN CONNECTION<br />
<pre>
INT 2F U - Quarterdeck TELTSR.COM - OPEN CONNECTION
	AX = DF02h
	BX = file handle for connection's socket
Return: AX = status
	    0000h successful
	    FFFFh no more room in TELTSR's JFT
Program: TELTSR is a Telnet TSR included with Quarterdeck's DESQview/X v2.00
Notes:	the indicated file handle becomes owned by TELTSR, and is closed in
	  the caller's JFT
	multiple calls to this function will override the previous assignment
	  without closing the previous file; use AX=DF01h before further calls
SeeAlso: AX=DF00h"TELTSR",AX=DF01h"TELTSR"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE000" name="2FE000"><b>2FE000</b></a> - INT 2F - SETDRVER.COM v2.10+ - INSTALLATION CHECK<br />
<pre>
INT 2F - SETDRVER.COM v2.10+ - INSTALLATION CHECK
	AX = E000h
Return: AX = 4A52h ("JR") if present
Program: SETDRVER is a public domain TSR by Jacob Rieper which sets the
	  apparent DOS version analogously to MS-DOS SETVER
Notes:	this installation check differs from the usual one of returning AL=FFh
	the SETDRVER API is fully emulated by Matthias Paul's FREEVER
SeeAlso: AX=E000h/DX=4D50h,AX=E001h,INT 21/AH=52h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE000_0" name="2FE000_0"><b>2FE000</b></a> - INT 2F - KAOSHIDE - INSTALLATION CHECK<br />
<pre>
INT 2F - KAOSHIDE - INSTALLATION CHECK
	AX = E000h
Return: AL = FFh if installed
Program: KAOSHIDE ('Hidden Kaos') is a PD joke TSR which randomly capitalizes
	  alphabetic keys, written by Philip Maland. Although not a virus,
	  v2.0 uses some viral-like techniques to hide itself from
	  memory-reports by reducing DOS memory size.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE000DX4D50" name="2FE000DX4D50"><b>2FE000DX4D50</b></a> - INT 2F - FREEVER v1.0+ - INSTALLATION CHECK<br />
<pre>
INT 2F - FREEVER v1.0+ - INSTALLATION CHECK
	AX = E000h
	DX = 4D50h ('MP')
Return: AL = FFh if installed
	    AH = AMIS INT 2Dh multiplex ID
	    CX = FREEVER version (CH=major, CL=minor)
	    DX:DI -&gt; AMIS-compliant signature (see #02569)
		(vendor ID is "M. Paul ", program name is "FREEVER ")
Program: FREEVER is an AMIS-conformant freeware DOS version-faking TSR similar
	  to SETVER for any DOS-compatible OS, written by Matthias Paul
Note:	FREEVER emulates INT 21/AH=30h, INT 21/AX=3306h, INT 21/AX=4412h,
	  INT 21/AX=4452h, and SETDRVER's API on INT 2F/AX=E00xh, as well as
	  providing an AMIS API on INT 2Dh
SeeAlso: AX=E000h"SETDRVER",INT 21/AH=30h,INT 21/AX=3306h,INT 21/AX=4452h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE000DX5354" name="2FE000DX5354"><b>2FE000DX5354</b></a> - INT 2F - StuffIt v3.21+ - INSTALLATION CHECK<br />
<pre>
INT 2F - StuffIt v3.21+ - INSTALLATION CHECK
	AX = E000h
	DX = 5354h ("ST")
Return: AL = FFh if installed
	    BX = version (BH = major, BL = BCD minor)
	    DX = segment of resident code
Program: StuffIt is a freeware delayed keyboard stuffer by Terje Mathisen

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE001" name="2FE001"><b>2FE001</b></a> - INT 2F - SETDRVER.COM v2.10+ - GET SETDRVER VERSION<br />
<pre>
INT 2F - SETDRVER.COM v2.10+ - GET SETDRVER VERSION
	AX = E001h
Return: AH = major version
	AL = minor version
Note:	the SETDRVER API is fully emulated by Matthias Paul's FREEVER, which
	  returns version 2.10 for this call; use AX=E000h/DX=45D0h to get
	  FREEVER's version number
SeeAlso: AX=E000h,AX=E000h/DX=45D0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE002" name="2FE002"><b>2FE002</b></a> - INT 2F - SETDRVER.COM v2.10+ - GET ORIGINAL DOS VERSION INFO<br />
<pre>
INT 2F - SETDRVER.COM v2.10+ - GET ORIGINAL DOS VERSION INFO
	AX = E002h
Return: AL = FFh if successful
	    BH = major DOS version
	    BL = minor DOS version
	    CH = DOS version flag
	    CL = OEM number
	    DH = major DR DOS version number (FFh if unknown)
	    DL = minor DR DOS version number (FFh if unknown)
SeeAlso: AX=E003h,AX=E007h,INT 21/AH=30h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE003" name="2FE003"><b>2FE003</b></a> - INT 2F - SETDRVER.COM v2.10+ - RESET INTERNAL VARIABLES<br />
<pre>
INT 2F - SETDRVER.COM v2.10+ - RESET INTERNAL VARIABLES
	AX = E003h
	BH = new major DOS version
	BL = new minor DOS version
	CH = new DOS version flag
	CL = new DOS revision number
	DH = new OEM number
SeeAlso: AX=E002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE004" name="2FE004"><b>2FE004</b></a> - INT 2F - SETDRVER.COM v2.10+ - ENABLE TSR<br />
<pre>
INT 2F - SETDRVER.COM v2.10+ - ENABLE TSR
	AX = E004h
Return: AL = FFh if successful
SeeAlso: AX=E000h,AX=E005h,AX=E006h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE005" name="2FE005"><b>2FE005</b></a> - INT 2F - SETDRVER.COM v2.10+ - DISABLE TSR<br />
<pre>
INT 2F - SETDRVER.COM v2.10+ - DISABLE TSR
	AX = E005h
Return: AL = FFh if successful
SeeAlso: AX=E000h,AX=E004h,AX=E006h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE006" name="2FE006"><b>2FE006</b></a> - INT 2F - SETDRVER.COM v2.10+ - GET TSR STATUS<br />
<pre>
INT 2F - SETDRVER.COM v2.10+ - GET TSR STATUS
	AX = E006h
Return: AL = FFh if successful
	    BL = status
		01h resident and active
		02h resident and inactive

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE007" name="2FE007"><b>2FE007</b></a> - INT 2F - SETDRVER.COM v2.10+ - GET TaskMAX STATUS AT INSTALLATION<br />
<pre>
INT 2F - SETDRVER.COM v2.10+ - GET TaskMAX STATUS AT INSTALLATION
	AX = E007h
Return: AL = FFh if successful
	    BL = status
		00h if TaskMAX not loaded before SETDRVER
		FFh if TaskMAX was loaded before SETDRVER
SeeAlso: AX=E003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE0" name="2FE0"><b>2FE0</b></a> - INT 2F - SETDRVER.COM - RESERVED FOR FUTURE USE<br />
<pre>
INT 2F - SETDRVER.COM - RESERVED FOR FUTURE USE
	AH = E0h
	AL = 08h-10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE100" name="2FE100"><b>2FE100</b></a> - INT 2F - Phantom2 v1.1+ - INSTALLATION CHECK<br />
<pre>
INT 2F - Phantom2 v1.1+ - INSTALLATION CHECK
	AX = E100h
Return: AX = 0001h if installed
	    DS:SI -&gt; ASCIZ hotkey name
	    DS:DI -&gt; ASCIZ recording filename
Program: Phantom of the Keyboard II is a shareware keystroke recorder/replayer
	  by P2 Enterprises
SeeAlso: AX=E101h,AX=E102h,AX=E103h,AX=E300h
Index:	hotkeys;Phantom2

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE101" name="2FE101"><b>2FE101</b></a> - INT 2F - Phantom2 v1.1+ - FUNCTION REQUEST<br />
<pre>
INT 2F - Phantom2 v1.1+ - FUNCTION REQUEST
	AX = E101h
	BX = function mask (see #03107)
	CX = code for hotkey (as returned by INT 16/AH=00h) if BX bit 6 set
	DS:DX -&gt; ASCIZ filespec if BX bit 7 set
SeeAlso: AX=E100h
Index:	hotkeys;Phantom2

Bitfields for Phantom2 function mask:
Bit(s)	Description	(Table 03107)
 0	record
 1	play
 2	QuickPlay
 3	loop
 4	mode display toggle
 5	sound toggle
 6	set hotkey
 7	set filespec

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE102" name="2FE102"><b>2FE102</b></a> - INT 2F - Phantom2 v1.1+ - UNINSTALL<br />
<pre>
INT 2F - Phantom2 v1.1+ - UNINSTALL
	AX = E102h
Return: AX = status
	    0001h removal successful
	    0002h not installed as TSR
	    FFFFh disabled but not removed
SeeAlso: AX=E100h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE103" name="2FE103"><b>2FE103</b></a> - INT 2F - Phantom2 v2.8 - SET ??? FLAG<br />
<pre>
INT 2F - Phantom2 v2.8 - SET ??? FLAG
	AX = E103h
Return: AX = 0001h
SeeAlso: AX=E100h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE200" name="2FE200"><b>2FE200</b></a> - INT 2F - SecureDevice - LOGIN TO DRIVE<br />
<pre>
INT 2F - SecureDevice - LOGIN TO DRIVE
	AX = E200h
	DL = drive number (0 = A:)
	DS:SI -&gt; 104-byte key
Return: AL = status
	    00h unable to determine key's validity
	    01h key is valid
	    FFh key is invalid
Program: SecureDevice is a copylefted device driver by Max Loewenthal and
	  Arthur Helwig which turns one or more disk files into encrypted
	  logical drives
SeeAlso: AX=E201h,AX=E203h,AX=E209h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE201" name="2FE201"><b>2FE201</b></a> - INT 2F - SecureDevice - GET INFORMATION<br />
<pre>
INT 2F - SecureDevice - GET INFORMATION
	AX = E201h
	DX = driver index (0000h = first loaded)
Return: AL = number of volumes handled by driver
	DL = drive number of first volume (00h = A:)
SeeAlso: AX=E200h,AX=E203h,AX=E209h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE203" name="2FE203"><b>2FE203</b></a> - INT 2F - SecureDevice - DESTROY PASSWORD (LOGOUT FROM DRIVE)<br />
<pre>
INT 2F - SecureDevice - DESTROY PASSWORD (LOGOUT FROM DRIVE)
	AX = E203h
	DL = drive number (00h = A:) or FFh for all drives
Return: nothing
SeeAlso: AX=E200h,AX=E209h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE209DX0000" name="2FE209DX0000"><b>2FE209DX0000</b></a> - INT 2F - SecureDevice - INSTALLATION CHECK<br />
<pre>
INT 2F - SecureDevice - INSTALLATION CHECK
	AX = E209h
	DX = 0000h
Return: AX = 1DEAh if installed
	    DX = number of drivers installed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE300" name="2FE300"><b>2FE300</b></a> - INT 2F - ANARKEY.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - ANARKEY.COM - INSTALLATION CHECK
	AX = E300h
Return: AL = state
	    00h not installed
	    FEh if installed but suspended (v3.0+)
	    FFh installed
Program: ANARKEY.COM is a commandline recall program by Steven Calwas
Range:	AH=C0h to AH=FFh, selected by commandline switch
SeeAlso: AX=E100h,AX=E301h,AX=E302h,AX=E303h,AX=E304h,AX=E305h,AX=E306h
SeeAlso: AX=E307h,INT 66"Newkey"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE300_0" name="2FE300_0"><b>2FE300</b></a> - INT 2F - Blank - INSTALLATION CHECK<br />
<pre>
INT 2F - Blank - INSTALLATION CHECK
	AX = E300h
Return: AL = FFh if installed
	    ES = resident code segment
Program: Blank is a shareware screen blanker by Yonah Schmeidler
Note:	AH=E3h is the default, which may be reconfigured by the installation
	  program in the registered version
SeeAlso: AH=93h,AX=C050h,INT 14/AX=AA01h
Index:	screen saver;Blank

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE301" name="2FE301"><b>2FE301</b></a> - INT 2F U - ANARKEY.COM v2+ - GET ???<br />
<pre>
INT 2F U - ANARKEY.COM v2+ - GET ???
	AX = E301h
Return: DX:BX -&gt; ??? (see #03108,#03109)
SeeAlso: AX=E300h

Format of returned data structure for ANARKEY v2.0:
Offset	Size	Description	(Table 03108)
 -7   7 BYTEs	signature ('ANARKEY')
 00h	WORD	??? (I see 0001h in v2.0)
 02h	WORD	??? (I see 0001h in v2.0)
 04h	WORD	??? (I see 0 in v2.0)
 06h	WORD	PSP segment of next program loaded

Format of returned data structure for ANARKEY v3+:
Offset	Size	Description	(Table 03109)
 -1	BYTE	multiplex number
 00h	WORD	??? (I see 0001h in v3.0-4.0)
 02h	WORD	??? (I see 0001h in v3.0-4.0)
 04h	BYTE	??? (I see 0 in v3.0-4.0)
 05h	WORD	PSP segment of next program loaded

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE302" name="2FE302"><b>2FE302</b></a> - INT 2F U - ANARKEY.COM v3+ - ???<br />
<pre>
INT 2F U - ANARKEY.COM v3+ - ???
	AX = E302h
	BL = ???
Return: ???
SeeAlso: AX=E300h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE303" name="2FE303"><b>2FE303</b></a> - INT 2F U - ANARKEY.COM v3+ - ANARKMD API<br />
<pre>
INT 2F U - ANARKEY.COM v3+ - ANARKMD API
	AX = E303h
	BL = function
	    01h toggle insert mode
	    02h display contents of history buffer
	    03h write history buffer to file
		ES:DX -&gt; file name
	    04h clear history buffer
	    05h undefine all aliases
	    06h show aliases
	    07h list programs using Unix switchar
	    08h jump to bottom of history buffer
	    09h (v4.0) add string to history buffer
		ES:DX -&gt; ASCIZ string
	    0Ah (v4.0) ???
		ES:DX -&gt; ???
	    0Bh (v4.0) copy string to edit buffer for use as next input line
		ES:DX -&gt; ASCIZ string
	    0Ch (v4.0) ???
	    0Dh (v4.0) copy ??? to ???
	    0Eh (v4.0) ???
	    0Fh (v4.0) ???
	    10h (v4.0) set ??? flag
	    11h (v4.0) display error message about running in EMS under Windows
Return: ???
SeeAlso: AX=E300h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE304" name="2FE304"><b>2FE304</b></a> - INT 2F U - ANARKEY.COM v2+ - ???<br />
<pre>
INT 2F U - ANARKEY.COM v2+ - ???
	AX = E304h
	BL = ???
Return: ???
SeeAlso: AX=E300h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE305" name="2FE305"><b>2FE305</b></a> - INT 2F U - ANARKEY.COM v3+ - ENABLE/SUSPEND ANARKEY<br />
<pre>
INT 2F U - ANARKEY.COM v3+ - ENABLE/SUSPEND ANARKEY
	AX = E305h
	BL = new state
	    01h suspended
	    00h enabled
SeeAlso: AX=E300h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE306" name="2FE306"><b>2FE306</b></a> - INT 2F U - ANARKEY.COM v4.0 - GET ???<br />
<pre>
INT 2F U - ANARKEY.COM v4.0 - GET ???
	AX = E306h
Return: AX = ???
SeeAlso: AX=E300h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE307" name="2FE307"><b>2FE307</b></a> - INT 2F U - ANARKEY.COM v4.0 - GET ???<br />
<pre>
INT 2F U - ANARKEY.COM v4.0 - GET ???
	AX = E307h
Return: AX = ???
	BL = ???
SeeAlso: AX=E300h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE337" name="2FE337"><b>2FE337</b></a> - INT 2F - INT16.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - INT16.COM - INSTALLATION CHECK
	AX = E337h
Return: AX = 0013h if installed
Program: INT16.COM is an INT16 keyboard BIOS replacement for
	  INT 16/AH=00h-02h,10h-12h (based on K3) written by Martin Gerdes
	  and published in c't 05/1990.
SeeAlso: AX=ED58h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE44D" name="2FE44D"><b>2FE44D</b></a> - INT 2F - NDOS - API<br />
<pre>
INT 2F - NDOS - API
	AX = E44Dh
Program: NDOS is a version of 4DOS licensed to Symantec for inclusion in the
	  Norton Utilities
Note:	as NDOS is a licensed version of 4DOS v3.03, the API is identical to
	  that for 4DOS, except that AH=E4h instead of D4h and the installation
	  check returns AX=44EEh instead of AX=44DDh
SeeAlso: AX=D44Dh,AX=E44Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE44E" name="2FE44E"><b>2FE44E</b></a> - INT 2F C - NDOS - AWAITING USER INPUT<br />
<pre>
INT 2F C - NDOS - AWAITING USER INPUT
	AX = E44Eh
	BX = condition
	    0000h NDOS is ready to display prompt
	    0001h NDOS has displayed the prompt, about to accept user input
Return: handler must preserve SI, DI, BP, SP, DS, ES, and SS
SeeAlso: AX=E44Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE44FBX0000" name="2FE44FBX0000"><b>2FE44FBX0000</b></a> - INT 2F - NDOS v4.0+ - KSTACK.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - NDOS v4.0+ - KSTACK.COM - INSTALLATION CHECK
	AX = E44Fh
	BX = 0000h
Return: AX = 44EEh if installed
Program: NDOS is a version of 4DOS licensed to Symantec for inclusion in the
	  Norton Utilities
Note:	this function is also supported by ANSIPLUS v3.01+ and K3PLUS v6.20+,
	  which emulate the 4DOS and NDOS keystack
SeeAlso: AX=D44Fh/BX=0000h,AX=E44Fh/BX=0001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE44FBX0001" name="2FE44FBX0001"><b>2FE44FBX0001</b></a> - INT 2F - NDOS v4.0+ - KSTACK.COM - PLACE KEYSTROKES INTO KEYSTACK<br />
<pre>
INT 2F - NDOS v4.0+ - KSTACK.COM - PLACE KEYSTROKES INTO KEYSTACK
	AX = E44Fh
	BX = 0001h
	CX = number of keystrokes (01h-FFh)
	DS:DX -&gt; keystroke list (one word per keystroke)
Return: AX = status
	    0000h successful
	    nonzero failed
	BX,CX,DX destroyed
Notes:	the keystrokes are the exact values to return from subsequent calls to
	  INT 16 with AH=00h,01h,10h, or 11h, with the following exceptions:
		0000h causes subfunctions 01h and 11h to indicate an empty
		      keyboard buffer
		FFFFh is followed by a word indicating the number of clock
		      ticks to delay before the next faked keystroke
	v4.00 KSTACK overwrites any unread keystrokes from the previous
	  invocation, and does not range-check CX; it will overwrite memory
	  following the resident portion if CX is greater than 100h.
	this function is also supported by ANSIPLUS v3.01+ and K3PLUS v6.20+,
	  which emulate the 4DOS and NDOS keystack
SeeAlso: AX=E44Fh/BX=0000h,INT 16/AH=00h,INT 21/AX=4403h"DOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE600CL30" name="2FE600CL30"><b>2FE600CL30</b></a> - INT 2F - Virtual 486 - INSTALLATION CHECK<br />
<pre>
INT 2F - Virtual 486 - INSTALLATION CHECK
	AX = E600h
	CL = 30h
	BX = C0DEh
Return: BX = DEC0h if installed
Program: Virtual 486 is a 80486 CPU emulator for an 80386 by Solar Designer

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE700BX4158" name="2FE700BX4158"><b>2FE700BX4158</b></a> - INT 2F - Multiplex - ??? - INSTALLATION CHECK???<br />
<pre>
INT 2F - Multiplex - ??? - INSTALLATION CHECK???
	AX = E700h
	BX = 4158h ("AX")
	CX = 4953h ("IS")
	DX = 4845h ("HE")
Return: AL = FFh if installed
	    BX = 4C4Fh ("LO") if ??? installed
	    CX = 4F4Bh ("OK")
	    DX = 4F55h ("OU")
		ES:DI -&gt; ???
Range:	AH=C0h to AH=FFh, selected by scanning AH=E7-FFh, then AH=C0h-E6h
Note:	called by QDPMI when its Real to Protected Mode Switch Entry Point
	  is called

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FE77EBX0000" name="2FE77EBX0000"><b>2FE77EBX0000</b></a> - INT 2F - CTDEMN - INSTALLATION CHECK<br />
<pre>
INT 2F - CTDEMN - INSTALLATION CHECK
	AX = E77Eh
	BX = 0000h
	CX = 4F4Dh ('OM')
	DX = 5453h ('TS')
Return: AX = 7EE7h if installed
	    BX = resident code segment
	    CX = 6F6Dh ('om')
	    DX = 7473h ('ts')
Program: CTDEMN is a file daemon TSR by Simultan AG

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FED00" name="2FED00"><b>2FED00</b></a> - INT 2F - Phar Lap DOS EXTENDERS - INSTALLATION CHECK<br />
<pre>
INT 2F - Phar Lap DOS EXTENDERS - INSTALLATION CHECK
	AX = ED00h
	BL = DOS extender ID (see #03110)
Return: AL = status
	    00h not installed
	    FFh installed
		SI = 5048h ("PH")
		DI = 4152h ("AR")
		CH = major version number
		CL = minor version number
		DX = flags
		    bit 0: running under DPMI
		    bit 1: running under Phar Lap VMM
		if running under DPMI:
		    BX = DPMI version (BH = major, BL = minor)
SeeAlso: AH=A1h,AX=F100h,AX=FBA1h

(Table 03110)
Values for Phar Lap DOS extender ID:
 01h	286dosx v1.3+ (Software Development Kit)
 02h	286dosx v1.3+ (Run-Time Kit)
 03h	386dosx v4.0+ (SDK)
 04h	386dosx v4.0+ (RTK)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FED03" name="2FED03"><b>2FED03</b></a> - INT 2F R - Phar Lap 386/DOS-Extender v4.1 - GET EXTENDER ENTRY POINT<br />
<pre>
INT 2F R - Phar Lap 386/DOS-Extender v4.1 - GET EXTENDER ENTRY POINT
	AX = ED03h
	CX = real-mode code segment
	DX = real-mode data segment
Return: CF clear if successful
	    CX = protected-mode code segment selector
	    DX = protected-mode data segment selector
	    ES:DI -&gt; real-mode entry point for calling protected-mode functions
		      (see INT 21/AX=250Dh)
	CF set on error
	    AX = error code
		0008h unable to allocate LDT descriptors

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FED10BL05" name="2FED10BL05"><b>2FED10BL05</b></a> - INT 2F - Pharlap DOS Extender - ???<br />
<pre>
INT 2F - Pharlap DOS Extender - ???
	AX = ED10h
	BL = 05h
	ES:SI -&gt; ??? structure
Return: AX = ???
	SI = ???
	DI = ???
SeeAlso: AX=ED00h,AX=ED11h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FED11BL05" name="2FED11BL05"><b>2FED11BL05</b></a> - INT 2F - Pharlap DOS Extender - FATAL EXIT TO REAL MODE ???<br />
<pre>
INT 2F - Pharlap DOS Extender - FATAL EXIT TO REAL MODE ???
	AX = ED11h
	BL = 05h
	CX = ???
	DX = ???
	ES:SI -&gt; ??? structure
	SS:SP = new stack ???
Return: ???
Note:	called immediately prior to terminating program with INT 21/AX=4CFFh
SeeAlso: AX=ED00h,AX=ED10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FED58" name="2FED58"><b>2FED58</b></a> - INT 2F U - K5.COM - INSTALLATION CHECK<br />
<pre>
INT 2F U - K5.COM - INSTALLATION CHECK
	AX = ED58h
Return: AX = 000Dh if installed
	    ES = resident code segment
	    BX = ??? (9999h)
	    ???
Program: K5 is an extended keyboard driver by Martin Gerdes, based on his K3
SeeAlso: AX=E337h,INT 16/AX=AF20h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FED80" name="2FED80"><b>2FED80</b></a> - INT 2F - Phar Lap 286|DOS Extender Lite v2.5 - ???<br />
<pre>
INT 2F - Phar Lap 286|DOS Extender Lite v2.5 - ???
	AX = ED80h
	BL = DOS extender ID (see #03110)
	SI = 5048h ("PH")
	DI = 4152h ("AR")
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEDC8BX0000" name="2FEDC8BX0000"><b>2FEDC8BX0000</b></a> - INT 2F - Novell DOS 7+ - SECURITY.BIN - INSTALLATION CHECK<br />
<pre>
INT 2F - Novell DOS 7+ - SECURITY.BIN - INSTALLATION CHECK
	AX = EDC8h ('EDC' = Novell European Development Centre)
	BX = 0000h
	CX = 0000h
	DX = 1234h
Return: ???
Note:	called by Novell DOS 7 LOCK command during installation

(Table 04107)
Call Novell DOS SECURITY.BIN API with:
	AX??? = function
	    0000h get status
	    0001h authenticate password hash
	    0002h get / change encrypted master key password???
	    0003h ??? Set encrypted master key password
	    0004h ??? Get logged-in user ID
	    0005h ??? Set logged-in user ID
	    0006h Get device restriction mask
	    0007h Set device restriction mask
	    0008h Disable PNW DB access
	    0009h Enable PNW DB access
	    000Ah Get user name
	    000Bh Set user name
	    000Ch Change user password hash
	    000Dh Get last function
	    000Eh Get Encoded ASCII password
	    000Fh Set Encoded ASCII password
	    0010h Get user seed
	    0011h Set user seed
	    !!! more info to follow

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEE00" name="2FEE00"><b>2FEE00</b></a> - INT 2F - GRIDLOC.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F - GRIDLOC.EXE - INSTALLATION CHECK
	AX = EE00h
Return: AL = FFh if installed
Program: GRIDLOC is a PC security program by Intelligent Security Systems, Inc.
SeeAlso: INT 21/AH=40h"NB.SYS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEE00_0" name="2FEE00_0"><b>2FEE00</b></a> - INT 2F - XVIEW - INSTALLATION CHECK<br />
<pre>
INT 2F - XVIEW - INSTALLATION CHECK
	AX = EE00h
Return: AX = 00FFh if installed
Program: XVIEW is a hypertext viewer by Flambeaux Software, Inc.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEE00_1" name="2FEE00_1"><b>2FEE00</b></a> - INT 2F - WEB v4.02 - INSTALLATION CHECK<br />
<pre>
INT 2F - WEB v4.02 - INSTALLATION CHECK
	AX = EE00h
Return: AL = status
	    00h not installed
	    FFh installed
Program: WEB is an IPX-based peer-to-peer network by Webcorp.
SeeAlso: AH=EEh"WEB",AX=EEF0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEE01" name="2FEE01"><b>2FEE01</b></a> - INT 2F - XVIEW - POP UP GIVING TOPIC SEARCH KEYWORD<br />
<pre>
INT 2F - XVIEW - POP UP GIVING TOPIC SEARCH KEYWORD
	AX = EE01h
	DS:DX -&gt; ASCIZ string containing case-insensitive keyword to look up
Return: AX = status (see #03111)
Note:	the specified keyword should be a hyperlink in the _IndexPage of some
	  database; the current database is searched first
SeeAlso: AX=EE00h"XVIEW",AX=EE02h,AX=EE03h,AX=EE04h,AX=EE06h

(Table 03111)
Values for XVIEW function status:
 0000h	successful
 00F1h	unknown subfunction
 00F2h	unable to pop up

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEE02" name="2FEE02"><b>2FEE02</b></a> - INT 2F - XVIEW - POP UP GIVING A PAGE NUMBER<br />
<pre>
INT 2F - XVIEW - POP UP GIVING A PAGE NUMBER
	AX = EE02h
	DX = physical page number or anchor page number (see #03112)
Return: AX = status (see #03111)
Note:	physical page numbers are assigned by the hypertext compiler, and
	  will change if a page is inserted in the middle
SeeAlso: AX=EE00h"XVIEW",AX=EE01h,AX=EE05h,AX=EE06h

(Table 03112)
Values for XVIEW anchor page number:
 FFEAh	_Credits
 FFECh	_SearchTopics
 FFEDh	_SearchText
 FFF0h	_ManualList
 FFF5h	_HelpOnHelp
 FFF8h	_HomePage
 FFF9h	_IndexPage

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEE03" name="2FEE03"><b>2FEE03</b></a> - INT 2F - XVIEW - POP UP GIVING FILENAME AND SEARCH TOPIC OR PAGE NUMBER<br />
<pre>
INT 2F - XVIEW - POP UP GIVING FILENAME AND SEARCH TOPIC OR PAGE NUMBER
	AX = EE03h
	DS:DX -&gt; data packet (see #03113)
Return: AX = status (see #03111)
SeeAlso: AX=EE00h"XVIEW",AX=EE01h,AX=EE02h,AX=EE06h

Format of XVIEW data packet:
Offset	Size	Description	(Table 03113)
 00h	DWORD	-&gt; ASCIZ database filespec (0000h:0000h for current database)
 04h	DWORD	-&gt; ASCIZ text to look up or 0000h:0000h
 08h	WORD	page number (0000h if keyword used)
 0Ah  6 BYTEs	reserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEE04" name="2FEE04"><b>2FEE04</b></a> - INT 2F - XVIEW - POP UP AND READ SCREEN FOR SEARCH TOPIC KEYWORD<br />
<pre>
INT 2F - XVIEW - POP UP AND READ SCREEN FOR SEARCH TOPIC KEYWORD
	AX = EE04h
Return: AX = status (see #03111)
Note:	equivalent to the action taken when the user presses the Alt-L hotkey
SeeAlso: AX=EE00h"XVIEW",AX=EE01h,AX=EE03h,AX=EE06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEE05" name="2FEE05"><b>2FEE05</b></a> - INT 2F - XVIEW - POP UP TO MOST-RECENTLY VIEWED PAGE<br />
<pre>
INT 2F - XVIEW - POP UP TO MOST-RECENTLY VIEWED PAGE
	AX = EE05h
Return: AX = status (see #03111)
Note:	equivalent to the action taken when the user presses the Alt-H hotkey
SeeAlso: AX=EE00h"XVIEW",AX=EE02h,AX=EE06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEE06" name="2FEE06"><b>2FEE06</b></a> - INT 2F - XVIEW - WAIT FOR POP-DOWN AND GET EXIT CODE<br />
<pre>
INT 2F - XVIEW - WAIT FOR POP-DOWN AND GET EXIT CODE
	AX = EE06h
Return: AX = status (see also AX=EE01h)
	    0001h specified filename is not an xText database
	    0002h no databases found
	    0003h bad data in file
	    0004h memory shortage
	    0005h unable to open the requested file
	    0007h invalid page number for file
Note:	although this call is not required, the exit code can alert the
	  caller to problems; if the call is not made, the program should
	  enforce a delay of about 1/2 second to allow the viewer to pop up,
	  and should not get keyboard input or attempt disk accesses during
	  the delay
SeeAlso: AX=EE00h"XVIEW",AX=EE01h,AX=EE02h,AX=EE03h,AX=EE04h,AX=EE05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEE" name="2FEE"><b>2FEE</b></a> - INT 2F - WEB v4.02 - WEB MODULE INSTALLATION CHECK<br />
<pre>
INT 2F - WEB v4.02 - WEB MODULE INSTALLATION CHECK
	AH = EEh
	AL = module ID (see #03114)
Return: AX = 0000h if installed
	    ES:DI -&gt; far entry point for module-specific API calls
		  (see #03115,#03116,#03117,#03118,#03119)
Program: WEB is an IPX-based peer-to-peer network by Webcorp.
SeeAlso: AX=EE00h"WEB"

(Table 03114)
Values for WEB module ID:
 10h	server module (SERVER.EXE)
 20h	client module (CLIENT.EXE)
 30h	mail module (MAIL.EXE)
 40h	spooler (PCSPOOL.EXE)
 50h	kernel module (KERNEL.EXE)
 60h	SAP module (KERNEL.EXE)
 70h	resident station manager (SM.EXE)
 90h	router module (ROUTER.EXE)

(Table 03115)
Call server module entry point with:
	BX = function
	    0000h remove server module
		Return: AX = status (0000h if successful, else WEB error code)
	    0001h create SYSINFO file
		Note:	the SYSINFO file is used by the station manager when
			  displaying info for a particular station
	    0002h get server object table
		Return: CX = number of server objects
			ES:DI -&gt; server object table
		Note:	server objects include drives and devices that the
			  server module controls
	    0003h get server variables
		Return: ES:DI -&gt; server variables

(Table 03116)
Call client module entry point with:
	BX = function
	    0000h remove client module
		Return: AX = status (0000h if successful, else WEB error code)
	    0001h decrement client-only flag
	    0002h increment client-only flag
	    0005h set device capture
		Note:	decrements DeviceOutput flag, telling the spooler that
			  it may trap device output again
	    0006h clear device capture
		Note:	increments DeviceOutput flag, telling the spooler that
			  it should not trap device output (this is used
			  internally by the spooler to prevent it from trapping
			  its own output)
	    0007h get client debug pointer
		Return: ES:DI -&gt; client debug data structure (see #03120)
	    0008h get root drive
		Return: AL = WEB startup drive
	    0009h get maximum possible drive/device redirections
		Return: AL = maximum drive redirections
			CH = maximum LPTx redirections
			CL = maximum COMx redirections
	    000Ah suspend client
		Return: AX = previous value of Suspend flag
	    000Bh resume client
		Return: AX = previous value of Suspend flag
	    000Ch get instance data
		CX = maximum number of structures in array
		ES:DI -&gt; buffer for array of WIN_INSTANCE_DATA structures
			  (see #03121)
		Return: CX = number of structures actually returned
		Note:	used internally by WEB4WIN

(Table 03117)
Call mail module entry point with:
	BX = function
	    0000h remove mail module
		Return: AX = status (0000h successful, else WEB error code)
	    0001h set mail poll
		Note:	schedules the WEB mail module
	    0002h set mail notify
		Note:	sets the Notify flag, which determines whether the
			  user will be notified when mail is received
	    0003h clear mail notify
		Note:	clears the Notify flag, which determines whether the
			  user will be notified when mail is received
	    0004h check whether new mail has arrived
		Return: AL = new mail status
			    00h no new mail since last call
			    else new mail has arrived
		Note:	also clears the new-mail flag after retrieving it
	    0005h send notify
		ES:DI -&gt; name of WEB user to be notified
	    0006h get post office
		Return: ES:DI -&gt; full network path of Post Office subdirectory

(Table 03118)
Call spooler entry point with:
	BX = function
	    0000h remove PCSpool module
		Return: AX = status (0000h successful, else WEB error code)
	    0001h set spooler poll
		Note:	schedules the WEB spooler
	    0002h check spooler changed
		Return:	AX = 0000h
		Note:	this call is a NOP in current versions of WEB

(Table 03119)
Call kernel entry point with:
	BX = function
	    0000h remove kernel module
		Return: AX = status (0000h successful, else WEB error code)
	    0001h set kernel ^S filter
		DL = new state (00h don't filter ^S, nonzero do filter)
	    0002h get kernel data area
		Return: ES:DI -&gt; kernel data area
	    0003h display dialog box
		CL = dialog box type
		    00h password
		    01h E-Note received notification
		    02h Novell login
		    03h general notification
		DL = number of rows to display
		ES:SI -&gt; array of far pointers to rows to be displayed
		ES:DI -&gt; Pascal-style input buffer
		Return: AX = status (0000h successful, else error code)
	    0004h kernel service events
	    0005h get kernel's in-critical-section flag
		Return: ES:DI -&gt; kernel InCriticalSection flag
	    0006h schedule DOS event
		AL = directive
		    00h do not ignore WEB ExtraBusy flag
		    01h ignore ExtraBusy flag
		    02h (WEB4WIN) check that current Windows VM is foregrnd VM
		ES:SI -&gt; WEB AES Event Control Block (ECB) (see #03122)
		Notes:	the WEB Asynchronous Event Scheduler is similar to the
			  one used by IPX; this call schedules a special ECB
			  to be executed at a later time.  Unlike IPX ECBs,
			  the timeout must be set explicitly by the caller
			this function also calls function 0004h
	    0007h check busy
		AL = directive
		    00h do not ignore WEB ExtraBusy flag
		    01h ignore ExtraBusy flag
		    02h (WEB4WIN) check that current Windows VM is foregrnd VM
		Return: AX = status (0000h not busy, else busy)
	    0008h set keyboard intercept
		Note:	currently a NOP which returns immediately
	    0009h get keyboard intercept
		Note:	currently a NOP which returns immediately
	    000Ah get dialog flags
		Return: ES:DI -&gt; kernel dialog flags (see #03123)
	    000Bh get network path
		Return: ES:DI -&gt; fully-qualified network path of file where
				the screen is stored on Dialog calls
	    000Ch kernel alternate dialog
		CL = dialog box type
		    00h password
		    01h E-Note received notification
		    02h Novell login
		    03h general notification
		DL = number of rows to display
		ES:SI -&gt; array of far pointers to rows to be displayed
		ES:DI -&gt; Pascal-style input buffer
		Return: AX = status (0000h successful, else error code)
		Note:	this function is identical to function 0003h except
			  that it does not notify WEB4WIN of the impending
			  dialog request
	    000Dh get machine/operating system type
		Return: AX = machine/operating system type
			    01h IBM PC, MS-DOS
			    02h IBM PC, DOSV (Japanese)
			    03h NEC PC-9800, JDOS (Japanese)
			    04h IBM PC, Korean DBC DOS

Format of client debug data structure:
Offset	Size	Description	(Table 03120)
 00h	WORD	total files
 02h	WORD	files free
 04h	WORD	no files
 06h	WORD	minimum files
 08h	WORD	total FCBs
 0Ah	WORD	total safe FCBs
 0Ch	WORD	FCBs in use
 0Eh	WORD	wrong FCB
 10h	WORD	compressed
 12h	WORD	retransmits

Format of WIN_INSTANCE_DATA structure:
Offset	Size	Description	(Table 03121)
 00h	DWORD	real-mode pointer to data to be instanced
 04h	WORD	size of data to be instanced

Format of WEB AES Event Control Block:
Offset	Size	Description	(Table 03122)
 00h	DWORD	link address
 04h	WORD	ESR address
 08h	BYTE	InUse flag
 09h	BYTE	completion code
 0Ah  3 BYTEs	reserved
 0Dh	WORD	timeout
 0Fh	BYTE	IgnoreExtra flag
 10h	WORD	PSP
 12h	DWORD	DTA
 16h	WORD	AX value for DOS critical information
 18h	WORD	BX value for DOS critical information
 1Ah	WORD	CX value for DOS critical information
 1Ch	WORD	DX value for DOS critical information

(Table 03123)
Values for kernel dialog flags:
 01h	dialog will timeout
 02h	display stars instead of entered keystrokes

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEEF0" name="2FEEF0"><b>2FEEF0</b></a> - INT 2F - WEB v4.02 - WEB GENERAL NOTIFICATION<br />
<pre>
INT 2F - WEB v4.02 - WEB GENERAL NOTIFICATION
	AX = EEF0h
	BX = notification function ID (see #03124)
Return: varies by notification function
Program: WEB is an IPX-based peer-to-peer network by Webcorp.
Note:	the notification functions are used internally by WEB modules to notify
	  other modules and external programs of actions or event, and should
	  never be called by an application
SeeAlso: AX=EE00h"WEB"

(Table 03124)
Values for WEB Notification Function ID:
 00h	node added
 01h	node deleted
 02h	dial attempt
 03h	dial failed
 04h	file close
 05h	close connection
 07h	check Windows mode
 20h	link up
 21h	link down

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF000" name="2FF000"><b>2FF000</b></a> - INT 2F U - 4MAP - INSTALLATION CHECK<br />
<pre>
INT 2F U - 4MAP - INSTALLATION CHECK
	AX = F000h
Return: AX = 00FFh
Program: 4MAP is a keybinding program for 4DOS (see AX=D44Dh) by Ho-Ping Tseng
Note:	returns AX=00FFh for any value of AL not listed here
SeeAlso: AX=D44Dh,AX=F001h,AX=F002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF001" name="2FF001"><b>2FF001</b></a> - INT 2F U - 4MAP - GET KEY MAPPINGS<br />
<pre>
INT 2F U - 4MAP - GET KEY MAPPINGS
	AX = F001h
Return: ES:BX -&gt; key mappings
SeeAlso: AX=F000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF002" name="2FF002"><b>2FF002</b></a> - INT 2F U - 4MAP - INSERT CHARACTER INTO ???<br />
<pre>
INT 2F U - 4MAP - INSERT CHARACTER INTO ???
	AX = F002h
	BL = character to insert
Return: AX = status
	    0000h successful
	    0001h buffer full
SeeAlso: AX=F000h,AX=F003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF003" name="2FF003"><b>2FF003</b></a> - INT 2F U - 4MAP - INSERT CHARACTER INTO ???<br />
<pre>
INT 2F U - 4MAP - INSERT CHARACTER INTO ???
	AX = F003h
	BL = character to insert
Return: AX = status
	    0000h successful
	    0001h buffer full
Program: 4MAP is a keybinding program for 4DOS (see AX=D44Dh) by Ho-Ping Tseng
SeeAlso: AX=F000h,AX=F002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF1" name="2FF1"><b>2FF1</b></a> - INT 2F U - MIN-MEM v2.11 - INSTALLATION CHECK<br />
<pre>
INT 2F U - MIN-MEM v2.11 - INSTALLATION CHECK
	AH = F1h
	AL &lt;&gt; F1h
Return: AL = F1h if installed
Program: MIN-MEM is a shareware TSR manager by Biologic which permits up to 24
	  popup TSRs to be loaded but swapped out to disk, EMS, or XMS.	 One
	  TSR at a time is brought back into memory at the user's request.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF100" name="2FF100"><b>2FF100</b></a> - INT 2F - DOS EXTENDER INSTALLATION CHECK<br />
<pre>
INT 2F - DOS EXTENDER INSTALLATION CHECK
	AX = F100h
Return: AL = FFh if DOS extender present
	    SI = 444Fh ("DO")
	    DI = 5358h ("SX")
Note:	supported or soon to be supported by Phar Lap, Rational, Ergo, and IGC
SeeAlso: AH=A1h,AX=ED00h,AX=FBA1h/BX=0081h,INT 15/AX=BF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF1_0" name="2FF1_0"><b>2FF1</b></a> - INT 2F U - RTKernel v4.0 - INSTALLATION CHECK<br />
<pre>
INT 2F U - RTKernel v4.0 - INSTALLATION CHECK
	AH = F1h
	AL = 00h
Return: AX = FFFFh if present
	    CX = 00F1h
Program: RTKernel is a DOS preemptive multitasking library for C/Pascal by
	  On Time Informatik GmbH

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF200" name="2FF200"><b>2FF200</b></a> - INT 2F - WINX - INSTALLATION CHECK<br />
<pre>
INT 2F - WINX - INSTALLATION CHECK
	AX = F200h
Return: AX = 00FFh if installed
Program: WINX is a DOS/Windows utilities by Al Williams which can be used to
	  launch Windows applications from a DOS Box; it was published in
	  "DOS and Windows Protected Mode-Programming with DOS Extenders"
	  (Addison-Wesley) and should not be confused with the Windows driver
	  of the same name which is part of the DESQview/X package

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF201" name="2FF201"><b>2FF201</b></a> - INT 2F - WINX - RETURN ADDRESS OF SERVER BUFFER<br />
<pre>
INT 2F - WINX - RETURN ADDRESS OF SERVER BUFFER
	AX = F201h
Return: AX = status
	    FFFFh if WINX is busy processing a different request
	    0000h if successful
		BX:CX = address of server buffer (see #03125)

Format of WINX server buffer:
Offset	Size	Description	(Table 03125)
 00h	BYTE	command/status
		00h buffer available
		01h buffer contains result
		02h change directory
		03h execute program
		FFh terminate windows portion of WINX
 01h  ? BYTEs	command (03h) or directory (02h)
  or
 01h	DWORD	result (01h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF202" name="2FF202"><b>2FF202</b></a> - INT 2F - WINX - SET SERVER'S WORKING DIRECTORY<br />
<pre>
INT 2F - WINX - SET SERVER'S WORKING DIRECTORY
	AX = F202h
	BX:CX -&gt; directory
Return: AX = status
	    FFFFh if WINX is busy processing a different request
	    0000h if successful
SeeAlso: AX=F200h,AX=F203h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF203" name="2FF203"><b>2FF203</b></a> - INT 2F - WINX - EXECUTE COMMAND<br />
<pre>
INT 2F - WINX - EXECUTE COMMAND
	AX = F203h
	BX:CX -&gt; command
Return: AX = status
	    0000h if successful
	    FFFFh if WINX is busy processing a different request
SeeAlso: AX=F200h,AX=F202h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF400" name="2FF400"><b>2FF400</b></a> - INT 2F - FINDIRQ.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - FINDIRQ.COM - INSTALLATION CHECK
	AX = F400h
Return: AL = 01h if installed
Program: FINDIRQ is a program by Rick Knoblaugh published in the 9/28/93 issue
	  of PC Magazine; when run as a TSR it can determine which IRQs are
	  used only when a device is active
SeeAlso: AX=F401h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF400_0" name="2FF400_0"><b>2FF400</b></a> - INT 2F - PowerLAN - INSTALLATION CHECK???<br />
<pre>
INT 2F - PowerLAN - INSTALLATION CHECK???
	AX = F400h
	???
Return: ???
Note:	this function is called by PowerLAN's NET.EXE just prior to calling
	  AX=F401h (get version)
SeeAlso: AX=F401h"PowerLAN"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF401" name="2FF401"><b>2FF401</b></a> - INT 2F - PowerLAN - GET VERSION<br />
<pre>
INT 2F - PowerLAN - GET VERSION
	AX = F401h
Return: ES:BX -&gt; WORD containing 100*version (in decimal)
Program: PowerLAN is a networking product by Performance Technology
SeeAlso: AX=F400h"PowerLAN",AX=F483h"PowerLAN"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF401CX5121" name="2FF401CX5121"><b>2FF401CX5121</b></a> - INT 2F - FINDIRQ.COM - GET HOOKED INTERRUPTS<br />
<pre>
INT 2F - FINDIRQ.COM - GET HOOKED INTERRUPTS
	AX = F401h
	CX = 5121h ('Q!')
Return: AX:DX -&gt; hooked interrupt table (see #03126)
SeeAlso: AX=F400h

Format of FINDIRQ hooked interrupt table:
Offset	Size	Description	(Table 03126)
 00h	BYTE	1Ch
 01h	DWORD	FINDIRQ's INT 1C handler
 05h	DWORD	original INT 1C handler
 09h	BYTE	28h
 0Ah	DWORD	FINDIRQ's INT 28 handler
 0Eh	DWORD	original INT 28 handler
 12h	BYTE	2Fh
 13h	DWORD	FINDIRQ's INT 2F handler
 17h	DWORD	original INT 2F handler

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF483" name="2FF483"><b>2FF483</b></a> - INT 2F - PowerLAN - ???<br />
<pre>
INT 2F - PowerLAN - ???
	AX = F483h
	???
Return: ???
SeeAlso: AX=F400h"PowerLAN",AX=F401h"PowerLAN"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF700" name="2FF700"><b>2FF700</b></a> - INT 2F - AUTOPARK.COM - INSTALLATION CHECK<br />
<pre>
INT 2F - AUTOPARK.COM - INSTALLATION CHECK
	AX = F700h
Return: AL = state
	    00h not installed
	    FFh installed
Program: AUTOPARK.COM is a resident hard disk parker by Alan D. Jones

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF701" name="2FF701"><b>2FF701</b></a> - INT 2F - AUTOPARK.COM - SET PARKING DELAY<br />
<pre>
INT 2F - AUTOPARK.COM - SET PARKING DELAY
	AX = F701h
	BX:CX = 32-bit count of 55ms timer ticks

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF800CX4455" name="2FF800CX4455"><b>2FF800CX4455</b></a> - INT 2F U - SuperStor PRO 2XON.COM - INSTALLATION CHECK<br />
<pre>
INT 2F U - SuperStor PRO 2XON.COM - INSTALLATION CHECK
	AX = F800h
	CX = 4455h ("DU")
	DL = 45h ("E")
Return: AL = FFh if installed
	    ES:BX -&gt; ASCII signature "Universal Data Exchange"
Program: SuperStor is a disk-compression program by Addstor.
Note:	returns AX=0001h if AL is not 00h or 01h
SeeAlso: AX=1001h,AX=F801h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF801CX4455" name="2FF801CX4455"><b>2FF801CX4455</b></a> - INT 2F U - SuperStor PRO 2XON.COM - UNINSTALL<br />
<pre>
INT 2F U - SuperStor PRO 2XON.COM - UNINSTALL
	AX = F801h
	CX = 4455h ("DU")
	DL = 45h ("E")
	ES:BX = return address if successful
Return: at specified address if successfully removed from memory
	else
	    AL = error code
	    ???
Program: SuperStor is a disk-compression program by Addstor.
Note:	returns AX=0001h if AL is not 00h or 01h
SeeAlso: AX=1001h,AX=F800h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFA00" name="2FFA00"><b>2FFA00</b></a> - INT 2F - Multiplex - ??? - INSTALLATION CHECK???<br />
<pre>
INT 2F - Multiplex - ??? - INSTALLATION CHECK???
	AX = FA00h
	BX = ??? (0408h)
	CX = ??? (001Fh)
	DX = ??? (0102h)
	SI = ??? (5ACCh)
	DI = ??? (0632h)
Return: ???
Note:	called by WinEmacs at startup

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFA00_0" name="2FFA00_0"><b>2FFA00</b></a> - INT 2F - Multiplex - ??? - INSTALLATION CHECK???<br />
<pre>
INT 2F - Multiplex - ??? - INSTALLATION CHECK???
	AX = FA00h
	BX = ??? (03FCh)
	CX = ??? (003Fh)
	DX = ??? (00FFh)
	SI = ??? (5AA6h)
	DI = ??? (0620h)
Return: ???
Note:	called by Matlab at startup

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB" name="2FFB"><b>2FFB</b></a> - INT 2F - Multiplex - RESERVED BY BORLAND INTERNATIONAL<br />
<pre>
INT 2F - Multiplex - RESERVED BY BORLAND INTERNATIONAL
	AH = FBh
SeeAlso: AX=FB42h/BX=0001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB_0" name="2FFB_0"><b>2FFB</b></a> - INT 2F U - Conner Backup Exec AUTORES - API<br />
<pre>
INT 2F U - Conner Backup Exec AUTORES - API
	AH = FBh
	BL = function number (00h-07h)
	???
Return: ???
Program: AUTORES is a resident program launcher for unattended backups

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB00" name="2FFB00"><b>2FFB00</b></a> - INT 2F U - AutoBraille v1.1A - INSTALLATION CHECK<br />
<pre>
INT 2F U - AutoBraille v1.1A - INSTALLATION CHECK
	AX = FB00h
Return: AX = 00FFh if installed
Program: AutoBraille is a shareware text-to-braille converter by KANSYS, Inc.
SeeAlso: INT 10/AX=3800h,INT 14/AX=F0F1h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB00_0" name="2FFB00_0"><b>2FFB00</b></a> - INT 2F U - Jot-It! v1.50 - INSTALLATION CHECK<br />
<pre>
INT 2F U - Jot-It! v1.50 - INSTALLATION CHECK
	AX = FB00h
Return: AX = FFFFh if installed
	    BX = version (BCD, BH=major, BL=minor)
SeeAlso: AX=FB03h"Jot-It",AX=FB01h"Jot-It"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB01" name="2FFB01"><b>2FFB01</b></a> - INT 2F U - AutoBraille v1.1A - ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - ???
	AX = FB01h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB01_0" name="2FFB01_0"><b>2FFB01</b></a> - INT 2F U - Jot-It! v1.50 - GET USER NAME<br />
<pre>
INT 2F U - Jot-It! v1.50 - GET USER NAME
	AX = FB01h
Return: DX:BX -&gt; ASCIZ user name
SeeAlso: AX=FB02h"Jot-It"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB02" name="2FFB02"><b>2FFB02</b></a> - INT 2F U - AutoBraille v1.1A - ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - ???
	AX = FB02h
Return: AH = ???
	AL = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB02_0" name="2FFB02_0"><b>2FFB02</b></a> - INT 2F U - Jot-It! v1.50 - GET MESSAGE DIRECTORY<br />
<pre>
INT 2F U - Jot-It! v1.50 - GET MESSAGE DIRECTORY
	AX = FB02h
Return: DX:BX -&gt; ASCIZ name of directory in which messages are stored
SeeAlso: AX=FB01h"Jot-It"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB03" name="2FFB03"><b>2FFB03</b></a> - INT 2F U - AutoBraille v1.1A - GET NEXT ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - GET NEXT ???
	AX = FB03h
Return: AX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB03_0" name="2FFB03_0"><b>2FFB03</b></a> - INT 2F U - Jot-It! v1.50 - UNINSTALL<br />
<pre>
INT 2F U - Jot-It! v1.50 - UNINSTALL
	AX = FB03h
Return: resident code removed from memory
Note:	CAUTION: NO checks are performed to ensure that the interrupt vectors
	  being unhooked (08h,09h,28h,2Fh) actually point at the Jot-It! code
SeeAlso: AX=FB00h"Jot-It"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB_1" name="2FFB_1"><b>2FFB</b></a> - INT 2F U - AutoBraille v1.1A - SET ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - SET ???
	AH = FBh
	AL = 04h-08h
Return: AX = 0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB_2" name="2FFB_2"><b>2FFB</b></a> - INT 2F U - AutoBraille v1.1A - SET ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - SET ???
	AH = FBh
	AL = 09h-0Fh (???, 0Eh = COM1, 0Fh = COM2)
Return: ???
Program: AutoBraille is a shareware text-to-braille converter by KANSYS, Inc.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB_3" name="2FFB_3"><b>2FFB</b></a> - INT 2F U - AutoBraille v1.1A - SET ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - SET ???
	AH = FBh
	AL = 10h-1Fh
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB20" name="2FFB20"><b>2FFB20</b></a> - INT 2F U - AutoBraille v1.1A - SET ??? FLAGS<br />
<pre>
INT 2F U - AutoBraille v1.1A - SET ??? FLAGS
	AX = FB20h
	BL = flags to set
SeeAlso: AX=FB21h"AutoBraille"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB21" name="2FFB21"><b>2FFB21</b></a> - INT 2F U - AutoBraille v1.1A - CLEAR ??? FLAGS<br />
<pre>
INT 2F U - AutoBraille v1.1A - CLEAR ??? FLAGS
	AX = FB21h
	BL = flags to clear
SeeAlso: AX=FB20h"AutoBraille"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB22" name="2FFB22"><b>2FFB22</b></a> - INT 2F U - AutoBraille v1.1A - SET ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - SET ???
	AX = FB22h
	BL = ???
Program: AutoBraille is a shareware text-to-braille converter by KANSYS, Inc.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB28" name="2FFB28"><b>2FFB28</b></a> - INT 2F U - AutoBraille v1.1A - ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - ???
	AX = FB28h
	BX = ???
	???
Return: ???
SeeAlso: AX=FB29h"AutoBraille"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB29" name="2FFB29"><b>2FFB29</b></a> - INT 2F U - AutoBraille v1.1A - ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - ???
	AX = FB29h
	BX = ???
	???
Return: ???
SeeAlso: AX=FB28h"AutoBraille"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB_4" name="2FFB_4"><b>2FFB</b></a> - INT 2F U - AutoBraille v1.1A - SET ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - SET ???
	AH = FBh
	AL = 2Bh-34h
	BX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB35" name="2FFB35"><b>2FFB35</b></a> - INT 2F U - AutoBraille v1.1A - SET ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - SET ???
	AX = FB35h
	BL = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB36" name="2FFB36"><b>2FFB36</b></a> - INT 2F U - AutoBraille v1.1A - SET ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - SET ???
	AX = FB36h
	BL = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB37" name="2FFB37"><b>2FFB37</b></a> - INT 2F U - AutoBraille v1.1A - SET ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - SET ???
	AX = FB37h
	BL = ???
Program: AutoBraille is a shareware text-to-braille converter by KANSYS, Inc.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0001" name="2FFB42BX0001"><b>2FFB42BX0001</b></a> - INT 2F PU - Borland C++ DPMILOAD.EXE - INSTALLATION CHECK???<br />
<pre>
INT 2F PU - Borland C++ DPMILOAD.EXE - INSTALLATION CHECK???
	AX = FB42h
	BX = 0001h
Return: AX = version number??? (AL=major, AH=minor)
	CX = next-selector increment
---BC2.0---
	ES:BX -&gt; 80-byte buffer for ???
	DX = DPMI version
---BC3.0---
	BX = ??? (0000h)
	DX = ???
	ES:SI -&gt; list of valid selectors ???
Notes:	The version of DPMILOAD distributed with BC++ v2.0 identifies itself
	  as version 1.000, while the version distributed with BC++ 3.0
	  identifies itself as version 1.0; the former is 10864 bytes, the
	  latter 22180 bytes.  The BC2.0 version is a DPMI loader, while
	  the BC3.0 version also adds a DPMI host and DOS extender
	the BC++ 2.0 version displays an error message if called with BX
	  values other than 0001h-0008h
SeeAlso: AX=1687h,AX=FB42h/BX=1001h,AX=FB43h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0002" name="2FFB42BX0002"><b>2FFB42BX0002</b></a> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ALLOCATE MEMORY<br />
<pre>
INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ALLOCATE MEMORY
	AX = FB42h
	BX = 0002h
	CX = size in bytes
	DX = bit flags
	    bit 2: set to allocate DOS memory, clear for DPMI memory
	SI = selector of descriptor to be modified to access allocated memory
	DI = selector of a second descriptor to be modified
Return: AX = ??? or 0000h on error
	CX:DX = linear base address of DPMI memory block
	SI:DI = handle for DPMI memory block or FFFFh:FFFFh
	???
Note:	two segment descriptors may be set if a code and an aliased data
	  segment are required; if only one descriptor is needed, SI should
	  equal DI on entry
BUG:	when allocating DOS memory, the code computes the linear address by
	  multiplying the segment number by 4 rather than shifting by 4
SeeAlso: AX=FB42h/BX=0003h,AX=FB42h/BX=0008h,INT 31/AX=0501h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0002_0" name="2FFB42BX0002_0"><b>2FFB42BX0002</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ALLOCATE MEMORY<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ALLOCATE MEMORY
	AX = FB42h
	BX = 0002h
	ES:SI -&gt; memory block info (see #03127)
Return: ???
Note:	The version of DPMILOAD distributed with BC++ v2.0 identifies itself
	  as version 1.000, while the version distributed with BC++ 3.0
	  identifies itself as version 1.0; the former is 10864 bytes, the
	  latter 22180 bytes.
SeeAlso: AX=FB42h/BX=0003h,AX=FB42h/BX=0008h,INT 31/AX=0501h

Format of DPMILOAD memory block info:
Offset	Size	Description	(Table 03127)
 00h	WORD	flags (see #03128)
 02h	DWORD	block size in bytes
---DPMI memory block---
 06h	DWORD	DPMI memory block handle
---DOS memory block---
 06h	WORD	real-mode segment of memory block
 08h	WORD	selector of memory block
---
 0Ah	DWORD	linear address of memory
 0Eh	WORD	memory operation error code
		0008h no more free LDT descriptors
---if flags bit 0 clear---
 10h	WORD	code segment selector for memory block or 0000h or FFFFh
 12h	WORD	data alias selector for memory block or 0000h or FFFFh
---if flags bit 0 set---
 10h	WORD	data segment selector for memory block or 0000h or FFFFh
 12h	WORD	unused???

Bitfields for DPMILOAD memory block flags:
Bit(s)	Description	(Table 03128)
 0	set if data segment rather than code segment
 1	information valid
 2	set if DOS memory block rather than DPMI memory block
 4	???
 15	set if no LDT selectors for memory block???
SeeAlso: #03127

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0003" name="2FFB42BX0003"><b>2FFB42BX0003</b></a> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET AVAILABLE MEMORY<br />
<pre>
INT 2F PU - Borland C++ DPMILOAD.EXE - GET AVAILABLE MEMORY
	AX = FB42h
	BX = 0003h
Return: DX:AX = size of largest free block in paragraphs
		0000h:0000h on error (BC3.0 version only)
Note:	AX and DX are destroyed on error, but no other error indicator is
	  returned, under the BC++ 2.0 version of DPMILOAD
SeeAlso: AX=FB42h/BX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0004" name="2FFB42BX0004"><b>2FFB42BX0004</b></a> - INT 2F PU - Borland C++ DPMILOAD.EXE - LOAD PROTECTED-MODE EXECUTABLE???<br />
<pre>
INT 2F PU - Borland C++ DPMILOAD.EXE - LOAD PROTECTED-MODE EXECUTABLE???
	AX = FB42h
	BX = 0004h
	DS:DX -&gt; ASCIZ filename of protected-mode executable
Return: CX = selector of ??? or 0000h
---BC3.0---
	DX = status (0000h,FFF4h,others???) (see #03129)
Note:	the filename may also be terminated by a CR rather than a NUL under the
	  BC++ 3.0 version of DPMILOAD

(Table 03129)
Values for DPMILOAD function status:
 0000h	successful
 0001h	??? failure
 0002h	invalid selector
 0004h	unknown error
 0008h	no more LDT descriptors available???
 FFDEh	unable to set descriptor
 FFDFh	unable to get segment base address
 FFE0h	???
 FFF2h	invalid parameter value
 FFF4h	component of filename too long (name not in 8.3 format)
 FFF5h	pathname too long (&gt;79 chars)
 FFF6h	???
 FFF8h	???
 FFF9h	index out of range
 FFFAh	???
 FFFCh	invalid access to code segment???
 FFFEh	???
 FFFFh	general error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0005" name="2FFB42BX0005"><b>2FFB42BX0005</b></a> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NAME<br />
<pre>
INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NAME
	AX = FB42h
	BX = 0005h
	CX = selector of DPMILOAD data (see #03130)
	DS:DX -&gt; ASCIZ or CR-terminated name of ??? (case ignored)
Return: DX = status (see #03129)
	    0000h successful
		AX:BX -&gt; ??? FAR function (called with two words on top of stk)
	    else
		BX destroyed
SeeAlso: AX=FB42h/BX=0006h,AX=FB42h/BX=000Eh

Format of DPMILOAD data:
Offset	Size	Description	(Table 03130)
 00h 12 BYTEs	???
 0Ch	WORD	??? bit flags
 0Eh 14 BYTEs	???
 1Ch	WORD	number of memory control records (see #03133)
 1Eh 25 BYTEs	???
 37h	BYTE	??? bit flags
		bit 4: data valid???
 38h  4 BYTEs	???
 3Ch	WORD	???
 3Eh 12 BYTEs	???
 46h	BYTE	??? counter
 47h	BYTE	???
 48h	BYTE	???
 49h	BYTE	???
 4Ah	WORD	???
 4Ch  2 BYTEs	???
 4Eh	WORD	offset of array of 64-byte memory control records
 52h	WORD	offset of name list (see #03131)
 54h  4 BYTEs	???
 58h	WORD	offset of array of 6-byte objects (see #03132)
 5Ah  8 BYTEs	???
 62h  9 BYTEs	ASCIZ name for ???
 6Bh  9 BYTEs	ASCIZ name for ???
	???

Format of name list entry [array]:
Offset	Size	Description	(Table 03131)
 00h	BYTE	length of name (00h if end of array)
 01h  N BYTEs	name
 N+1	WORD	1-based index into array of unknown 6-byte objects

Format of 6-byte objects:
Offset	Size	Description	(Table 03132)
 00h	BYTE	???
 01h	BYTE	???
 02h	BYTE	???
 03h	BYTE	1-based index of memory control record
 04h	WORD	???

Format of memory control record:
Offset	Size	Description	(Table 03133)
 00h 20 BYTEs	memory block info (see #03127)
 14h  6 BYTEs	???
 1Ah	BYTE	???
 1Bh  2 BYTEs	???
 1Dh	BYTE	??? bit flags
 1Eh 14 BYTEs	???
 2Ch	DWORD	pointer to ??? memory control record or 0000h:0000h
 30h	DWORD	pointer to ??? memory control record or 0000h:0000h
 34h	DWORD	pointer to next??? memory control record or 0000h:0000h
 38h	DWORD	pointer to prev??? memory control record or 0000h:0000h
 3Ch  4 BYTEs	???
Note:	the pointers at offsets 2Ch and 30h form a doubly-linked list, as do
	  the pointers at offsets 34h and 38h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0006" name="2FFB42BX0006"><b>2FFB42BX0006</b></a> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NUMBER<br />
<pre>
INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NUMBER
	AX = FB42h
	BX = 0006h
	CX = selector of DPMILOAD data (see #03130)
	DX = 1-based index into array of ??? 6-byte objects
Return: DX = status (see #03129)
	    0000h successful
		AX:BX -&gt; ??? FAR function (called with two words on top of stk)
	    else
		BX destroyed
SeeAlso: AX=FB42h/BX=0005h,AX=FB42h/BX=000Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0007" name="2FFB42BX0007"><b>2FFB42BX0007</b></a> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0007h
	CX = selector of ???
Return: ???
Note:	The version of DPMILOAD distributed with BC++ v2.0 identifies itself
	  as version 1.000, while the version distributed with BC++ 3.0
	  identifies itself as version 1.0; the former is 10864 bytes, the
	  latter 22180 bytes.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0007_0" name="2FFB42BX0007_0"><b>2FFB42BX0007</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0007h
	CX = selector of DPMILOAD data (see #03130)
	???
Return: DX = status (see #03129)
	    0000h successful
		AX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0008" name="2FFB42BX0008"><b>2FFB42BX0008</b></a> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - FREE MEMORY BLOCK<br />
<pre>
INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - FREE MEMORY BLOCK
	AX = FB42h
	BX = 0008h
	CX = bit flags
	    bit 2: set if DPMI memory, clear if DOS memory
	DX = selector of DOS memory block
	SI:DI = handle of DPMI memory block
Return: DX = 0000h on error, unchanged if succcessful
Note:	The version of DPMILOAD distributed with BC++ v2.0 identifies itself
	  as version 1.000, while the version distributed with BC++ 3.0
	  identifies itself as version 1.0; the former is 10864 bytes, the
	  latter 22180 bytes.
SeeAlso: AX=FB42h/BX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0008_0" name="2FFB42BX0008_0"><b>2FFB42BX0008</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE MEMORY BLOCK<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE MEMORY BLOCK
	AX = FB42h
	BX = 0008h
	ES:SI -&gt; memory block info (see #03127)
Return: ???
SeeAlso: AX=FB42h/BX=0009h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0009" name="2FFB42BX0009"><b>2FFB42BX0009</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - RESIZE MEMORY BLOCK<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - RESIZE MEMORY BLOCK
	AX = FB42h
	BX = 0009h
	ES:SI -&gt; memory block info (see #03127)
	???
Return: ???
SeeAlso: AX=FB42h/BX=0008h"3.0"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000A" name="2FFB42BX000A"><b>2FFB42BX000A</b></a> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INIT DPMI HOST AND SPAWN SUBSHELL<br />
<pre>
INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INIT DPMI HOST AND SPAWN SUBSHELL
	AX = FB42h
	BX = 000Ah
	CX = 0001h
	DX = ???
	SI = ???
Return: after user exits subshell
Notes:	this call is used by DPMIRES; unlike most of the DPMILOAD calls, this
	  function is not available in protected mode.
	the BC2.0 version of DPMILOAD is purely a DPMI loader, while the BC3.0
	  version also adds a DPMI host and DOS extender.
SeeAlso: AX=FB42h/BX=0004h,AX=FB42h/BX=0015h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000B" name="2FFB42BX000B"><b>2FFB42BX000B</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - UNUSED<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - UNUSED
	AX = FB42h
	BX = 000Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000C" name="2FFB42BX000C"><b>2FFB42BX000C</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE DESCRIPTORS FOR MEMORY BLOCK???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE DESCRIPTORS FOR MEMORY BLOCK???
	AX = FB42h
	BX = 000Ch
	ES:SI -&gt; memory block info ??? (see #03127)
Return: DX = status???
SeeAlso: AX=FB42h/BX=000Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000D" name="2FFB42BX000D"><b>2FFB42BX000D</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SIMULATE REAL MODE INTERRUPT<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SIMULATE REAL MODE INTERRUPT
	AX = FB42h
	BX = 000Dh
	CX = number of words to copy from protected-mode to real mode stack
	DL = interrupt number
	DH = flags
	    bit 0: reset the interrupt controller and A20 line
	ES:DI -&gt; real-mode call structure (see #03148 at INT 31/AX=0300h)
Return: CX = status
	    0000h successful
	    0001h failed
SeeAlso: INT 31/AX=0300h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000E" name="2FFB42BX000E"><b>2FFB42BX000E</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???
	AX = FB42h
	BX = 000Eh
	DS:DX -&gt; ASCIZ or CR-terminated name of ???
Return: CX = selector of DPMILOAD data (see #03130) corresponding to name,
	      0000h on error
SeeAlso: AX=FB42h/BX=0006h,AX=FB42h/BX=001Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000F" name="2FFB42BX000F"><b>2FFB42BX000F</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - REALLOCATE LDT DESCRPS TO MEMBLK???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - REALLOCATE LDT DESCRPS TO MEMBLK???
	AX = FB42h
	BX = 000Fh
	ES:SI -&gt; memory block info (see #03127)
Return: ???
SeeAlso: AX=FB42h/BX=000Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0010" name="2FFB42BX0010"><b>2FFB42BX0010</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SEGMENT TO SELECTOR<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SEGMENT TO SELECTOR
	AX = FB42h
	BX = 0010h
	DX = segment number
Return: CX = status (0000h,0008h) (see also AX=FB42h/BX=0004h)
	    0000h successful
		DX = selector number for descriptor
	    0008h failed
SeeAlso: AX=FB42h/BX=0023h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0011" name="2FFB42BX0011"><b>2FFB42BX0011</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0011h
	CX = selector of DPMILOAD data (see #03130)
	???
Return: DX = status (0000h,0002h,FFFEh) (see also #03129)
	    0000h successful
		AX:BX -&gt; ??? name
	    FFFEh ??? error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0012" name="2FFB42BX0012"><b>2FFB42BX0012</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0012h
	CX = selector for ???
Return: CX = selector for ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0013" name="2FFB42BX0013"><b>2FFB42BX0013</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0013h
	CX = selector of DPMILOAD data (see #03130)
	DX = 1-based index of ???
Return: CX = status (0000h,0002h,FFF9h) (see also #03129)
	    0000h successful
		BX = ??? or 0000h
	    FFF9h ??? error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0014" name="2FFB42BX0014"><b>2FFB42BX0014</b></a> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INSTALLATION CHECK
	AX = FB42h
	BX = 0014h
	CX = 0001h
Return: BX = 0000h if installed
Note:	unlike most of the DPMILOAD functions, this call is available only in
	  real or V86 mode
SeeAlso: AX=FB42h/BX=0001h,AX=FB42h/BX=000Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0015" name="2FFB42BX0015"><b>2FFB42BX0015</b></a> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - UNINSTALL<br />
<pre>
INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - UNINSTALL
	AX = FB42h
	BX = 0015h
	CX = 0001h
Return: ???
Note:	unlike most of the DPMILOAD functions, this call is available only in
	  real or V86 mode
SeeAlso: AX=FB42h/BX=000Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0016" name="2FFB42BX0016"><b>2FFB42BX0016</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???
	AX = FB42h
	BX = 0016h
	CX = selector of DPMILOAD data (see #03130)
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
		CX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0017" name="2FFB42BX0017"><b>2FFB42BX0017</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0017h
	CX = ???
	DX = ???
	???
Return: DX = status (0000h,0001h) (see #03129)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0018" name="2FFB42BX0018"><b>2FFB42BX0018</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET ???
	AX = FB42h
	BX = 0018h
	CX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0019" name="2FFB42BX0019"><b>2FFB42BX0019</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0019h
	CX = selector for ???
	???
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
		CX = selector for ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001A" name="2FFB42BX001A"><b>2FFB42BX001A</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 001Ah
	CX = selector for ???
	???
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
	    0004h failed
	CX:BX -&gt; ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001B" name="2FFB42BX001B"><b>2FFB42BX001B</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 001Bh
	CX = selector of DPMILOAD data (see #03130)
	DX = offset of ???
Return: DX = status (0000h,0002h) (see also #03129)
	    0000h successful
		BX = selector for ???
		CX = selector for ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001C" name="2FFB42BX001C"><b>2FFB42BX001C</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 001Ch
	ES = selector for DPMILOAD data (see #03130)
	CX = 1-based index of ???
	DX = 1-based index of ???
Return: DX = status (0000h,0002h,FFF9h) (see #03129)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001D" name="2FFB42BX001D"><b>2FFB42BX001D</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???
	AX = FB42h
	BX = 001Dh
Return: CX:DX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001E" name="2FFB42BX001E"><b>2FFB42BX001E</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 001Eh
	CX = ???
	???
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
	    FFF7h ??? error
	CX:BX -&gt; ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001F" name="2FFB42BX001F"><b>2FFB42BX001F</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???
	AX = FB42h
	BX = 001Fh
	DS:DX -&gt; 8-character name of ???
	???
Return: CX = selector of DPMILOAD data (see #03130) for ???
		0000h on error
SeeAlso: AX=FB42h/BX=000Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0020" name="2FFB42BX0020"><b>2FFB42BX0020</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION???
	AX = FB42h
	BX = 0020h
Return: DX = ??? (always 0000h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0021" name="2FFB42BX0021"><b>2FFB42BX0021</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROCESSOR EXCEPTION HANDLER VECT<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROCESSOR EXCEPTION HANDLER VECT
	AX = FB42h
	BX = 0021h
	CL = exception number (00h-1Fh)
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
		AX:BX = selector:offset of handler
	    FFF2h unable to get exception handler vector
SeeAlso: AX=FB42h/BX=0022h,AX=FB42h/BX=0024h,INT 31/AX=0202h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0022" name="2FFB42BX0022"><b>2FFB42BX0022</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROCESSOR EXCEPTION HANDLER VECT<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROCESSOR EXCEPTION HANDLER VECT
	AX = FB42h
	BX = 0022h
	CL = exception number (00h-1Fh)
	SI:DX = selector:offset of new handler
Return: DX = status (0000h,0004h,FFF2h) (see #03129)
SeeAlso: AX=FB42h/BX=0021h,AX=FB42h/BX=0025h,INT 31/AX=0203h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0023" name="2FFB42BX0023"><b>2FFB42BX0023</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SELECTOR TO SEGMENT NUMBER<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SELECTOR TO SEGMENT NUMBER
	AX = FB42h
	BX = 0023h
	CX = selector
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
		CX = real-mode segment number
	    FFF2h descriptor has invalid base address for real-mode segment
SeeAlso: AX=FB42h/BX=0010h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0024" name="2FFB42BX0024"><b>2FFB42BX0024</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROTECTED-MODE INTERRUPT VECTOR<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROTECTED-MODE INTERRUPT VECTOR
	AX = FB42h
	BX = 0024h
	CL = interrupt number
Return: DX = status (0000h) (see also AX=FB42h/BX=0004h)
	AX:BX = selector:offset of handler
SeeAlso: AX=FB42h/BX=0025h,INT 31/AX=0204h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0025" name="2FFB42BX0025"><b>2FFB42BX0025</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROTECTED-MODE INTERRUPT VECTOR<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROTECTED-MODE INTERRUPT VECTOR
	AX = FB42h
	BX = 0025h
	CL = interrupt number
	SI:DX = selector:offset of new handler
Return: DX = status (0000h,0004h,FFF2h) (see #03129)
SeeAlso: AX=FB42h/BX=0024h,INT 31/AX=0205h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0026" name="2FFB42BX0026"><b>2FFB42BX0026</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0026h
	CX = selector of DPMILOAD data (see #03130)
	DX = 1-based index of ???
	???
Return: DX = status (0000h,0002h,FFF9h) (see #03129)
	    0000h successful
		BX = offset of ??? within data structure

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0027" name="2FFB42BX0027"><b>2FFB42BX0027</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???
	AX = FB42h
	BX = 0027h
	CX = selector of DPMILOAD data (see #03130)
	DX = offset of ???
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
		BX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0080" name="2FFB42BX0080"><b>2FFB42BX0080</b></a> - INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE<br />
<pre>
INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE
	AX = FB42h
	BX = 0080h
	???
Return: AX = ???
	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0081" name="2FFB42BX0081"><b>2FFB42BX0081</b></a> - INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE<br />
<pre>
INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE
	AX = FB42h
	BX = 0081h
	???
Return: AX = ???
	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX1001" name="2FFB42BX1001"><b>2FFB42BX1001</b></a> - INT 2F U - Borland RTM.EXE 1.0 - INSTALLATION CHECK???<br />
<pre>
INT 2F U - Borland RTM.EXE 1.0 - INSTALLATION CHECK???
	AX = FB42h
	BX = 1001h
Return: BX = 0000h
SeeAlso: AX=FB42h/BX=0001h,AX=FB42h/BX=1002h,AX=FB42h/BX=1003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX1002" name="2FFB42BX1002"><b>2FFB42BX1002</b></a> - INT 2F U - Borland RTM.EXE 1.0 - EXECUTE COMPILED PROGRAM<br />
<pre>
INT 2F U - Borland RTM.EXE 1.0 - EXECUTE COMPILED PROGRAM
	AX = FB42h
	BX = 1002h
	DX = 0014h ???
	???
Return: AX = nonzero if successful
	    AH = child program exit method??? (usually 4Ch)
	    AL = child program exit code (Errorlevel)
	AX = 0000h on load error
	    DX = error code (0000h-0027h) (see #03134)
SeeAlso: AX=FB42h/BX=1001h

(Table 03134)
Values for RTM.EXE error code:
 01h	out of memory
 02h	out of selectors
 03h	out of internal tables
 10h	internal error
 18h	internal error
 1Ah	internal error
 1Bh	internal error
 1Ch	internal error
 20h	invalid dynamic link
 21h	internal error
 22h	unable to open file
 23h	invalid .EXE format
 24h	wrong version
 25h	unable to initialize 
 26h	DLL initialization error
 other	unrecognized error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX1003" name="2FFB42BX1003"><b>2FFB42BX1003</b></a> - INT 2F U - Borland RTM.EXE 1.0 - ???<br />
<pre>
INT 2F U - Borland RTM.EXE 1.0 - ???
	AX = FB42h
	BX = 1003h
	???
Return: ???
SeeAlso: AX=FB42h/BX=1001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB43" name="2FFB43"><b>2FFB43</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION
	AX = FB43h
	BX = subfunction (at least 0000h-000Eh)
Notes:	this function is only present in protected mode; it does nothing but
	  an immediate IRET
	DPMILOAD.EXE itself calls various subfunctions:
	    subfunction 0004h is called with CX=selector of ???, DI=selector
		  of DPMILOAD data
	    subfunction 0008h is called with CX=selector of DPMILOAD data
SeeAlso: AX=FB42h/BX=0001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB43BX0100" name="2FFB43BX0100"><b>2FFB43BX0100</b></a> - INT 2F PU - Borland TDX - INSTALLATION CHECK<br />
<pre>
INT 2F PU - Borland TDX - INSTALLATION CHECK
	AX = FB43h
	BX = 0100h
Return: BX = FB43h if loaded
Program: TDX is Borland's Turbo Debugger variant for DPMI programs
Note:	Borland Pascal 7 DPMI programs use this call to check whether they
	  should install their own stack and general protection exception
	  handlers, or allow TDX to handle those exceptions

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB64" name="2FFB64"><b>2FFB64</b></a> - INT 2F U - AutoBraille v1.1A - GET ???<br />
<pre>
INT 2F U - AutoBraille v1.1A - GET ???
	AX = FB64h
Return: AX = ??? (0006h seen)
Program: AutoBraille is a shareware text-to-braille converter by KANSYS, Inc.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFBA1BX0081" name="2FFBA1BX0081"><b>2FFBA1BX0081</b></a> - INT 2F U - TKERNEL (Borland DOS extender) - INSTALLATION CHECK<br />
<pre>
INT 2F U - TKERNEL (Borland DOS extender) - INSTALLATION CHECK
	AX = FBA1h
	BX = 0081h
	ES:DI -&gt; 16-byte buffer
Return: if installed, first four bytes of ES:DI buffer are "IABH"
Program: TKERNEL is a licensed version of AI Architects/Ergo's OS/x86.
Note:	TKERNEL was present only in Borland C++ 2.0; with version 3.0, the DOS
	  extender was moved into DPMILOAD.
SeeAlso: AH=A1h,AX=F100h,AX=FBA1h/BX=0082h,AX=FBA1h/BX=0084h,INT 15/AX=BF02h
SeeAlso: INT 21/AX=4403h"AI Architects"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFBA1BX0082" name="2FFBA1BX0082"><b>2FFBA1BX0082</b></a> - INT 2F U - TKERNEL (Borland DOS extender) - GET ENTRY POINT<br />
<pre>
INT 2F U - TKERNEL (Borland DOS extender) - GET ENTRY POINT
	AX = FBA1h
	BX = 0082h
	ES:DI -&gt; response buffer (see #03135)
Return: ES:DI buffer filled
SeeAlso: AX=FBA1h/BX=0081h,AX=FBA1h/BX=0084h

Format of TKERNEL response buffer:
Offset	Size	Description	(Table 03135)
 00h  4 BYTEs	signature "IABH"
 04h	DWORD	pointer to FAR extender entry point (see #03136)

(Table 03136)
Call TKERNEL entry point with:
	AX = function number
	    0000h initialize???
		STACK:	WORD  ???
		Return: AX = status???
			STACK unchanged
	    0001h get version???
		Return: AX = 0200h for v2.0.34
	    0002h get ???
		Return: AX = ??? (011Eh or 0182h seen)
	    0003h load protected-mode executable
		STACK:	DWORD -&gt; ASCIZ filename of executable
			DWORD	???
			DWORD -&gt; program arguments (counted string plus CR)
			DWORD -&gt; environment for protected-mode executable
				(terminated with two consecutive NULs)
			DWORD -&gt; WORD buffer for ???
		Return: AX = status???
			STACK unchanged
	    0004h get descriptor
		STACK:	WORD	selector for which to get descriptor
			WORD	segment number (when running in real mode)
			DWORD -&gt; buffer for descriptor
		Return: CF clear if successful
			    buffer filled
			CF set on error
			    AX destroyed???
			STACK unchanged
	    0005h ???
		STACK:	WORD	selector for ???
			WORD	subfunction number???
				0000h run previously-loaded program???
				0001h ??? (similar to 0000h)
				0002h
				0003h
				0005h ??? (similar to 0000h and 0001h)
		Return: AX = status???
			STACK unchanged
	    0006h ???
		STACK:	WORD ???
			DWORD -&gt; WORD (call) max iterations of ???
				      (ret) remaining iterations
		Return: AX = ???
			STACK unchanged
	    0007h unused
		Return: AX = 0001h
	    0008h unused
		Return: AX = 0001h
	    0009h copy protected-mode memory into conventional memory
		STACK:	WORD	selector for source segment
			WORD	segment of source if in real mode???
			DWORD	offset of source
			WORD	number of bytes to copy
			DWORD -&gt; low-memory destination
		Return: AX = status
			STACK unchanged
	    000Ah copy conventional memory into protected-mode memory
		STACK:	WORD	selector for destination segment
			WORD	segment of destination if in real mode???
			DWORD	offset of destination
			WORD	number of bytes to copy
			DWORD -&gt; low-memory source
		Return: AX = status
			STACK unchanged
	    000Bh get ??? pointers
		STACK:	WORD desired pointer
				0000h get ???
				0002h get protected-mode CR3
				0003h get 4K page table buffer pointer
				else Return: DX:AX = FFFFh:FFFFh
		Return: DX:AX = requested pointer
			STACK unchanged
	    000Ch set ??? pointers
		STACK:	WORD desired pointer
				0000h set ???
				0002h set protected-mode CR3
				0003h set 4K page table buffer pointer
				else ignore
			DWORD new value for pointer
		Return: STACK unchanged
	    000Dh get ??? pointers
		STACK:	WORD desired pointer
				0000h get ???
				0001h get ???
				0002h get ???
				0003h get ???
				0004h get ???
				0005h get ???
				0006h get ???
				0007h get ???
				else Return: DX:AX = FFFFh:FFFFh
		Return: DX:AX = desired pointer
			STACK unchanged
	    000Eh set ??? pointer
		STACK:	WORD desired pointer
				0000h set ???
				0001h set ???
				0002h set ???
				0003h set ???
				0004h set ???
				0005h set ???
				0006h set ???
				0007h set ???
				else Return: DX:AX = FFFFh:FFFFh
		Return: STACK unchanged
	    000Fh get ???
		Return: AX = ??? (seen 0008h)
	    0010h get ???
		Return: AX = ???
	    0011h determine whether selector is valid
		STACK:	WORD	possible selector
		Return: AX = selector or 0000h if invalid
			STACK unchanged
	    0012h get physical address
		STACK:	WORD	selector for desired segment
			WORD	segment number if in real mode
			DWORD	offset within segment
		Return: DX:AX = 32-bit physical address or 00000000h on error
			BX destroyed
			STACK unchanged
	    0013h ???
		Note:	normally jumps to code for function 0012h
	    0014h copy protected-mode memory to conventional memory, with ???
		STACK:	WORD	selector for source segment
			WORD	segment of source if in real mode???
			DWORD	offset of source
			WORD	number of bytes to copy
			DWORD -&gt; low-memory destination
		Return: AX = status???
			STACK unchanged
	    0015h copy conventional memory to protected-mode memory, with ???
		STACK:	WORD	selector for destination segment
			WORD	segment of destination if in real mode???
			DWORD	offset of destination
			WORD	number of bytes to copy
			DWORD -&gt; low-memory source
		Return: AX = status???
			STACK unchanged
	    0016h set ??? pointer
		STACK:	WORD	unused
			DWORD -&gt; ??? or 0000h:0000h
		Return: AX = 0000h
			STACK unchanged
	    0017h allocate real-mode procedure???
		STACK:	DWORD	ASCIZ name of procedure
			DWORD ???
			DWORD	address of subroutine to invoke
		Return: AX = status
			    0032h procedure by that name exists
			    0033h no more real-mode procedures available
			DX destroyed
			STACK unchanged
	    0018h unused
		Return: AX = 0001h
	    0019h get parameter block
		Return: DX:AX -&gt; parameter block (format unknown at this time,
				  but 92h bytes)
				  (preceded by signature "!!PARAM-BLOCK!!")
	    001Ah get ???
		Return: AX = ??? (0148h seen)
	    001Bh free real-mode procedure???
		STACK:	DWORD -&gt; ASCIZ name of procedure
		Return: ???
			STACK unchanged
	    001Ch check whether packets from protected mode task pending
		Return: AX = 0001h if packets pending, 0000h if not
	    001Dh set ???
		STACK:	DWORD ??? or 0000h:0000h
		Return: AX,BX destroyed
			STACK unchanged
	    001Eh ???
		STACK:	WORD ??? (high byte ignored)
			DWORD -&gt; data structure (below)
		Return: AX,BX,CX,DX destroyed
			data structure updated
			STACK unchanged
		Format of data structure:
		Offset	Size	Description
		 00h  2 BYTEs	unused
		 02h	WORD	???
		 04h	WORD	???
		 06h	WORD	???
		 08h  2 BYTEs	unused
		 0Ah	WORD	???
		 0Ch	WORD	(call) ???
				(ret) offset of this data structure (BUG?)
	    001Fh set ???
		STACK:	WORD ??? (set to 0001h if zero)
		Return: AX destroyed
			STACK unchanged
	    0020h ???
		STACK:	DWORD -&gt; ??? (8 bytes of data)
		Return: AX = ???
			STACK unchanged
	    0021h ???
		STACK:	DWORD -&gt; ??? (8 bytes of data)
			WORD	???
			WORD	???
		Return: AX = ???
			STACK unchanged
	    0022h ???
		STACK:	DWORD -&gt; ??? (8 bytes of data)
			DWORD -&gt; 4-byte buffer for results
		Return: AX = ???
			STACK unchanged
	    0023h ???
		STACK:	DWORD -&gt; ??? (8 bytes of data)
		Return: AX = ???
			STACK unchanged
	    0024h set ???
		STACK:	WORD ???
		Return: AX destroyed
			STACK unchanged
	    0025h get ???
		Return: AX = ??? (value set with func 0024h)
	    0026h BUG: jumps to hyperspace due to fencepost error
	    FFFFh set DOS memory management functions
		BX:SI -&gt; FAR routine for allocating DOS memory
			  (called with AH=48h,BX=number of paragraphs to alloc;
			  returns CF clear, AX=segment of allocated memory, or
				  CF set on error)
		CX:DI -&gt; FAR routine for freeing DOS memory
			  (called with AH=49h,ES=segment of block to free;
			  returns CF set on error, AX=error code)
		Note: each of these pointers normally points at INT 21/RETF
	    other Return: AX = 0001h
Note:	BX may be destroyed by any of the API calls

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFBA1BX0084" name="2FFBA1BX0084"><b>2FFBA1BX0084</b></a> - INT 2F U - TKERNEL (Borland DOS extender) - UNINSTALL<br />
<pre>
INT 2F U - TKERNEL (Borland DOS extender) - UNINSTALL
	AX = FBA1h
	BX = 0084h
	ES:DI -&gt; response buffer (see #03137)
Return: ES:DI buffer filled
SeeAlso: AX=FBA1h/BX=0081h,AX=FBA1h/BX=0084h

Format of TKERNEL response buffer:
Offset	Size	Description	(Table 03137)
 00h  4 BYTEs	signature "IABH"
 04h	WORD	success indicator
		0001h failed (INT 2F hooked by another program)
		unchanged if successful
 06h	WORD	segment of ???
 08h	WORD	segment of ??? memory block to free if nonzero
 0Ah	WORD	segment of ??? memory block to free if nonzero

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFBFBES0000" name="2FFBFBES0000"><b>2FFBFBES0000</b></a> - INT 2F U - SoundBlaster speech driver - INSTALLATION CHECK<br />
<pre>
INT 2F U - SoundBlaster speech driver - INSTALLATION CHECK
	AX = FBFBh
	ES = 0000h
Return: ES nonzero if installed
	    ES:BX -&gt; entry point data structure (see #03138)
SeeAlso: INT 80/BX=0000h,INT F3"SoundBlaster"

Format of SoundBlaster entry point data structure:
Offset	Size	Description	(Table 03138)
 00h  3 BYTEs	signature "FB "
 03h	BYTE	driver major version number???
 04h	DWORD	speech driver entry point (see #03139)
 08h 24 BYTEs	???
 20h  ? BYTEs	data buffer for calling speech driver
		  (can be 117 bytes or more)

(Table 03139)
Call SoundBlaster speech driver entry point with:
	AL = function
	    07h speak a string
		data buffer (see #03138) contains:
			BYTE  length of string
		      N BYTEs string to speak

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFD12" name="2FFD12"><b>2FFD12</b></a> - INT 2F - KS/KEYSTKCT.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F - KS/KEYSTKCT.EXE - INSTALLATION CHECK
	AX = FD12h
Return: AX = 0093h if installed
	    ES = resident code segment
	    ES:CX -&gt; internal "putbuf" routine
Program: KS/KEYSTKCT.EXE is a key stacking utility (4DOS KEYSTACK.SYS
	  look-alike) by Martin Gerdes, published in c't 11/1991, which can be
	  loaded as a device driver or as a TSR. It does not emulate 4DOS
	  KSTACK API
Note:	the default buffer size is 128 keys

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFE00BX4454" name="2FFE00BX4454"><b>2FFE00BX4454</b></a> - INT 2F - PC-NFS ??? - INSTALLATION CHECK<br />
<pre>
INT 2F - PC-NFS ??? - INSTALLATION CHECK
	AX = FE00h
	BX = 4454h ("DT")
	CX = 4B52h ("KR")
	DX = 4E4Dh ("NM")
Return: AL = FFh if installed
	   BX = 524Eh ("RM")
	   CX = 4D44h ("MD")
	   DX = 544Bh ("TK")
Note:	DV/X 1.10 DVPCNFS.DVR searches AH=FEh,FFh,C0h-FDh for a valid response
SeeAlso: AX=FE08h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFE00BX4454_0" name="2FFE00BX4454_0"><b>2FFE00BX4454</b></a> - INT 2F - PC-NFS ??? - INSTALLATION CHECK<br />
<pre>
INT 2F - PC-NFS ??? - INSTALLATION CHECK
	AX = FE00h
	BX = 4454h ("DT")
	CX = 4B52h ("KR")
	DX = 544Dh ("TM")
Return: AL = FFh if installed
	   BX = 5254h ("RT")
	   CX = 4D44h ("MD")
	   DX = 544Bh ("TK")
Note:	DV/X 1.10 DVPCNFS.DVR searches AH=FEh,FFh,C0h-FDh for a valid response
SeeAlso: AX=FE08h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFE00DI4E55" name="2FFE00DI4E55"><b>2FFE00DI4E55</b></a> - INT 2F U - NORTON UTILITIES 5.0+ TSRs - INSTALLATION CHECK/STATUS REPORT<br />
<pre>
INT 2F U - NORTON UTILITIES 5.0+ TSRs - INSTALLATION CHECK/STATUS REPORT
	AX = FE00h
	DI = 4E55h ("NU")
	SI = TSR identifier (see #03140)
Return: SI = TSR reply
	    lowercase version of SI on entry (i.e. SI ORed with 2020h)
	    execpt SMARTCAN v8.0, which returns SI=6673h ('fs')
	AH = status
	    00h installed but disabled internally
	    01h installed and enabled
	AL = installed product
	    00h NCACHE-x or DISKREET
	    01h SPEEDRV / FILESAVE / EP / DISKMON v6+ installed
	    02h NCACHE2 / SMARTCAN
	    45h DISKMON v5 installed
	BX = length of *.INI file (DISKMON and FILESAVE/EP/SMARTCAN only)
	      (see #03141,#03142)
	CX = segment of resident portion
	    FFFFh if completely loaded high (NCACHE)
	DI may be destroyed
---FILESAVE/EP---
	DL = ??? (apparently always 00h)
---DISKMON---
	DX = ??? (apparently always 1AE6h [v5] / 1B86h [v6] / 1C26h [v7])
Notes:	the value returned in CX is incorrect for NCACHE 6.00
	all Norton Caches install as SMARTAAR drivers like SMARTDRV v3
	NCACHE2 and SPEEDRV both support the SMARTDRV v4+ installation check
	to detect Diskreet NDisk drives use CDS/DPB (see INT 21/AH=52h)
SeeAlso: AX=4A10h/BX=0000h,AX=FE01h,AX=FE02h,AX=FE03h,AX=FE04h,AX=FE05h
SeeAlso: INT 21/AX=4402h"SMARTDRV"

(Table 03140)
Values for Norton Utilities TSR identifier:
 4346h	("CF") NCACHE-F (v5) / NCACHE (v6) / NCACHE2 (v7+) / SPEEDRV
 4353h	("CS") NCACHE-S (v5 only)
 4443h	("DC") DISKREET
 444Dh	("DM") DISKMON
 4653h	("FS") FILESAVE (v5) / EP (v6) / SMARTCAN (v7+)

Format of DISKMON.INI file:
Offset	Size	Description	(Table 03141)
-6Ch 108 BYTEs	(in memory copy only)
		list of filenames which are always protected:
		  IBMBIO.COM/IBMDOS.COM, IO.SYS/MSDOS.SYS, TBIOS.SYS/TDOS.SYS,
		  MIO.SYS/IO.BIN, COMMAND.COM
 00h	BYTE	??? always 01h
 01h	BYTE	disk light (00h off, 01h on)
 02h	BYTE	disk protection (00h off, 01h on)
 03h	BYTE	protected areas
		01h system area
		02h files
		03h system area and files
		04h entire disk
 04h	BYTE	floppy access (00h not allowed, 01h allowed)
 05h 27 BYTEs	filename extension list (9 entries)
		(lowercase, blank padded or = 000000h)
 20h 240 BYTEs	filename list (20 entries)
		(lowercase, name and extension blank padded, with '.')
Note:	CX:0508h -&gt; copy in installed TSR (v5)
	CX:052Fh -&gt; copy in installed TSR (v6)
	CX:04E0h -&gt; copy in installed TSR (v7-v8)

Format of FILESAVE.INI / EP.INI / SMARTCAN.INI file:
Offset	Size	Description	(Table 03142)
 00h 26 BITs	drive list (bit set: file protection on, cleared: off):
 00h	BYTE	drives	A: - H:
 01h	BYTE	drives	I: - P:
 02h	BYTE	drives	Q: - X:
 03h	BYTE	drives	Y: - Z:
 04h	BYTE	which files to protect
		00h all files
		01h all files with extension in list
		02h all files except those with extension in list
 05h 27 BYTEs	filename extension list (9 entries, uppercase, ASCIZ)
 20h	BYTE	include files with archive bit clear (00h no, 01h yes)
 21h	WORD	number of days after which files are purged (0 = never)
 23h	WORD	max kilobytes of erased file space to hold (0 = all)
Note:	CX:03D2h -&gt; copy in installed TSR (v5)
	CX:03F5h -&gt; copy in installed TSR (v6)
	CX:0434h -&gt; copy in installed TSR (v7-v8)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFE00DX474F" name="2FFE00DX474F"><b>2FFE00DX474F</b></a> - INT 2F - GO! v3.22+ - API<br />
<pre>
INT 2F - GO! v3.22+ - API
	AX = FE00h
	DX = 474Fh ('GO')
	SI = function number
	    0063h (BCD for '?') installation check
	    0078h (BCD for 'N') non-registered search (two levels only)
	    0082h (BCD for 'R') reserved for registered version
	    0083h (BCD for 'S') reserved for registered version
	    0085h (BCD for 'U') uninstall
	BX:CX -&gt; buffer (for search functions)
		buffer filled with search spec, i.e. "APL" to get first
		  directory containing the substring APL, ":\APL" to find
		  the first top-level directory beginning with the letters
		  APL
Return: BX:CX buffer filled with result (search functions only)
		result is counted ASCIZ directory name, empty string if
		no matches (i.e. first byte is length of name, followed by
		name)
Program: GO! is a shareware directory locator TSR by Steve Ryckman
Note:	the application-supplied buffer for the requests and results which
	  BX:CX points at must lie outside the conventional (low-640K)
	  memory, since the TSR swaps memory on pop-up; a common location is
	  the last 96 bytes of the video memory or a UMB

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFE01DI4E55" name="2FFE01DI4E55"><b>2FFE01DI4E55</b></a> - INT 2F U - NORTON UTILITIES 5.0+ TSRs - ENABLE<br />
<pre>
INT 2F U - NORTON UTILITIES 5.0+ TSRs - ENABLE
	AX = FE01h
	DI = 4E55h ("NU")
	SI = TSR identifier (see #03140)
Return: SI = TSR reply (lowercase version of entry SI, i.e. SI OR 2020h)
	AX = status
	    0002h successful (DISKMON, FILESAVE, EP)
	    FE00h successful (NCACHE-x, DISKREET)
Notes:	if the enable/disable calls are used on DISKMON or NCACHE-x, the status
	  report generated by the programs still indicates the previous state,
	  and DISKMON.INI is not updated
	apparently has no effect on DISKREET
SeeAlso: AX=FE00h,AX=FE02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFE02DI4E55" name="2FFE02DI4E55"><b>2FFE02DI4E55</b></a> - INT 2F U - NORTON UTILITIES 5.0+ TSRs - DISABLE<br />
<pre>
INT 2F U - NORTON UTILITIES 5.0+ TSRs - DISABLE
	AX = FE02h
	DI = 4E55h ("NU")
	SI = TSR identifier (see #03140)
Return: SI = TSR reply (lowercase version of entry SI, i.e. SI OR 2020h)
	AX = status
	    0004h successful (DISKMON, FILESAVE)
	    FE00h successful (NCACHE-x, DISKREET)
Notes:	(see also AX=FE01h)
	this function appears to be unsafe, as the cache buffers are not
	  flushed
SeeAlso: AX=FE00h,AX=FE01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFE03DI4E55" name="2FFE03DI4E55"><b>2FFE03DI4E55</b></a> - INT 2F U - NORTON UTILITIES 5.0+ TSRs - FLUSH BUFFERS<br />
<pre>
INT 2F U - NORTON UTILITIES 5.0+ TSRs - FLUSH BUFFERS
	AX = FE03h
	DI = 4E55h ("NU")
	SI = TSR identifier (see #03140)
Return: SI = TSR reply (lowercase version of entry SI, i.e. SI OR 2020h)
	AX = status
	    0006h successful???
Notes:	only supported by DISKMON, FILESAVE, and NCACHE-x
	useful for flushing NCACHE before rebooting
SeeAlso: AX=FE00h,AX=FE10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFE04DI4E55" name="2FFE04DI4E55"><b>2FFE04DI4E55</b></a> - INT 2F U - NORTON UTILITIES 5.0+ DISKMON, FILESAVE / EP - internal - ???<br />
<pre>
INT 2F U - NORTON UTILITIES 5.0+ DISKMON, FILESAVE / EP - internal - ???
	AX = FE04h
	DI = 4E55h ("NU")
	SI = TSR identifier (see #03140)
Return: SI = TSR reply (lowercase version of entry SI, i.e. SI or 2020h)
	AX = status
	    0008h successful???
SeeAlso: AX=FE00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFE05DI4E55" name="2FFE05DI4E55"><b>2FFE05DI4E55</b></a> - INT 2F U - NORTON UTILITIES 5.0+ DISKMON, FILESAVE / EP - internal - ???<br />
<pre>
INT 2F U - NORTON UTILITIES 5.0+ DISKMON, FILESAVE / EP - internal - ???
	AX = FE05h
	DI = 4E55h ("NU")
	SI = TSR identifier (see #03140)
Return: SI = TSR reply (lowercase version of entry SI, i.e. SI or 2020h)
	AX = status
	    000Ah successful???
Note:	reportedly dangerous
SeeAlso: AX=FE00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFE08" name="2FFE08"><b>2FFE08</b></a> - INT 2F - PC-NFS ??? - GET ???<br />
<pre>
INT 2F - PC-NFS ??? - GET ???
	AX = FE08h
Return: ES:BX -&gt; ???
Notes:	DV/X 1.10 DVPCNFS.DVR searches AH=FEh,FFh,C0h-FDh for a valid response
	both the driver responding to AX=FE00h/DX=4E4Dh and the one responding
	  to AX=FE00h/DX=544Dh support this function
SeeAlso: AX=FE00h/BX=4454h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFE10DI4E55" name="2FFE10DI4E55"><b>2FFE10DI4E55</b></a> - INT 2F U - NORTON UTILITIES 6.0 NCACHE - REBOOT<br />
<pre>
INT 2F U - NORTON UTILITIES 6.0 NCACHE - REBOOT
	AX = FE10h
	DI = 4E55h ("NU")
	SI = TSR identifier (see #03140)
Return: SI = TSR reply (lowercase version of entry SI, i.e. SI or 2020h)
	AX = status
Note:	probably used to flush NCACHE buffers and reboot when Ctrl-Alt-Del is
	  detected
SeeAlso: AX=FE03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFEEF" name="2FFEEF"><b>2FFEEF</b></a> - INT 2F - RTS Control TSR - INSTALLATION CHECK<br />
<pre>
INT 2F - RTS Control TSR - INSTALLATION CHECK
	AX = FEEFh
Return: AX = EFFEh if installed
	    BX = port address
Program: RTS Control TSR is a utility by Michal Szokolo to lower the RTS
	  signal on a COM port during disk accesses to avoid losing incoming
	  data

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF00" name="2FFF00"><b>2FFF00</b></a> - INT 2F - Topware Network Operating System - INSTALLATION CHECK<br />
<pre>
INT 2F - Topware Network Operating System - INSTALLATION CHECK
	AX = FF00h
Return: AL = status
	    00h not installed, OK to install
	    01h not installed, not OK to install
	    FFh installed
SeeAlso: AX=FF01h,AX=FF02h,AX=FF10h,INT 21/AX=FF00h"Topware",INT 7A"Topware"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF01" name="2FFF01"><b>2FFF01</b></a> - INT 2F - Topware Network Operating System - GET VERSION<br />
<pre>
INT 2F - Topware Network Operating System - GET VERSION
	AX = FF01h
Return: AX = version
SeeAlso: AX=FF00h,AX=FF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF02" name="2FFF02"><b>2FFF02</b></a> - INT 2F - TopWare Network OS v5.10+ - GET TopNet VERSION STRING<br />
<pre>
INT 2F - TopWare Network OS v5.10+ - GET TopNet VERSION STRING
	AX = FF02h
Return: ES:BX -&gt; version string
SeeAlso: AX=FF00h,AX=FF01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF10" name="2FFF10"><b>2FFF10</b></a> - INT 2F - TopWare Network OS v5.10+ - TopTerm - INSTALLATION CHECK<br />
<pre>
INT 2F - TopWare Network OS v5.10+ - TopTerm - INSTALLATION CHECK
	AX = FF10h
Return: AL = status (00h not installed, 01h installed)
SeeAlso: AX=FF00h,AX=FF11h,AX=FF12h,AX=FF13h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF11" name="2FFF11"><b>2FFF11</b></a> - INT 2F - TopWare Network OS v5.10+ - TopTerm - ENABLE KEYBOARD SERVICE<br />
<pre>
INT 2F - TopWare Network OS v5.10+ - TopTerm - ENABLE KEYBOARD SERVICE
	AX = FF11h
Note:	this function is only available on workstations, not on the server
SeeAlso: AX=FF10h,AX=FF12h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF12" name="2FFF12"><b>2FFF12</b></a> - INT 2F - TopWare Network OS v5.10+ - TopTerm - DISABLE KEYBOARD SERVICE<br />
<pre>
INT 2F - TopWare Network OS v5.10+ - TopTerm - DISABLE KEYBOARD SERVICE
	AX = FF12h
Note:	this function is only available on workstations, not on the server
SeeAlso: AX=FF10h,AX=FF11h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF13" name="2FFF13"><b>2FFF13</b></a> - INT 2F - TopWare Network OS v5.10+ - TopTerm - SET INSTALLATION FLAG<br />
<pre>
INT 2F - TopWare Network OS v5.10+ - TopTerm - SET INSTALLATION FLAG
	AX = FF13h
	CL = new state (00h off, 01h on)
SeeAlso: AX=FF10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF14" name="2FFF14"><b>2FFF14</b></a> - INT 2F - TopWare Network OS v5.10+ - START BACKGROUND RECEIVE VIDEO DATA<br />
<pre>
INT 2F - TopWare Network OS v5.10+ - START BACKGROUND RECEIVE VIDEO DATA
	AX = FF14h
Note:	this function is only available on workstations, not on the server
SeeAlso: AX=FF10h,AX=FF15h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF15" name="2FFF15"><b>2FFF15</b></a> - INT 2F - TopWare Network OS v5.10+ - END BACKGROUND RECEIVE VIDEO DATA<br />
<pre>
INT 2F - TopWare Network OS v5.10+ - END BACKGROUND RECEIVE VIDEO DATA
	AX = FF15h
Note:	this function is only available on workstations, not on the server
SeeAlso: AX=FF10h,AX=FF14h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF16" name="2FFF16"><b>2FFF16</b></a> - INT 2F - TopWare Network OS v5.10+ - SET CONTROL NUMBER OF "SHOW" SCREEN<br />
<pre>
INT 2F - TopWare Network OS v5.10+ - SET CONTROL NUMBER OF "SHOW" SCREEN
	AX = FF16h
	BL = which to set (00h TopShow, FFh TopTerm)
	CX = destination screen
	    0000h all stations
	    0000h-00FFh (TopTerm only) send to group CL
	    8001h-80FEh send to station CL
SeeAlso: AX=FF18h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF18" name="2FFF18"><b>2FFF18</b></a> - INT 2F - TopWare Network OS v5.10+ - SEND FULL SCREEN OF DATA FOR TopShow<br />
<pre>
INT 2F - TopWare Network OS v5.10+ - SEND FULL SCREEN OF DATA FOR TopShow
	AX = FF18h
SeeAlso: AX=FF00h,AX=FF16h,AX=FF27h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF23" name="2FFF23"><b>2FFF23</b></a> - INT 2F - TopWare Network OS v5.10+ - CLOSE SPOOL FILES AND START PRINTING<br />
<pre>
INT 2F - TopWare Network OS v5.10+ - CLOSE SPOOL FILES AND START PRINTING
	AX = FF23h
SeeAlso: AX=FF00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFF27" name="2FFF27"><b>2FFF27</b></a> - INT 2F - TopWare Network OS v5.10+ - GET "SHOW" TYPE<br />
<pre>
INT 2F - TopWare Network OS v5.10+ - GET "SHOW" TYPE
	AX = FF27h
Return: AL = type (00h complete version, 01h simple version)
	BL = "show" functions flag (00h disabled, 01h enabled)
SeeAlso: AX=FF16h,AX=FF18h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<div class="bottom-nav"><b><a href="./index.html">Home</a></b> <b>Interrupt Index</b>: <a href="./INTERRUP.CAT.HTML">by Category</a> <a href="./INTERRUP.NUM.HTML">by Number</a> <b>TOC</b>: <a href="#__toc">by Order</a> <b><a href="#top">Top</a></b></div>

</body>
</html>
