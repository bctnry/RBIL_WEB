
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INTERRUP._E</title>
    <style>
        body {
            font-variant-ligatures: none;
        }
        pre {
            font-family: 'Courier New', Courier, monospace;
        }
        a {
            color: black;
        }
        .bottom-nav {
            position: sticky;
            bottom: 0px;
            background-color: white;
            text-align: right;
        }
        h3, h4 {
            margin: 0;
        }
</style>
</head>
<body>

<b>Interrupt List Release 61 Last change 16jul00</b><br />
<b>Copyright (c) 1989-1999,2000 Ralf Brown</b><br />
<pre>
Index for category E - DOS extenders
</pre>

<p>
<a name="__toc"><b>Table of Contents by Order</b></a><br />

<a href="#10FF_0"><b>10FF</b> - INT 10 - DJ GO32.EXE 80386+ DOS extender - VIDEO EXTENSIONS</a><br />
<a href="#15BF00"><b>15BF00</b> - INT 15 - Rational Systems DOS/16M - ???</a><br />
<a href="#15BF01"><b>15BF01</b> - INT 15 - Rational Systems DOS/16M - ???</a><br />
<a href="#15BF02DX0000"><b>15BF02DX0000</b> - INT 15 - Rational Systems DOS/16M - INSTALLATION CHECK</a><br />
<a href="#15BF03"><b>15BF03</b> - INT 15 - Rational Systems DOS/4GW - UNINSTALL???</a><br />
<a href="#15BF04"><b>15BF04</b> - INT 15 - Rational Systems DOS/4GW - ???</a><br />
<a href="#15BF05"><b>15BF05</b> - INT 15 - Rational Systems DOS/4GW - INITIALIZE PROTECTED-MODE INTERFACE</a><br />
<a href="#15BF06"><b>15BF06</b> - INT 15 - Rational Systems DOS/4GW - ???</a><br />
<a href="#15BFDCDX0000"><b>15BFDCDX0000</b> - INT 15 - Rational Systems DOS/4GW - INSTALLATION CHECK</a><br />
<a href="#15BFDEBX0000"><b>15BFDEBX0000</b> - INT 15 - DESQview/X - DVDOS4GX.DVR - INSTALLATION CHECK</a><br />
<a href="#15BFDEBX0001"><b>15BFDEBX0001</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET PROCESS MANAGER NAME</a><br />
<a href="#15BFDEBX0002"><b>15BFDEBX0002</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???</a><br />
<a href="#15BFDEBX0003"><b>15BFDEBX0003</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???</a><br />
<a href="#15BFDEBX0004"><b>15BFDEBX0004</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???</a><br />
<a href="#15BFDEBX0005"><b>15BFDEBX0005</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???</a><br />
<a href="#15BFDEBX0006"><b>15BFDEBX0006</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???</a><br />
<a href="#15BFDEBX0007"><b>15BFDEBX0007</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???</a><br />
<a href="#15BFDEBX0008"><b>15BFDEBX0008</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???</a><br />
<a href="#15BFDEBX0009"><b>15BFDEBX0009</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET PROTECTED MODE PROGRAM LOADER</a><br />
<a href="#15BFDEBX000A"><b>15BFDEBX000A</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - DECREMENT ???</a><br />
<a href="#15BFDEBX000B"><b>15BFDEBX000B</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - INCREMENT ???</a><br />
<a href="#15BFDEBX000C"><b>15BFDEBX000C</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???</a><br />
<a href="#15BFDEBX000D"><b>15BFDEBX000D</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???</a><br />
<a href="#15BFDEBX000E"><b>15BFDEBX000E</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???</a><br />
<a href="#15BFDEBX000F"><b>15BFDEBX000F</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???</a><br />
<a href="#15BFDEBX0010"><b>15BFDEBX0010</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET TASK HANDLE</a><br />
<a href="#15BFDEBX0011"><b>15BFDEBX0011</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???</a><br />
<a href="#15BFDEBX0012"><b>15BFDEBX0012</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???</a><br />
<a href="#15BFDEBX0013"><b>15BFDEBX0013</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???</a><br />
<a href="#15BFDEBX0014"><b>15BFDEBX0014</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - LOCK ??? MAILBOX</a><br />
<a href="#15BFDEBX0015"><b>15BFDEBX0015</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - UNLOCK ??? MAILBOX</a><br />
<a href="#15BFDEBX0016"><b>15BFDEBX0016</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - CHECK IF ??? MAILBOX OWNED</a><br />
<a href="#15BFDEBX0017"><b>15BFDEBX0017</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ??? MAILBOX OWNER</a><br />
<a href="#15BFDEBXFFFD"><b>15BFDEBXFFFD</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???</a><br />
<a href="#15BFDEBXFFFE"><b>15BFDEBXFFFE</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???</a><br />
<a href="#15BFDEBXFFFF"><b>15BFDEBXFFFF</b> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - NOP</a><br />
<a href="#212501"><b>212501</b> - INT 21 P - Phar Lap 386/DOS-Extender - RESET DOS EXTENDER DATA STRUCTURES</a><br />
<a href="#212502"><b>212502</b> - INT 21 P - Phar Lap 386/DOS-Extender - GET PROTECTED-MODE INTERRUPT VECTOR</a><br />
<a href="#212503"><b>212503</b> - INT 21 P - Phar Lap 386/DOS-Extender - GET REAL-MODE INTERRUPT VECTOR</a><br />
<a href="#212504"><b>212504</b> - INT 21 P - Phar Lap 386/DOS-Extender - SET PROTECTED-MODE INTERRUPT VECTOR</a><br />
<a href="#212505"><b>212505</b> - INT 21 P - Phar Lap 386/DOS-Extender - SET REAL-MODE INTERRUPT VECTOR</a><br />
<a href="#212506"><b>212506</b> - INT 21 P - Phar Lap 386/DOS-Extender - SET INT TO ALWAYS GAIN CNTRL IN PR. MODE</a><br />
<a href="#212507"><b>212507</b> - INT 21 P - Phar Lap 386/DOS-Extender - SET REAL- & PROTECTED-MODE INT VECTORS</a><br />
<a href="#212508"><b>212508</b> - INT 21 P - Phar Lap 386/DOS-Extender - GET SEGMENT LINEAR BASE ADDRESS</a><br />
<a href="#212509"><b>212509</b> - INT 21 P - Phar Lap 386/DOS-Extender - CONVERT LINEAR TO PHYSICAL ADDRESS</a><br />
<a href="#212509_0"><b>212509</b> - INT 21 P - FlashTek X-32VM - GET SYSTEM SEGMENTS AND SELECTORS</a><br />
<a href="#21250A"><b>21250A</b> - INT 21 P - Phar Lap 386/DOS-Extender - MAP PHYSICAL MEMORY AT END OF SEGMENT</a><br />
<a href="#21250C"><b>21250C</b> - INT 21 P - Phar Lap 386/DOS-Extender - GET HARDWARE INTERRUPT VECTORS</a><br />
<a href="#21250D"><b>21250D</b> - INT 21 P - Phar Lap 386/DOS-Extender - GET REAL-MODE LINK INFORMATION</a><br />
<a href="#21250E"><b>21250E</b> - INT 21 P - Phar Lap 386/DOS-Extender - CALL REAL-MODE PROCEDURE</a><br />
<a href="#21250F"><b>21250F</b> - INT 21 P - Phar Lap 386/DOS-Extender - CONVERT PROTECTED-MODE ADDRESS TO MS-DOS</a><br />
<a href="#212510"><b>212510</b> - INT 21 P - Phar Lap 386/DOS-Extender - CALL REAL-MODE PROCEDURE, REGISTERS</a><br />
<a href="#212511"><b>212511</b> - INT 21 P - Phar Lap 386/DOS-Extender - ISSUE REAL-MODE INTERRUPT</a><br />
<a href="#212512"><b>212512</b> - INT 21 P - Phar Lap 386/DOS-Extender - LOAD PROGRAM FOR DEBUGGING</a><br />
<a href="#212513"><b>212513</b> - INT 21 P - Phar Lap 386/DOS-Extender - ALIAS SEGMENT DESCRIPTOR</a><br />
<a href="#212514"><b>212514</b> - INT 21 P - Phar Lap 386/DOS-Extender - CHANGE SEGMENT ATTRIBUTES</a><br />
<a href="#212515"><b>212515</b> - INT 21 P - Phar Lap 386/DOS-Extender - GET SEGMENT ATTRIBUTES</a><br />
<a href="#212516"><b>212516</b> - INT 21 P - Phar Lap 386/DOS-Extender v2.2+ - FREE ALL MEMORY OWNED BY LDT</a><br />
<a href="#212517"><b>212517</b> - INT 21 P - Phar Lap 386/DOS-Extender v2.1c+ - GET INFO ON DOS DATA BUFFER</a><br />
<a href="#212518"><b>212518</b> - INT 21 P - Phar Lap 386/DOS-Extender 2.1c+ - SPECIFY HANDLER FOR MOVED SEGMENTS</a><br />
<a href="#212519"><b>212519</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM - GET ADDITIONAL MEMORY ERROR INFO</a><br />
<a href="#21251A"><b>21251A</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM - LOCK PAGES IN MEMORY</a><br />
<a href="#21251B"><b>21251B</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM - UNLOCK PAGES</a><br />
<a href="#21251C"><b>21251C</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM v2.1c+ - FREE PHYSICAL MEMORY PAGES</a><br />
<a href="#21251D"><b>21251D</b> - INT 21 OP - Phar Lap 386/DOS-Extender VMM v2.1c - READ PAGE-TABLE ENTRY</a><br />
<a href="#21251E"><b>21251E</b> - INT 21 OP - Phar Lap 386/DOS-Extender VMM v2.1c - WRITE PAGE-TABLE ENTRY</a><br />
<a href="#21251F"><b>21251F</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM - EXHANGE TWO PAGE-TABLE ENTRIES</a><br />
<a href="#212520"><b>212520</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM - GET MEMORY STATISTICS</a><br />
<a href="#212521"><b>212521</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM - LIMIT PROGRAM'S EXTENDED MEM USAGE</a><br />
<a href="#212522"><b>212522</b> - INT 21 P - Phar Lap 386/DOS-Ext VMM v2.2+ - SPECIFY ALTERNATE PAGE-FAULT HANDLR</a><br />
<a href="#212523"><b>212523</b> - INT 21 P - Phar Lap 386/DOS-Ext VMM v2.2+ - SPECIFY OUT-OF-SWAP-SPACE HANDLER</a><br />
<a href="#212524"><b>212524</b> - INT 21 P - Phar Lap 386/DOS-Ext VMM v2.2+ - INSTALL PAGE-REPLACEMENT HANDLERS</a><br />
<a href="#212525"><b>212525</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM - LIMIT PROGRAM'S CONVENT'L MEM USAGE</a><br />
<a href="#212526"><b>212526</b> - INT 21 P - Phar Lap 386/DOS-Extender - GET CONFIGURATION INFORMATION</a><br />
<a href="#212527"><b>212527</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM - EN/DISABLE STATE SAVE ON INTERRUPTS</a><br />
<a href="#212528"><b>212528</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM - READ REGISTERS AFTER CTRL-C INT</a><br />
<a href="#212529"><b>212529</b> - INT 21 P - Phar Lap 386/DOS-Extender - LOAD FLAT MODEL .EXP or .REX FILE</a><br />
<a href="#21252A"><b>21252A</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM - NEW LOAD PROGRAM FOR DEBUG</a><br />
<a href="#21252BBH00"><b>21252BBH00</b> - INT 21 Pu - Phar Lap 386/DOS-Extender - CREATE UNMAPPED PAGES</a><br />
<a href="#21252BBH01"><b>21252BBH01</b> - INT 21 Pu - Phar Lap 386/DOS-Extender - CREATE ALLOCATED PAGES</a><br />
<a href="#21252BBH02"><b>21252BBH02</b> - INT 21 Pu - Phar Lap 386/DOS-Extender - CREATE PHYSICAL DEVICE PAGES</a><br />
<a href="#21252BBH03"><b>21252BBH03</b> - INT 21 Pu - Phar Lap 386/DOS-Extender - MAP DATA FILE</a><br />
<a href="#21252BBH04"><b>21252BBH04</b> - INT 21 Pu - Phar Lap 386/DOS-Extender - GET PAGE TYPES</a><br />
<a href="#21252B"><b>21252B</b> - INT 21 P - Phar Lap 386/DOS-Extender - VIRTUAL MEMORY MANAGEMENT - PAGE LOCKING</a><br />
<a href="#21252B_0"><b>21252B</b> - INT 21 Pu - Phar Lap 386/DOS-Extender - FREE PHYSICAL PAGES</a><br />
<a href="#21252BBH09"><b>21252BBH09</b> - INT 21 P - Phar Lap 386/DOS-Extender v4.1 - GET PAGETABLE ENTRY/PAGE TABLE INFO</a><br />
<a href="#21252BBH0A"><b>21252BBH0A</b> - INT 21 P - Phar Lap 386/DOS-Extender v4.1 - SET PAGETABLE ENTRY/PAGE TABLE INFO</a><br />
<a href="#21252BBH0B"><b>21252BBH0B</b> - INT 21 P - Phar Lap 386/DOS-Extender v4.1+ - MAP DATA FILE AT FILE OFFSET</a><br />
<a href="#21252C"><b>21252C</b> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - ADD UNMAPPED PAGES AT END OF SEGMENT</a><br />
<a href="#21252D"><b>21252D</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM v2.3+ - CLOSE VMM FILE HANDLE</a><br />
<a href="#21252E"><b>21252E</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM v2.3+ - GET/SET VMM PARAMETERS</a><br />
<a href="#21252F"><b>21252F</b> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - WRITE RECORD TO VMM PAGE LOG FILE</a><br />
<a href="#212530"><b>212530</b> - INT 21 P - Phar Lap 386/DOS-Ext VMM v2.3+ - SET SIZE OF BUFFER FOR DOS CALLS</a><br />
<a href="#212531"><b>212531</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM v3.0 - READ/WRITE LDT DESCRIPTOR</a><br />
<a href="#212532"><b>212532</b> - INT 21 P - Phar Lap 386/DOS-Extender - GET EXCEPTION HANDLER VECTOR</a><br />
<a href="#212533"><b>212533</b> - INT 21 P - Phar Lap 386/DOS-Extender - SET EXCEPTION HANDLER VECTOR</a><br />
<a href="#212534"><b>212534</b> - INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - GET INTERRUPT FLAG</a><br />
<a href="#212535"><b>212535</b> - INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - READ/WRITE SYSTEM REGISTERS</a><br />
<a href="#212536"><b>212536</b> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0+ - MIN/MAX EXTENDED/CONV MEMORY USAGE</a><br />
<a href="#212537"><b>212537</b> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - ALLOCATE DOS MEMORY ABOVE DOS BUFFER</a><br />
<a href="#212538"><b>212538</b> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - READ PROTMODE REGS AFTER SFTWARE INT</a><br />
<a href="#212539"><b>212539</b> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - GET OFFSET OF .EXP FILE HEADER</a><br />
<a href="#21253A"><b>21253A</b> - INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - INSTALL MOD. SEG FAILURE HANDLER</a><br />
<a href="#21253B"><b>21253B</b> - INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - JUMP TO REAL MODE CODE, NO CONTEXT</a><br />
<a href="#21253C"><b>21253C</b> - INT 21 P - Phar Lap 386/DOS-Extender VMM v3.0+ - SHRINK 386|VMM SWAP FILE</a><br />
<a href="#21253D"><b>21253D</b> - INT 21 P - Phar Lap 386/DOS-Extender v4.0+ - READ/WRITE IDT DESCRIPTOR</a><br />
<a href="#21253F"><b>21253F</b> - INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - ALLOCATE LDT DESCRIPTOR</a><br />
<a href="#212540"><b>212540</b> - INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - FORCE ALIAS OF SEGMENT</a><br />
<a href="#212544"><b>212544</b> - INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - FREE DLL</a><br />
<a href="#212545"><b>212545</b> - INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - GET/SET PROCEDURE ADDRESS</a><br />
<a href="#212546"><b>212546</b> - INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - GET MODULE HANDLE</a><br />
<a href="#2125C0"><b>2125C0</b> - INT 21 P - Phar Lap 386/DOS-Extender - ALLOCATE MS-DOS MEMORY BLOCK</a><br />
<a href="#2125C1"><b>2125C1</b> - INT 21 P - Phar Lap 386/DOS-Extender - RELEASE MS-DOS MEMORY BLOCK</a><br />
<a href="#2125C2"><b>2125C2</b> - INT 21 P - Phar Lap 386/DOS-Extender - MODIFY MS-DOS MEMORY BLOCK</a><br />
<a href="#2125C3"><b>2125C3</b> - INT 21 P - Phar Lap 386/DOS-Extender - EXECUTE PROGRAM</a><br />
<a href="#212B--CX4149"><b>212B--CX4149</b> - INT 21 - AI Architects - ??? - INSTALLATION CHECK</a><br />
<a href="#2130_0"><b>2130</b> - INT 21 - Phar Lap 386/DOS-Extender, Intel Code Builder - INSTALLATION CHECK</a><br />
<a href="#213501"><b>213501</b> - INT 21 P - FlashTek X-32VM - ALLOCATE PROTECTED-MODE SELECTOR</a><br />
<a href="#213502"><b>213502</b> - INT 21 P - FlashTek X-32VM - DEALLOCATE PROTECTED-MODE SELECTOR</a><br />
<a href="#213503"><b>213503</b> - INT 21 P - FlashTek X-32VM - SET SELECTOR BASE ADDRESS</a><br />
<a href="#213504"><b>213504</b> - INT 21 P - FlashTek X-32VM - GET SELECTOR BASE ADDRESS</a><br />
<a href="#213505"><b>213505</b> - INT 21 P - FlashTek X-32VM - SET SELECTOR LIMIT</a><br />
<a href="#21350A"><b>21350A</b> - INT 21 P - FlashTek X-32VM - PHYSICAL ADDRESS MAPPING</a><br />
<a href="#21350B"><b>21350B</b> - INT 21 P - FlashTek X-32VM - UPDATE AND RETURN AVAILABLE FREE MEMORY</a><br />
<a href="#21350C"><b>21350C</b> - INT 21 P - FlashTek X-32VM - ALLOCATE A BLOCK OF MEMORY</a><br />
<a href="#21350D"><b>21350D</b> - INT 21 P - FlashTek X-32VM - RESERVE BLOCK OF MEMORY FOR 32-BIT STACK</a><br />
<a href="#214403_4"><b>214403</b> - INT 21 U - AI Architects - OS/x86??? - API</a><br />
<a href="#21E0_0"><b>21E0</b> - INT 21 - OS/286, OS/386 - INITIALIZE REAL PROCEDURE</a><br />
<a href="#21E1"><b>21E1</b> - INT 21 - OS/286, OS/386 - ISSUE REAL PROCEDURE CALL</a><br />
<a href="#21E2"><b>21E2</b> - INT 21 - OS/286, OS/386 - SET REAL PROCEDURE SIGNAL HANDLER</a><br />
<a href="#21E3"><b>21E3</b> - INT 21 - OS/286, OS/386 - ISSUE REAL INTERRUPT</a><br />
<a href="#21E400_0"><b>21E400</b> - INT 21 - OS/286, OS/386 - CHAIN TO REAL-MODE HANDLER</a><br />
<a href="#21E402"><b>21E402</b> - INT 21 - OS/286, OS/386 - SET PROTECTED-MODE TASK GATE</a><br />
<a href="#21E403"><b>21E403</b> - INT 21 - OS/286, OS/386 - REMOVE PROTECTED-MODE TASK GATE</a><br />
<a href="#21E500"><b>21E500</b> - INT 21 - OS/286, OS/386 - HEAP MANAGEMENT STRATEGY</a><br />
<a href="#21E501"><b>21E501</b> - INT 21 - OS/286, OS/386 - FORCE HEAP COMPACTION</a><br />
<a href="#21E6_0"><b>21E6</b> - INT 21 P - OS/286, OS/386 - ISSUE REAL PROCEDURE SIGNAL FROM PROTECTED MODE</a><br />
<a href="#21E7_0"><b>21E7</b> - INT 21 - OS/286, OS/386 - CREATE CODE SEGMENT</a><br />
<a href="#21E8_0"><b>21E8</b> - INT 21 - OS/286, OS/386 - SEGMENT CREATION</a><br />
<a href="#21E9"><b>21E9</b> - INT 21 P - OS/286, OS/386 - CHANGE SEGMENTS</a><br />
<a href="#21EA_1"><b>21EA</b> - INT 21 - OS/286, OS/386 - ALLOCATE HUGE SEGMENT</a><br />
<a href="#21EB00"><b>21EB00</b> - INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY LINEAR ADDRESS</a><br />
<a href="#21EB02"><b>21EB02</b> - INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY 16-BIT SEGMENT:OFFSET</a><br />
<a href="#21EB03"><b>21EB03</b> - INT 21 - OS/386 VMM - FREE MAPPED PAGES</a><br />
<a href="#21EB04"><b>21EB04</b> - INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY 32-BIT SEGMENT:OFFSET</a><br />
<a href="#21EB05"><b>21EB05</b> - INT 21 - OS/386 VMM - MAP PAGES</a><br />
<a href="#21EB06"><b>21EB06</b> - INT 21 - OS/386 VMM - LOCK PAGES IN MEMORY</a><br />
<a href="#21EB07"><b>21EB07</b> - INT 21 - OS/386 VMM - UNLOCK MEMORY PAGES</a><br />
<a href="#21EC_1"><b>21EC</b> - INT 21 - OS/286, OS/386 - BLOCK TRANSFER</a><br />
<a href="#21ED_0"><b>21ED</b> - INT 21 - OS/286, OS/386 - GET SEGMENT OR WINDOW DESCRIPTOR</a><br />
<a href="#21FF_1"><b>21FF</b> - INT 21 - DJ GO32.EXE 80386+ DOS extender - DOS EXTENSIONS</a><br />
<a href="#21FF_4"><b>21FF</b> - INT 21 UP - Rational Systems DOS/4GW - API</a><br />
<a href="#21FF--DH00"><b>21FF--DH00</b> - INT 21 UP - Rational Systems DOS/4GW - GET VERSION???</a><br />
<a href="#21FF--DH02"><b>21FF--DH02</b> - INT 21 UP - Rational Systems DOS/4GW - SET ???</a><br />
<a href="#21FF--DH05"><b>21FF--DH05</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH06"><b>21FF--DH06</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH07"><b>21FF--DH07</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH08"><b>21FF--DH08</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH09"><b>21FF--DH09</b> - INT 21 UP - Rational Systems DOS/4GW - GET ???</a><br />
<a href="#21FF--DH0A"><b>21FF--DH0A</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH0B"><b>21FF--DH0B</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH0C"><b>21FF--DH0C</b> - INT 21 UP - Rational Systems DOS/4GW - GET/SET ???</a><br />
<a href="#21FF--DH0D"><b>21FF--DH0D</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH0E"><b>21FF--DH0E</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH0F"><b>21FF--DH0F</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH10"><b>21FF--DH10</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH11"><b>21FF--DH11</b> - INT 21 UP - Rational Systems DOS/4GW - NOP</a><br />
<a href="#21FF--DH12"><b>21FF--DH12</b> - INT 21 UP - Rational Systems DOS/4GW - EXCHANGE ??? POINTERS</a><br />
<a href="#21FF--DH13"><b>21FF--DH13</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH14"><b>21FF--DH14</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF--DH15"><b>21FF--DH15</b> - INT 21 UP - Rational Systems DOS/4GW - GET ??? FUNCTIONS</a><br />
<a href="#21FF--DH16"><b>21FF--DH16</b> - INT 21 UP - Rational Systems DOS/4GW - GET ???</a><br />
<a href="#21FF--DH17"><b>21FF--DH17</b> - INT 21 UP - Rational Systems DOS/4GW - ???</a><br />
<a href="#21FF00DX0078"><b>21FF00DX0078</b> - INT 21 - Rational Systems DOS/4G - INSTALLATION CHECK</a><br />
<a href="#2F1607BX22C0"><b>2F1607BX22C0</b> - INT 2F C - Rational Systems DOS/4GW - ???</a><br />
<a href="#2F1686"><b>2F1686</b> - INT 2F - DOS Protected-Mode Interface - DETECT MODE</a><br />
<a href="#2F1687"><b>2F1687</b> - INT 2F - DOS Protected-Mode Interface - INSTALLATION CHECK</a><br />
<a href="#2F168A"><b>2F168A</b> - INT 2F - DPMI 0.9+ - GET VENDOR-SPECIFIC API ENTRY POINT</a><br />
<a href="#2F4040"><b>2F4040</b> - INT 2F - PharLap 286|DOS-Extender Lite v2.5 - ???</a><br />
<a href="#2F43E0BX0000"><b>2F43E0BX0000</b> - INT 2F - DOS Protected Mode Services (DPMS) v1.0 - INSTALLATION CHECK</a><br />
<a href="#2F44"><b>2F44</b> - INT 2F U - DOS Extender support???</a><br />
<a href="#2F46"><b>2F46</b> - INT 2F U - Windows/286 DOS Extender</a><br />
<a href="#2FA1--BX0081"><b>2FA1--BX0081</b> - INT 2F - Ergo DOS extenders - INSTALLATION CHECK</a><br />
<a href="#2FD201BX4D45"><b>2FD201BX4D45</b> - INT 2F U - Quarterdeck RPCI - DVDOS4GX.DVR - ???</a><br />
<a href="#2FED00"><b>2FED00</b> - INT 2F - Phar Lap DOS EXTENDERS - INSTALLATION CHECK</a><br />
<a href="#2FED03"><b>2FED03</b> - INT 2F R - Phar Lap 386/DOS-Extender v4.1 - GET EXTENDER ENTRY POINT</a><br />
<a href="#2FED10BL05"><b>2FED10BL05</b> - INT 2F - Pharlap DOS Extender - ???</a><br />
<a href="#2FED11BL05"><b>2FED11BL05</b> - INT 2F - Pharlap DOS Extender - FATAL EXIT TO REAL MODE ???</a><br />
<a href="#2FED80"><b>2FED80</b> - INT 2F - Phar Lap 286|DOS Extender Lite v2.5 - ???</a><br />
<a href="#2FF100"><b>2FF100</b> - INT 2F - DOS EXTENDER INSTALLATION CHECK</a><br />
<a href="#2FFB42BX0001"><b>2FFB42BX0001</b> - INT 2F PU - Borland C++ DPMILOAD.EXE - INSTALLATION CHECK???</a><br />
<a href="#2FFB42BX0002"><b>2FFB42BX0002</b> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ALLOCATE MEMORY</a><br />
<a href="#2FFB42BX0002_0"><b>2FFB42BX0002</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ALLOCATE MEMORY</a><br />
<a href="#2FFB42BX0003"><b>2FFB42BX0003</b> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET AVAILABLE MEMORY</a><br />
<a href="#2FFB42BX0004"><b>2FFB42BX0004</b> - INT 2F PU - Borland C++ DPMILOAD.EXE - LOAD PROTECTED-MODE EXECUTABLE???</a><br />
<a href="#2FFB42BX0005"><b>2FFB42BX0005</b> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NAME</a><br />
<a href="#2FFB42BX0006"><b>2FFB42BX0006</b> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NUMBER</a><br />
<a href="#2FFB42BX0007"><b>2FFB42BX0007</b> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0007_0"><b>2FFB42BX0007</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0008"><b>2FFB42BX0008</b> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - FREE MEMORY BLOCK</a><br />
<a href="#2FFB42BX0008_0"><b>2FFB42BX0008</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE MEMORY BLOCK</a><br />
<a href="#2FFB42BX0009"><b>2FFB42BX0009</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - RESIZE MEMORY BLOCK</a><br />
<a href="#2FFB42BX000A"><b>2FFB42BX000A</b> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INIT DPMI HOST AND SPAWN SUBSHELL</a><br />
<a href="#2FFB42BX000B"><b>2FFB42BX000B</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - UNUSED</a><br />
<a href="#2FFB42BX000C"><b>2FFB42BX000C</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE DESCRIPTORS FOR MEMORY BLOCK???</a><br />
<a href="#2FFB42BX000D"><b>2FFB42BX000D</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SIMULATE REAL MODE INTERRUPT</a><br />
<a href="#2FFB42BX000E"><b>2FFB42BX000E</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???</a><br />
<a href="#2FFB42BX000F"><b>2FFB42BX000F</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - REALLOCATE LDT DESCRPS TO MEMBLK???</a><br />
<a href="#2FFB42BX0010"><b>2FFB42BX0010</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SEGMENT TO SELECTOR</a><br />
<a href="#2FFB42BX0011"><b>2FFB42BX0011</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0012"><b>2FFB42BX0012</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0013"><b>2FFB42BX0013</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0014"><b>2FFB42BX0014</b> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INSTALLATION CHECK</a><br />
<a href="#2FFB42BX0015"><b>2FFB42BX0015</b> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - UNINSTALL</a><br />
<a href="#2FFB42BX0016"><b>2FFB42BX0016</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???</a><br />
<a href="#2FFB42BX0017"><b>2FFB42BX0017</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0018"><b>2FFB42BX0018</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET ???</a><br />
<a href="#2FFB42BX0019"><b>2FFB42BX0019</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX001A"><b>2FFB42BX001A</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX001B"><b>2FFB42BX001B</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX001C"><b>2FFB42BX001C</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX001D"><b>2FFB42BX001D</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???</a><br />
<a href="#2FFB42BX001E"><b>2FFB42BX001E</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX001F"><b>2FFB42BX001F</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???</a><br />
<a href="#2FFB42BX0020"><b>2FFB42BX0020</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION???</a><br />
<a href="#2FFB42BX0021"><b>2FFB42BX0021</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROCESSOR EXCEPTION HANDLER VECT</a><br />
<a href="#2FFB42BX0022"><b>2FFB42BX0022</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROCESSOR EXCEPTION HANDLER VECT</a><br />
<a href="#2FFB42BX0023"><b>2FFB42BX0023</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SELECTOR TO SEGMENT NUMBER</a><br />
<a href="#2FFB42BX0024"><b>2FFB42BX0024</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROTECTED-MODE INTERRUPT VECTOR</a><br />
<a href="#2FFB42BX0025"><b>2FFB42BX0025</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROTECTED-MODE INTERRUPT VECTOR</a><br />
<a href="#2FFB42BX0026"><b>2FFB42BX0026</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???</a><br />
<a href="#2FFB42BX0027"><b>2FFB42BX0027</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???</a><br />
<a href="#2FFB42BX0080"><b>2FFB42BX0080</b> - INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE</a><br />
<a href="#2FFB42BX0081"><b>2FFB42BX0081</b> - INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE</a><br />
<a href="#2FFB42BX1001"><b>2FFB42BX1001</b> - INT 2F U - Borland RTM.EXE 1.0 - INSTALLATION CHECK???</a><br />
<a href="#2FFB42BX1002"><b>2FFB42BX1002</b> - INT 2F U - Borland RTM.EXE 1.0 - EXECUTE COMPILED PROGRAM</a><br />
<a href="#2FFB42BX1003"><b>2FFB42BX1003</b> - INT 2F U - Borland RTM.EXE 1.0 - ???</a><br />
<a href="#2FFB43"><b>2FFB43</b> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION</a><br />
<a href="#2FFBA1BX0081"><b>2FFBA1BX0081</b> - INT 2F U - TKERNEL (Borland DOS extender) - INSTALLATION CHECK</a><br />
<a href="#2FFBA1BX0082"><b>2FFBA1BX0082</b> - INT 2F U - TKERNEL (Borland DOS extender) - GET ENTRY POINT</a><br />
<a href="#2FFBA1BX0084"><b>2FFBA1BX0084</b> - INT 2F U - TKERNEL (Borland DOS extender) - UNINSTALL</a><br />
<a href="#310000"><b>310000</b> - INT 31 P - DPMI 0.9+ - ALLOCATE LDT DESCRIPTORS</a><br />
<a href="#310001"><b>310001</b> - INT 31 P - DPMI 0.9+ - FREE LDT DESCRIPTOR</a><br />
<a href="#310002"><b>310002</b> - INT 31 P - DPMI 0.9+ - SEGMENT TO DESCRIPTOR</a><br />
<a href="#310003"><b>310003</b> - INT 31 P - DPMI 0.9+ - GET NEXT SELECTOR INCREMENT VALUE</a><br />
<a href="#310004"><b>310004</b> - INT 31 P - DPMI 0.9+ - LOCK SELECTOR</a><br />
<a href="#310005"><b>310005</b> - INT 31 P - DPMI 0.9+ - UNLOCK SELECTOR</a><br />
<a href="#310006"><b>310006</b> - INT 31 P - DPMI 0.9+ - GET SEGMENT BASE ADDRESS</a><br />
<a href="#310007"><b>310007</b> - INT 31 P - DPMI 0.9+ - SET SEGMENT BASE ADDRESS</a><br />
<a href="#310008"><b>310008</b> - INT 31 P - DPMI 0.9+ - SET SEGMENT LIMIT</a><br />
<a href="#310009"><b>310009</b> - INT 31 P - DPMI 0.9+ - SET DESCRIPTOR ACCESS RIGHTS</a><br />
<a href="#31000A"><b>31000A</b> - INT 31 P - DPMI 0.9+ - CREATE ALIAS DESCRIPTOR</a><br />
<a href="#31000B"><b>31000B</b> - INT 31 P - DPMI 0.9+ - GET DESCRIPTOR</a><br />
<a href="#31000C"><b>31000C</b> - INT 31 P - DPMI 0.9+ - SET DESCRIPTOR</a><br />
<a href="#31000D"><b>31000D</b> - INT 31 P - DPMI 0.9+ - ALLOCATE SPECIFIC LDT DESCRIPTOR</a><br />
<a href="#31000E"><b>31000E</b> - INT 31 P - DPMI 1.0+ - GET MULTIPLE DESCRIPTORS</a><br />
<a href="#31000F"><b>31000F</b> - INT 31 P - DPMI 1.0+ - SET MULTIPLE DESCRIPTORS</a><br />
<a href="#310100"><b>310100</b> - INT 31 P - DPMI 0.9+ - ALLOCATE DOS MEMORY BLOCK</a><br />
<a href="#310101"><b>310101</b> - INT 31 P - DPMI 0.9+ - FREE DOS MEMORY BLOCK</a><br />
<a href="#310102"><b>310102</b> - INT 31 P - DPMI 0.9+ - RESIZE DOS MEMORY BLOCK</a><br />
<a href="#310200"><b>310200</b> - INT 31 P - DPMI 0.9+ - GET REAL MODE INTERRUPT VECTOR</a><br />
<a href="#310201"><b>310201</b> - INT 31 P - DPMI 0.9+ - SET REAL MODE INTERRUPT VECTOR</a><br />
<a href="#310202"><b>310202</b> - INT 31 P - DPMI 0.9+ - GET PROCESSOR EXCEPTION HANDLER VECTOR</a><br />
<a href="#310203"><b>310203</b> - INT 31 P - DPMI 0.9+ - SET PROCESSOR EXCEPTION HANDLER VECTOR</a><br />
<a href="#310204"><b>310204</b> - INT 31 P - DPMI 0.9+ - GET PROTECTED MODE INTERRUPT VECTOR</a><br />
<a href="#310205"><b>310205</b> - INT 31 P - DPMI 0.9+ - SET PROTECTED MODE INTERRUPT VECTOR</a><br />
<a href="#310210"><b>310210</b> - INT 31 P - DPMI 1.0+ - GET PROTECTED MODE EXTENDED PROCESSOR EXCEPTION HANDLER</a><br />
<a href="#310211"><b>310211</b> - INT 31 P - DPMI 1.0+ - GET REAL MODE EXTENDED PROCESSOR EXCEPTION HANDLER</a><br />
<a href="#310212"><b>310212</b> - INT 31 P - DPMI 1.0+ - SET PROTECTED MODE EXTENDED PROCESSOR EXCEPTION HANDLER</a><br />
<a href="#310213"><b>310213</b> - INT 31 P - DPMI 1.0+ - SET REAL MODE EXTENDED PROCESSOR EXCEPTION HANDLER</a><br />
<a href="#310300"><b>310300</b> - INT 31 P - DPMI 0.9+ - SIMULATE REAL MODE INTERRUPT</a><br />
<a href="#310301"><b>310301</b> - INT 31 P - DPMI 0.9+ - CALL REAL MODE PROCEDURE WITH FAR RETURN FRAME</a><br />
<a href="#310302"><b>310302</b> - INT 31 P - DPMI 0.9+ - CALL REAL MODE PROCEDURE WITH IRET FRAME</a><br />
<a href="#310303"><b>310303</b> - INT 31 P - DPMI 0.9+ - ALLOCATE REAL MODE CALLBACK ADDRESS</a><br />
<a href="#310304"><b>310304</b> - INT 31 P - DPMI 0.9+ - FREE REAL MODE CALLBACK ADDRESS</a><br />
<a href="#310305"><b>310305</b> - INT 31 P - DPMI 0.9+ - GET STATE SAVE/RESTORE ADDRESSES</a><br />
<a href="#310306"><b>310306</b> - INT 31 P - DPMI 0.9+ - GET RAW MODE SWITCH ADDRESSES</a><br />
<a href="#310400"><b>310400</b> - INT 31 P - DPMI 0.9+ - GET DPMI VERSION</a><br />
<a href="#310401"><b>310401</b> - INT 31 P - DPMI 1.0+ - GET DPMI CAPABILITIES</a><br />
<a href="#310500"><b>310500</b> - INT 31 P - DPMI 0.9+ - GET FREE MEMORY INFORMATION</a><br />
<a href="#310501"><b>310501</b> - INT 31 P - DPMI 0.9+ - ALLOCATE MEMORY BLOCK</a><br />
<a href="#310502"><b>310502</b> - INT 31 P - DPMI 0.9+ - FREE MEMORY BLOCK</a><br />
<a href="#310503"><b>310503</b> - INT 31 P - DPMI 0.9+ - RESIZE MEMORY BLOCK</a><br />
<a href="#310504"><b>310504</b> - INT 31 P - DPMI 1.0+ - ALLOCATE LINEAR MEMORY BLOCK</a><br />
<a href="#310505"><b>310505</b> - INT 31 P - DPMI 1.0+ - RESIZE LINEAR MEMORY BLOCK</a><br />
<a href="#310506"><b>310506</b> - INT 31 P - DPMI 1.0+ - GET PAGE ATTRIBUTES</a><br />
<a href="#310507"><b>310507</b> - INT 31 P - DPMI 1.0+ - MODIFY PAGE ATTRIBUTES</a><br />
<a href="#310508"><b>310508</b> - INT 31 P - DPMI 1.0+ - MAP DEVICE IN MEMORY BLOCK</a><br />
<a href="#310509"><b>310509</b> - INT 31 P - DPMI 1.0+ - MAP CONVENTIONAL MEMORY IN MEMORY BLOCK</a><br />
<a href="#31050A"><b>31050A</b> - INT 31 P - DPMI 1.0+ - GET MEMORY BLOCK SIZE AND BASE</a><br />
<a href="#31050B"><b>31050B</b> - INT 31 P - DPMI 1.0+ - GET MEMORY INFORMATION</a><br />
<a href="#310600"><b>310600</b> - INT 31 P - DPMI 0.9+ - LOCK LINEAR REGION</a><br />
<a href="#310601"><b>310601</b> - INT 31 P - DPMI 0.9+ - UNLOCK LINEAR REGION</a><br />
<a href="#310602"><b>310602</b> - INT 31 P - DPMI 0.9+ - MARK REAL MODE REGION AS PAGEABLE</a><br />
<a href="#310603"><b>310603</b> - INT 31 P - DPMI 0.9+ - RELOCK REAL MODE REGION</a><br />
<a href="#310604"><b>310604</b> - INT 31 P - DPMI 0.9+ - GET PAGE SIZE</a><br />
<a href="#310700"><b>310700</b> - INT 31 Pu - DPMI 0.9+ - MARK PAGES AS PAGING CANDIDATES</a><br />
<a href="#310701"><b>310701</b> - INT 31 Pu - DPMI 0.9+ - DISCARD PAGES</a><br />
<a href="#310702"><b>310702</b> - INT 31 P - DPMI 0.9+ - MARK PAGE AS DEMAND PAGING CANDIDATE</a><br />
<a href="#310703"><b>310703</b> - INT 31 P - DPMI 0.9+ - DISCARD PAGE CONTENTS</a><br />
<a href="#310800"><b>310800</b> - INT 31 P - DPMI 0.9+ - PHYSICAL ADDRESS MAPPING</a><br />
<a href="#310801"><b>310801</b> - INT 31 P - DPMI 1.0+ - FREE PHYSICAL ADDRESS MAPPING</a><br />
<a href="#310900"><b>310900</b> - INT 31 P - DPMI 0.9+ - GET AND DISABLE VIRTUAL INTERRUPT STATE</a><br />
<a href="#310901"><b>310901</b> - INT 31 P - DPMI 0.9+ - GET AND ENABLE VIRTUAL INTERRUPT STATE</a><br />
<a href="#310902"><b>310902</b> - INT 31 P - DPMI 0.9+ - GET VIRTUAL INTERRUPT STATE</a><br />
<a href="#310A00"><b>310A00</b> - INT 31 P - DPMI 0.9+ - GET VENDOR SPECIFIC API ENTRY POINT</a><br />
<a href="#310B00"><b>310B00</b> - INT 31 P - DPMI 0.9+ - SET DEBUG WATCHPOINT</a><br />
<a href="#310B01"><b>310B01</b> - INT 31 P - DPMI 0.9+ - CLEAR DEBUG WATCHPOINT</a><br />
<a href="#310B02"><b>310B02</b> - INT 31 P - DPMI 0.9+ - GET STATE OF DEBUG WATCHPOINT</a><br />
<a href="#310B03"><b>310B03</b> - INT 31 P - DPMI 0.9+ - RESET DEBUG WATCHPOINT</a><br />
<a href="#310C00"><b>310C00</b> - INT 31 P - DPMI 1.0+ - INSTALL RESIDENT HANDLER INIT CALLBACK</a><br />
<a href="#310C01"><b>310C01</b> - INT 31 P - DPMI 1.0+ - TERMINATE AND STAY RESIDENT</a><br />
<a href="#310D00"><b>310D00</b> - INT 31 P - DPMI 1.0+ - ALLOCATE SHARED MEMORY</a><br />
<a href="#310D01"><b>310D01</b> - INT 31 P - DPMI 1.0+ - FREE SHARED MEMORY</a><br />
<a href="#310D02"><b>310D02</b> - INT 31 P - DPMI 1.0+ - SERIALIZE SHARED MEMORY</a><br />
<a href="#310D03"><b>310D03</b> - INT 31 P - DPMI 1.0+ - FREE SERIALIZATION ON SHARED MEMORY</a><br />
<a href="#310E00"><b>310E00</b> - INT 31 P - DPMI 1.0+ - GET COPROCESSOR STATUS</a><br />
<a href="#310E01"><b>310E01</b> - INT 31 P - DPMI 1.0+ - SET EMULATION</a><br />
<a href="#3157"><b>3157</b> - INT 31 - Netroom3 DPMI.EXE v3.00 - ???</a><br />
<a href="#315702"><b>315702</b> - INT 31 - Netroom3 DPMI.EXE v3.00 - SWITCH TO PROTECTED MODE</a><br />
<a href="#31EE00"><b>31EE00</b> - INT 31 - DOS32 v3.0+ - GET DOS32 VERSION AND SELECTOR VALUES</a><br />
<a href="#31EE02"><b>31EE02</b> - INT 31 - DOS32 v3.0+ - GET DOS32 ADDRESS INFORMATION</a><br />
<a href="#31EE10"><b>31EE10</b> - INT 31 - DOS32 v3.2+ - SET UP A DOS32 LOADABLE LIBRARY</a><br />
<a href="#31EE11"><b>31EE11</b> - INT 31 - DOS32 v3.2+ - LOAD LIBRARY FILE</a><br />
<a href="#31EE20"><b>31EE20</b> - INT 31 - DOS32 v3.0+ - GET REAL MODE CALL BACK ADDRESS WITH RETF STACK FRAME</a><br />
<a href="#31EE21"><b>31EE21</b> - INT 31 - DOS32 v3.0+ - GET REAL MODE CALL BACK ADDRESS WITH IRET STACK FRAME</a><br />
<a href="#31EE30"><b>31EE30</b> - INT 31 - DOS32 v3.0+ - TERMINATE AND STAY RESIDENT</a><br />
<a href="#31EE40"><b>31EE40</b> - INT 31 - DOS32 v3.0+ - UNDO PREVIOUS MEMORY ALLOCATION or DMA BUFFER</a><br />
<a href="#31EE41"><b>31EE41</b> - INT 31 - DOS32 v3.0+ - ALLOCATE 16KB DMA BLOCK</a><br />
<a href="#31EE42"><b>31EE42</b> - INT 31 - DOS32 v3.0+ - ALLOCATE MEMORY BLOCK</a><br />
<a href="#31FF00"><b>31FF00</b> - INT 31 P - CauseWay - "Info" - GET SYSTEM SELECTORS/FLAGS</a><br />
<a href="#31FF01"><b>31FF01</b> - INT 31 P - CauseWay - "IntXX" - SIMULATE REAL-MODE INTERRUPT</a><br />
<a href="#31FF02"><b>31FF02</b> - INT 31 P - CauseWay - "FarCallReal" - SIMULATE REAL-MODE FAR CALL</a><br />
<a href="#31FF03"><b>31FF03</b> - INT 31 P - CauseWay - "GetSel" - ALLOCATE NEW SELECTOR</a><br />
<a href="#31FF04"><b>31FF04</b> - INT 31 P - CauseWay - "RelSel" - RELEASE A SELECTOR</a><br />
<a href="#31FF05"><b>31FF05</b> - INT 31 P - CauseWay - "CodeSel" - CONVERT SELECTOR TO EXECUTABLE CODE SELECTOR</a><br />
<a href="#31FF06"><b>31FF06</b> - INT 31 P - CauseWay - "AliasSel" - CREATE READ/WRITE DATA ALIAS SELECTOR</a><br />
<a href="#31FF07"><b>31FF07</b> - INT 31 P - CauseWay - "GetSelDet" - GET SELECTOR BASE AND LIMIT</a><br />
<a href="#31FF08"><b>31FF08</b> - INT 31 P - CauseWay - "GetSelDet32" - GET SELECTOR BASE AND LIMIT (32-bit)</a><br />
<a href="#31FF09"><b>31FF09</b> - INT 31 P - CauseWay - "SetSelDet" - SET SELECTOR BASE AND LIMIT</a><br />
<a href="#31FF0A"><b>31FF0A</b> - INT 31 P - CauseWay - "SetSelDet32" - SET SELECTOR BASE AND LIMIT (32-bit)</a><br />
<a href="#31FF0B"><b>31FF0B</b> - INT 31 P - CauseWay - "GetMem" - ALLOCATE BLOCK OF MEMORY</a><br />
<a href="#31FF0C"><b>31FF0C</b> - INT 31 P - CauseWay - "GetMem32" - ALLOCATE BLOCK OF MEMORY (32-bit)</a><br />
<a href="#31FF0D"><b>31FF0D</b> - INT 31 P - CauseWay - "ResMem" - RESIZE MEMORY BLOCK</a><br />
<a href="#31FF0E"><b>31FF0E</b> - INT 31 P - CauseWay - "ResMem32" - RESIZE MEMORY BLOCK (32-bit)</a><br />
<a href="#31FF0F"><b>31FF0F</b> - INT 31 P - CauseWay - "RelMem" - RELEASE PREVIOUSLY ALLOCATED MEMORY</a><br />
<a href="#31FF10"><b>31FF10</b> - INT 31 P - CauseWay - "GetMemLinear" - ALLOCATE MEMORY WITHOUT SELECTOR</a><br />
<a href="#31FF11"><b>31FF11</b> - INT 31 P - CauseWay - "GetMemLinear32" - ALLOCATE MEMORY WITHOUT SELECTOR</a><br />
<a href="#31FF12"><b>31FF12</b> - INT 31 P - CauseWay - "ResMemLinear" - RESIZE LINEAR MEMORY BLOCK</a><br />
<a href="#31FF13"><b>31FF13</b> - INT 31 P - CauseWay - "ResMemLinear32" - RESIZE LINEAR MEMORY BLOCK (32-bit)</a><br />
<a href="#31FF14"><b>31FF14</b> - INT 31 P - CauseWay - "RelMemLinear" - RELEASE LINEAR MEMORY BLOCK</a><br />
<a href="#31FF15"><b>31FF15</b> - INT 31 P - CauseWay - "RelMemLinear32" - RELEASE LINEAR MEMORY BLOCK (32-bit)</a><br />
<a href="#31FF16"><b>31FF16</b> - INT 31 P - CauseWay - "GetMemNear" - ALLOCATE APPLICATION-RELATIVE MEMORY</a><br />
<a href="#31FF17"><b>31FF17</b> - INT 31 P - CauseWay - "ResMemNear" - RESIZE APPLICATION-RELATIVE MEMORY BLOCK</a><br />
<a href="#31FF18"><b>31FF18</b> - INT 31 P - CauseWay - "RelMemNear" - RELEASE APPLICATION-RELATIVE MEMORY BLOCK</a><br />
<a href="#31FF19"><b>31FF19</b> - INT 31 P - CauseWay - "Linear2Near" - CONVERT LINEAR TO APP-RELATIVE ADDRESS</a><br />
<a href="#31FF1A"><b>31FF1A</b> - INT 31 P - CauseWay - "Near2Linear" - CONVERT APP-RELATIVE TO LINEAR ADDRESS</a><br />
<a href="#31FF1B"><b>31FF1B</b> - INT 31 P - CauseWay - "LockMem" - LOCK REGION OF MEMORY</a><br />
<a href="#31FF1C"><b>31FF1C</b> - INT 31 P - CauseWay - "LockMem32" - LOCK REGION OF MEMORY (32-bit)</a><br />
<a href="#31FF1D"><b>31FF1D</b> - INT 31 P - CauseWay - "UnLockMem" - UNLOCK REGION OF MEMORY</a><br />
<a href="#31FF1E"><b>31FF1E</b> - INT 31 P - CauseWay - "UnLockMem32" - UNLOCK REGION OF MEMORY (32-bit)</a><br />
<a href="#31FF1F"><b>31FF1F</b> - INT 31 P - CauseWay - "LockMemNear" - LOCK APPLICATION-RELATIVE MEMORY REGION</a><br />
<a href="#31FF20"><b>31FF20</b> - INT 31 P - CauseWay - "UnLockMemNear" - UNLOCK APP-RELATIVE MEMORY REGION</a><br />
<a href="#31FF21"><b>31FF21</b> - INT 31 P - CauseWay - "GetMemDOS" - ALLOCATE CONVENTIONAL MEMORY</a><br />
<a href="#31FF22"><b>31FF22</b> - INT 31 P - CauseWay - "ResMemDOS" - RESIZE CONVENTIONAL MEMORY BLOCK</a><br />
<a href="#31FF23"><b>31FF23</b> - INT 31 P - CauseWay - "RelMemDOS" - RELEASE CONVENTIONAL MEMORY BLOCK</a><br />
<a href="#31FF24"><b>31FF24</b> - INT 31 P - CauseWay - "ExecOverlay" - LOAD AND OPTIONALLY EXECUTE APP CODE</a><br />
<a href="#31FF25"><b>31FF25</b> - INT 31 P - CauseWay - "GetDOSTrans" - GET DOS TRANSFER BUFFER</a><br />
<a href="#31FF26"><b>31FF26</b> - INT 31 P - CauseWay - "SetDOSTrans" - SET DOS TRANSFER BUFFER</a><br />
<a href="#31FF27"><b>31FF27</b> - INT 31 P - CauseWay v1.3 - "GetMCBSize" - GET CURRENT MCB ALLOCATION BLOCK SIZE</a><br />
<a href="#31FF28"><b>31FF28</b> - INT 31 P - CauseWay v1.3 - "SetMCBSize" - SET MCB MEMORY ALLOCATION BLOCK SIZE</a><br />
<a href="#31FF29"><b>31FF29</b> - INT 31 P - CauseWay v1.3 - "GetSels" - ALLOCATE MULTIPLE SELECTORS</a><br />
<a href="#31FF2A"><b>31FF2A</b> - INT 31 P - CauseWay v1.3 - "cwLoad" - LOAD ANOTHER CAUSEWAY PROGRAM AS OVERLAY</a><br />
<a href="#31FF2B"><b>31FF2B</b> - INT 31 P - CauseWay v1.3 - "cwcInfo" - VALIDATE AND GET SIZE OF CWC FILE</a><br />
<a href="#31FF2C"><b>31FF2C</b> - INT 31 P - CauseWay v1.3 - "GetMemSO" - ALLOCATE MEMORY AND RETURN SEL:OFFSET</a><br />
<a href="#31FF2D"><b>31FF2D</b> - INT 31 P - CauseWay v1.3 - "ResMemSO" - RESIZE SELECTOR:OFFSET MEMORY BLOCK</a><br />
<a href="#31FF2E"><b>31FF2E</b> - INT 31 P - CauseWay v1.3 - "RelMemSO" - RELEASE SELECTOR:OFFSET MEMORY BLOCK</a><br />
<a href="#31FFFB"><b>31FFFB</b> - INT 31 P - Causeway v1.3 - "cwcLoad" - LOAD/EXPAND CWC-COMPRESSED FILE</a><br />
<a href="#67DE00"><b>67DE00</b> - INT 67 - Virtual Control Program Interface - INSTALLATION CHECK</a><br />
<a href="#67DE01"><b>67DE01</b> - INT 67 - Virtual Control Program Interface - GET PROTECTED MODE INTERFACE</a><br />
<a href="#67DE02"><b>67DE02</b> - INT 67 - Virtual Control Program Interface - GET MAX PHYSICAL MEMORY ADDRESS</a><br />
<a href="#67DE03"><b>67DE03</b> - INT 67 - Virtual Control Program Interface - GET NUMBER OF FREE 4K PAGES</a><br />
<a href="#67DE04"><b>67DE04</b> - INT 67 - Virtual Control Program Interface - ALLOCATE A 4K PAGE</a><br />
<a href="#67DE05"><b>67DE05</b> - INT 67 - Virtual Control Program Interface - FREE 4K PAGE</a><br />
<a href="#67DE06"><b>67DE06</b> - INT 67 - Virtual Control Program Interface - GET PHYS ADDR OF PAGE IN FIRST MB</a><br />
<a href="#67DE07"><b>67DE07</b> - INT 67 - Virtual Control Program Interface - READ CR0</a><br />
<a href="#67DE08"><b>67DE08</b> - INT 67 - Virtual Control Program Interface - READ DEBUG REGISTERS</a><br />
<a href="#67DE09"><b>67DE09</b> - INT 67 - Virtual Control Program Interface - SET DEBUG REGISTERS</a><br />
<a href="#67DE0A"><b>67DE0A</b> - INT 67 - Virtual Control Program Interface - GET 8259 INTERRUPT VECTOR MAPPINGS</a><br />
<a href="#67DE0B"><b>67DE0B</b> - INT 67 - Virtual Control Program Interface - SET 8259 INTERRUPT VECTOR MAPPINGS</a><br />
<a href="#67DE0C"><b>67DE0C</b> - INT 67 - Virtual Control Program Interface - SWITCH TO PROTECTED MODE</a><br />
<a href="#78"><b>78</b> - INT 78 - UofSalford DBOS DOS extender - API</a><br />
<a href="#78_0"><b>78</b> - INT 78 - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ0</a><br />
<a href="#780000"><b>780000</b> - INT 78 - HugeRealMode Driver - INSTALLATION CHECK</a><br />
<a href="#780001"><b>780001</b> - INT 78 - HugeRealMode Driver - GET ENTRY POINT</a><br />
<a href="#79_0"><b>79</b> - INT 79 - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ1</a><br />
<a href="#79_2"><b>79</b> - INT 79 - DBOS DOS Extender</a><br />
<a href="#7A_1"><b>7A</b> - INT 7A - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ2</a><br />
<a href="#7B_1"><b>7B</b> - INT 7B - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ3</a><br />
<a href="#7C_0"><b>7C</b> - INT 7C - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ4</a><br />
<a href="#7D_1"><b>7D</b> - INT 7D - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ5</a><br />
<a href="#7E_1"><b>7E</b> - INT 7E - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ6</a><br />
<a href="#7F_4"><b>7F</b> - INT 7F - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ7</a><br />
<a href="#80_1"><b>80</b> - INT 80 - Phar Lap 386|DOS-Extender - RELOCATED PRINT-SCREEN</a><br />

<hr />

<a href="#10FF_0" name="10FF_0"><b>10FF</b></a> - INT 10 - DJ GO32.EXE 80386+ DOS extender - VIDEO EXTENSIONS<br />
<pre>
INT 10 - DJ GO32.EXE 80386+ DOS extender - VIDEO EXTENSIONS
	AH = FFh
	AL = video mode (see #00225)
Program: GO32.EXE is a DOS extender included as part of the 80386 port of the
	  GNU C/C++ compiler by DJ Delorie and distributed as DJGPP
SeeAlso: AH=00h,INT 21/AH=FFh"GO32"

(Table 00225)
Values for GO32 video mode number:
 00h	80x25 text
 01h	default text
 02h	CXxDX text
 03h	biggest text
 04h	320x200 graphics
 05h	default graphics
 06h	CXxDX graphics
 07h	biggest non-interlaced graphics
 08h	biggest graphics
Index:	video modes;GO32

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BF00" name="15BF00"><b>15BF00</b></a> - INT 15 - Rational Systems DOS/16M - ???<br />
<pre>
INT 15 - Rational Systems DOS/16M - ???
	AX = BF00h
	???
Return: ???
Note:	under DESQview/X 1.02 DVDOS4GX.DVR, this call is identical to AX=BF02h
SeeAlso: AX=BF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BF01" name="15BF01"><b>15BF01</b></a> - INT 15 - Rational Systems DOS/16M - ???<br />
<pre>
INT 15 - Rational Systems DOS/16M - ???
	AX = BF01h
	???
Return: ???
Notes:	under DESQview/X 1.02 DVDOS4GX.DVR, this call is identical to AX=BF02h
	called by DOS/4GW
SeeAlso: AX=BF00h,AX=BF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BF02DX0000" name="15BF02DX0000"><b>15BF02DX0000</b></a> - INT 15 - Rational Systems DOS/16M - INSTALLATION CHECK<br />
<pre>
INT 15 - Rational Systems DOS/16M - INSTALLATION CHECK
	AX = BF02h
	DX = 0000h
Return: DX = nonzero if installed
	    DX:SI -&gt; XBRK structure (see #00508)
Note:	this function is also supported by DOS/4G
SeeAlso: AX=BF01h,AX=BFDCh,AX=BFDEh/BX=0000h
SeeAlso: INT 21/AH=FFh/DH=0Eh,INT 2F/AH=A1h,INT 2F/AX=F100h,INT 2F/AX=FBA1h

Format of DOS/16M XBRK structure:
Offset	Size	Description	(Table 00508)
 00h	DWORD	linear address of first available byte
 04h	DWORD	linear address of last available byte + 1 ???
 08h	DWORD	real-mode address of XBRK structure???
 0Ch	DWORD	???
 10h  2 BYTEs	???
 12h	WORD	segment of ???
 14h  8 BYTEs	???
 1Ch 512 BYTEs	protected-mode IDT
21Ch  N BYTEs	protected-mode GDT

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BF03" name="15BF03"><b>15BF03</b></a> - INT 15 - Rational Systems DOS/4GW - UNINSTALL???<br />
<pre>
INT 15 - Rational Systems DOS/4GW - UNINSTALL???
	AX = BF03h
	BX = PSP segment of extender
	???
Return: ???
Note:	if BX is not the PSP segment of the extender, it passes the call down
	  the INT 15 chain; this allows nested instances of the extender
SeeAlso: AX=BF06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BF04" name="15BF04"><b>15BF04</b></a> - INT 15 - Rational Systems DOS/4GW - ???<br />
<pre>
INT 15 - Rational Systems DOS/4GW - ???
	AX = BF04h
	BX = PSP segment of extender
Return: nothing???
Notes:	if BX is not the PSP segment of the extender, it passes the call down
	  the INT 15 chain; this allows nested instances of the extender
	grabs INT 2Fh and installs handlers for INT 2F/AX=1605h-1607h
SeeAlso: INT 2F/AX=1607h/BX=22C0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BF05" name="15BF05"><b>15BF05</b></a> - INT 15 - Rational Systems DOS/4GW - INITIALIZE PROTECTED-MODE INTERFACE<br />
<pre>
INT 15 - Rational Systems DOS/4GW - INITIALIZE PROTECTED-MODE INTERFACE
	AX = BF05h
	BX = PSP segment of extender
Return: nothing???
Notes:	if BX is not the PSP segment of the extender, it passes the call down
	  the INT 15 chain; this allows nested instances of the extender
	calls INT 67/AX=DE01h if ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BF06" name="15BF06"><b>15BF06</b></a> - INT 15 - Rational Systems DOS/4GW - ???<br />
<pre>
INT 15 - Rational Systems DOS/4GW - ???
	AX = BF06h
	BX = PSP segment of extender
	???
Return: ???
Note:	if BX is not the PSP segment of the extender, it passes the call down
	  the INT 15 chain; this allows nested instances of the extender
SeeAlso: AX=BF03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDCDX0000" name="15BFDCDX0000"><b>15BFDCDX0000</b></a> - INT 15 - Rational Systems DOS/4GW - INSTALLATION CHECK<br />
<pre>
INT 15 - Rational Systems DOS/4GW - INSTALLATION CHECK
	AX = BFDCh
	DX = 0000h
	SI = 0000h
Return: DX = nonzero if installed
	    DX:SI -&gt; XBRK structure (see #00508)
SeeAlso: AX=BF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0000" name="15BFDEBX0000"><b>15BFDEBX0000</b></a> - INT 15 - DESQview/X - DVDOS4GX.DVR - INSTALLATION CHECK<br />
<pre>
INT 15 - DESQview/X - DVDOS4GX.DVR - INSTALLATION CHECK
	AX = BFDEh
	BX = 0000h
Return: AX = ??? (0003h)
	BX = FFFFh
SeeAlso: AX=BF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0001" name="15BFDEBX0001"><b>15BFDEBX0001</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET PROCESS MANAGER NAME<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET PROCESS MANAGER NAME
	AX = BFDEh
	BX = 0001h
Return: BX = 0000h (success)
	CX:DX -&gt; name of process manager executable
SeeAlso: AX=BFDEh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0002" name="15BFDEBX0002"><b>15BFDEBX0002</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???
	AX = BFDEh
	BX = 0002h
	CX:DX -&gt; ???
Return: BX = 0000h (success)
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=0003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0003" name="15BFDEBX0003"><b>15BFDEBX0003</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = 0003h
Return: BX = 0000h (success)
	CX:DX -&gt; ???
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0004" name="15BFDEBX0004"><b>15BFDEBX0004</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 0004h
	CL = ???
Return: BX = 0000h (success)
	CX:DX -&gt; XBRK structure (see #00508)
SeeAlso: AX=BFDEh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0005" name="15BFDEBX0005"><b>15BFDEBX0005</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 0005h
	CX = new value for ???
Return: BX = 0000h (success)
	AX = old value of ???
	DS:SI -&gt; ??? (if AX nonzero on return)
	ES:DI -&gt; ??? (if AX zero on return)
Note:	called by DOS4GW.EXE
SeeAlso: AX=BFDEh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0006" name="15BFDEBX0006"><b>15BFDEBX0006</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = 0006h
Return: BX = 0000h (success)
	AH = interrupt number??? (BEh)
	CX:DX = ???
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=0007h,INT BE"DESQview"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0007" name="15BFDEBX0007"><b>15BFDEBX0007</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???
	AX = BFDEh
	BX = 0007h
	CX:DX = ???
Return: BX = 0000h (success)
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=0006h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0008" name="15BFDEBX0008"><b>15BFDEBX0008</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 0008h
	CX = segment of ???
	DS = ???
Return: BX = status
	    0000h successful
		AL = ??? (80h or C0h)
		DX = ??? (0603h) if AL=C0h
	    0001h failed
		AX = 0000h
Note:	called by DOS4GW.EXE
SeeAlso: AX=BFDEh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0009" name="15BFDEBX0009"><b>15BFDEBX0009</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET PROTECTED MODE PROGRAM LOADER<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET PROTECTED MODE PROGRAM LOADER
	AX = BFDEh
	BX = 0009h
Return: BX = 0000h (success)
	CX:DX -&gt; full pathname to LOAD32.EXP
SeeAlso: AX=BFDEh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX000A" name="15BFDEBX000A"><b>15BFDEBX000A</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - DECREMENT ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - DECREMENT ???
	AX = BFDEh
	BX = 000Ah
Return: BX = 0000h (success)
	AX = new value of ??? counter
Notes:	also resets a variety of values if the counter goes negative
	called by DOS4GW.EXE
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=000Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX000B" name="15BFDEBX000B"><b>15BFDEBX000B</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - INCREMENT ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - INCREMENT ???
	AX = BFDEh
	BX = 000Bh
Return: AX = new value of ??? counter
Note:	called by DOS4GW.EXE
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=000Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX000C" name="15BFDEBX000C"><b>15BFDEBX000C</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 000Ch
	CL = ???
	    00h
	    nonzero
Return: ???
SeeAlso: AX=BFDEh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX000D" name="15BFDEBX000D"><b>15BFDEBX000D</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 000Dh
	???
Return: ???
SeeAlso: AX=BFDEh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX000E" name="15BFDEBX000E"><b>15BFDEBX000E</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 000Eh
	DX:CX -&gt; ???
Return: AX = segment of handle for calling task
	BX = ??? (probably destroyed)
	DX:CX -&gt; ???
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=000Fh,AX=BFDEh/BX=0013h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX000F" name="15BFDEBX000F"><b>15BFDEBX000F</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 000Fh
Return: AX = segment of handle for calling task
	BX = ??? (probably destroyed)
	DX:CX -&gt; ???
Note:	identical to AX=BFDEh/BX=000Eh with CX:DX = 0000h:0000h
SeeAlso: AX=BFDEh/BX=000Eh,AX=BFDEh/BX=0010h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0010" name="15BFDEBX0010"><b>15BFDEBX0010</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET TASK HANDLE<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET TASK HANDLE
	AX = BFDEh
	BX = 0010h
Return: AX = segment of caller's task handle
	BX destroyed
SeeAlso: AX=BFDEh/BX=000Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0011" name="15BFDEBX0011"><b>15BFDEBX0011</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = 0011h
Return: CX = code segment of DVDOS4GX.DVR
	BX = ??? (0004h)
SeeAlso: AX=BFDEh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0012" name="15BFDEBX0012"><b>15BFDEBX0012</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = 0012h
Return: DX = code segment of DVDOS4GX.DVR
	BX = ??? (012Ch)
	CX = ??? (0006h)
SeeAlso: AX=BFDEh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0013" name="15BFDEBX0013"><b>15BFDEBX0013</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = 0013h
Return: DX:CX -&gt; ???
SeeAlso: AX=BFDEh/BX=000Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0014" name="15BFDEBX0014"><b>15BFDEBX0014</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - LOCK ??? MAILBOX<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - LOCK ??? MAILBOX
	AX = BFDEh
	BX = 0014h
	CX = index of ??? mailbox
		(0000h-0004h valid, but no range checking done)
Return: AX,BX destroyed
SeeAlso: AX=BFDEh/BX=0015h,AX=BFDEh/BX=0017h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0015" name="15BFDEBX0015"><b>15BFDEBX0015</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - UNLOCK ??? MAILBOX<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - UNLOCK ??? MAILBOX
	AX = BFDEh
	BX = 0015h
	CX = index of ??? mailbox
		(0000h-0004h valid, but no range checking done)
Return: AX,BX destroyed
SeeAlso: AX=BFDEh/BX=0014h,AX=BFDEh/BX=0016h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0016" name="15BFDEBX0016"><b>15BFDEBX0016</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - CHECK IF ??? MAILBOX OWNED<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - CHECK IF ??? MAILBOX OWNED
	AX = BFDEh
	BX = 0016h
	CX = index of ??? mailbox
		(0000h-0004h valid, but no range checking done)
Return: AX = status
	    0000h no one owns mailbox
	    0001h mailbox has an owner
	BX destroyed
SeeAlso: AX=BFDEh/BX=0015h,AX=BFDEh/BX=0017h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBX0017" name="15BFDEBX0017"><b>15BFDEBX0017</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ??? MAILBOX OWNER<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ??? MAILBOX OWNER
	AX = BFDEh
	BX = 0017h
	CX = index of ??? mailbox
		(0000h-0004h valid, but no range checking done)
Return: AX = segment of mailbox owner's handle
	BX = segment of caller's task handle
SeeAlso: AX=BFDEh/BX=0015h,AX=BFDEh/BX=0016h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBXFFFD" name="15BFDEBXFFFD"><b>15BFDEBXFFFD</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = FFFDh
Return: CX:DX = ???
SeeAlso: AX=BFDEh/BX=FFFEh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBXFFFE" name="15BFDEBXFFFE"><b>15BFDEBXFFFE</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???
	AX = BFDEh
	BX = FFFEh
	CX:DX = ???
SeeAlso: AX=BFDEh/BX=FFFDh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#15BFDEBXFFFF" name="15BFDEBXFFFF"><b>15BFDEBXFFFF</b></a> - INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - NOP<br />
<pre>
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - NOP
	AX = BFDEh
	BX = FFFFh
SeeAlso: AX=BFDEh/BX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212501" name="212501"><b>212501</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - RESET DOS EXTENDER DATA STRUCTURES<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - RESET DOS EXTENDER DATA STRUCTURES
	AX = 2501h
	SS = application's original SS or DS (FlashTek X-32VM)
Return: CF clear if successful
	CF set on error
	    caller is operating on X-32 stack (FlashTek X-32VM)
Notes:	Phar Lap uses INT 21/AH=25h as the entry point for all 386/DOS-Extender
	  system calls.	 Only available when directly using 386/DOS-Extender or
	  a compatible DOS extender, or when using a product that was created
	  using 386-DOS/Extender or a compatible
	this function is also supported by FlashTek X-32VM
SeeAlso: AH=30h"Phar Lap"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212502" name="212502"><b>212502</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - GET PROTECTED-MODE INTERRUPT VECTOR<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - GET PROTECTED-MODE INTERRUPT VECTOR
	AX = 2502h
	CL = interrupt number
Return: CF clear
	ES:EBX = CS:EIP of protected-mode interrupt handler
Note:	this function is also supported by FlashTek X-32VM
SeeAlso: AX=2503h,AX=2504h,INT 31/AX=0204h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212503" name="212503"><b>212503</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - GET REAL-MODE INTERRUPT VECTOR<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - GET REAL-MODE INTERRUPT VECTOR
	AX = 2503h
	CL = interrupt number
Return: CF clear
	EBX = CS:IP of real-mode interrupt handler
Note:	this function is also supported by FlashTek X-32VM
SeeAlso: AX=2502h,AX=2504h,AH=35h,INT 31/AX=0200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212504" name="212504"><b>212504</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - SET PROTECTED-MODE INTERRUPT VECTOR<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - SET PROTECTED-MODE INTERRUPT VECTOR
	AX = 2504h
	CL = interrupt number
	DS:EDX = CS:EIP of protected-mode interrupt handler
Return: CF clear
Note:	this function is also supported by FlashTek X-32VM
SeeAlso: AX=2502h,AX=2505h,INT 31/AX=0205h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212505" name="212505"><b>212505</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - SET REAL-MODE INTERRUPT VECTOR<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - SET REAL-MODE INTERRUPT VECTOR
	AX = 2505h
	CL = interrupt number
	EBX = CS:IP of real-mode interrupt handler
Return: CF clear
Note:	this function is also supported by FlashTek X-32VM
SeeAlso: AX=2503h,AX=2504h,INT 31/AX=0201h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212506" name="212506"><b>212506</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - SET INT TO ALWAYS GAIN CNTRL IN PR. MODE<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - SET INT TO ALWAYS GAIN CNTRL IN PR. MODE
	AX = 2506h
	CL = interrupt number
	DS:EDX = CS:EIP of protected-mode interrupt handler
Return: CF clear
Notes:	this function modifies both the real-mode low-memory interrupt
	  vector table and the protected-mode Interrupt Descriptor Table (IDT)
	interrupts occurring in real mode are resignaled in protected mode
	this function is also supported by FlashTek X-32VM

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212507" name="212507"><b>212507</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - SET REAL- & PROTECTED-MODE INT VECTORS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - SET REAL- & PROTECTED-MODE INT VECTORS
	AX = 2507h
	CL = interrupt number
	DS:EDX = CS:EIP of protected-mode interrupt handler
	EBX = CS:IP of real-mode interrupt handler
Return: CF clear
Notes:	interrupts are disabled until both vectors have been modified
	this function is also supported by FlashTek X-32VM
SeeAlso: AX=2504h,AX=2505h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212508" name="212508"><b>212508</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - GET SEGMENT LINEAR BASE ADDRESS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - GET SEGMENT LINEAR BASE ADDRESS
	AX = 2508h
	BX = segment selector
Return: CF clear if successful
	    ECX = linear base address of segment
	CF set if invalid segment selector
Note:	this function is also supported by FlashTek X-32VM
SeeAlso: AX=2509h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212509" name="212509"><b>212509</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - CONVERT LINEAR TO PHYSICAL ADDRESS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - CONVERT LINEAR TO PHYSICAL ADDRESS
	AX = 2509h
	EBX = linear address to convert
Return: CF clear if successful
	    ECX = physical address (carry flag clear)
	CF set if linear address not mapped in page tables
SeeAlso: AX=2508h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212509_0" name="212509_0"><b>212509</b></a> - INT 21 P - FlashTek X-32VM - GET SYSTEM SEGMENTS AND SELECTORS<br />
<pre>
INT 21 P - FlashTek X-32VM - GET SYSTEM SEGMENTS AND SELECTORS
	AX = 2509h
Return: CF clear
	EAX high word = default DS
	AX = alias for 16-bit data segment
	BX = real mode code segment
	EDX high word = selector covering full 4GB address space
	DX = default SS
	ESI high word = PSP selector
	SI = environment selector

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21250A" name="21250A"><b>21250A</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - MAP PHYSICAL MEMORY AT END OF SEGMENT<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - MAP PHYSICAL MEMORY AT END OF SEGMENT
	AX = 250Ah
	ES = segment selector in the Local Descriptor Table (LDT) of segment
	     to modify
	EBX = physical base address of memory to map (multiple of 4K)
	ECX = number of physical 4K pages to map
Return: CF clear if successful
	    EAX = 32-bit offset in segment of mapped memory
	CF set on error
	    EAX = error code
		08h insufficient memory to create page tables
		09h invalid segment selector
SeeAlso: INT 31/AX=0800h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21250C" name="21250C"><b>21250C</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - GET HARDWARE INTERRUPT VECTORS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - GET HARDWARE INTERRUPT VECTORS
	AX = 250Ch
Return: CF clear
	AL = base interrupt vector for IRQ0-IRQ7
	AH = base interrupt vector for IRQ8-IRQ15
	BL = interrupt vector for BIOS print screen function (Phar Lap only)
Note:	this function is also supported by FlashTek X-32VM
SeeAlso: INT 31/AX=0400h,INT 67/AX=DE0Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21250D" name="21250D"><b>21250D</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - GET REAL-MODE LINK INFORMATION<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - GET REAL-MODE LINK INFORMATION
	AX = 250Dh
Return: CF clear
	EAX = CS:IP of real-mode callback procedure (see #01358) that will
		  call through from real mode to a protected-mode routine
	EBX = 32-bit real-mode address of intermode call data buffer
	ECX = size in bytes of intermode call data buffer
	ES:EDX = protected-mode address of intermode call data buffer
Notes:	this function is also supported by FlashTek X-32VM
	X-32VM guarantees the intermode buffer to be at least 4 KB
SeeAlso: AX=250Eh

(Table 01358)
Call Phar Lap real-mode callback with:
	STACK:	DWORD	offset to protected-mode code
		WORD	placeholder for protected-mode CS
		DWORD	pointer to selector structure (see #01359)
			or 0000h:0000h for defaults
		var	parameters for protected-mode procedure
Return: via FAR return

Format of Phar Lap selector structure:
Offset	Size	Description	(Table 01359)
 00h	WORD	protected-mode GS selector
 02h	WORD	protected-mode FS selector
 04h	WORD	protected-mode ES selector
 06h	WORD	protected-mode DS selector

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21250E" name="21250E"><b>21250E</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - CALL REAL-MODE PROCEDURE<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - CALL REAL-MODE PROCEDURE
	AX = 250Eh
	EBX = CS:IP of real-mode procedure to call
	ECX = number of two-byte words to copy from protected-mode stack
	      to real-mode stack
Return: CF clear if successful
	    all segment registers unchanged
	    all general registers contain values set by real-mode procedure
	    all other flags set as they were left by real-mode procedure
	    stack unchanged
	CF set on error
	    EAX = error code
		01h not enough real-mode stack space
Note:	this function is also supported by FlashTek X-32VM; under X-32VM, the
	  call will fail if ECX &gt; 0000003Fh
SeeAlso: AX=250Dh,AX=2510h,AH=E1h"OS/286",INT 31/AX=0301h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21250F" name="21250F"><b>21250F</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - CONVERT PROTECTED-MODE ADDRESS TO MS-DOS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - CONVERT PROTECTED-MODE ADDRESS TO MS-DOS
	AX = 250Fh
	ES:EBX = 48-bit protected-mode address to convert
	ECX = 00000000h or length of data in bytes
Return: CF clear if successful (address &lt; 1MB and contiguous)
	    ECX = 32-bit real-mode MS-DOS address
	CF set on error (address &gt;= 1MB or not contiguous)
	    ECX = linear address
Note:	this function is also supported by FlashTek X-32VM
SeeAlso: AX=2510h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212510" name="212510"><b>212510</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - CALL REAL-MODE PROCEDURE, REGISTERS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - CALL REAL-MODE PROCEDURE, REGISTERS
	AX = 2510h
	EBX = CS:IP of real-mode procedure to call
	ECX = number of two-byte words to copy to protected-mode stack to
	      real-mode stack
	DS:EDX -&gt; pointer to parameter block (see #01360)
Return: CF clear if successful
	    all segment registers unchanged,
	    EDX unchanged
	    all other general registers contain values set by real-mode proc
	    all other flags are set as they were left by real-mode procedure
	    real-mode register values are returned in the parameter block
	CF set on error
	    EAX = error code
		01h not enough real-mode stack space
Note:	unlike most of the preceding 25xxh functions, this one is not
	  supported by FlashTek X-32VM
SeeAlso: AX=250Eh,AX=250Fh

Format of Phar Lap real-mode call parameter block:
Offset	Size	Description	(Table 01360)
 00h	WORD	real-mode DS value
 02h	WORD	real-mode ES value
 04h	WORD	real-mode FS value
 06h	WORD	real-mode GS value
 08h	DWORD	real-mode EAX value
 0Ch	DWORD	real-mode EBX value
 10h	DWORD	real-mode ECX value
 14h	DWORD	real-mode EDX value

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212511" name="212511"><b>212511</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - ISSUE REAL-MODE INTERRUPT<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - ISSUE REAL-MODE INTERRUPT
	AX = 2511h
	DS:EDX -&gt; parameter block (see #01361)
Return: all segment registers unchanged
	EDX unchanged
	all other registers contain values set by the real-mode int handler
	the flags are set as they were left by the real-mode interrupt handler
	real-mode register values are returned in the parameter block
Note:	this function is also supported by FlashTek X-32VM
SeeAlso: AX=2503h,AX=2505h,AX=250Eh,AH=E3h"OS/286",INT 31/AX=0300h

Format of Phar Lap real-mode interrupt parameter block:
Offset	Size	Description	(Table 01361)
 00h	WORD	interrupt number
 02h	WORD	real-mode DS value
 04h	WORD	real-mode ES value
 06h	WORD	real-mode FS value
 08h	WORD	real-mode GS value
 0Ah	DWORD	real-mode EAX value
 0Eh	DWORD	real-mode EDX value
Note: all other real-mode values set from protected-mode registers

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212512" name="212512"><b>212512</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - LOAD PROGRAM FOR DEBUGGING<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - LOAD PROGRAM FOR DEBUGGING
	AX = 2512h
	DS:EDX -&gt; pointer to ASCIZ program name
	ES:EBX -&gt; pointer to parameter block (see #01363)
	ECX = size in bytes of LDT buffer
Return: CF clear if successful
	    EAX = number of segment descriptors in LDT
	CF set on error
	    EAX = error code (see #01362)
SeeAlso: AX=2517h

(Table 01362)
Values for Phar Lap error code:
 02h	file not found or path invalid
 05h	access denied
 08h	insufficient memory
 0Ah	environment invalid
 0Bh	invalid file format
 80h	LDT too small

Format of Phar Lap program load parameter block:
Offset	Size	Description	(Table 01363)
Input:
 00h	DWORD	32-bit offset of environment string
 04h	WORD	segment of environment string
 06h	DWORD	32-bit offset of command-tail string
 0Ah	WORD	segment of command-tail string
 0Ch	DWORD	32-bit offset of LDT buffer (size in ECX)
 10h	WORD	segment of LDT buffer
Output:
 12h	WORD	real-mode paragraph address of PSP (see also AH=26h)
 14h	WORD	real/protected mode flag
		0000h  real mode
		0001h  protected mode
 16h	DWORD	initial EIP value
 1Ah	WORD	initial CS value
 1Ch	DWORD	initial ESP value
 20h	WORD	initial SS value
 22h	WORD	initial DS value
 24h	WORD	initial ES value
 26h	WORD	initial FS value
 28h	WORD	initial GS value

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212513" name="212513"><b>212513</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - ALIAS SEGMENT DESCRIPTOR<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - ALIAS SEGMENT DESCRIPTOR
	AX = 2513h
	BX = segment selector of descriptor in GDT or LDT
	CL = access-rights byte for alias descriptor
	CH = use-type bit (USE16 or USE32) for alias descriptor
Return: CF clear if successful
	    AX = segment selector for created alias
	CF set on error
	    EAX = error code
		08h insufficient memory (can't grow LDT)
		09h invalid segment selector in BX

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212514" name="212514"><b>212514</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - CHANGE SEGMENT ATTRIBUTES<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - CHANGE SEGMENT ATTRIBUTES
	AX = 2514h
	BX = segment selector of descriptor in GDT or LDT
	CL = new access-rights byte
	CH = new use-type bit (USE16 or USE32)
Return: CF clear if successful
	CF set on error
	    EAX = error code
		09h invalid selector in BX
SeeAlso: AX=2515h,INT 31/AX=0009h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212515" name="212515"><b>212515</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - GET SEGMENT ATTRIBUTES<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - GET SEGMENT ATTRIBUTES
	AX = 2515h
	BX = segment selector of descriptor in GDT or LDT
Return: CF clear if successful
	    CL = access-rights byte for segment
	    CH = use-type bit (USE16 or USE32)
	ECX&lt;16-31&gt; destroyed
	CF set on error
	    EAX = error code
		09h invalid segment selector in BX
SeeAlso: AX=2514h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212516" name="212516"><b>212516</b></a> - INT 21 P - Phar Lap 386/DOS-Extender v2.2+ - FREE ALL MEMORY OWNED BY LDT<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender v2.2+ - FREE ALL MEMORY OWNED BY LDT
	AX = 2516h
Return: CF clear
Note:	this function must be called from Ring 0 or the CS descriptor is freed

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212517" name="212517"><b>212517</b></a> - INT 21 P - Phar Lap 386/DOS-Extender v2.1c+ - GET INFO ON DOS DATA BUFFER<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender v2.1c+ - GET INFO ON DOS DATA BUFFER
	AX = 2517h
Return: CF clear
	ES:EBX -&gt; data buffer (protected mode address)
	ECX -&gt; data buffer (real mode address)
	EDX = size of data buffer in bytes
Note:	the data buffer's address changes after calls to AX=2512h and AX=252Ah
SeeAlso: AX=2512h,AX=252Ah,AX=2530h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212518" name="212518"><b>212518</b></a> - INT 21 P - Phar Lap 386/DOS-Extender 2.1c+ - SPECIFY HANDLER FOR MOVED SEGMENTS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender 2.1c+ - SPECIFY HANDLER FOR MOVED SEGMENTS
	AX = 2518h
	ES:EBX -&gt; function to call when a segment is moved
Return: CF clear
	ES:EBX -&gt; previous handler

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212519" name="212519"><b>212519</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM - GET ADDITIONAL MEMORY ERROR INFO<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM - GET ADDITIONAL MEMORY ERROR INFO
	AX = 2519h
Return: CF clear
	EAX = error code
	    0000h  no error
	    0001h  out of physical memory
	    0002h  out of swap space (unable to grow swap file)
	    0003h  out of LDT entries and unable to grow LDT
	    0004h  unable to change extended memory allocation mark
	    FFFFFFFFh	paging disabled
Note:	VMM is the Virtual Memory Manager option

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21251A" name="21251A"><b>21251A</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM - LOCK PAGES IN MEMORY<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM - LOCK PAGES IN MEMORY
	AX = 251Ah
	EDX = number of 4k pages to lock
	if BL = 00h
	    ECX = linear address of first page to lock
	if BL = 01h
	    ES:ECX -&gt; pointer to first page to lock
Return: CF clear if successful
	CF set on error
	    EAX = error code
		08h insufficient memory
		09h invalid address range
SeeAlso: AX=251Bh,AX=EB06h,INT 31/AX=0600h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21251B" name="21251B"><b>21251B</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM - UNLOCK PAGES<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM - UNLOCK PAGES
	AX = 251Bh
	EDX = number of pages to unlock
	if BL = 00h
	    ECX = linear address of first page to unlock
	if BL = 01h
	    ES:ECX -&gt; pointer to first page to unlock
Return: CF clear if successful
	CF set on error
	    EAX = error code
		09h invalid address range
SeeAlso: AX=251Ah,AX=EB07h,INT 31/AX=0601h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21251C" name="21251C"><b>21251C</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM v2.1c+ - FREE PHYSICAL MEMORY PAGES<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM v2.1c+ - FREE PHYSICAL MEMORY PAGES
	AX = 251Ch
	BH = preservation flag (00h preserve contents, 01h discard contents)
	EDX = number of pages to free
	BL = address type
	    00h linear address
		ECX = linear address of first page to be freed
	    01h pointer
		ES:ECX -&gt; first page to be freed
Return: CF clear if successful
	CF set on error
	    EAX = error code
		08h memory error, swap space full, no VMM or DPMI
		09h invalid address

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21251D" name="21251D"><b>21251D</b></a> - INT 21 OP - Phar Lap 386/DOS-Extender VMM v2.1c - READ PAGE-TABLE ENTRY<br />
<pre>
INT 21 OP - Phar Lap 386/DOS-Extender VMM v2.1c - READ PAGE-TABLE ENTRY
	AX = 251Dh
	BL = address type
	    00h linear address
		ECX = linear address of page table entry to read
	    01h pointer
		ES:ECX -&gt; page table entry to read
Return: CF clear if successful
	    EAX = contents of page table entry
	CF set on error
	    EAX = error code
		09h invalid address or NOPAGE option set
		78h invalid under DPMI
Note:	this function is obsolete; use AX=252Bh/BH=09h instead
SeeAlso: AX=251Eh,AX=252Bh/BH=09h,AX=EB00h,INT 31/AX=0506h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21251E" name="21251E"><b>21251E</b></a> - INT 21 OP - Phar Lap 386/DOS-Extender VMM v2.1c - WRITE PAGE-TABLE ENTRY<br />
<pre>
INT 21 OP - Phar Lap 386/DOS-Extender VMM v2.1c - WRITE PAGE-TABLE ENTRY
	AX = 251Eh
	BL = address type
	    00h linear address
		ECX = linear address of page table entry to read
	    01h pointer
		ES:ECX -&gt; page table entry to read
	EDX = new value for page table entry
Return: CF clear if successful
	CF set on error
	    EAX = error code
		09h invalid address or NOPAGE option set
		82h not compatible with DPMI
Note:	this call is obsolete; use AX=252Bh/BH=0Ah instead
SeeAlso: AX=251Dh,AX=252Bh/BH=0Ah,INT 31/AX=0507h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21251F" name="21251F"><b>21251F</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM - EXHANGE TWO PAGE-TABLE ENTRIES<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM - EXHANGE TWO PAGE-TABLE ENTRIES
	AX = 251Fh
	BL = address type
	    00h linear address
		ECX = linear address of first page table entry
		EDX = linear address of second page table entry
	    01h pointer
		ES:ECX -&gt; first page table entry
		ES:EDX -&gt; second page table entry
Return: CF clear if successful
	CF set on error
	    EAX = error code
		09h invalid address or NOPAGE option set
		82h not compatible with DPMI
SeeAlso: AX=251Dh,AX=251Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212520" name="212520"><b>212520</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM - GET MEMORY STATISTICS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM - GET MEMORY STATISTICS
	AX = 2520h
	DS:EDX -&gt; pointer to buffer at least 100 bytes in size (see #01364)
	BL = 0 (don't reset VM stats), 1 (reset VM stats)
Return: carry flag clear

Format of Phar Lap VM statistics buffer:
Offset	Size	Description	(Table 01364)
 00h	DWORD	VM status
		0001h VM subsystem is present
		0000h VM not present
 04h	DWORD	"nconvpg" number of conventional memory pages available
 08h	DWORD	"nbimpg" number of Compaq built-in memory pages available
 0Ch	DWORD	"nextpg" total number of extended memory pages
 10h	DWORD	"extlim" extender memory pages limit
 14h	DWORD	"aphyspg" number of physical memory pages allocated to appl
 18h	DWORD	"alockpg" number of locked pages owned by application
 1Ch	DWORD	"sysphyspg" number physical memory pages allocated to system
 20h	DWORD	"nfreepg" number of free physical pages; approx if EMS VCPI
 24h	DWORD	linear address of beginning of application address space
 28h	DWORD	linear address of end of application address space
 2Ch	DWORD	number of seconds since last time VM stats were reset
 30h	DWORD	number of page faults since last time
 34h	DWORD	number of pages written to swap file since last time
 38h	DWORD	number of reclaimed pages (page faults on swapped pages)
 3Ch	DWORD	number of virtual pages allocated to the application
 40h	DWORD	size in pages of swap file
 44h	DWORD	number of system pages allocated with EMS calls
 48h	DWORD	minimum number of conventional memory pages
 4Ch	DWORD	maximum size in pages to which swap file can be increased
 50h	DWORD	"vmflags"
		bit 0 = 1 if page fault in progress
---v4.0+ ---
 54h	DWORD	number of physical pages guaranteed to be free
 58h	DWORD	number of free physical pages currently available
 5Ch	DWORD	size in pages of largest free block of memory (including disk
		  swap space)
 60h	DWORD	reserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212521" name="212521"><b>212521</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM - LIMIT PROGRAM'S EXTENDED MEM USAGE<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM - LIMIT PROGRAM'S EXTENDED MEM USAGE
	AX = 2521h
	EBX = max 4k pages of physical extended memory which program may use
Return: CF clear if successful
	   EBX = maximum limit in pages
	   ECX = minimum limit in pages
	CF set on error
	    EAX = error code
		08h insufficient memory or -nopage switch used
SeeAlso: AX=2522h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212522" name="212522"><b>212522</b></a> - INT 21 P - Phar Lap 386/DOS-Ext VMM v2.2+ - SPECIFY ALTERNATE PAGE-FAULT HANDLR<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Ext VMM v2.2+ - SPECIFY ALTERNATE PAGE-FAULT HANDLR
	AX = 2522h
	ES:EBX -&gt; alternate handler for page faults
Return: CF clear
	ES:EBX -&gt; previous page-fault handler
SeeAlso: AX=2523h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212523" name="212523"><b>212523</b></a> - INT 21 P - Phar Lap 386/DOS-Ext VMM v2.2+ - SPECIFY OUT-OF-SWAP-SPACE HANDLER<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Ext VMM v2.2+ - SPECIFY OUT-OF-SWAP-SPACE HANDLER
	AX = 2523h
	???
Return: ???
Note:	this function takes a DWORD pointer and a DWORD pointer to a DWORD
	  pointer as arguments
SeeAlso: AX=2522h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212524" name="212524"><b>212524</b></a> - INT 21 P - Phar Lap 386/DOS-Ext VMM v2.2+ - INSTALL PAGE-REPLACEMENT HANDLERS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Ext VMM v2.2+ - INSTALL PAGE-REPLACEMENT HANDLERS
	AX = 2524h
	???
Return: ???
Note:	this function takes three DWORD pointers and three DWORD pointers to
	  DWORD pointers as arguments

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212525" name="212525"><b>212525</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM - LIMIT PROGRAM'S CONVENT'L MEM USAGE<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM - LIMIT PROGRAM'S CONVENT'L MEM USAGE
	AX = 2525h
	EBX = limit in 4k pages of physical conventional memory which program
	      may use
Return: CF clear if successful
	    EBX = maximum limit in pages
	    ECX = minimum limit in pages
	CF set on error
	    EAX = error code
		08h insufficient memory or -nopage switch used
SeeAlso: AX=2521h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212526" name="212526"><b>212526</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - GET CONFIGURATION INFORMATION<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - GET CONFIGURATION INFORMATION
	AX = 2526h
	???
Return: ???
Notes:	details are not yet available
	this function takes a pointer to the configuration buffer (see #01365)
	  and a poitner to a BYTE as arguments

Format of Phar Lap configuration buffer:
Offset	Size	Description	(Table 01365)
 00h	DWORD	flags 1 (see #01366)
 04h	DWORD	flags 2 (unused through v5.0)
 08h	DWORD	flags 3 (unused through v5.0)
 0Ch	DWORD	386|DOS-Extender major version
 10h	DWORD	386|DOS-Extender minor version
 14h	DWORD	first letter of text after minor version number in version str
 18h	DWORD	beta flag (00h normal release, 01h beta release)
 1Ch	DWORD	processor (3 = 386, 4 = 486)
 20h	DWORD	coprocessor (4 = none, 6 = 287, 7 = 387/486)
 24h	DWORD	Weitek coprocessor flag (0 = none, 1 = present)
 28h	DWORD	machine type (0 = IBM PC compatible, 1 = NEC 9800 series)
 2Ch	DWORD	machine class
		IBM: bus type (0=ISA, 1=MCA, 2=XT, 3=EISA)
		NEC: 0=normal mode, 1=high-res mode
 30h	DWORD	VCPI flag (0 = none, 1 = present)
 34h	DWORD	-WEITEK/-1167 switch (0 = AUTO, 1 = ON, 2 = OFF)
 38h	DWORD	-MINREAL setting
 3Ch	DWORD	-MAXREAL setting
 40h	DWORD	-MINIBUF setting
 44h	DWORD	-MAXIBUF setting
 48h	DWORD	size in bytes of DOS call data buffer
 4Ch	DWORD	number of interrupt stacks (-NISTACK)
 50h	DWORD	interrupt stack size (-ISTKSIZE)
 54h	DWORD	-REALBREAK setting
 58h	DWORD	-CALLBUFS
 5Ch	DWORD	-HWIVEC
 60h	DWORD	-PRIVEC
 64h	DWORD	-INTMAP
 68h	DWORD	-PRIMAP
 6Ch	DWORD	VCPI: master 8259 interrupt vector base (IRQ0 mapping)
 70h	DWORD	VCPI: slave 8259 interrupt vector base (IRQ8 mapping)
 74h	DWORD	BIOS print screen interrupt vector (0 if NEC)
 78h	DWORD	-EXTLOW setting
 7Ch	DWORD	-EXTHIGH setting
 80h	DWORD	lowest physical extended-memory address allocatable
 84h	DWORD	highest physical extended-memory address allocatable + 1
 88h	DWORD	special memory's physical base address (00000000h if none)
 8Ch	DWORD	special memory size in bytes (00000000h if none)
 90h	DWORD	-MAXVCPIMEM setting
 94h	DWORD	-VSCAN
 98h	DWORD	-SWAPCHK (0 = OFF, 1 = ON, 2 = FORCE, 3 = MAX)
 9Ch	DWORD	-CODESIZE setting
 A0h	DWORD	minimum swap file size (-MINSWFSIZE)
 A4h	DWORD	maximum swap fiel size (-MAXSWFSIZE)
 A8h	DWORD	page replacement policy (0 = LFU, 1 = NUR)
 ACh	DWORD	number of GDT entries (-NGDTENT)
 B0h	DWORD	number of LDT entries (-NLDTENT)
 B4h	DWORD	program's privilege level (0-3)
---386|DOS-Extender v3.0+ ---
 B8h	DWORD	-LOCKSTACK setting
 BCh	DWORD	-MAXEXTMEM
 C0h	DWORD	-MAXXMSMEM
 C4h	DWORD	-MAXPGMMEM
 C8h	DWORD	-DATATHRESHOLD
 CCh	DWORD	virtual memory manager flag (0 = not present, 1 = present)
 D0h	DWORD	Cyrix coprocessor flag (0 = no Cyrix EMC387, 1 = present)
 D4h	DWORD	-CYRIX setting (0 = AUTO, 1 = ON, 2 = OFF)
 D8h	DWORD	DPMI flag (0 = not present, 1 = present)
 DCh	DWORD	DPMI major version
 E0h	DWORD	DPMI minor version
 E4h	DWORD	DPMI capabilities flags (see #01367)
 E8h	DWORD	VCPI major version
 ECh	DWORD	VCPI minor version
 F0h	WORD	VCPI: IRQ0-7 physical base interrupt vector
 F2h	WORD	VCPI: IRQ8-15 physical base interrupt vector
 F4h	DWORD	XMS flag (0 = none, 1 = present)
 F8h	DWORD	XMS major version
 FCh	DWORD	XMS minor version
100h	WORD	application's CS selector
102h	WORD	application's DS selector
104h	WORD	application's PSP selector
106h	WORD	application's environment selector
108h	WORD	selector mapping entire first megabyte
10Ah	WORD	selector mapping text video memory
10Ch	WORD	selector mapping video memory (text for IBM, graphics for NEC)
10Eh	WORD	selector mapping Weitek address space, 0000h if not present
110h	WORD	selector mapping Cyrix EMC387 address space, 0000h if none
112h	WORD	reserved (0)
114h	DWORD	real-mode FAR entry point to call to switch to protected mode
		  with no saved context
118h	DWORD	size of LDT in bytes
---386|DOS-Extender v5.0+ ---
11Ch	DWORD	Windows flag (0 = not present, 1 = Windows present)
120h	DWORD	Windows major version
124h	DWORD	Windows minor version
128h	DWORD	Windows mode (0 = real/standard, 1 = enhanced)
12Ch	DWORD	OS/2 flag (0 = not present, 1 = OS/2 present)
130h	DWORD	OS/2 major version
134h	DWORD	OS/2 minor version
138h 50 DWORDs	reserved (0)

Bitfields for flags 1:
Bit(s)	Description	(Table 01366)
 0	-NOPAGE specified
 1	-A20 specified
 2	-VDISK specified
 3	-XT specified
 4	-AT specified
 5	-MCA specified
 6	-EISA specified
 7	-NORMRES specified (NEC only)
 8	-HIGHRES specified (NEC only)
 9	set if -SWFGROW1ST, clear if -NOSWFGROW1ST
 10	-NOVM specified
 11	-SAVEREGS specified
 12	unused (clear)
 13	-NOVCPI specified
 14	-NOMUL specified
 15	-NOBMCHK specified
 16	-NOSPCLMEM or -NOBIM
 17	-NOPGEXP specified
 18	-SWAPDEFDISK specified
---v3.0+ ---
 19	-SAVEINTS specified
 20	-NOLOAD specified
 21	-PAGELOG specified
 22	-OPENDENY specified
 23	-ERRATA17 specified
---v4.1+ ---
 24	-NESTDPMI specified
 25	-NONESTDPMI specified
 26	-NODPMI specified
 27	-NOPCDWEITEK specified
---v4.2+ ---
 28	-WININT21 specified

Bitfields for DPMI capabilities flags:
Bit(s)	Description	(Table 01367)
 0	paging supported
 1	physical device mapping
 2	conventional memory mapping
 3	exceptions restartable

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212527" name="212527"><b>212527</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM - EN/DISABLE STATE SAVE ON INTERRUPTS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM - EN/DISABLE STATE SAVE ON INTERRUPTS
	AX = 2527h
	EBX = new status (00h disabled, 01h enabled)
Return: CF clear
	EBX = previous state save flag
SeeAlso: AX=2528h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212528" name="212528"><b>212528</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM - READ REGISTERS AFTER CTRL-C INT<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM - READ REGISTERS AFTER CTRL-C INT
	AX = 2528h
	DS:EBX -&gt; buffer for registers (see #01368)
Return: CF clear if successful
	    DS:EBX buffer filled
	CF set on error
	    EAX = error code
		83h interrupt state save not enabled
		84h no active interrupt
SeeAlso: AX=2527h

Format of Phar Lap buffer for registers:
Offset	Size	Description	(Table 01368)
 00h  8 BYTEs	unused
 08h  4	DWORDs	EAX,EBX,ECX,EDX
 18h  4 DWORDs	ESI,EDI,EBP,ESP
 28h  6 WORDs	CS,DS,SS,ES,FS,GS
 34h	DWORD	EIP
 38h	DWORD	EFLAGS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212529" name="212529"><b>212529</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - LOAD FLAT MODEL .EXP or .REX FILE<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - LOAD FLAT MODEL .EXP or .REX FILE
	AX = 2529h
	???
Return: ES:EBX -&gt; parameter block (see #01369)
	???
Note:	details not available at this time
SeeAlso: AX=252Ah

Format of Phar Lap program load parameter block:
Offset	Size	Description	(Table 01369)
 00h	DWORD	initial EIP
 04h	WORD	initial CS
 06h	DWORD	initial ESP
 0Ah	WORD	initial SS
 0Ch  4 WORDs	initial DS, ES, FS, GS
 14h	DWORD	minimum size in bytes of program segment
 18h	DWORD	bytes of additional memory allocated
 1Ch	DWORD	flags
		bit 0: child linked with -UNPRIVILEGED
		---v6.0+ ---
		bit 1: child is PE file instead of .EXP
		bit 2: loaded file is a DLL
		bits 3-31 reserved
---v6.0+ ---
 20h	DWORD	module handles (PE files only)
 24h  7 DWORDs	reserved (0)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252A" name="21252A"><b>21252A</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM - NEW LOAD PROGRAM FOR DEBUG<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM - NEW LOAD PROGRAM FOR DEBUG
	AX = 252Ah
	DS:EDX -&gt; ASCIZ program name
	ES:EBX -&gt; parameter block (see #01363)
	ECX = size of LDT buffer in bytes
	ESI = bit flags
	    bit 0: allow demand paging rather than loading entire program
	    bit 1: demand page from swap file rather than from .EXP
Return: CF clear if successful
	    EAX = VMM handle or FFFFFFFFh if none
	    ECX = number of descriptors in LDT buffer
	CF set on error
	    EAX = error code
		02h file error
		    EBX = file error code (see #01370)
		    ECX = DOS error code if EBX=1,2,3, or 8
		08h insufficient memory
		    EBX = memory error code (see #01371)
		80h LDT buffer too small
		87h called twice without intervening call to AX=2531h
SeeAlso: AX=2512h,AX=2517h,AX=2529h,AX=2531h

(Table 01370)
Values for Phar Lap file error code:
 01h	DOS open error
 02h	DOS seek error
 03h	DOS read error
 04h	not an .EXP or .REX file
 05h	invalid file format
 06h	-OFFSET is not a multiple of 64K
 07h	-NOPAGE incompatible with -REALBREAK/-OFFSET
 08h	DOS error loading .EXE file

(Table 01371)
Values for Phar Lap memory error code:
 01h	out of physical memory
 02h	out of swap space
 04h	unable to change extended memory allocation
 05h	-MAXPGMMEM exceeded
 06h	insufficient low memory to REALBREAK value
 07h	insufficient low memory for PSP and environment

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252BBH00" name="21252BBH00"><b>21252BBH00</b></a> - INT 21 Pu - Phar Lap 386/DOS-Extender - CREATE UNMAPPED PAGES<br />
<pre>
INT 21 Pu - Phar Lap 386/DOS-Extender - CREATE UNMAPPED PAGES
	AX = 252Bh
	BH = 00h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252BBH01" name="21252BBH01"><b>21252BBH01</b></a> - INT 21 Pu - Phar Lap 386/DOS-Extender - CREATE ALLOCATED PAGES<br />
<pre>
INT 21 Pu - Phar Lap 386/DOS-Extender - CREATE ALLOCATED PAGES
	AX = 252Bh
	BH = 01h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252BBH02" name="21252BBH02"><b>21252BBH02</b></a> - INT 21 Pu - Phar Lap 386/DOS-Extender - CREATE PHYSICAL DEVICE PAGES<br />
<pre>
INT 21 Pu - Phar Lap 386/DOS-Extender - CREATE PHYSICAL DEVICE PAGES
	AX = 252Bh
	BH = 02h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252BBH03" name="21252BBH03"><b>21252BBH03</b></a> - INT 21 Pu - Phar Lap 386/DOS-Extender - MAP DATA FILE<br />
<pre>
INT 21 Pu - Phar Lap 386/DOS-Extender - MAP DATA FILE
	AX = 252Bh
	BH = 03h
	???
Return: ???
SeeAlso: AX=252Bh/BH=0Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252BBH04" name="21252BBH04"><b>21252BBH04</b></a> - INT 21 Pu - Phar Lap 386/DOS-Extender - GET PAGE TYPES<br />
<pre>
INT 21 Pu - Phar Lap 386/DOS-Extender - GET PAGE TYPES
	AX = 252Bh
	BH = 04h
	???
Return: ???
Note:	returns one word per page
SeeAlso: #01372

Bitfields for Phar Lap page information:
Bit(s)	Description	(Table 01372)
 7	mapped to read/write data file
 6	mapped to read-only data file
 5	swapped to disk
 4	locked
 3-0	page type
	0 unmapped
	1 allocated
	2 physical device page

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252B" name="21252B"><b>21252B</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - VIRTUAL MEMORY MANAGEMENT - PAGE LOCKING<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - VIRTUAL MEMORY MANAGEMENT - PAGE LOCKING
	AX = 252Bh
	BH = function
	    05h lock pages
	    06h unlock pages
	BL = address type
	    00h linear address
		ECX = linear start address of memory region
	    01h segmented address
		ES:ECX -&gt; start of memory region
	EDX = size of memory region in bytes
Return: CF clear if successful
	CF set on error
Note:	this function is also supported by FlashTek X-32VM; if X-32 is not
	  using virtual memory, this function always succeeds

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252B_0" name="21252B_0"><b>21252B</b></a> - INT 21 Pu - Phar Lap 386/DOS-Extender - FREE PHYSICAL PAGES<br />
<pre>
INT 21 Pu - Phar Lap 386/DOS-Extender - FREE PHYSICAL PAGES
	AX = 252Bh
	BH = function (07h,08h)
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252BBH09" name="21252BBH09"><b>21252BBH09</b></a> - INT 21 P - Phar Lap 386/DOS-Extender v4.1 - GET PAGETABLE ENTRY/PAGE TABLE INFO<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender v4.1 - GET PAGETABLE ENTRY/PAGE TABLE INFO
	AX = 252Bh
	BH = 09h
	BL = subfunction
	    00h get page table entry by linear address
		ECX = linear address for which to get page table entry
	    01h get page table entry by logical address
		ES:ECX = address for which to get page table entry
Return: CF clear if successful
	    EAX = page table entry
	    EBX = additional page table information
	CF set on error
	    EAX = error code
		0009h invalid address
		0082h running under DPMI
SeeAlso: AX=251Dh,AX=252Bh/BH=0Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252BBH0A" name="21252BBH0A"><b>21252BBH0A</b></a> - INT 21 P - Phar Lap 386/DOS-Extender v4.1 - SET PAGETABLE ENTRY/PAGE TABLE INFO<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender v4.1 - SET PAGETABLE ENTRY/PAGE TABLE INFO
	AX = 252Bh
	BH = 0Ah
	BL = subfunction
	    00h set page table entry for linear address
		ECX = linear address for which to get page table entry
	    01h set page table entry for logical address
		ES:ECX = address for which to get page table entry
	ESI = page table entry
	EDI = additional page table information
Return: CF clear if successful
	CF set on error
	    EAX = error code
		0009h invalid address
		0082h running under DPMI
SeeAlso: AX=252Bh/BH=09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252BBH0B" name="21252BBH0B"><b>21252BBH0B</b></a> - INT 21 P - Phar Lap 386/DOS-Extender v4.1+ - MAP DATA FILE AT FILE OFFSET<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender v4.1+ - MAP DATA FILE AT FILE OFFSET
	AX = 252Bh
	BH = 0Bh
	BL = subfunction
	    00h by linear address
		ECX = linear address at which to map data file
	    01h by logical address
		ES:ECX = logical address at which to map data file
	EDX = number of bytes to map
	DS:ESI -&gt; mapping structure (see #01373)
	DS:EDI -&gt; ASCIZ filename
Return: CF clear if successful
	CF set on error
	    EAX = error code
		0002h file error
		    ECX = phase (01h opening file, 02h seeking, 03h reading)
		    EDX = error code returned by DOS
		0009h invalid address
		0081h invalid parameters or 386|VMM not present
		0086h all 386|VMM file handles already in use
SeeAlso: AX=252Bh/BH=03h,AX=252Bh/BH=09h

Format of Phar Lap mapping structure:
Offset	Size	Description	(Table 01373)
 00h	DWORD	starting file offset to be mapped
 04h	DWORD	DOS file access and sharing modes (see #01403 at INT 21/AH=3Dh)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252C" name="21252C"><b>21252C</b></a> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - ADD UNMAPPED PAGES AT END OF SEGMENT<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - ADD UNMAPPED PAGES AT END OF SEGMENT
	AX = 252Ch
	BX = segment selector
	ECX = number of 4K pages to add
Return: CF clear if successful
	    EAX = offset in segment of beginning of unmapped pages
	CF set on error
	    EAX = error code
		08h insufficent memory
		09h invalid selector
		82h not supported by current DPMI

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252D" name="21252D"><b>21252D</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM v2.3+ - CLOSE VMM FILE HANDLE<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM v2.3+ - CLOSE VMM FILE HANDLE
	AX = 252Dh
	EBX = VMM file handle
Return: CF clear if successful
	CF set on error
	    EAX = error code (81h invalid VMM handle)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252E" name="21252E"><b>21252E</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM v2.3+ - GET/SET VMM PARAMETERS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM v2.3+ - GET/SET VMM PARAMETERS
	AX = 252Eh
	CL = direction (00h get parameters, 01h set parameters)
	DS:EBX -&gt; parameter buffer (see #01374)
Return: CF clear if successful
	CF set on error
	    EAX = error code (81h bad parameter value)

Format of Phar Lap VMM parameter buffer:
Offset	Size	Description	(Table 01374)
 00h	DWORD	flags
		bit 0: page fault logging enabled
		---v5.0+ ---
		bit 1: swap extender to disk during DOS EXEC call
		bit 2: don't zero allocated memory
 04h	DWORD	scan period for page aging, in milliseconds
 08h	DWORD	maximum size (in bytes) to check on each page scan
 0Ch 52 BYTEs	unused

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21252F" name="21252F"><b>21252F</b></a> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - WRITE RECORD TO VMM PAGE LOG FILE<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - WRITE RECORD TO VMM PAGE LOG FILE
	AX = 252Fh
	DS:EBX -&gt; data to be written
	CX = size of data in bytes
Return: CF clear if successful
	CF set on error
	    EAX = error code (85h no page log file or not 386/VMM)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212530" name="212530"><b>212530</b></a> - INT 21 P - Phar Lap 386/DOS-Ext VMM v2.3+ - SET SIZE OF BUFFER FOR DOS CALLS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Ext VMM v2.3+ - SET SIZE OF BUFFER FOR DOS CALLS
	AX = 2530h
	ECX = size of data buffer in bytes (1024 to 65536)
Return: CF clear if successful
	CF set on error
	    EAX = error code
		08h insufficient low memory
		81h invalid size
SeeAlso: AX=2517h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212531" name="212531"><b>212531</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM v3.0 - READ/WRITE LDT DESCRIPTOR<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM v3.0 - READ/WRITE LDT DESCRIPTOR
	AX = 2531h
	BX = segment selector
	ECX = direction (00h read, 01h write)
	DS:EDX -&gt; 8-byte buffer for descriptor contents
Return: CF clear if successful
	CF set on error
	    EAX = error code
		81h invalid selector
		82h DPMI running, or not a code or data segment

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212532" name="212532"><b>212532</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - GET EXCEPTION HANDLER VECTOR<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - GET EXCEPTION HANDLER VECTOR
	AX = 2532h
	CL = exception number (00h-0Fh)
Return: CF clear if successful
	    ES:EBX = CS:EIP of current exception handler
	CF set on error (CL &gt; 0Fh)
Notes:	this call is also supported by the FlashTek X-32VM extender
	this function is incompatible with 386|VMM; use AX=2522h instead
SeeAlso: AX=2522h,AX=2533h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212533" name="212533"><b>212533</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - SET EXCEPTION HANDLER VECTOR<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - SET EXCEPTION HANDLER VECTOR
	AX = 2533h
	CL = exception number (00h-0Fh)
	DS:EDX = CS:EIP of new exception handler
Return: CF clear if successful
	CF set on error (CL &gt; 0Fh)
Notes:	this call is also supported by the FlashTek X-32VM extender
	this function is incompatible with 386|VMM; use AX=2522h instead
SeeAlso: AX=2522h,AX=2532h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212534" name="212534"><b>212534</b></a> - INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - GET INTERRUPT FLAG<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - GET INTERRUPT FLAG
	AX = 2534h
Return: CF clear
	EAX = interrupt state (00h disabled, 01h enabled)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212535" name="212535"><b>212535</b></a> - INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - READ/WRITE SYSTEM REGISTERS<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - READ/WRITE SYSTEM REGISTERS
	AX = 2535h
	EBX = direction (00h read registers, 01h write)
	DS:EDX -&gt; system register record (see #01375)
Return: CF clear
Note:	this call is only available under MS Windows if PHARLAP.386 VDD is
	  installed

Format of Phar Lap system register record:
Offset	Size	Description	(Table 01375)
 00h	DWORD	CR0
 04h  4 DWORDs	DR0,DR1,DR2,DR3
 14h  2 DWORDs	reserved
 1Ch  2 DWORDs	DR6,DR7
 24h  3 DWORDs	reserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212536" name="212536"><b>212536</b></a> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0+ - MIN/MAX EXTENDED/CONV MEMORY USAGE<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0+ - MIN/MAX EXTENDED/CONV MEMORY USAGE
	AX = 2536h
	EBX = bit flags
	    bit 0: modifying conventional memory rather than extended memory
	    bit 1: setting maximum memory usage rather than minimum
	ECX = new limit in 4K pages
Return: CF clear if successful
	    EAX = new limit
	CF set on error
	    EAX = error code (08h memory error or -NOPAGE set)
	    EBX = maximum limit in pages
	    ECX = minimum limit in pages

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212537" name="212537"><b>212537</b></a> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - ALLOCATE DOS MEMORY ABOVE DOS BUFFER<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - ALLOCATE DOS MEMORY ABOVE DOS BUFFER
	AX = 2537h
	BX = number of paragraphs to allocate
Return: CF clear if successful
	    AX = real-mode segment of allocated block
	CF set on error
	    AX = error code
		07h MS-DOS memory chain corrupted
		08h insufficient low memory
	    BX = size in paragraphs of largest free block
SeeAlso: AH=48h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212538" name="212538"><b>212538</b></a> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - READ PROTMODE REGS AFTER SFTWARE INT<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - READ PROTMODE REGS AFTER SFTWARE INT
	AX = 2538h
	DS:EBX -&gt; buffer for registers (see #01368)
	ECX = register record to retrieve
	    00h first interrupt state
	    01h next interrupt state
		EDX = handle for current interrupt state
Return: CF clear if successful
	    DS:EBX buffer filled
	    EDX = handle of current interrupt state
	    ESI = number of interrupt which occurred
	CF set on error
	    EAX = error code
		81h invalid handle in EDX
		83h register saving not enabled
		84h no more interrupt states
SeeAlso: AX=2527h,AX=2528h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212539" name="212539"><b>212539</b></a> - INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - GET OFFSET OF .EXP FILE HEADER<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Ext VMM v3.0 - GET OFFSET OF .EXP FILE HEADER
	AX = 2539h
	BX = MS-DOS file handle for open file
Return: CF clear if successful
	    EAX = offset of .EXP header in file
	CF set on error
	    EAX = error code (02h file error)
	    EBX = file error code
		02h DOS error seeking
		03h DOS error reading
		04h invalid file type
		05h invalid file format
	    ECX = DOS error code if EBX=02h or 03h
	current file position in file modified

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21253A" name="21253A"><b>21253A</b></a> - INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - INSTALL MOD. SEG FAILURE HANDLER<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - INSTALL MOD. SEG FAILURE HANDLER
	AX = 253Ah
	ES:EBX -&gt; function to be called when INT 21/AH=4Ah is about to return
		an error
Return: CF clear
	ES:EBX -&gt; previous handler
SeeAlso: AH=4Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21253B" name="21253B"><b>21253B</b></a> - INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - JUMP TO REAL MODE CODE, NO CONTEXT<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender v3.0+ - JUMP TO REAL MODE CODE, NO CONTEXT
	AX = 253Bh
	DS:EBX -&gt; buffer containing register contents (see #01368)
Return: never returns
SeeAlso: AX=2528h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21253C" name="21253C"><b>21253C</b></a> - INT 21 P - Phar Lap 386/DOS-Extender VMM v3.0+ - SHRINK 386|VMM SWAP FILE<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender VMM v3.0+ - SHRINK 386|VMM SWAP FILE
	AX = 253Ch
Return: CF clear
	EAX = old size of swap file in bytes
	EBX = new size of swap file in bytes

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21253D" name="21253D"><b>21253D</b></a> - INT 21 P - Phar Lap 386/DOS-Extender v4.0+ - READ/WRITE IDT DESCRIPTOR<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender v4.0+ - READ/WRITE IDT DESCRIPTOR
	AX = 253Dh
	BL = interrupt number
	ECX = direction (0 = read, 1 = write)
	DS:EDX -&gt; 8-byte buffer for descriptor
Return: CF clear if successful
	    DS:EDX filled if reading
	CF set on error
	    EAX = error code (0082h if running under DPMI)
Desc:	access hardware-level IDT rather than the internal 386/DOS-Extender
	  shadow IDT
Notes:	this call will always fail under DPMI because it is not possible to
	  access the IDT
	the descriptor is not checked when writing
	this call can normally be used only by programs running in ring 0
	  because the processor does not allow an interrupt to be vectored to
	  a less privileged ring

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21253F" name="21253F"><b>21253F</b></a> - INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - ALLOCATE LDT DESCRIPTOR<br />
<pre>
INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - ALLOCATE LDT DESCRIPTOR
	AX = 253Fh
	BX = LDT descriptor to allocate (0000h for any)
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212540" name="212540"><b>212540</b></a> - INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - FORCE ALIAS OF SEGMENT<br />
<pre>
INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - FORCE ALIAS OF SEGMENT
	AX = 2540h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212544" name="212544"><b>212544</b></a> - INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - FREE DLL<br />
<pre>
INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - FREE DLL
	AX = 2544h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212545" name="212545"><b>212545</b></a> - INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - GET/SET PROCEDURE ADDRESS<br />
<pre>
INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - GET/SET PROCEDURE ADDRESS
	AX = 2545h
	ECX = direction (00h get, 01h set)
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212546" name="212546"><b>212546</b></a> - INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - GET MODULE HANDLE<br />
<pre>
INT 21 Pu - Phar Lap 386/DOS-Extender v6.0+ - GET MODULE HANDLE
	AX = 2546h
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2125C0" name="2125C0"><b>2125C0</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - ALLOCATE MS-DOS MEMORY BLOCK<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - ALLOCATE MS-DOS MEMORY BLOCK
	AX = 25C0h
	BX = number of 16-byte paragraphs of MS-DOS memory requested
Return: CF clear if successful
	    AX = real-mode paragraph address of memory
	CF set on error
	    AX = error code
		07h MS-DOS memory control blocks destroyed
		08h insufficient memory
	    BX = size in paragraphs of largest available memory block
SeeAlso: AX=25C1h,AX=25C2h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2125C1" name="2125C1"><b>2125C1</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - RELEASE MS-DOS MEMORY BLOCK<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - RELEASE MS-DOS MEMORY BLOCK
	AX = 25C1h
	CX = real-mode paragraph address of memory block to free
Return: CF clear if successful
	    EAX destroyed
	CF set on error
	    AX = error code
		07h MS-DOS memory control blocks destroyed
		09h invalid memory block address in CX
SeeAlso: AX=25C0h,AX=25C2h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2125C2" name="2125C2"><b>2125C2</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - MODIFY MS-DOS MEMORY BLOCK<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - MODIFY MS-DOS MEMORY BLOCK
	AX = 25C2h
	BX = new requested block size in paragraphs
	CX = real-mode paragraph address of memory block to modify
Return: CF clear if successful
	    EAX destroyed
	CF set on error
	    AX = error code
		07h MS-DOS memory control blocks destroyed
		08h insufficient memory
		09h invalid memory block address in CX
	    BX = size in paragraphs of largest available memory block
SeeAlso: AX=25C0h,AX=25C1h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2125C3" name="2125C3"><b>2125C3</b></a> - INT 21 P - Phar Lap 386/DOS-Extender - EXECUTE PROGRAM<br />
<pre>
INT 21 P - Phar Lap 386/DOS-Extender - EXECUTE PROGRAM
	AX = 25C3h
	ES:EBX -&gt; pointer to parameter block (see #01377)
	DS:EDX -&gt; pointer to ASCIZ program filename
Return: CF clear if successful
	    all registers unchanged
	CF set on error
	    EAX = error code (see #01376)

(Table 01376)
Values for Phar Lap error code:
 01h	function code in AL is invalid ???
 02h	file not found or path invalid
 05h	access denied
 08h	insufficient memory to load program
 0Ah	environment invalid
 0Bh	invalid file format

Format of parameter block:
Offset	Size	Description	(Table 01377)
 00h	DWORD	32-bit offset of environment string
 04h	WORD	segment selector of environment string
 06h	DWORD	32-bit offset of command-tail string
 0Ah	WORD	segment selector of command-tail string

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#212B--CX4149" name="212B--CX4149"><b>212B--CX4149</b></a> - INT 21 - AI Architects - ??? - INSTALLATION CHECK<br />
<pre>
INT 21 - AI Architects - ??? - INSTALLATION CHECK
	AH = 2Bh
	CX = 4149h ('AI')
	DX = 413Fh ('A?')
Return: AL &lt;&gt; FFh if installed
Note:	Borland's TKERNEL makes this call

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2130_0" name="2130_0"><b>2130</b></a> - INT 21 - Phar Lap 386/DOS-Extender, Intel Code Builder - INSTALLATION CHECK<br />
<pre>
INT 21 - Phar Lap 386/DOS-Extender, Intel Code Builder - INSTALLATION CHECK
	AH = 30h
	EAX = 00003000h
	EBX = 50484152h ("PHAR")
Return: AL = major DOS version
	AH = minor DOS version
	EAX bits 31-16 = 4458h ('DX') if 386/DOS-extender installed
	    BL = ASCII major version number
	EAX bits 31-16 = 4243h ('BC') if Intel Code Builder installed
	    EDX = address of GDA
SeeAlso: AX=2501h,AX=FF00h,INT 2F/AX=F100h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#213501" name="213501"><b>213501</b></a> - INT 21 P - FlashTek X-32VM - ALLOCATE PROTECTED-MODE SELECTOR<br />
<pre>
INT 21 P - FlashTek X-32VM - ALLOCATE PROTECTED-MODE SELECTOR
	AX = 3501h
Return: CF clear if successful
	    BX = new selector
	CF set on error (no more selectors available)
Note:	the new selector will be an expand-up read/write data selector with
	  undefined base and limit
SeeAlso: AX=3502h,INT 31/AX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#213502" name="213502"><b>213502</b></a> - INT 21 P - FlashTek X-32VM - DEALLOCATE PROTECTED-MODE SELECTOR<br />
<pre>
INT 21 P - FlashTek X-32VM - DEALLOCATE PROTECTED-MODE SELECTOR
	AX = 3502h
	BX = selector
Return: CF clear if successful
	CF set on error (invalid selector)
Note:	only selectors allocated via AX=3501h should be deallocated
SeeAlso: AX=3501h,INT 31/AX=0001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#213503" name="213503"><b>213503</b></a> - INT 21 P - FlashTek X-32VM - SET SELECTOR BASE ADDRESS<br />
<pre>
INT 21 P - FlashTek X-32VM - SET SELECTOR BASE ADDRESS
	AX = 3503h
	BX = selector
	ECX = base address
Return: CF clear if successful
	CF set on error (invalid selector)
SeeAlso: AX=3504h,AX=3505h,INT 31/AX=0007h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#213504" name="213504"><b>213504</b></a> - INT 21 P - FlashTek X-32VM - GET SELECTOR BASE ADDRESS<br />
<pre>
INT 21 P - FlashTek X-32VM - GET SELECTOR BASE ADDRESS
	AX = 3504h
	BX = selector
Return: CF clear if successful
	    ECX = absolute base address of selector
	CF set on error (invalid selector)
SeeAlso: AX=3503h,INT 31/AX=0006h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#213505" name="213505"><b>213505</b></a> - INT 21 P - FlashTek X-32VM - SET SELECTOR LIMIT<br />
<pre>
INT 21 P - FlashTek X-32VM - SET SELECTOR LIMIT
	AX = 3505h
	BX = selector
	ECX = desired limit
Return: CF clear if successful
	    ECX = actual limit set
	CF set on error (no more selectors available)
Note:	the limit will be rounded down to nearest 4K boundary if the requested
	  limit is greater than 1MB
SeeAlso: AX=3503h,INT 31/AX=0008h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21350A" name="21350A"><b>21350A</b></a> - INT 21 P - FlashTek X-32VM - PHYSICAL ADDRESS MAPPING<br />
<pre>
INT 21 P - FlashTek X-32VM - PHYSICAL ADDRESS MAPPING
	AX = 350Ah
	EBX = absolute physical address
	ECX = size in bytes of area to map
Return: CF clear if successful
	CF set on error (insufficient memory or service refused by DPMI host)
Notes:	should not make repeated calls for the same physical address
	there is no provision for unmapping memory

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21350B" name="21350B"><b>21350B</b></a> - INT 21 P - FlashTek X-32VM - UPDATE AND RETURN AVAILABLE FREE MEMORY<br />
<pre>
INT 21 P - FlashTek X-32VM - UPDATE AND RETURN AVAILABLE FREE MEMORY
	AX = 350Bh
	DS = default selector for DS
Return: CF clear
	EAX = maximum amount of memory which can be allocated via AX=350Ch
SeeAlso: AX=350Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21350C" name="21350C"><b>21350C</b></a> - INT 21 P - FlashTek X-32VM - ALLOCATE A BLOCK OF MEMORY<br />
<pre>
INT 21 P - FlashTek X-32VM - ALLOCATE A BLOCK OF MEMORY
	AX = 350Ch
	ECX = size of block in bytes
	DS = default DS
Return: CF clear if successful
	    EAX = near pointer to new block
	    EDX = new lowest legal value for stack
	CF set on error (requested size not multiple of 4K)
SeeAlso: AX=350Bh,AX=350Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21350D" name="21350D"><b>21350D</b></a> - INT 21 P - FlashTek X-32VM - RESERVE BLOCK OF MEMORY FOR 32-BIT STACK<br />
<pre>
INT 21 P - FlashTek X-32VM - RESERVE BLOCK OF MEMORY FOR 32-BIT STACK
	AX = 350Dh
	EBX = current ESP value
	ECX = size of block in bytes
	DS = default DS
Return: CF clear if successful
	    EBX = new value for ESP
	    EDX = suggested new limit for SS
	CF set on error
Note:	this function should only be called once during initialization
SeeAlso: AX=350Bh,AX=350Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214403_4" name="214403_4"><b>214403</b></a> - INT 21 U - AI Architects - OS/x86??? - API<br />
<pre>
INT 21 U - AI Architects - OS/x86??? - API
	AX = 4403h
	BX = handle for device "AIA_OS"
	CX = number of bytes to write (ignored)
	DS:DX -&gt; 12-byte buffer (see #01526), first byte is command:
		  81h installation check
		  82h get API entry point
		  84h uninstall
Return: CF clear if successful
	    AX = number of bytes actually written
	    DS:DX buffer filled
	CF set on error
	    AX = error code (01h,05h,06h,0Ch,0Dh) (see #01680 at AH=59h)
Notes:	these functions are only available if the DOS extender was loaded as a
	  device driver in CONFIG.SYS
	called by TKERNEL (a licensed version of AI Architects/Ergo OS/x86)
SeeAlso: INT 2F/AX=FBA1h/BX=0081h,INT 2F/AX=FBA1h/BX=0082h
Index:	installation check;OS/x86|entry point;OS/x86|uninstall;OS/x86

Format of buffer on return:
Offset	Size	Description	(Table 01526)
 00h  4 BYTEs	signature "IABH"
---if function 81h---
 (no additional fields)
---if function 82h---
 04h	DWORD	pointer to API entry point (see INT 2F/AX=FBA1h/BX=0082h)
---if function 84h---
 04h	WORD	success indicator
 06h	WORD	segment of ???
 08h	WORD	segment of ??? memory block to free if nonzero
 0Ah	WORD	segment of ??? memory block to free if nonzero

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E0_0" name="21E0_0"><b>21E0</b></a> - INT 21 - OS/286, OS/386 - INITIALIZE REAL PROCEDURE<br />
<pre>
INT 21 - OS/286, OS/386 - INITIALIZE REAL PROCEDURE
	AH = E0h
	???
Return: ???
SeeAlso: AH=E1h"OS/286"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E1" name="21E1"><b>21E1</b></a> - INT 21 - OS/286, OS/386 - ISSUE REAL PROCEDURE CALL<br />
<pre>
INT 21 - OS/286, OS/386 - ISSUE REAL PROCEDURE CALL
	AH = E1h
	???
Return: ???
Note:	protected mode only???
SeeAlso: AH=E0h"OS/286",AH=E2h"OS/286",AH=E3h"OS/286",AX=250Eh,INT 31/AX=0301h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E2" name="21E2"><b>21E2</b></a> - INT 21 - OS/286, OS/386 - SET REAL PROCEDURE SIGNAL HANDLER<br />
<pre>
INT 21 - OS/286, OS/386 - SET REAL PROCEDURE SIGNAL HANDLER
	AH = E2h
	???
Return: ???
SeeAlso: AH=E0h"OS/286",AH=E1h"OS/286",AH=E6h"OS/286"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E3" name="21E3"><b>21E3</b></a> - INT 21 - OS/286, OS/386 - ISSUE REAL INTERRUPT<br />
<pre>
INT 21 - OS/286, OS/386 - ISSUE REAL INTERRUPT
	AH = E3h
	AL = interrupt number
	???
Return: ???
Note:	protected mode only???
SeeAlso: AH=E1h"OS/286",INT 31/AX=0300h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E400_0" name="21E400_0"><b>21E400</b></a> - INT 21 - OS/286, OS/386 - CHAIN TO REAL-MODE HANDLER<br />
<pre>
INT 21 - OS/286, OS/386 - CHAIN TO REAL-MODE HANDLER
	AX = E400h
	???
Return: ???
Note:	protected mode only???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E402" name="21E402"><b>21E402</b></a> - INT 21 - OS/286, OS/386 - SET PROTECTED-MODE TASK GATE<br />
<pre>
INT 21 - OS/286, OS/386 - SET PROTECTED-MODE TASK GATE
	AX = E402h
	???
Return: ???
Note:	protected mode only???
SeeAlso: AX=E403h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E403" name="21E403"><b>21E403</b></a> - INT 21 - OS/286, OS/386 - REMOVE PROTECTED-MODE TASK GATE<br />
<pre>
INT 21 - OS/286, OS/386 - REMOVE PROTECTED-MODE TASK GATE
	AX = E403h
	???
Return: ???
Note:	protected mode only???
SeeAlso: AX=E402h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E500" name="21E500"><b>21E500</b></a> - INT 21 - OS/286, OS/386 - HEAP MANAGEMENT STRATEGY<br />
<pre>
INT 21 - OS/286, OS/386 - HEAP MANAGEMENT STRATEGY
	AX = E500h
	???
Return: ???
SeeAlso: AX=E501h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E501" name="21E501"><b>21E501</b></a> - INT 21 - OS/286, OS/386 - FORCE HEAP COMPACTION<br />
<pre>
INT 21 - OS/286, OS/386 - FORCE HEAP COMPACTION
	AX = E501h
	???
Return: ???
SeeAlso: AX=E500h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E6_0" name="21E6_0"><b>21E6</b></a> - INT 21 P - OS/286, OS/386 - ISSUE REAL PROCEDURE SIGNAL FROM PROTECTED MODE<br />
<pre>
INT 21 P - OS/286, OS/386 - ISSUE REAL PROCEDURE SIGNAL FROM PROTECTED MODE
	AH = E6h
	???
Return: ???
SeeAlso: AH=E2h"OS/286"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E7_0" name="21E7_0"><b>21E7</b></a> - INT 21 - OS/286, OS/386 - CREATE CODE SEGMENT<br />
<pre>
INT 21 - OS/286, OS/386 - CREATE CODE SEGMENT
	AH = E7h
	???
Return: ???
SeeAlso: AH=E8h"OS/286",AH=E9h"OS/286",AH=EAh"OS/286"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E8_0" name="21E8_0"><b>21E8</b></a> - INT 21 - OS/286, OS/386 - SEGMENT CREATION<br />
<pre>
INT 21 - OS/286, OS/386 - SEGMENT CREATION
	AH = E8h
	AL = type
	    00h data segment
	    01h data window/alias
	    02h real segment
	    03h real window/alias
		CX:DX = size in bytes
		SI:BX -&gt; start of desired memory block
		Return:	AX = selector
	    06h shareable segment
	???
Return: ???
SeeAlso: AH=E7h"OS/286",AH=E9h"OS/286"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E9" name="21E9"><b>21E9</b></a> - INT 21 P - OS/286, OS/386 - CHANGE SEGMENTS<br />
<pre>
INT 21 P - OS/286, OS/386 - CHANGE SEGMENTS
	AH = E9h
	AL = function
	    01h change code segment parameters
	    02h change data segment parameters
	    05h adjust segment limit
	    06h change segment base address
	???
Return: ???
SeeAlso: AH=E7h"OS/286",AH=E8h"OS/286",AH=EAh"OS/286",AH=EDh"OS/286"
SeeAlso: INT 31/AX=0007h,INT 31/AX=0008h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21EA_1" name="21EA_1"><b>21EA</b></a> - INT 21 - OS/286, OS/386 - ALLOCATE HUGE SEGMENT<br />
<pre>
INT 21 - OS/286, OS/386 - ALLOCATE HUGE SEGMENT
	AH = EAh
	???
Return: ???
Note:	protected mode only???
SeeAlso: AH=E7h"OS/286",AH=E8h"OS/286",AH=E9h"OS/286"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21EB00" name="21EB00"><b>21EB00</b></a> - INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY LINEAR ADDRESS<br />
<pre>
INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY LINEAR ADDRESS
	AX = EB00h
	???
Return: ???
Note:	protected mode only???
SeeAlso: AX=EB02h,AX=EB04h,INT 31/AX=0506h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21EB02" name="21EB02"><b>21EB02</b></a> - INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY 16-BIT SEGMENT:OFFSET<br />
<pre>
INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY 16-BIT SEGMENT:OFFSET
	AX = EB02h
	???
Return: ???
Note:	protected mode only???
SeeAlso: AX=EB00h,AX=EB04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21EB03" name="21EB03"><b>21EB03</b></a> - INT 21 - OS/386 VMM - FREE MAPPED PAGES<br />
<pre>
INT 21 - OS/386 VMM - FREE MAPPED PAGES
	AX = EB03h
	???
Return: ???
Note:	protected mode only???
SeeAlso: AX=EB05h,INT 31/AX=0801h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21EB04" name="21EB04"><b>21EB04</b></a> - INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY 32-BIT SEGMENT:OFFSET<br />
<pre>
INT 21 - OS/386 VMM - GET A PAGE TABLE ENTRY BY 32-BIT SEGMENT:OFFSET
	AX = EB04h
	???
Return: ???
Note:	protected mode only???
SeeAlso: AX=EB00h,AX=EB02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21EB05" name="21EB05"><b>21EB05</b></a> - INT 21 - OS/386 VMM - MAP PAGES<br />
<pre>
INT 21 - OS/386 VMM - MAP PAGES
	AX = EB05h
	???
Return: ???
Note:	protected mode only???
SeeAlso: AX=EB03h,INT 31/AX=0800h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21EB06" name="21EB06"><b>21EB06</b></a> - INT 21 - OS/386 VMM - LOCK PAGES IN MEMORY<br />
<pre>
INT 21 - OS/386 VMM - LOCK PAGES IN MEMORY
	AX = EB06h
	???
Return: ???
Note:	protected mode only???
SeeAlso: AX=EB07h,INT 31/AX=0600h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21EB07" name="21EB07"><b>21EB07</b></a> - INT 21 - OS/386 VMM - UNLOCK MEMORY PAGES<br />
<pre>
INT 21 - OS/386 VMM - UNLOCK MEMORY PAGES
	AX = EB07h
	???
Return: ???
Note:	protected mode only???
SeeAlso: AX=EB06h,INT 31/AX=0601h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21EC_1" name="21EC_1"><b>21EC</b></a> - INT 21 - OS/286, OS/386 - BLOCK TRANSFER<br />
<pre>
INT 21 - OS/286, OS/386 - BLOCK TRANSFER
	AH = ECh
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21ED_0" name="21ED_0"><b>21ED</b></a> - INT 21 - OS/286, OS/386 - GET SEGMENT OR WINDOW DESCRIPTOR<br />
<pre>
INT 21 - OS/286, OS/386 - GET SEGMENT OR WINDOW DESCRIPTOR
	AH = EDh
	???
Return: ???
Note:	protected mode only???
SeeAlso: AH=E9h"OS/286"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF_1" name="21FF_1"><b>21FF</b></a> - INT 21 - DJ GO32.EXE 80386+ DOS extender - DOS EXTENSIONS<br />
<pre>
INT 21 - DJ GO32.EXE 80386+ DOS extender - DOS EXTENSIONS
	AH = FFh
	AL = function
	    01h create file
	    02h open file
	    03h get file statistics
	    04h get time of day
	    05h set time of day
	    06h stat
	    07h system
Program: GO32.EXE is a DOS extender included as part of the 80386 port of the
	  GNU C/C++ compiler by DJ Delorie and distributed as DJGPP
SeeAlso: INT 10/AH=FFh"GO32"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF_4" name="21FF_4"><b>21FF</b></a> - INT 21 UP - Rational Systems DOS/4GW - API<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - API
	AH = FFh
	DH = function (00h-17h) (also see separate entries below)
	DL = subfunction or argument
Return: CF clear if valid function number
	    AX = status???
	CF set if invalid function
SeeAlso: INT 15/AX=BFDCh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH00" name="21FF--DH00"><b>21FF--DH00</b></a> - INT 21 UP - Rational Systems DOS/4GW - GET VERSION???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - GET VERSION???
	AH = FFh
	DH = 00h
	DL = ??? (78h seen)
Return: CF clear
	EAX = 4734FFFFh (high word is byte-swapped "4G") if DOS/4G installed
Note:	Quarterdeck's DESQview/X X Toolkit library uses this call to determine
	  whether the direct-mapped linear 4GB segment's selector is 34h or 38h
SeeAlso: INT 21/AH=FFh/DH=00h"DOS/4GW"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH02" name="21FF--DH02"><b>21FF--DH02</b></a> - INT 21 UP - Rational Systems DOS/4GW - SET ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - SET ???
	AH = FFh
	DH = 02h
	DL = ???
Return: CF clear

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH05" name="21FF--DH05"><b>21FF--DH05</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 05h
	BX = ???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH06" name="21FF--DH06"><b>21FF--DH06</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 06h
	BX = ???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH07" name="21FF--DH07"><b>21FF--DH07</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 07h
	BX = ???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH08" name="21FF--DH08"><b>21FF--DH08</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 08h
	BX = ???
	CX = ???
	ES = ???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH09" name="21FF--DH09"><b>21FF--DH09</b></a> - INT 21 UP - Rational Systems DOS/4GW - GET ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - GET ???
	AH = FFh
	DH = 09h
Return: ES:BX -&gt; ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH0A" name="21FF--DH0A"><b>21FF--DH0A</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 0Ah
	AL = ???
	BX = ???
	CX = ???
Return: ES = ??? or 0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH0B" name="21FF--DH0B"><b>21FF--DH0B</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 0Bh
	AL = ???
	BX = ???
	CX = ???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH0C" name="21FF--DH0C"><b>21FF--DH0C</b></a> - INT 21 UP - Rational Systems DOS/4GW - GET/SET ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - GET/SET ???
	AH = FFh
	DH = 0Ch
	DL = ??? (00h or 01h)
Return: CF clear if successful
	    AL = previous value of ???
	CF set on error (DL out of range)
	    AX = FFFFh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH0D" name="21FF--DH0D"><b>21FF--DH0D</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 0Dh
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH0E" name="21FF--DH0E"><b>21FF--DH0E</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 0Eh
Return: DX:AX -&gt; XBRK structure (see #00508 at INT 15/AX=BF02h)
	BX = ???
	CX = ???
SeeAlso: INT 15/AX=BF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH0F" name="21FF--DH0F"><b>21FF--DH0F</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 0Fh
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH10" name="21FF--DH10"><b>21FF--DH10</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 10h
	AL = ???
	BX = ???
	CX = ???
	DI = ???
	SI = ???
Return: ???
Note:	among other things, frees two memory blocks via INT 21/AH=49h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH11" name="21FF--DH11"><b>21FF--DH11</b></a> - INT 21 UP - Rational Systems DOS/4GW - NOP<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - NOP
	AH = FFh
	DH = 11h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH12" name="21FF--DH12"><b>21FF--DH12</b></a> - INT 21 UP - Rational Systems DOS/4GW - EXCHANGE ??? POINTERS<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - EXCHANGE ??? POINTERS
	AH = FFh
	DH = 12h
	DS:SI -&gt; new ???
	ES:DI -&gt; new ???
Return: DS:SI -&gt; previous ???
	ES:DI -&gt; previous ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH13" name="21FF--DH13"><b>21FF--DH13</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 13h
	AL = ???
	ES = ???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH14" name="21FF--DH14"><b>21FF--DH14</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 14h
	BX = ???
	CX = ???
Return: CF clear
	    AX = ???
	    DX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH15" name="21FF--DH15"><b>21FF--DH15</b></a> - INT 21 UP - Rational Systems DOS/4GW - GET ??? FUNCTIONS<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - GET ??? FUNCTIONS
	AH = FFh
	DH = 15h
Return: CF clear
	    DX:AX -&gt; FAR function for ???
	    CX:BX -&gt; FAR function for ???
	    SI:DI -&gt; FAR function for ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH16" name="21FF--DH16"><b>21FF--DH16</b></a> - INT 21 UP - Rational Systems DOS/4GW - GET ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - GET ???
	AH = FFh
	DH = 16h
Return: AX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF--DH17" name="21FF--DH17"><b>21FF--DH17</b></a> - INT 21 UP - Rational Systems DOS/4GW - ???<br />
<pre>
INT 21 UP - Rational Systems DOS/4GW - ???
	AH = FFh
	DH = 17h
	AL = ???
	DL = ???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21FF00DX0078" name="21FF00DX0078"><b>21FF00DX0078</b></a> - INT 21 - Rational Systems DOS/4G - INSTALLATION CHECK<br />
<pre>
INT 21 - Rational Systems DOS/4G - INSTALLATION CHECK
	AX = FF00h
	DX = 0078h
Return: AL &lt;&gt; 00h if installed
	    GS = segment of kernel if nonzero
SeeAlso: INT 15/AX=BF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1607BX22C0" name="2F1607BX22C0"><b>2F1607BX22C0</b></a> - INT 2F C - Rational Systems DOS/4GW - ???<br />
<pre>
INT 2F C - Rational Systems DOS/4GW - ???
	AX = 1607h
	BX = 22C0h
	???
Return: ???
SeeAlso: INT 15/AX=BF02h,INT 15/AX=BF04h,#02642

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1686" name="2F1686"><b>2F1686</b></a> - INT 2F - DOS Protected-Mode Interface - DETECT MODE<br />
<pre>
INT 2F - DOS Protected-Mode Interface - DETECT MODE
	AX = 1686h
Return: AX = 0000h if operating in protected mode under DPMI (INT 31 available)
	AX nonzero if in real/V86 mode or no DPMI (INT 31 not available)
SeeAlso: AX=1687h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1687" name="2F1687"><b>2F1687</b></a> - INT 2F - DOS Protected-Mode Interface - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS Protected-Mode Interface - INSTALLATION CHECK
	AX = 1687h
Return: AX = 0000h if installed
	    BX = flags
		bit 0: 32-bit programs supported
	    CL = processor type (02h=80286, 03h=80386, 04h=80486)
	    DH = DPMI major version
	    DL = two-digit DPMI minor version (binary)
	    SI = number of paragraphs of DOS extender private data
	    ES:DI -&gt; DPMI mode-switch entry point (see #02718)
	AX nonzero if not installed
SeeAlso: AX=1686h,AX=43E0h,AX=DE01h/BX=4450h,AX=FB42h/BX=0001h
SeeAlso: INT 31/AX=0400h,INT 31/AX=5702h,INT D4/AH=10h

(Table 02718)
Call DPMI mode switch entry point with:
	AX = flags
	    bit 0: set if 32-bit program
	ES = real mode segment of buffer for DPMI private data (ignored if
		SI was zero)
Return: CF set on error
	    program still in real mode
	    AX = error code (DPMI 1.0+)
	       8011h unable to allocate all necessary descriptors
	       8021h 32-bit program specified, but 16-bit DPMI host
	CF clear if successful
	    CS = 16-bit selector corresponding to real-mode CS
	    SS = selector corresponding to real-mode SS (64K limit)
	    DS = selector corresponding to real-mode DS (64K limit)
	    ES = selector to program's PSP (100h byte limit)
	    FS = GS = 0
	    high word of ESP = 0 if 32-bit program
	    program now in protected mode
Note:	this entry point is only called for the initial switch to protected
	  mode

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F168A" name="2F168A"><b>2F168A</b></a> - INT 2F - DPMI 0.9+ - GET VENDOR-SPECIFIC API ENTRY POINT<br />
<pre>
INT 2F - DPMI 0.9+ - GET VENDOR-SPECIFIC API ENTRY POINT
	AX = 168Ah
	DS:(E)SI = selector:offset of ASCIZ vendor name (see #02719)
Return: AL = status
	    00h successful
	       ES:(E)DI -&gt; extended API entry point
	    8Ah unsuccessful
Notes:	the vendor name is used to determine which entry point to return; it is
	  case-sensitive
	available in protected mode only
	32-bit applications use ESI and EDI, 16-bit applications use SI and DI
	this call is present but not documented for DPMI 0.9
	the Borland C++ 3.1 DPMILOAD does not handle requests for entry points
	  other than the MS-DOS one gracefully, producing an unhandled
	  exception report; this has been fixed in the Borland Pascal 7 version
SeeAlso: AX=1687h,INT 31/AX=0A00h,INT 31/AH=57h

(Table 02719)
Values for DPMI vendor-specific API names:
 "MS-DOS"	MS Windows and 386MAX v6.00+ (see #02720)
 "386MAX"	386MAX v6.00+
 "HELIX_DPMI"	Helix Netroom's DPMI server
 "Phar Lap"	Phar Lap 286|DOS-Extender RUN286 (see #02721)
 "RATIONAL DOS/4G"  DOS/4G, DOS/4GW
 "VIRTUAL SUPPORT"  Borland 32RTM

(Table 02720)
Call Windows-support ("MS-DOS") entry point with:
	AX = 0100h get LDT alias selector
Return: CF clear if successful
	    AX = alias selector
	CF set on error
SeeAlso: #02719,AX=1688h/BX=0BADh

(Table 02721)
Call Phar Lap RUN286 entry point with:
	AX = 0000h (function "load MSW")
	BX = new value for MSW register (low word of CR0)
Return: ???
SeeAlso: #02719

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4040" name="2F4040"><b>2F4040</b></a> - INT 2F - PharLap 286|DOS-Extender Lite v2.5 - ???<br />
<pre>
INT 2F - PharLap 286|DOS-Extender Lite v2.5 - ???
	AX = 4040h
Return: BX:CX -&gt; ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F43E0BX0000" name="2F43E0BX0000"><b>2F43E0BX0000</b></a> - INT 2F - DOS Protected Mode Services (DPMS) v1.0 - INSTALLATION CHECK<br />
<pre>
INT 2F - DOS Protected Mode Services (DPMS) v1.0 - INSTALLATION CHECK
	AX = 43E0h
	BX = 0000h
	CX = 4450h ('DP')
	DX = 4D53h ('MS')
Return: AX = 0000h if installed
	    CF clear
	    ES:DI -&gt; server structure (see #02791)
	    ES:BX -&gt; registration structure (pre-NWDOS 7 beta spec) (see #02793)
Note:	the DPMS 1.0 server included with the original release of Novell DOS
	  7.0 supports both the beta and 1.0 specification, setting ES:BX even
	  if CX and DX are not as specified on entry (since the beta
	  specification did not use those registers).  However, the DPMS 1.1
	  server included with the March 1994 update does not support the beta
	  specification
SeeAlso: AX=43E1h,AX=43E2h,AX=43E3h,INT 2F/AX=1687h
Index:	signature strings;DPMS

Format of DPMS 1.0 server structure:
Offset	Size	Description	(Table 02791)
 00h  4 BYTEs	signature string "DPMS"
 04h  2 BYTEs	DPMS version (major,minor)
 06h  8 BYTEs	blank-padded server OEM name
 0Eh  2 BYTEs	OEM server version (major,minor)
 10h	WORD	DPMS flags (see #02792)
 12h	BYTE	CPU type
		(02h = 286, 03h = 386 or higher, higher values allowed)

Bitfields for DPMS flags:
Bit(s)	Description	(Table 02792)
 0	fast processor reset available (286 only)
 1	DPMS server is enabled
 2	memory is remapped
 3-15	reserved (undefined)

Format of beta DPMS registration structure:
Offset	Size	Description	(Table 02793)
 00h	DWORD	real-mode API entry point (see #02795)
 04h	DWORD	16-bit protected-mode API entry point (see #02795)
 08h  8 BYTEs	reserved (0)
 10h  8 BYTEs	blank-padded server OEM name
 18h	WORD	flags
		bit 0: fast processor reset available (286 only)
		bits 1-15 reserved (undefined)
 1Ah  2 BYTEs	DPMS version (major,minor)
 1Ch	BYTE	CPU type (02h = 286, 03h = 386 or higher)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F44" name="2F44"><b>2F44</b></a> - INT 2F U - DOS Extender support???<br />
<pre>
INT 2F U - DOS Extender support???
	AH = 44h
	AL = function (at least 0Bh, 15h, 17h)
	???
Return: ???
Note:	called by Codeview for Windows
SeeAlso: AH=86h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F46" name="2F46"><b>2F46</b></a> - INT 2F U - Windows/286 DOS Extender<br />
<pre>
INT 2F U - Windows/286 DOS Extender
	AH = 46h
	AL = subfunction (03h,04h)
Return: ???
Note:	these two subfunctions are called by MS Windows 3.0

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FA1--BX0081" name="2FA1--BX0081"><b>2FA1--BX0081</b></a> - INT 2F - Ergo DOS extenders - INSTALLATION CHECK<br />
<pre>
INT 2F - Ergo DOS extenders - INSTALLATION CHECK
	AH = A1h
	BX = 0081h
	AL = which
	    FEh OS/286,OS/386
	    FFh HummingBoard DOS extender
	ES:DI -&gt; 16-byte buffer
Return: if installed, first four bytes of ES:DI buffer are "IABH"
Note:	since TKERNEL is a licensed version, it is likely that subfunctions
	  BX=0082h and BX=0084h are present and function identically to the
	  AX=FBA1h/BX=008xh calls
SeeAlso: AX=ED00h,AX=FBA1h/BX=0081h,INT 15/AX=BF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FD201BX4D45" name="2FD201BX4D45"><b>2FD201BX4D45</b></a> - INT 2F U - Quarterdeck RPCI - DVDOS4GX.DVR - ???<br />
<pre>
INT 2F U - Quarterdeck RPCI - DVDOS4GX.DVR - ???
	AX = D201h
	BX = 4D45h ("ME")
	CX = 5155h ("QU")
	DX = 5044h ("PD")
Return: AL = FFh
	BX = 4F4Bh ("OK")
Range:	AH=C0h to AH=FFh, selected by scanning AH=D2h-FFh, then AH=C0h-D1h
Note:	this function is called by QEMM 6.03
	performs a variety of actions before setting return registers
SeeAlso: AX=D200h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FED00" name="2FED00"><b>2FED00</b></a> - INT 2F - Phar Lap DOS EXTENDERS - INSTALLATION CHECK<br />
<pre>
INT 2F - Phar Lap DOS EXTENDERS - INSTALLATION CHECK
	AX = ED00h
	BL = DOS extender ID (see #03110)
Return: AL = status
	    00h not installed
	    FFh installed
		SI = 5048h ("PH")
		DI = 4152h ("AR")
		CH = major version number
		CL = minor version number
		DX = flags
		    bit 0: running under DPMI
		    bit 1: running under Phar Lap VMM
		if running under DPMI:
		    BX = DPMI version (BH = major, BL = minor)
SeeAlso: AH=A1h,AX=F100h,AX=FBA1h

(Table 03110)
Values for Phar Lap DOS extender ID:
 01h	286dosx v1.3+ (Software Development Kit)
 02h	286dosx v1.3+ (Run-Time Kit)
 03h	386dosx v4.0+ (SDK)
 04h	386dosx v4.0+ (RTK)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FED03" name="2FED03"><b>2FED03</b></a> - INT 2F R - Phar Lap 386/DOS-Extender v4.1 - GET EXTENDER ENTRY POINT<br />
<pre>
INT 2F R - Phar Lap 386/DOS-Extender v4.1 - GET EXTENDER ENTRY POINT
	AX = ED03h
	CX = real-mode code segment
	DX = real-mode data segment
Return: CF clear if successful
	    CX = protected-mode code segment selector
	    DX = protected-mode data segment selector
	    ES:DI -&gt; real-mode entry point for calling protected-mode functions
		      (see INT 21/AX=250Dh)
	CF set on error
	    AX = error code
		0008h unable to allocate LDT descriptors

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FED10BL05" name="2FED10BL05"><b>2FED10BL05</b></a> - INT 2F - Pharlap DOS Extender - ???<br />
<pre>
INT 2F - Pharlap DOS Extender - ???
	AX = ED10h
	BL = 05h
	ES:SI -&gt; ??? structure
Return: AX = ???
	SI = ???
	DI = ???
SeeAlso: AX=ED00h,AX=ED11h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FED11BL05" name="2FED11BL05"><b>2FED11BL05</b></a> - INT 2F - Pharlap DOS Extender - FATAL EXIT TO REAL MODE ???<br />
<pre>
INT 2F - Pharlap DOS Extender - FATAL EXIT TO REAL MODE ???
	AX = ED11h
	BL = 05h
	CX = ???
	DX = ???
	ES:SI -&gt; ??? structure
	SS:SP = new stack ???
Return: ???
Note:	called immediately prior to terminating program with INT 21/AX=4CFFh
SeeAlso: AX=ED00h,AX=ED10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FED80" name="2FED80"><b>2FED80</b></a> - INT 2F - Phar Lap 286|DOS Extender Lite v2.5 - ???<br />
<pre>
INT 2F - Phar Lap 286|DOS Extender Lite v2.5 - ???
	AX = ED80h
	BL = DOS extender ID (see #03110)
	SI = 5048h ("PH")
	DI = 4152h ("AR")
	???
Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FF100" name="2FF100"><b>2FF100</b></a> - INT 2F - DOS EXTENDER INSTALLATION CHECK<br />
<pre>
INT 2F - DOS EXTENDER INSTALLATION CHECK
	AX = F100h
Return: AL = FFh if DOS extender present
	    SI = 444Fh ("DO")
	    DI = 5358h ("SX")
Note:	supported or soon to be supported by Phar Lap, Rational, Ergo, and IGC
SeeAlso: AH=A1h,AX=ED00h,AX=FBA1h/BX=0081h,INT 15/AX=BF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0001" name="2FFB42BX0001"><b>2FFB42BX0001</b></a> - INT 2F PU - Borland C++ DPMILOAD.EXE - INSTALLATION CHECK???<br />
<pre>
INT 2F PU - Borland C++ DPMILOAD.EXE - INSTALLATION CHECK???
	AX = FB42h
	BX = 0001h
Return: AX = version number??? (AL=major, AH=minor)
	CX = next-selector increment
---BC2.0---
	ES:BX -&gt; 80-byte buffer for ???
	DX = DPMI version
---BC3.0---
	BX = ??? (0000h)
	DX = ???
	ES:SI -&gt; list of valid selectors ???
Notes:	The version of DPMILOAD distributed with BC++ v2.0 identifies itself
	  as version 1.000, while the version distributed with BC++ 3.0
	  identifies itself as version 1.0; the former is 10864 bytes, the
	  latter 22180 bytes.  The BC2.0 version is a DPMI loader, while
	  the BC3.0 version also adds a DPMI host and DOS extender
	the BC++ 2.0 version displays an error message if called with BX
	  values other than 0001h-0008h
SeeAlso: AX=1687h,AX=FB42h/BX=1001h,AX=FB43h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0002" name="2FFB42BX0002"><b>2FFB42BX0002</b></a> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ALLOCATE MEMORY<br />
<pre>
INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ALLOCATE MEMORY
	AX = FB42h
	BX = 0002h
	CX = size in bytes
	DX = bit flags
	    bit 2: set to allocate DOS memory, clear for DPMI memory
	SI = selector of descriptor to be modified to access allocated memory
	DI = selector of a second descriptor to be modified
Return: AX = ??? or 0000h on error
	CX:DX = linear base address of DPMI memory block
	SI:DI = handle for DPMI memory block or FFFFh:FFFFh
	???
Note:	two segment descriptors may be set if a code and an aliased data
	  segment are required; if only one descriptor is needed, SI should
	  equal DI on entry
BUG:	when allocating DOS memory, the code computes the linear address by
	  multiplying the segment number by 4 rather than shifting by 4
SeeAlso: AX=FB42h/BX=0003h,AX=FB42h/BX=0008h,INT 31/AX=0501h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0002_0" name="2FFB42BX0002_0"><b>2FFB42BX0002</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ALLOCATE MEMORY<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ALLOCATE MEMORY
	AX = FB42h
	BX = 0002h
	ES:SI -&gt; memory block info (see #03127)
Return: ???
Note:	The version of DPMILOAD distributed with BC++ v2.0 identifies itself
	  as version 1.000, while the version distributed with BC++ 3.0
	  identifies itself as version 1.0; the former is 10864 bytes, the
	  latter 22180 bytes.
SeeAlso: AX=FB42h/BX=0003h,AX=FB42h/BX=0008h,INT 31/AX=0501h

Format of DPMILOAD memory block info:
Offset	Size	Description	(Table 03127)
 00h	WORD	flags (see #03128)
 02h	DWORD	block size in bytes
---DPMI memory block---
 06h	DWORD	DPMI memory block handle
---DOS memory block---
 06h	WORD	real-mode segment of memory block
 08h	WORD	selector of memory block
---
 0Ah	DWORD	linear address of memory
 0Eh	WORD	memory operation error code
		0008h no more free LDT descriptors
---if flags bit 0 clear---
 10h	WORD	code segment selector for memory block or 0000h or FFFFh
 12h	WORD	data alias selector for memory block or 0000h or FFFFh
---if flags bit 0 set---
 10h	WORD	data segment selector for memory block or 0000h or FFFFh
 12h	WORD	unused???

Bitfields for DPMILOAD memory block flags:
Bit(s)	Description	(Table 03128)
 0	set if data segment rather than code segment
 1	information valid
 2	set if DOS memory block rather than DPMI memory block
 4	???
 15	set if no LDT selectors for memory block???
SeeAlso: #03127

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0003" name="2FFB42BX0003"><b>2FFB42BX0003</b></a> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET AVAILABLE MEMORY<br />
<pre>
INT 2F PU - Borland C++ DPMILOAD.EXE - GET AVAILABLE MEMORY
	AX = FB42h
	BX = 0003h
Return: DX:AX = size of largest free block in paragraphs
		0000h:0000h on error (BC3.0 version only)
Note:	AX and DX are destroyed on error, but no other error indicator is
	  returned, under the BC++ 2.0 version of DPMILOAD
SeeAlso: AX=FB42h/BX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0004" name="2FFB42BX0004"><b>2FFB42BX0004</b></a> - INT 2F PU - Borland C++ DPMILOAD.EXE - LOAD PROTECTED-MODE EXECUTABLE???<br />
<pre>
INT 2F PU - Borland C++ DPMILOAD.EXE - LOAD PROTECTED-MODE EXECUTABLE???
	AX = FB42h
	BX = 0004h
	DS:DX -&gt; ASCIZ filename of protected-mode executable
Return: CX = selector of ??? or 0000h
---BC3.0---
	DX = status (0000h,FFF4h,others???) (see #03129)
Note:	the filename may also be terminated by a CR rather than a NUL under the
	  BC++ 3.0 version of DPMILOAD

(Table 03129)
Values for DPMILOAD function status:
 0000h	successful
 0001h	??? failure
 0002h	invalid selector
 0004h	unknown error
 0008h	no more LDT descriptors available???
 FFDEh	unable to set descriptor
 FFDFh	unable to get segment base address
 FFE0h	???
 FFF2h	invalid parameter value
 FFF4h	component of filename too long (name not in 8.3 format)
 FFF5h	pathname too long (&gt;79 chars)
 FFF6h	???
 FFF8h	???
 FFF9h	index out of range
 FFFAh	???
 FFFCh	invalid access to code segment???
 FFFEh	???
 FFFFh	general error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0005" name="2FFB42BX0005"><b>2FFB42BX0005</b></a> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NAME<br />
<pre>
INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NAME
	AX = FB42h
	BX = 0005h
	CX = selector of DPMILOAD data (see #03130)
	DS:DX -&gt; ASCIZ or CR-terminated name of ??? (case ignored)
Return: DX = status (see #03129)
	    0000h successful
		AX:BX -&gt; ??? FAR function (called with two words on top of stk)
	    else
		BX destroyed
SeeAlso: AX=FB42h/BX=0006h,AX=FB42h/BX=000Eh

Format of DPMILOAD data:
Offset	Size	Description	(Table 03130)
 00h 12 BYTEs	???
 0Ch	WORD	??? bit flags
 0Eh 14 BYTEs	???
 1Ch	WORD	number of memory control records (see #03133)
 1Eh 25 BYTEs	???
 37h	BYTE	??? bit flags
		bit 4: data valid???
 38h  4 BYTEs	???
 3Ch	WORD	???
 3Eh 12 BYTEs	???
 46h	BYTE	??? counter
 47h	BYTE	???
 48h	BYTE	???
 49h	BYTE	???
 4Ah	WORD	???
 4Ch  2 BYTEs	???
 4Eh	WORD	offset of array of 64-byte memory control records
 52h	WORD	offset of name list (see #03131)
 54h  4 BYTEs	???
 58h	WORD	offset of array of 6-byte objects (see #03132)
 5Ah  8 BYTEs	???
 62h  9 BYTEs	ASCIZ name for ???
 6Bh  9 BYTEs	ASCIZ name for ???
	???

Format of name list entry [array]:
Offset	Size	Description	(Table 03131)
 00h	BYTE	length of name (00h if end of array)
 01h  N BYTEs	name
 N+1	WORD	1-based index into array of unknown 6-byte objects

Format of 6-byte objects:
Offset	Size	Description	(Table 03132)
 00h	BYTE	???
 01h	BYTE	???
 02h	BYTE	???
 03h	BYTE	1-based index of memory control record
 04h	WORD	???

Format of memory control record:
Offset	Size	Description	(Table 03133)
 00h 20 BYTEs	memory block info (see #03127)
 14h  6 BYTEs	???
 1Ah	BYTE	???
 1Bh  2 BYTEs	???
 1Dh	BYTE	??? bit flags
 1Eh 14 BYTEs	???
 2Ch	DWORD	pointer to ??? memory control record or 0000h:0000h
 30h	DWORD	pointer to ??? memory control record or 0000h:0000h
 34h	DWORD	pointer to next??? memory control record or 0000h:0000h
 38h	DWORD	pointer to prev??? memory control record or 0000h:0000h
 3Ch  4 BYTEs	???
Note:	the pointers at offsets 2Ch and 30h form a doubly-linked list, as do
	  the pointers at offsets 34h and 38h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0006" name="2FFB42BX0006"><b>2FFB42BX0006</b></a> - INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NUMBER<br />
<pre>
INT 2F PU - Borland C++ DPMILOAD.EXE - GET ADDRESS OF ??? BY NUMBER
	AX = FB42h
	BX = 0006h
	CX = selector of DPMILOAD data (see #03130)
	DX = 1-based index into array of ??? 6-byte objects
Return: DX = status (see #03129)
	    0000h successful
		AX:BX -&gt; ??? FAR function (called with two words on top of stk)
	    else
		BX destroyed
SeeAlso: AX=FB42h/BX=0005h,AX=FB42h/BX=000Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0007" name="2FFB42BX0007"><b>2FFB42BX0007</b></a> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0007h
	CX = selector of ???
Return: ???
Note:	The version of DPMILOAD distributed with BC++ v2.0 identifies itself
	  as version 1.000, while the version distributed with BC++ 3.0
	  identifies itself as version 1.0; the former is 10864 bytes, the
	  latter 22180 bytes.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0007_0" name="2FFB42BX0007_0"><b>2FFB42BX0007</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0007h
	CX = selector of DPMILOAD data (see #03130)
	???
Return: DX = status (see #03129)
	    0000h successful
		AX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0008" name="2FFB42BX0008"><b>2FFB42BX0008</b></a> - INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - FREE MEMORY BLOCK<br />
<pre>
INT 2F PU - Borland C++ 2.0 DPMILOAD.EXE - FREE MEMORY BLOCK
	AX = FB42h
	BX = 0008h
	CX = bit flags
	    bit 2: set if DPMI memory, clear if DOS memory
	DX = selector of DOS memory block
	SI:DI = handle of DPMI memory block
Return: DX = 0000h on error, unchanged if succcessful
Note:	The version of DPMILOAD distributed with BC++ v2.0 identifies itself
	  as version 1.000, while the version distributed with BC++ 3.0
	  identifies itself as version 1.0; the former is 10864 bytes, the
	  latter 22180 bytes.
SeeAlso: AX=FB42h/BX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0008_0" name="2FFB42BX0008_0"><b>2FFB42BX0008</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE MEMORY BLOCK<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE MEMORY BLOCK
	AX = FB42h
	BX = 0008h
	ES:SI -&gt; memory block info (see #03127)
Return: ???
SeeAlso: AX=FB42h/BX=0009h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0009" name="2FFB42BX0009"><b>2FFB42BX0009</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - RESIZE MEMORY BLOCK<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - RESIZE MEMORY BLOCK
	AX = FB42h
	BX = 0009h
	ES:SI -&gt; memory block info (see #03127)
	???
Return: ???
SeeAlso: AX=FB42h/BX=0008h"3.0"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000A" name="2FFB42BX000A"><b>2FFB42BX000A</b></a> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INIT DPMI HOST AND SPAWN SUBSHELL<br />
<pre>
INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INIT DPMI HOST AND SPAWN SUBSHELL
	AX = FB42h
	BX = 000Ah
	CX = 0001h
	DX = ???
	SI = ???
Return: after user exits subshell
Notes:	this call is used by DPMIRES; unlike most of the DPMILOAD calls, this
	  function is not available in protected mode.
	the BC2.0 version of DPMILOAD is purely a DPMI loader, while the BC3.0
	  version also adds a DPMI host and DOS extender.
SeeAlso: AX=FB42h/BX=0004h,AX=FB42h/BX=0015h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000B" name="2FFB42BX000B"><b>2FFB42BX000B</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - UNUSED<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - UNUSED
	AX = FB42h
	BX = 000Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000C" name="2FFB42BX000C"><b>2FFB42BX000C</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE DESCRIPTORS FOR MEMORY BLOCK???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - FREE DESCRIPTORS FOR MEMORY BLOCK???
	AX = FB42h
	BX = 000Ch
	ES:SI -&gt; memory block info ??? (see #03127)
Return: DX = status???
SeeAlso: AX=FB42h/BX=000Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000D" name="2FFB42BX000D"><b>2FFB42BX000D</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SIMULATE REAL MODE INTERRUPT<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SIMULATE REAL MODE INTERRUPT
	AX = FB42h
	BX = 000Dh
	CX = number of words to copy from protected-mode to real mode stack
	DL = interrupt number
	DH = flags
	    bit 0: reset the interrupt controller and A20 line
	ES:DI -&gt; real-mode call structure (see #03148 at INT 31/AX=0300h)
Return: CX = status
	    0000h successful
	    0001h failed
SeeAlso: INT 31/AX=0300h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000E" name="2FFB42BX000E"><b>2FFB42BX000E</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???
	AX = FB42h
	BX = 000Eh
	DS:DX -&gt; ASCIZ or CR-terminated name of ???
Return: CX = selector of DPMILOAD data (see #03130) corresponding to name,
	      0000h on error
SeeAlso: AX=FB42h/BX=0006h,AX=FB42h/BX=001Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX000F" name="2FFB42BX000F"><b>2FFB42BX000F</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - REALLOCATE LDT DESCRPS TO MEMBLK???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - REALLOCATE LDT DESCRPS TO MEMBLK???
	AX = FB42h
	BX = 000Fh
	ES:SI -&gt; memory block info (see #03127)
Return: ???
SeeAlso: AX=FB42h/BX=000Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0010" name="2FFB42BX0010"><b>2FFB42BX0010</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SEGMENT TO SELECTOR<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SEGMENT TO SELECTOR
	AX = FB42h
	BX = 0010h
	DX = segment number
Return: CX = status (0000h,0008h) (see also AX=FB42h/BX=0004h)
	    0000h successful
		DX = selector number for descriptor
	    0008h failed
SeeAlso: AX=FB42h/BX=0023h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0011" name="2FFB42BX0011"><b>2FFB42BX0011</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0011h
	CX = selector of DPMILOAD data (see #03130)
	???
Return: DX = status (0000h,0002h,FFFEh) (see also #03129)
	    0000h successful
		AX:BX -&gt; ??? name
	    FFFEh ??? error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0012" name="2FFB42BX0012"><b>2FFB42BX0012</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0012h
	CX = selector for ???
Return: CX = selector for ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0013" name="2FFB42BX0013"><b>2FFB42BX0013</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0013h
	CX = selector of DPMILOAD data (see #03130)
	DX = 1-based index of ???
Return: CX = status (0000h,0002h,FFF9h) (see also #03129)
	    0000h successful
		BX = ??? or 0000h
	    FFF9h ??? error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0014" name="2FFB42BX0014"><b>2FFB42BX0014</b></a> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - INSTALLATION CHECK
	AX = FB42h
	BX = 0014h
	CX = 0001h
Return: BX = 0000h if installed
Note:	unlike most of the DPMILOAD functions, this call is available only in
	  real or V86 mode
SeeAlso: AX=FB42h/BX=0001h,AX=FB42h/BX=000Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0015" name="2FFB42BX0015"><b>2FFB42BX0015</b></a> - INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - UNINSTALL<br />
<pre>
INT 2F RU - Borland C++ 3.0 DPMILOAD.EXE - UNINSTALL
	AX = FB42h
	BX = 0015h
	CX = 0001h
Return: ???
Note:	unlike most of the DPMILOAD functions, this call is available only in
	  real or V86 mode
SeeAlso: AX=FB42h/BX=000Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0016" name="2FFB42BX0016"><b>2FFB42BX0016</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???
	AX = FB42h
	BX = 0016h
	CX = selector of DPMILOAD data (see #03130)
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
		CX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0017" name="2FFB42BX0017"><b>2FFB42BX0017</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0017h
	CX = ???
	DX = ???
	???
Return: DX = status (0000h,0001h) (see #03129)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0018" name="2FFB42BX0018"><b>2FFB42BX0018</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET ???
	AX = FB42h
	BX = 0018h
	CX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0019" name="2FFB42BX0019"><b>2FFB42BX0019</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0019h
	CX = selector for ???
	???
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
		CX = selector for ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001A" name="2FFB42BX001A"><b>2FFB42BX001A</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 001Ah
	CX = selector for ???
	???
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
	    0004h failed
	CX:BX -&gt; ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001B" name="2FFB42BX001B"><b>2FFB42BX001B</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 001Bh
	CX = selector of DPMILOAD data (see #03130)
	DX = offset of ???
Return: DX = status (0000h,0002h) (see also #03129)
	    0000h successful
		BX = selector for ???
		CX = selector for ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001C" name="2FFB42BX001C"><b>2FFB42BX001C</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 001Ch
	ES = selector for DPMILOAD data (see #03130)
	CX = 1-based index of ???
	DX = 1-based index of ???
Return: DX = status (0000h,0002h,FFF9h) (see #03129)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001D" name="2FFB42BX001D"><b>2FFB42BX001D</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???
	AX = FB42h
	BX = 001Dh
Return: CX:DX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001E" name="2FFB42BX001E"><b>2FFB42BX001E</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 001Eh
	CX = ???
	???
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
	    FFF7h ??? error
	CX:BX -&gt; ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX001F" name="2FFB42BX001F"><b>2FFB42BX001F</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ADDRESS OF ???
	AX = FB42h
	BX = 001Fh
	DS:DX -&gt; 8-character name of ???
	???
Return: CX = selector of DPMILOAD data (see #03130) for ???
		0000h on error
SeeAlso: AX=FB42h/BX=000Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0020" name="2FFB42BX0020"><b>2FFB42BX0020</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION???
	AX = FB42h
	BX = 0020h
Return: DX = ??? (always 0000h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0021" name="2FFB42BX0021"><b>2FFB42BX0021</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROCESSOR EXCEPTION HANDLER VECT<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROCESSOR EXCEPTION HANDLER VECT
	AX = FB42h
	BX = 0021h
	CL = exception number (00h-1Fh)
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
		AX:BX = selector:offset of handler
	    FFF2h unable to get exception handler vector
SeeAlso: AX=FB42h/BX=0022h,AX=FB42h/BX=0024h,INT 31/AX=0202h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0022" name="2FFB42BX0022"><b>2FFB42BX0022</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROCESSOR EXCEPTION HANDLER VECT<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROCESSOR EXCEPTION HANDLER VECT
	AX = FB42h
	BX = 0022h
	CL = exception number (00h-1Fh)
	SI:DX = selector:offset of new handler
Return: DX = status (0000h,0004h,FFF2h) (see #03129)
SeeAlso: AX=FB42h/BX=0021h,AX=FB42h/BX=0025h,INT 31/AX=0203h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0023" name="2FFB42BX0023"><b>2FFB42BX0023</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SELECTOR TO SEGMENT NUMBER<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - CONVERT SELECTOR TO SEGMENT NUMBER
	AX = FB42h
	BX = 0023h
	CX = selector
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
		CX = real-mode segment number
	    FFF2h descriptor has invalid base address for real-mode segment
SeeAlso: AX=FB42h/BX=0010h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0024" name="2FFB42BX0024"><b>2FFB42BX0024</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROTECTED-MODE INTERRUPT VECTOR<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET PROTECTED-MODE INTERRUPT VECTOR
	AX = FB42h
	BX = 0024h
	CL = interrupt number
Return: DX = status (0000h) (see also AX=FB42h/BX=0004h)
	AX:BX = selector:offset of handler
SeeAlso: AX=FB42h/BX=0025h,INT 31/AX=0204h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0025" name="2FFB42BX0025"><b>2FFB42BX0025</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROTECTED-MODE INTERRUPT VECTOR<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - SET PROTECTED-MODE INTERRUPT VECTOR
	AX = FB42h
	BX = 0025h
	CL = interrupt number
	SI:DX = selector:offset of new handler
Return: DX = status (0000h,0004h,FFF2h) (see #03129)
SeeAlso: AX=FB42h/BX=0024h,INT 31/AX=0205h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0026" name="2FFB42BX0026"><b>2FFB42BX0026</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - ???
	AX = FB42h
	BX = 0026h
	CX = selector of DPMILOAD data (see #03130)
	DX = 1-based index of ???
	???
Return: DX = status (0000h,0002h,FFF9h) (see #03129)
	    0000h successful
		BX = offset of ??? within data structure

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0027" name="2FFB42BX0027"><b>2FFB42BX0027</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - GET ???
	AX = FB42h
	BX = 0027h
	CX = selector of DPMILOAD data (see #03130)
	DX = offset of ???
Return: DX = status (see also AX=FB42h/BX=0004h)
	    0000h successful
		BX = ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0080" name="2FFB42BX0080"><b>2FFB42BX0080</b></a> - INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE<br />
<pre>
INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE
	AX = FB42h
	BX = 0080h
	???
Return: AX = ???
	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX0081" name="2FFB42BX0081"><b>2FFB42BX0081</b></a> - INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE<br />
<pre>
INT 2F U - ??? - CALLED BY Borland C++ 3.0 DPMILOAD.EXE
	AX = FB42h
	BX = 0081h
	???
Return: AX = ???
	???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX1001" name="2FFB42BX1001"><b>2FFB42BX1001</b></a> - INT 2F U - Borland RTM.EXE 1.0 - INSTALLATION CHECK???<br />
<pre>
INT 2F U - Borland RTM.EXE 1.0 - INSTALLATION CHECK???
	AX = FB42h
	BX = 1001h
Return: BX = 0000h
SeeAlso: AX=FB42h/BX=0001h,AX=FB42h/BX=1002h,AX=FB42h/BX=1003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX1002" name="2FFB42BX1002"><b>2FFB42BX1002</b></a> - INT 2F U - Borland RTM.EXE 1.0 - EXECUTE COMPILED PROGRAM<br />
<pre>
INT 2F U - Borland RTM.EXE 1.0 - EXECUTE COMPILED PROGRAM
	AX = FB42h
	BX = 1002h
	DX = 0014h ???
	???
Return: AX = nonzero if successful
	    AH = child program exit method??? (usually 4Ch)
	    AL = child program exit code (Errorlevel)
	AX = 0000h on load error
	    DX = error code (0000h-0027h) (see #03134)
SeeAlso: AX=FB42h/BX=1001h

(Table 03134)
Values for RTM.EXE error code:
 01h	out of memory
 02h	out of selectors
 03h	out of internal tables
 10h	internal error
 18h	internal error
 1Ah	internal error
 1Bh	internal error
 1Ch	internal error
 20h	invalid dynamic link
 21h	internal error
 22h	unable to open file
 23h	invalid .EXE format
 24h	wrong version
 25h	unable to initialize 
 26h	DLL initialization error
 other	unrecognized error

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB42BX1003" name="2FFB42BX1003"><b>2FFB42BX1003</b></a> - INT 2F U - Borland RTM.EXE 1.0 - ???<br />
<pre>
INT 2F U - Borland RTM.EXE 1.0 - ???
	AX = FB42h
	BX = 1003h
	???
Return: ???
SeeAlso: AX=FB42h/BX=1001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFB43" name="2FFB43"><b>2FFB43</b></a> - INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION<br />
<pre>
INT 2F PU - Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION
	AX = FB43h
	BX = subfunction (at least 0000h-000Eh)
Notes:	this function is only present in protected mode; it does nothing but
	  an immediate IRET
	DPMILOAD.EXE itself calls various subfunctions:
	    subfunction 0004h is called with CX=selector of ???, DI=selector
		  of DPMILOAD data
	    subfunction 0008h is called with CX=selector of DPMILOAD data
SeeAlso: AX=FB42h/BX=0001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFBA1BX0081" name="2FFBA1BX0081"><b>2FFBA1BX0081</b></a> - INT 2F U - TKERNEL (Borland DOS extender) - INSTALLATION CHECK<br />
<pre>
INT 2F U - TKERNEL (Borland DOS extender) - INSTALLATION CHECK
	AX = FBA1h
	BX = 0081h
	ES:DI -&gt; 16-byte buffer
Return: if installed, first four bytes of ES:DI buffer are "IABH"
Program: TKERNEL is a licensed version of AI Architects/Ergo's OS/x86.
Note:	TKERNEL was present only in Borland C++ 2.0; with version 3.0, the DOS
	  extender was moved into DPMILOAD.
SeeAlso: AH=A1h,AX=F100h,AX=FBA1h/BX=0082h,AX=FBA1h/BX=0084h,INT 15/AX=BF02h
SeeAlso: INT 21/AX=4403h"AI Architects"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFBA1BX0082" name="2FFBA1BX0082"><b>2FFBA1BX0082</b></a> - INT 2F U - TKERNEL (Borland DOS extender) - GET ENTRY POINT<br />
<pre>
INT 2F U - TKERNEL (Borland DOS extender) - GET ENTRY POINT
	AX = FBA1h
	BX = 0082h
	ES:DI -&gt; response buffer (see #03135)
Return: ES:DI buffer filled
SeeAlso: AX=FBA1h/BX=0081h,AX=FBA1h/BX=0084h

Format of TKERNEL response buffer:
Offset	Size	Description	(Table 03135)
 00h  4 BYTEs	signature "IABH"
 04h	DWORD	pointer to FAR extender entry point (see #03136)

(Table 03136)
Call TKERNEL entry point with:
	AX = function number
	    0000h initialize???
		STACK:	WORD  ???
		Return: AX = status???
			STACK unchanged
	    0001h get version???
		Return: AX = 0200h for v2.0.34
	    0002h get ???
		Return: AX = ??? (011Eh or 0182h seen)
	    0003h load protected-mode executable
		STACK:	DWORD -&gt; ASCIZ filename of executable
			DWORD	???
			DWORD -&gt; program arguments (counted string plus CR)
			DWORD -&gt; environment for protected-mode executable
				(terminated with two consecutive NULs)
			DWORD -&gt; WORD buffer for ???
		Return: AX = status???
			STACK unchanged
	    0004h get descriptor
		STACK:	WORD	selector for which to get descriptor
			WORD	segment number (when running in real mode)
			DWORD -&gt; buffer for descriptor
		Return: CF clear if successful
			    buffer filled
			CF set on error
			    AX destroyed???
			STACK unchanged
	    0005h ???
		STACK:	WORD	selector for ???
			WORD	subfunction number???
				0000h run previously-loaded program???
				0001h ??? (similar to 0000h)
				0002h
				0003h
				0005h ??? (similar to 0000h and 0001h)
		Return: AX = status???
			STACK unchanged
	    0006h ???
		STACK:	WORD ???
			DWORD -&gt; WORD (call) max iterations of ???
				      (ret) remaining iterations
		Return: AX = ???
			STACK unchanged
	    0007h unused
		Return: AX = 0001h
	    0008h unused
		Return: AX = 0001h
	    0009h copy protected-mode memory into conventional memory
		STACK:	WORD	selector for source segment
			WORD	segment of source if in real mode???
			DWORD	offset of source
			WORD	number of bytes to copy
			DWORD -&gt; low-memory destination
		Return: AX = status
			STACK unchanged
	    000Ah copy conventional memory into protected-mode memory
		STACK:	WORD	selector for destination segment
			WORD	segment of destination if in real mode???
			DWORD	offset of destination
			WORD	number of bytes to copy
			DWORD -&gt; low-memory source
		Return: AX = status
			STACK unchanged
	    000Bh get ??? pointers
		STACK:	WORD desired pointer
				0000h get ???
				0002h get protected-mode CR3
				0003h get 4K page table buffer pointer
				else Return: DX:AX = FFFFh:FFFFh
		Return: DX:AX = requested pointer
			STACK unchanged
	    000Ch set ??? pointers
		STACK:	WORD desired pointer
				0000h set ???
				0002h set protected-mode CR3
				0003h set 4K page table buffer pointer
				else ignore
			DWORD new value for pointer
		Return: STACK unchanged
	    000Dh get ??? pointers
		STACK:	WORD desired pointer
				0000h get ???
				0001h get ???
				0002h get ???
				0003h get ???
				0004h get ???
				0005h get ???
				0006h get ???
				0007h get ???
				else Return: DX:AX = FFFFh:FFFFh
		Return: DX:AX = desired pointer
			STACK unchanged
	    000Eh set ??? pointer
		STACK:	WORD desired pointer
				0000h set ???
				0001h set ???
				0002h set ???
				0003h set ???
				0004h set ???
				0005h set ???
				0006h set ???
				0007h set ???
				else Return: DX:AX = FFFFh:FFFFh
		Return: STACK unchanged
	    000Fh get ???
		Return: AX = ??? (seen 0008h)
	    0010h get ???
		Return: AX = ???
	    0011h determine whether selector is valid
		STACK:	WORD	possible selector
		Return: AX = selector or 0000h if invalid
			STACK unchanged
	    0012h get physical address
		STACK:	WORD	selector for desired segment
			WORD	segment number if in real mode
			DWORD	offset within segment
		Return: DX:AX = 32-bit physical address or 00000000h on error
			BX destroyed
			STACK unchanged
	    0013h ???
		Note:	normally jumps to code for function 0012h
	    0014h copy protected-mode memory to conventional memory, with ???
		STACK:	WORD	selector for source segment
			WORD	segment of source if in real mode???
			DWORD	offset of source
			WORD	number of bytes to copy
			DWORD -&gt; low-memory destination
		Return: AX = status???
			STACK unchanged
	    0015h copy conventional memory to protected-mode memory, with ???
		STACK:	WORD	selector for destination segment
			WORD	segment of destination if in real mode???
			DWORD	offset of destination
			WORD	number of bytes to copy
			DWORD -&gt; low-memory source
		Return: AX = status???
			STACK unchanged
	    0016h set ??? pointer
		STACK:	WORD	unused
			DWORD -&gt; ??? or 0000h:0000h
		Return: AX = 0000h
			STACK unchanged
	    0017h allocate real-mode procedure???
		STACK:	DWORD	ASCIZ name of procedure
			DWORD ???
			DWORD	address of subroutine to invoke
		Return: AX = status
			    0032h procedure by that name exists
			    0033h no more real-mode procedures available
			DX destroyed
			STACK unchanged
	    0018h unused
		Return: AX = 0001h
	    0019h get parameter block
		Return: DX:AX -&gt; parameter block (format unknown at this time,
				  but 92h bytes)
				  (preceded by signature "!!PARAM-BLOCK!!")
	    001Ah get ???
		Return: AX = ??? (0148h seen)
	    001Bh free real-mode procedure???
		STACK:	DWORD -&gt; ASCIZ name of procedure
		Return: ???
			STACK unchanged
	    001Ch check whether packets from protected mode task pending
		Return: AX = 0001h if packets pending, 0000h if not
	    001Dh set ???
		STACK:	DWORD ??? or 0000h:0000h
		Return: AX,BX destroyed
			STACK unchanged
	    001Eh ???
		STACK:	WORD ??? (high byte ignored)
			DWORD -&gt; data structure (below)
		Return: AX,BX,CX,DX destroyed
			data structure updated
			STACK unchanged
		Format of data structure:
		Offset	Size	Description
		 00h  2 BYTEs	unused
		 02h	WORD	???
		 04h	WORD	???
		 06h	WORD	???
		 08h  2 BYTEs	unused
		 0Ah	WORD	???
		 0Ch	WORD	(call) ???
				(ret) offset of this data structure (BUG?)
	    001Fh set ???
		STACK:	WORD ??? (set to 0001h if zero)
		Return: AX destroyed
			STACK unchanged
	    0020h ???
		STACK:	DWORD -&gt; ??? (8 bytes of data)
		Return: AX = ???
			STACK unchanged
	    0021h ???
		STACK:	DWORD -&gt; ??? (8 bytes of data)
			WORD	???
			WORD	???
		Return: AX = ???
			STACK unchanged
	    0022h ???
		STACK:	DWORD -&gt; ??? (8 bytes of data)
			DWORD -&gt; 4-byte buffer for results
		Return: AX = ???
			STACK unchanged
	    0023h ???
		STACK:	DWORD -&gt; ??? (8 bytes of data)
		Return: AX = ???
			STACK unchanged
	    0024h set ???
		STACK:	WORD ???
		Return: AX destroyed
			STACK unchanged
	    0025h get ???
		Return: AX = ??? (value set with func 0024h)
	    0026h BUG: jumps to hyperspace due to fencepost error
	    FFFFh set DOS memory management functions
		BX:SI -&gt; FAR routine for allocating DOS memory
			  (called with AH=48h,BX=number of paragraphs to alloc;
			  returns CF clear, AX=segment of allocated memory, or
				  CF set on error)
		CX:DI -&gt; FAR routine for freeing DOS memory
			  (called with AH=49h,ES=segment of block to free;
			  returns CF set on error, AX=error code)
		Note: each of these pointers normally points at INT 21/RETF
	    other Return: AX = 0001h
Note:	BX may be destroyed by any of the API calls

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FFBA1BX0084" name="2FFBA1BX0084"><b>2FFBA1BX0084</b></a> - INT 2F U - TKERNEL (Borland DOS extender) - UNINSTALL<br />
<pre>
INT 2F U - TKERNEL (Borland DOS extender) - UNINSTALL
	AX = FBA1h
	BX = 0084h
	ES:DI -&gt; response buffer (see #03137)
Return: ES:DI buffer filled
SeeAlso: AX=FBA1h/BX=0081h,AX=FBA1h/BX=0084h

Format of TKERNEL response buffer:
Offset	Size	Description	(Table 03137)
 00h  4 BYTEs	signature "IABH"
 04h	WORD	success indicator
		0001h failed (INT 2F hooked by another program)
		unchanged if successful
 06h	WORD	segment of ???
 08h	WORD	segment of ??? memory block to free if nonzero
 0Ah	WORD	segment of ??? memory block to free if nonzero

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310000" name="310000"><b>310000</b></a> - INT 31 P - DPMI 0.9+ - ALLOCATE LDT DESCRIPTORS<br />
<pre>
INT 31 P - DPMI 0.9+ - ALLOCATE LDT DESCRIPTORS
	AX = 0000h
	CX = number of descriptors to allocate
Return: CF clear if successful
	    AX = base selector
	CF set on error
	    AX = error code (DPMI 1.0+) (see #03143)
Notes:	DPMI is the DOS Protected-Mode Interface
	the base and limit of the returned descriptors will be 0, and the type
	  will be "data"
	add the value returned by INT 31/AX=0003h to move to subsequent
	  descriptors if multiple descriptors were allocated
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0001h,AX=000Dh,INT 21/AX=3501h

(Table 03143)
Values for DPMI 1.0 error code:
 0000h-7FFFh DOS error passed through by DPMI
 8001h	unsupported function
 8002h	object in wrong state for function
 8003h	system integrity would be endangered
 8004h	deadlock detected
 8005h	pending serialization request cancelled
 8010h	out of DPMI internal resources
 8011h	descriptor unavailable
 8012h	linear memory unavailable
 8013h	physical memory unavailable
 8014h	backing store unavailable
 8015h	callback unavailable
 8016h	handle unavailable
 8017h	maximum lock count exceeded
 8018h	shared memory already serialized exclusively by another
 8019h	shared memory already serialized shared by another client
 8021h	invalid value for numeric or flag parameter
 8022h	invalid segment selector
 8023h	invalid handle
 8024h	invalid callback
 8025h	invalid linear address
 8026h	request not supported by hardware

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310001" name="310001"><b>310001</b></a> - INT 31 P - DPMI 0.9+ - FREE LDT DESCRIPTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - FREE LDT DESCRIPTOR
	AX = 0001h
	BX = selector to free
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8022h) (see #03143)
Notes:	only one descriptor is freed per call
	the program's initial CS, DS, and SS descriptors may be freed
	(DPMI 1.0+) any segment registers containing the freed selector are
	  set to 0000h
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0000h,AX=000Ah,AX=000Dh,INT 21/AX=3502h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310002" name="310002"><b>310002</b></a> - INT 31 P - DPMI 0.9+ - SEGMENT TO DESCRIPTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - SEGMENT TO DESCRIPTOR
	AX = 0002h
	BX = real mode segment
Return: CF clear if successful
	    AX = selector corresponding to real mode segment (64K limit)
	CF set on error
	    AX = error code (DPMI 1.0+) (8011h) (see #03143)
Notes:	multiple calls for the same real mode segment return the same selector
	the returned descriptor can never be modified or freed
	not supported by MS Windows 3.0 in Standard mode

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310003" name="310003"><b>310003</b></a> - INT 31 P - DPMI 0.9+ - GET NEXT SELECTOR INCREMENT VALUE<br />
<pre>
INT 31 P - DPMI 0.9+ - GET NEXT SELECTOR INCREMENT VALUE
	AX = 0003h
Return: CF clear
	    AX = value to add to get next sequential selector
Notes:	the increment will be a power of two
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310004" name="310004"><b>310004</b></a> - INT 31 P - DPMI 0.9+ - LOCK SELECTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - LOCK SELECTOR
	AX = 0004h
	BX = selector to lock (prevent paging)
Return: ???
Note:	although marked as reserved in versions 0.9 and 1.0 of the DPMI
	  specification, this function is called by MS Windows TASKMAN,
	  PROGMAN, and KERNEL
SeeAlso: AX=0005h,AX=0600h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310005" name="310005"><b>310005</b></a> - INT 31 P - DPMI 0.9+ - UNLOCK SELECTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - UNLOCK SELECTOR
	AX = 0005h
	BX = selector to unlock (permit paging)
Return: ???
Note:	although marked as reserved in versions 0.9 and 1.0 of the DPMI
	  specification, this function is called by MS Windows TASKMAN,
	  PROGMAN, and KERNEL
SeeAlso: AX=0004h,AX=0601h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310006" name="310006"><b>310006</b></a> - INT 31 P - DPMI 0.9+ - GET SEGMENT BASE ADDRESS<br />
<pre>
INT 31 P - DPMI 0.9+ - GET SEGMENT BASE ADDRESS
	AX = 0006h
	BX = selector
Return: CF clear if successful
	    CX:DX = linear base address of segment
	CF set on error
	    AX = error code (DPMI 1.0+) (8022h) (see #03143)
Note:	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0007h,INT 21/AX=3504h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310007" name="310007"><b>310007</b></a> - INT 31 P - DPMI 0.9+ - SET SEGMENT BASE ADDRESS<br />
<pre>
INT 31 P - DPMI 0.9+ - SET SEGMENT BASE ADDRESS
	AX = 0007h
	BX = selector
	CX:DX = linear base address
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8022h,8025h) (see #03143)
Notes:	only modify descriptors allocated with INT 31/AX=0000h
	only the low 24 bits of the address will be used by 16-bit DPMI
	  implementations even on a 386 or higher
	DPMI 1.0+ automatically reloads any segment registers containing the
	  selector being modified
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0006h,AX=0008h,AX=0009h,AX=000Ch,INT 21/AX=3503h
SeeAlso: INT 21/AH=E9h"OS/286",INT 2C/AX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310008" name="310008"><b>310008</b></a> - INT 31 P - DPMI 0.9+ - SET SEGMENT LIMIT<br />
<pre>
INT 31 P - DPMI 0.9+ - SET SEGMENT LIMIT
	AX = 0008h
	BX = selector
	CX:DX = segment limit
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8021h,8022h,8025h) (see #03143)
Notes:	CX must be zero for 16-bit DPMI implementations
	limits greater than 1MB must be page aligned (low 12 bits set)
	only modify descriptors allocated with INT 31/AX=0000h
	DPMI 1.0+ automatically reloads any segment registers containing the
	  selector being modified
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0007h,AX=0009h,AX=000Ch,INT 21/AX=3505h,INT 21/AH=E9h"OS/286"
SeeAlso: INT 2C/AX=0003h,#00501 at INT 15/AH=89h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310009" name="310009"><b>310009</b></a> - INT 31 P - DPMI 0.9+ - SET DESCRIPTOR ACCESS RIGHTS<br />
<pre>
INT 31 P - DPMI 0.9+ - SET DESCRIPTOR ACCESS RIGHTS
	AX = 0009h
	BX = selector
	CL = access rights/type byte (see #00502 at INT 15/AH=89h)
	CH = 80386 extended rights/type byte (see #00505 at INT 15/AH=89h)
	    (32-bit DPMI implementations only)
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8021h,8022h,8025h) (see #03143)
Notes:	if the Present bit is clear, CL bits 0-3 may have any value
	DPMI 1.0+ automatically reloads any segment registers containing the
	  selector being modified
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0007h,AX=0008h,AX=000Ch,INT 21/AX=2514h,INT 2C/AX=0004h
SeeAlso: INT 2C/AX=0005h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31000A" name="31000A"><b>31000A</b></a> - INT 31 P - DPMI 0.9+ - CREATE ALIAS DESCRIPTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - CREATE ALIAS DESCRIPTOR
	AX = 000Ah
	BX = selector
Return: CF clear if successful
	    AX = new data selector
	CF set on error
	    AX = error code (DPMI 1.0+) (8011h,8022h) (see #03143)
Notes:	fails if selector in BX is not a code segment or is invalid
	use INT 31/AX=0001h to free new selector
	future changes to the original selector will not be reflected in the
	  returned alias selector
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31000B" name="31000B"><b>31000B</b></a> - INT 31 P - DPMI 0.9+ - GET DESCRIPTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - GET DESCRIPTOR
	AX = 000Bh
	BX = LDT selector
	ES:(E)DI -&gt; 8-byte buffer for copy of descriptor
Return: CF clear if successful
	    buffer filled
	CF set on error
	    AX = error code (DPMI 1.0+) (8022h) (see #03143)
Notes:	16-bit programs use ES:DI as pointer, 32-bit must use ES:EDI
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=000Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31000C" name="31000C"><b>31000C</b></a> - INT 31 P - DPMI 0.9+ - SET DESCRIPTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - SET DESCRIPTOR
	AX = 000Ch
	BX = LDT selector
	ES:(E)DI -&gt; 8-byte buffer containing descriptor
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8021h,8022h,8025h) (see #03143)
Notes:	16-bit programs use ES:DI as pointer, 32-bit must use ES:EDI
	only modify descriptors allocated with INT 31/AX=0000h
	DPMI 1.0+ automatically reloads any segment registers containing the
	  selector being modified
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=000Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31000D" name="31000D"><b>31000D</b></a> - INT 31 P - DPMI 0.9+ - ALLOCATE SPECIFIC LDT DESCRIPTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - ALLOCATE SPECIFIC LDT DESCRIPTOR
	AX = 000Dh
	BX = LDT selector
Return: CF clear if successful
	    descriptor allocated
	CF set on error
	    AX = error code (DPMI 1.0+) (8011h,8022h) (see #03143)
Notes:	free descriptor with INT 31/AX=0001h
	the first 16 descriptors (04h-7Ch) are reserved for this function, but
	  some may already be in use by other applications under DPMI 0.9;
	  DPMI 1.0 guarantees 16 descriptors per client
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0000h,AX=0001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31000E" name="31000E"><b>31000E</b></a> - INT 31 P - DPMI 1.0+ - GET MULTIPLE DESCRIPTORS<br />
<pre>
INT 31 P - DPMI 1.0+ - GET MULTIPLE DESCRIPTORS
	AX = 000Eh
	CX = number of descriptors to copy
	ES:(E)DI -&gt; descriptor buffer (see #03144)
Return: CF clear if successful
	    descriptors copied
	CF set on error
	    AX = error code (8022h) (see #03143)
	    CX = number of descriptors successfully copied
Notes:	16-bit programs use ES:DI as pointer, 32-bit must use ES:EDI
	if the function fails, the first CX descriptors are valid; the
	  remainder are not modified
SeeAlso: AX=000Bh,AX=000Fh

Format of DPMI descriptor buffer entry (one per descriptor to get):
Offset	Size	Description	(Table 03144)
 00h	WORD	selector (set by client)
 02h	QWORD	descriptor (set by host)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31000F" name="31000F"><b>31000F</b></a> - INT 31 P - DPMI 1.0+ - SET MULTIPLE DESCRIPTORS<br />
<pre>
INT 31 P - DPMI 1.0+ - SET MULTIPLE DESCRIPTORS
	AX = 000Fh
	CX = number of descriptors to copy
	ES:(E)DI -&gt; descriptor buffer (see #03145)
Return: CF clear if successful
	    descriptors copied
	CF set on error
	    AX = error code (8021h,8022h,8025h) (see #03143)
	    CX = number of descriptors successfully copied
Notes:	16-bit programs use ES:DI as pointer, 32-bit must use ES:EDI
	if the function fails, the first CX descriptors are valid; the
	  remainder are not modified
	DPMI 1.0+ automatically reloads any segment registers containing a
	  selector being modified
SeeAlso: AX=000Ch,AX=000Eh

Format of DPMI descriptor buffer entry (one per descriptor to set):
Offset	Size	Description	(Table 03145)
 00h	WORD	selector
 02h	QWORD	descriptor

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310100" name="310100"><b>310100</b></a> - INT 31 P - DPMI 0.9+ - ALLOCATE DOS MEMORY BLOCK<br />
<pre>
INT 31 P - DPMI 0.9+ - ALLOCATE DOS MEMORY BLOCK
	AX = 0100h
	BX = number of paragraphs to allocate
Return: CF clear if successful
	    AX = real mode segment of allocated block
	    DX = first selector for allocated block
	CF set on error
	    AX = DOS error code (07h,08h) (see #01680 at INT 21/AH=59h/BX=0000h)
		(DPMI 1.0+) DPMI error code (8011h) (see #03143)
	    BX = size (in paragraphs) of largest available block
Notes:	multiple contiguous selectors are allocated for blocks of more than 64K
	  if the caller is a 16-bit program
	never modify or deallocate returned descriptors
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0101h,AX=0501h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310101" name="310101"><b>310101</b></a> - INT 31 P - DPMI 0.9+ - FREE DOS MEMORY BLOCK<br />
<pre>
INT 31 P - DPMI 0.9+ - FREE DOS MEMORY BLOCK
	AX = 0101h
	DX = selector of block
Return: CF set if successful
	CF set on error
	    AX = DOS error code (07h,09h) (see #01680 at INT 21/AH=59h/BX=0000h)
Notes:	all descriptors allocated for the block are automatically freed
	DPMI 1.0+ automatically zeros any segment registers containing a
	  selector freed by this function
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0100h,AX=0102h,AX=0502h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310102" name="310102"><b>310102</b></a> - INT 31 P - DPMI 0.9+ - RESIZE DOS MEMORY BLOCK<br />
<pre>
INT 31 P - DPMI 0.9+ - RESIZE DOS MEMORY BLOCK
	AX = 0102h
	BX = new block size in paragraphs
	DX = selector of block
Return: CF clear if successful
	CF set on error
	    AX = DOS error code (07h,08h,09h)
		  (see #01680 at INT 21/AH=59h/BX=0000h)
		(DPMI 1.0+) DPMI error code (8011h,8022h) (see #03143)
	    BX = maximum block size (in paragraphs) possible
Notes:	increasing the size of a block past a 64K boundary will fail if the
	  next descriptor in the LDT is already in use
	shrinking a block past a 64K boundary will cause some selectors to be
	  freed; DPMI 1.0+ automatically zeros any segment registers containing
	  a selector freed by this function
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0100h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310200" name="310200"><b>310200</b></a> - INT 31 P - DPMI 0.9+ - GET REAL MODE INTERRUPT VECTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - GET REAL MODE INTERRUPT VECTOR
	AX = 0200h
	BL = interrupt number
Return: CF clear
	CX:DX = segment:offset of real mode interrupt handler
Note:	the DPMI implementation is required to support all 256 vectors
SeeAlso: AX=0201h,AX=0204h,INT 21/AX=2503h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310201" name="310201"><b>310201</b></a> - INT 31 P - DPMI 0.9+ - SET REAL MODE INTERRUPT VECTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - SET REAL MODE INTERRUPT VECTOR
	AX = 0201h
	BL = interrupt number
	CX:DX = segment:offset of real mode handler
Return: CF clear
Note:	all memory that may be touched by a hardware interrupt handler must be
	  locked down with INT 31/AX=0600h
SeeAlso: AX=0200h,AX=0205h,AX=0600h,INT 21/AX=2505h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310202" name="310202"><b>310202</b></a> - INT 31 P - DPMI 0.9+ - GET PROCESSOR EXCEPTION HANDLER VECTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - GET PROCESSOR EXCEPTION HANDLER VECTOR
	AX = 0202h
	BL = exception number (00h-1Fh)
Return: CF clear if successful
	    CX:(E)DX = selector:offset of handler
	CF set on error
	    AX = error code (DPMI 1.0+) (8021h) (see #03143)
Notes:	16-bit programs receive the pointer in CX:DX, 32-bit programs in CX:EDX
	DPMI 1.0+ supports this function only for backward compatibility; use
	   AX=0210h or AX=0211h instead
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0203h,AX=0210h,AX=0211h,INT 2F/AX=FB42h/BX=0021h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310203" name="310203"><b>310203</b></a> - INT 31 P - DPMI 0.9+ - SET PROCESSOR EXCEPTION HANDLER VECTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - SET PROCESSOR EXCEPTION HANDLER VECTOR
	AX = 0203h
	BL = exception number (00h-1Fh)
	CX:(E)DX = selector:offset of handler
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8021h,8022h) (see #03143)
Notes:	32-bit programs must supply an offset in EDX and use a 32-bit interrupt
	  stack frame on chaining to the next exception handler
	the handler should return using a FAR return
	all fault stack frames contain an error code, but it is only valid for
	  exceptions 08h and 0Ah-0Eh
	handlers will only be called if the exception occurs in protected mode,
	  and the DPMI host does not transparently handle the exception
	the handler may change certain values on the stack frame
	  (see #03146,#03147)
	DPMI 1.0+ supports this function only for backward compatibility; use
	   AX=0212h or AX=0213h instead
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0202h,AX=0212h,AX=0213h,INT 2F/AX=FB42h/BX=0022h

Format of stack frame for 16-bit programs: (offset from SS:SP)
Offset	Size	Description	(Table 03146)
 00h	DWORD	return CS:IP (do not change)
 04h	WORD	error code
 06h	DWORD	CS:IP of exception
 0Ah	WORD	flags
 0Ch	DWORD	SS:SP

Format of stack frame for 32-bit programs: (offset from SS:ESP)
Offset	Size	Description	(Table 03147)
 00h	DWORD	return EIP (do not change)
 04h	WORD	return CS selector (do not change)
 06h	WORD	reserved (do not change)
 08h	DWORD	error code
 0Ch	DWORD	EIP of exception
 10h	WORD	CS selector of exception
 12h	WORD	reserved (do not change)
 14h	DWORD	EFLAGS
 18h	DWORD	ESP
 1Ch	WORD	SS
 1Eh	WORD	reserved (do not change)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310204" name="310204"><b>310204</b></a> - INT 31 P - DPMI 0.9+ - GET PROTECTED MODE INTERRUPT VECTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - GET PROTECTED MODE INTERRUPT VECTOR
	AX = 0204h
	BL = interrupt number
Return: CF clear
	CX:(E)DX = selector:offset of handler
Notes:	16-bit programs use CX:DX, 32-bit programs use CX:EDX
	DPMI implementations are required to support all 256 vectors
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0200h,AX=0205h,INT 21/AX=2502h,INT 2C/AX=0006h
SeeAlso: INT 2F/AX=FB42h/BX=0024h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310205" name="310205"><b>310205</b></a> - INT 31 P - DPMI 0.9+ - SET PROTECTED MODE INTERRUPT VECTOR<br />
<pre>
INT 31 P - DPMI 0.9+ - SET PROTECTED MODE INTERRUPT VECTOR
	AX = 0205h
	BL = interrupt number
	CX:(E)DX = selector:offset of handler
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8022h) (see #03143)
Notes:	16-bit programs use CX:DX, 32-bit programs use CX:EDX
	32-bit programs must use a 32-bit interrupt stack frame when chaining
	  to the next handler
	DPMI implementations are required to support all 256 vectors
	hardware interrupts are reflected to the virtual machine's primary
	  client, software interrupts to the current client
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0201h,AX=0204h,INT 21/AX=2504h,INT 2C/AX=0007h
SeeAlso: INT 2F/AX=FB42h/BX=0025h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310210" name="310210"><b>310210</b></a> - INT 31 P - DPMI 1.0+ - GET PROTECTED MODE EXTENDED PROCESSOR EXCEPTION HANDLER<br />
<pre>
INT 31 P - DPMI 1.0+ - GET PROTECTED MODE EXTENDED PROCESSOR EXCEPTION HANDLER
	AX = 0210h
	BL = exception number (00h-1Fh)
Return: CF clear if successful
	    CX:(E)DX = selector:offset of exception handler
	CF set on error
	    AX = error code (8021h) (see #03143)
Note:	DPMI host reflects exception to current client's handler
SeeAlso: AX=0202h,AX=0211h,AX=0212h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310211" name="310211"><b>310211</b></a> - INT 31 P - DPMI 1.0+ - GET REAL MODE EXTENDED PROCESSOR EXCEPTION HANDLER<br />
<pre>
INT 31 P - DPMI 1.0+ - GET REAL MODE EXTENDED PROCESSOR EXCEPTION HANDLER
	AX = 0211h
	BL = exception number (00h-1Fh)
Return: CF clear if successful
	    CX:(E)DX = selector:offset of exception handler
	CF set on error
	    AX = error code (8021h) (see #03143)
Notes:	returns address of protected-mode handler for real-mode exception
	DPMI host performs a switch to protected mode, reflects the exception
	  to the virtual machine's primary client, and returns to real mode
	  on the handler's completion
SeeAlso: AX=0202h,AX=0210h,AX=0213h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310212" name="310212"><b>310212</b></a> - INT 31 P - DPMI 1.0+ - SET PROTECTED MODE EXTENDED PROCESSOR EXCEPTION HANDLER<br />
<pre>
INT 31 P - DPMI 1.0+ - SET PROTECTED MODE EXTENDED PROCESSOR EXCEPTION HANDLER
	AX = 0212h
	BL = exception or fault number (00h-1Fh)
	CX:(E)DX = exception handler selector:offset
Return: CF clear if successful
	CF set on error
	    AX = error code (8021h,8022h) (see #03143)
Note:	DPMI host sends exception to current client's handler
SeeAlso: AX=0203h,AX=0210h,AX=0213h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310213" name="310213"><b>310213</b></a> - INT 31 P - DPMI 1.0+ - SET REAL MODE EXTENDED PROCESSOR EXCEPTION HANDLER<br />
<pre>
INT 31 P - DPMI 1.0+ - SET REAL MODE EXTENDED PROCESSOR EXCEPTION HANDLER
	AX = 0213h
	BL = exception or fault number (00h-1Fh)
	CX:(E)DX = exception handler selector:offset
Return: CF clear if successful
	CF set on error
	    AX = error code (8021h,8022h) (see #03143)
Notes:	specifies address of protected-mode handler for real-mode exception
	DPMI host performs a switch to protected mode, reflects the exception
	  to the virtual machine's primary client, and returns to real mode
	  on the handler's completion
SeeAlso: AX=0203h,AX=0211h,AX=0212h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310300" name="310300"><b>310300</b></a> - INT 31 P - DPMI 0.9+ - SIMULATE REAL MODE INTERRUPT<br />
<pre>
INT 31 P - DPMI 0.9+ - SIMULATE REAL MODE INTERRUPT
	AX = 0300h
	BL = interrupt number
	BH = flags
	    bit 0: reset the interrupt controller and A20 line (DPMI 0.9)
		    reserved, must be 0 (DPMI 1.0+)
	    others: reserved, must be 0
	CX = number of words to copy from protected mode to real mode stack
	ES:(E)DI = selector:offset of real mode call structure (see #03148)
Return: CF clear if successful
	    real mode call structure modified (all fields except SS:SP, CS:IP
	      filled with return values from real mode interrupt)
	CF set on error
	    AX = error code (DPMI 1.0+) (8012h,8013h,8014h,8021h)(see #03143)
	protected mode stack unchanged
Notes:	16-bit programs use ES:DI as pointer, 32-bit programs use ES:EDI
	CS:IP in the real mode call structure is ignored for this call,
	  instead, the indicated interrupt vector is used for the address
	the flags in the call structure are pushed on the real mode stack to
	  form an interrupt stack frame, and the trace and interrupt flags are
	  clear on entry to the handler
	DPMI will provide a small (30 words) real mode stack if SS:SP is zero
	the real mode handler must return with the stack in the same state as
	  it was on being called
SeeAlso: AX=0302h,AX=FF01h,INT 21/AX=2511h,INT 21/AH=E3h"OS/286"
SeeAlso: INT 2C/AX=0026h,INT 2F/AX=FB42h/BX=000Dh

Format of DPMI real mode call structure:
Offset	Size	Description	(Table 03148)
 00h	DWORD	EDI
 04h	DWORD	ESI
 08h	DWORD	EBP
 0Ch	DWORD	reserved (00h)
 10h	DWORD	EBX
 14h	DWORD	EDX
 18h	DWORD	ECX
 1Ch	DWORD	EAX
 20h	WORD	flags
 22h	WORD	ES
 24h	WORD	DS
 26h	WORD	FS
 28h	WORD	GS
 2Ah	WORD	IP
 2Ch	WORD	CS
 2Eh	WORD	SP
 30h	WORD	SS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310301" name="310301"><b>310301</b></a> - INT 31 P - DPMI 0.9+ - CALL REAL MODE PROCEDURE WITH FAR RETURN FRAME<br />
<pre>
INT 31 P - DPMI 0.9+ - CALL REAL MODE PROCEDURE WITH FAR RETURN FRAME
	AX = 0301h
	BH = flags
	    bit 0: reset the interrupt controller and A20 line (DPMI 0.9)
		    reserved, must be 0 (DPMI 1.0+)
	    others: reserved must be 0
	CX = number of words to copy from protected mode to real mode stack
	ES:(E)DI = selector:offset of real mode call structure
		  (see #03148 at INT 31/AX=0300h)
Return: CF clear if successful
	    real mode call structure modified (all fields except SS:SP, CS:IP
	      filled with return values from real mode interrupt)
	CF set on error
	    AX = error code (DPMI 1.0+) (8012h,8013h,8014h,8021h)(see #03143)
	protected mode stack unchanged
Notes:	16-bit programs use ES:DI as pointer, 32-bit programs use ES:EDI
	the real mode procedure must exit with a FAR return
	DPMI will provide a small (30 words) real mode stack if SS:SP is zero
	the real mode handler must return with the stack in the same state as
	  it was on being called
SeeAlso: AX=0300h,AX=0302h,AX=FF02h,INT 21/AX=250Eh,INT 21/AH=E1h"OS/286"
SeeAlso: INT 2C/AX=0025h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310302" name="310302"><b>310302</b></a> - INT 31 P - DPMI 0.9+ - CALL REAL MODE PROCEDURE WITH IRET FRAME<br />
<pre>
INT 31 P - DPMI 0.9+ - CALL REAL MODE PROCEDURE WITH IRET FRAME
	AX = 0302h
	BH = flags
	    bit 0: reset the interrupt controller and A20 line (DPMI 0.9)
		    reserved, must be 0 (DPMI 1.0+)
	    others: reserved, must be 0
	CX = number of words to copy from protected mode to real mode stack
	ES:(E)DI = selector:offset of real mode call structure
		  (see #03148 at INT 31/AX=0300h)
Return: CF clear if successful
	    real mode call structure modified (all fields except SS:SP, CS:IP
	      filled with return values from real mode interrupt)
	CF set on error
	    AX = error code (DPMI 1.0+) (8012h,8013h,8014h,8021h)(see #03143)
	protected mode stack unchanged
Notes:	16-bit programs use ES:DI as pointer, 32-bit programs use ES:EDI
	the flags in the call structure are pushed on the real mode stack to
	  form an interrupt stack frame, and the trace and interrupt flags are
	  clear on entry to the handler
	the real mode procedure must exit with an IRET
	DPMI will provide a small (30 words) real mode stack if SS:SP is zero
	the real mode handler must return with the stack in the same state as
	  it was on being called
SeeAlso: AX=0300h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310303" name="310303"><b>310303</b></a> - INT 31 P - DPMI 0.9+ - ALLOCATE REAL MODE CALLBACK ADDRESS<br />
<pre>
INT 31 P - DPMI 0.9+ - ALLOCATE REAL MODE CALLBACK ADDRESS
	AX = 0303h
	DS:(E)SI = selector:offset of procedure to call
	ES:(E)DI = selector:offset of real mode call structure (see #03148)
Return: CF clear if successful
	    CX:DX = segment:offset of real mode call address (see #03149)
	CF set on error
	    AX = error code (DPMI 1.0+) (8015h) (see #03143)
Notes:	the real mode call structure is static, causing reentrancy problems;
	  its contents are only valid at the time of a callback
	the called procedure must modify the real mode CS:IP before returning
	values are returned to real mode by modifying the real mode call struc
	DPMI hosts must provide at least 16 callbacks per client
	the limited DPMI host built into Phar Lap's 286|DOS-Extender v2.5 does
	  not support this function
BUG:	Windows NT 4.0 either ignores or clears the high 16 bits of EDI,
	  causing an illegal instruction error if the real mode call
	  structure's offset in ES is greater than 64K
SeeAlso: AX=0304h,AX=0C00h

(Table 03149)
Values DPMI real-mode callback procedure is called with:
	DS:(E)SI = selector:offset of real mode SS:SP
	ES:(E)DI = selector:offset of real mode call structure
	SS:(E)SP = locked protected mode API stack
	interrupts disabled
Return: (with IRET)
	ES:(E)DI = selector:offset of real mode call structure to restore

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310304" name="310304"><b>310304</b></a> - INT 31 P - DPMI 0.9+ - FREE REAL MODE CALLBACK ADDRESS<br />
<pre>
INT 31 P - DPMI 0.9+ - FREE REAL MODE CALLBACK ADDRESS
	AX = 0304h
	CX:DX = real mode callback address
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8024h) (see #03143)
Note:	the limited DPMI host built into Phar Lap's 286|DOS-Extender v2.5 does
	  not support this function
SeeAlso: AX=0303h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310305" name="310305"><b>310305</b></a> - INT 31 P - DPMI 0.9+ - GET STATE SAVE/RESTORE ADDRESSES<br />
<pre>
INT 31 P - DPMI 0.9+ - GET STATE SAVE/RESTORE ADDRESSES
	AX = 0305h
Return: CF clear
	AX = size in bytes of state buffer
	BX:CX = real mode address of procedure to save/restore state
	SI:(E)DI = protected mode procedure to save/restore state (see #03150)
Notes:	the buffer size will be zero if it is not necessary to preserve state
	16-bit programs should call SI:DI, 32-bit programs should call SI:EDI
	this function is only needed if using the raw mode switch service
SeeAlso: AX=0306h

(Table 03150)
Call DPMI state-save procedures with:
	AL = direction
	    00h save state
	    01h restore state
	ES:(E)DI -&gt; state buffer
Return: all registers preserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310306" name="310306"><b>310306</b></a> - INT 31 P - DPMI 0.9+ - GET RAW MODE SWITCH ADDRESSES<br />
<pre>
INT 31 P - DPMI 0.9+ - GET RAW MODE SWITCH ADDRESSES
	AX = 0306h
Return: CF clear
	BX:CX -&gt; procedure to switch from real to protected mode (see #03151)
	SI:(E)DI -&gt; procedure to switch from protected to real mode
Notes:	16-bit programs should jump to SI:DI, 32-bit programs should use SI:EDI
	the caller must save and restore the state of the task with AX=0305h
	not supported by MS Windows 3.0 in Standard mode
SeeAlso: AX=0305h

(Table 03151)
Values to JUMP at mode-switch procedures with:
	AX = new DS
	CX = new ES
	DX = new SS
	(E)BX = new (E)SP
	SI:(E)DI = new CS:(E)IP
Notes:	BP/EBP is preserved across the call, but AX/EAX, BX/EBX, CX/ECX,
	  DX/EDX, SI/ESI, and DI/EDI will be undefined; FS and GS will be 0000h
	interrupts will stay disabled during the entire mode switch if they
	  are disabled on entry to the mode-switch procedure

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310400" name="310400"><b>310400</b></a> - INT 31 P - DPMI 0.9+ - GET DPMI VERSION<br />
<pre>
INT 31 P - DPMI 0.9+ - GET DPMI VERSION
	AX = 0400h
Return: CF clear
	AH = major version of DPMI spec supported
	AL = two-digit minor version of DPMI spec supported
	BX = DPMI host flags (see #03152)
	CL = processor type (02h=80286, 03h=80386, 04h=80486)
	DH = curr value of virtual master interrupt controller base interrupt
	DL = curr value of virtual slave interrupt controller base interrupt
BUG:	Windows NT versions from the March 1993 beta to at least the Final
	  release with fixes to CSD002 report version 0090h (0.144); this has
	  reportedly been corrected in the Windows NT 3.5 beta
SeeAlso: AX=0401h,INT 21/AX=250Ch,INT 2F/AX=1687h,INT 4B/AX=8102h/DX=0000h
SeeAlso: INT 67/AX=DE0Ah

Bitfields for DPMI host flags:
Bit(s)	Description	(Table 03152)
 0	running under an 80386 (32-bit) implementation
 1	processor returns to real mode for reflected interrupts instead of V86
	  mode
 2	virtual memory supported
 3	reserved (undefined)
 4-15	reserved (zero)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310401" name="310401"><b>310401</b></a> - INT 31 P - DPMI 1.0+ - GET DPMI CAPABILITIES<br />
<pre>
INT 31 P - DPMI 1.0+ - GET DPMI CAPABILITIES
	AX = 0401h
	ES:(E)DI -&gt; 128-byte buffer for host description (see #03153)
Return: CF clear if successful
	    AX = capabilities (see #03154)
	    CX = reserved (00h)
	    DX = reserved (00h)
	    buffer filled
	CF set on error (DPMI 0.9 only)
SeeAlso: AX=0400h

Format of DPMI host description:
Offset	Size	Description	(Table 03153)
 00h	BYTE	host major version number
 01h	BYTE	host minor version number
 02h 126 BYTEs	ASCIZ host vendor name

Bitfields for DPMI capabilities:
Bit(s)	Description	(Table 03154)
 0	paged accessed/dirty supported (see AX=0506h,AX=0507h)
 1	exceptions restartability supported
 2	device mapping supported (see AX=0508h)
 3	conventional memory mapping supported (see AX=0509h)
 4	demand zero-fill supported
 5	write-protect client capability supported
 6	write-protect host capability supported
 7-15	reserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310500" name="310500"><b>310500</b></a> - INT 31 P - DPMI 0.9+ - GET FREE MEMORY INFORMATION<br />
<pre>
INT 31 P - DPMI 0.9+ - GET FREE MEMORY INFORMATION
	AX = 0500h
	ES:(E)DI -&gt; buffer for memory information (see #03155)
Return: CF clear
Notes:	16-bit programs use ES:DI, 32-bit programs use ES:EDI
	this function must be considered advisory because other applications
	  may affect the results at any time after the call
	fields not supported by the DPMI implementation are filled with
	  FFFFFFFFh
	DPMI 1.0+ supports this function solely for backward compatibility; use
	  AX=050Bh instead
	the limited DPMI host built into Phar Lap's 286|DOS-Extender v2.5 only
	  returns the first field in the memory information record
SeeAlso: AX=0501h,AX=050Bh,AX=0604h

Format of DPMI memory information:
Offset	Size	Description	(Table 03155)
 00h	DWORD	largest available block in bytes
 04h	DWORD	maximum unlocked page allocation
 08h	DWORD	maximum locked page allocation
 0Ch	DWORD	total linear address space in pages
 10h	DWORD	total unlocked pages
 14h	DWORD	free pages
 18h	DWORD	total physical pages
 1Ch	DWORD	free linear address space in pages
 20h	DWORD	size of paging file/partition in pages
 24h 12 BYTEs	reserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310501" name="310501"><b>310501</b></a> - INT 31 P - DPMI 0.9+ - ALLOCATE MEMORY BLOCK<br />
<pre>
INT 31 P - DPMI 0.9+ - ALLOCATE MEMORY BLOCK
	AX = 0501h
	BX:CX = size in bytes
Return: CF clear if successful
	    BX:CX = linear address of block
	    SI:DI = memory block handle for resizing and freeing block
	CF set on error
	    AX = error code (DPMI 1.0+) (8012h-8014h,8016h,8021h)(see #03143)
Notes:	no selectors are allocated
	the memory block is allocated unlocked (can be locked with AX=0600h)
	allocations are often page granular (see AX=0604h)
	under MS Windows 3.10 Enhanced mode with paging enabled, it is possible
	  for this function to fail even if AX=0500h indicates that enough
	  memory is available
SeeAlso: AX=0000h,AX=0100h,AX=0500h,AX=0502h,AX=0503h,AX=0504h,AX=0D00h
SeeAlso: INT 2F/AX=FB42h/BX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310502" name="310502"><b>310502</b></a> - INT 31 P - DPMI 0.9+ - FREE MEMORY BLOCK<br />
<pre>
INT 31 P - DPMI 0.9+ - FREE MEMORY BLOCK
	AX = 0502h
	SI:DI = handle of memory block
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8023h) (see #03143)
Note:	any selectors allocated for the memory block must also be freed,
	  preferably before freeing the memory block
SeeAlso: AX=0001h,AX=0101h,AX=0501h,AX=0D01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310503" name="310503"><b>310503</b></a> - INT 31 P - DPMI 0.9+ - RESIZE MEMORY BLOCK<br />
<pre>
INT 31 P - DPMI 0.9+ - RESIZE MEMORY BLOCK
	AX = 0503h
	BX:CX = new size in bytes (nonzero)
	SI:DI = handle of memory block
Return: CF clear if successful
	    BX:CX = new linear address
	    SI:DI = new handle of memory block
	CF set on error
	    AX = error code (DPMI 1.0+) (8012h-8014h,8016h,8021h,8023h)
		(see #03143)
Notes:	any selectors pointing at the block must be updated
	the previous memory block handle becomes invalid
	an error is returned if the new size is 0
SeeAlso: AX=0102h,AX=0501h,AX=0505h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310504" name="310504"><b>310504</b></a> - INT 31 P - DPMI 1.0+ - ALLOCATE LINEAR MEMORY BLOCK<br />
<pre>
INT 31 P - DPMI 1.0+ - ALLOCATE LINEAR MEMORY BLOCK
	AX = 0504h
	EBX = page-aligned linear address of memory block (00000000h if any
	      address is acceptable)
	ECX = size in bytes (nonzero)
	EDX = flags
	    bit 0: set to create committed pages instead of uncommitted pages
	    bits 1-31 reserved (0)
Return: CF clear if successful
	    EBX = linear address of memory block
	    ESI = memory block handle
	CF set on error
	    AX = error code (8001h,8012h-8014h,8016h,8021h,8025h)(see #03143)
Note:	only supported by 32-bit DPMI hosts, but may be used by 16-bit clients
SeeAlso: AX=0501h,AX=0505h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310505" name="310505"><b>310505</b></a> - INT 31 P - DPMI 1.0+ - RESIZE LINEAR MEMORY BLOCK<br />
<pre>
INT 31 P - DPMI 1.0+ - RESIZE LINEAR MEMORY BLOCK
	AX = 0505h
	ESI = memory block handle
	ECX = new size in bytes (nonzero)
	EDX = flags
	    bit 0: create committed pages rather than uncommitted pages
	    bit 1: segment descriptor update required
		ES:EBX -&gt; buffer containing array of WORDs with selectors
		EDI = number of selectors in array
	    bits 2-31 reserved (0)
Return: CF clear if successful
	    EBX = new linear base address
	    ESI = new memory block handle
	CF set on error
	    AX = error code (8001h,8012h-8014h,8016h,8021h,8023h)(see #03143)
Notes:	only supported by 32-bit DPMI hosts, but may be used by 16-bit clients
	the old memory block handle becomes invalid
	if EDX bit 1 set and the block's base address is changed, DPMI updates
	  all descriptors for selectors in the update buffer which fall within
	  the memory block
SeeAlso: AX=0503h,AX=0504h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310506" name="310506"><b>310506</b></a> - INT 31 P - DPMI 1.0+ - GET PAGE ATTRIBUTES<br />
<pre>
INT 31 P - DPMI 1.0+ - GET PAGE ATTRIBUTES
	AX = 0506h
	ESI = memory block handle
	EBX = offset in memory block of first page
	ECX = number of pages
	ES:EDX -&gt; array of WORDs to hold page attributes (see #03156)
Return: CF clear if successful
	    buffer filled
	CF set on error
	    AX = error code (8001h,8023h,8025h) (see #03143)
Notes:	only supported by 32-bit DPMI hosts, but may be used by 16-bit clients
	if EBX is not page-aligned, it will be rounded down
SeeAlso: AX=0504h,AX=0507h,INT 21/AX=251Dh,INT 21/AX=EB00h

Bitfields for DPMI page attribute word:
Bit(s)	Description	(Table 03156)
 0-2	page type
	000 uncommitted
	001 committed
	010 mapped (see AX=0508h,AX=0509h)
	other currently unused
 3	page is read/write rather than read-only
 4	accessed/dirty bits supplied in bits 5 and 6
 5	page has been accessed (only valid if bit 4 set)
 6	page has been written (only valid if bit 4 set)
 7-15	reserved (0)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310507" name="310507"><b>310507</b></a> - INT 31 P - DPMI 1.0+ - MODIFY PAGE ATTRIBUTES<br />
<pre>
INT 31 P - DPMI 1.0+ - MODIFY PAGE ATTRIBUTES
	AX = 0507h
	ESI = memory block handle
	EBX = offset in memory block of first page
	ECX = number of pages
	ES:EDX -&gt; array of WORDs with new page attributes (see #03156)
Return: CF clear if successful
	CF set on error
	    AX = error code (8001h,8002h,8013h,8014h,8021h,8023h,8025h)
		(see #03143)
	    ECX = number of pages which have been set
Notes:	only supported by 32-bit DPMI hosts, but may be used by 16-bit clients
	if EBX is not page-aligned, it will be rounded down
SeeAlso: AX=0504h,AX=0506h,INT 21/AX=251Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310508" name="310508"><b>310508</b></a> - INT 31 P - DPMI 1.0+ - MAP DEVICE IN MEMORY BLOCK<br />
<pre>
INT 31 P - DPMI 1.0+ - MAP DEVICE IN MEMORY BLOCK
	AX = 0508h
	ESI = memory block handle
	EBX = page-aligned offset within memory block of page(s) to be mapped
	ECX = number of pages to map
	EDX = page-aligned physical address of device
Return: CF clear if successful
	CF set on error
	    AX = error code (8001h,8003h,8023h,8025h) (see #03143)
Notes:	only supported by 32-bit DPMI hosts, but may be used by 16-bit clients
	support of this function is optional; hosts are also allowed to support
	  the function for some devices but not others
SeeAlso: AX=0504h,AX=0509h,AX=0800h,AX=0801h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310509" name="310509"><b>310509</b></a> - INT 31 P - DPMI 1.0+ - MAP CONVENTIONAL MEMORY IN MEMORY BLOCK<br />
<pre>
INT 31 P - DPMI 1.0+ - MAP CONVENTIONAL MEMORY IN MEMORY BLOCK
	AX = 0509h
	ESI = memory block handle
	EBX = page-aligned offset within memory block of page(s) to map
	ECX = number of pages to map
	EDX = page-aligned linear address of conventional (below 1M) memory
Return: CF clear if successful
	CF set on error
	    AX = error code (8001h,8003h,8023h,8025h) (see #03143)
Notes:	only supported by 32-bit DPMI hosts, but may be used by 16-bit clients
	support of this function is optional
SeeAlso: AX=0504h,AX=0508h,AX=0801h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31050A" name="31050A"><b>31050A</b></a> - INT 31 P - DPMI 1.0+ - GET MEMORY BLOCK SIZE AND BASE<br />
<pre>
INT 31 P - DPMI 1.0+ - GET MEMORY BLOCK SIZE AND BASE
	AX = 050Ah
	SI:DI = memory block handle
Return: CF clear if successful
	    SI:DI = size in bytes
	    BX:CX = base address
	CF set on error
	    AX = error code (8023h) (see #03143)
SeeAlso: AX=0501h,AX=0504h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31050B" name="31050B"><b>31050B</b></a> - INT 31 P - DPMI 1.0+ - GET MEMORY INFORMATION<br />
<pre>
INT 31 P - DPMI 1.0+ - GET MEMORY INFORMATION
	AX = 050Bh
	ES:(E)DI -&gt; 128-byte buffer for memory information (see #03157)
Return: CF clear if successful
	CF set on error (DPMI 0.9 only)
Note:	16-bit programs use ES:DI, 32-bit programs must use ES:EDI
SeeAlso: AX=0500h

Format of DPMI memory information:
Offset	Size	Description	(Table 03157)
 00h	DWORD	total allocated bytes of physical memory controlled by host
 04h	DWORD	total allocated bytes of virtual memory controlled by host
 08h	DWORD	total available bytes of virtual memory controlled by host
 0Ch	DWORD	total allocated bytes of virtual memory for curr virtual mach
 10h	DWORD	total available bytes of virtual memory for curr virtual mach
 14h	DWORD	total allocated bytes of virtual memory for current client
 18h	DWORD	total available bytes of virtual memory for current client
 1Ch	DWORD	total locked bytes for current client
 20h	DWORD	maximum locked bytes for current client
 24h	DWORD	highest linear address available to current client
 28h	DWORD	largest available memory block in bytes
 2Ch	DWORD	minimum allocation unit in bytes
 30h	DWORD	allocation alignment unit size in bytes
 34h 76 BYTEs	reserved (00h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310600" name="310600"><b>310600</b></a> - INT 31 P - DPMI 0.9+ - LOCK LINEAR REGION<br />
<pre>
INT 31 P - DPMI 0.9+ - LOCK LINEAR REGION
	AX = 0600h
	BX:CX = starting linear address
	SI:DI = size of region in bytes
Return: CF clear if successful
	CF set on error
	    none of the memory is locked
	    AX = error code (DPMI 1.0+) (8013h,8017h,8025h) (see #03143)
Notes:	pages at beginning and end will be locked if the region overlaps them
	may be called multiple times for a given page; the DPMI host keeps a
	  lock count for each page
SeeAlso: AX=0004h,AX=0601h,INT 21/AX=251Ah,INT 21/AX=EB06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310601" name="310601"><b>310601</b></a> - INT 31 P - DPMI 0.9+ - UNLOCK LINEAR REGION<br />
<pre>
INT 31 P - DPMI 0.9+ - UNLOCK LINEAR REGION
	AX = 0601h
	BX:CX = starting linear address
	SI:DI = size of region in bytes
Return: CF clear if successful
	CF set on error
	    none of the memory is unlocked
	    AX = error code (DPMI 1.0+) (8002h,8025h) (see #03143)
Notes:	pages at beginning and end will be unlocked if the region overlaps them
	memory whose lock count has not reached zero remains locked
SeeAlso: AX=0005h,AX=0600h,INT 21/AX=251Bh,INT 21/AX=EB07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310602" name="310602"><b>310602</b></a> - INT 31 P - DPMI 0.9+ - MARK REAL MODE REGION AS PAGEABLE<br />
<pre>
INT 31 P - DPMI 0.9+ - MARK REAL MODE REGION AS PAGEABLE
	AX = 0602h
	BX:CX = starting linear address
	SI:DI = size of region in bytes
Return: CF clear if successful
	CF set on error
	    none of the memory is made pageable
	    AX = error code (DPMI 1.0+) (8002h,8025h) (see #03143)
Notes:	must relock all unlocked real mode memory before terminating process
	  for DPMI 0.9; DPMI 1.0+ automatically relocks real mode memory
	pages at beginning and end will be unlocked if the region overlaps them
	pageability of real mode pages is binary, not a count
SeeAlso: AX=0600h,AX=0603h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310603" name="310603"><b>310603</b></a> - INT 31 P - DPMI 0.9+ - RELOCK REAL MODE REGION<br />
<pre>
INT 31 P - DPMI 0.9+ - RELOCK REAL MODE REGION
	AX = 0603h
	BX:CX = starting linear address
	SI:DI = size of region in bytes
Return: CF clear if successful
	CF set on error
	    none of the memory is relocked
	    AX = error code (DPMI 1.0+) (8002h,8013h,8025h) (see #03143)
Notes:	pages at beginning and end will be relocked if the region overlaps them
	pageability of real mode pages is binary, not a count
SeeAlso: AX=0602h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310604" name="310604"><b>310604</b></a> - INT 31 P - DPMI 0.9+ - GET PAGE SIZE<br />
<pre>
INT 31 P - DPMI 0.9+ - GET PAGE SIZE
	AX = 0604h
Return: CF clear if successful
	    BX:CX = page size in bytes
	CF set on error
	    AX = error code (DPMI 1.0+) (see also #03143)
		8001h unsupported, 16-bit host
BUG:	the Borland C++ 3.1 DPMILOAD returns with CF clear but BX and CX
	  unchanged

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310700" name="310700"><b>310700</b></a> - INT 31 Pu - DPMI 0.9+ - MARK PAGES AS PAGING CANDIDATES<br />
<pre>
INT 31 Pu - DPMI 0.9+ - MARK PAGES AS PAGING CANDIDATES
	AX = 0700h
	BX:CX = starting linear page number
	SI:DI = number of pages to mark as paging candidates
Return: ???
Note:	although marked as reserved in versions 0.9 and 1.0 of the DPMI
	  specification, this function is called by MS Windows TASKMAN,
	  PROGMAN, and KERNEL
SeeAlso: AX=0701h,AX=0702h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310701" name="310701"><b>310701</b></a> - INT 31 Pu - DPMI 0.9+ - DISCARD PAGES<br />
<pre>
INT 31 Pu - DPMI 0.9+ - DISCARD PAGES
	AX = 0701h
	BX:CX = starting linear page number
	SI:DI = number of pages to discard
Return: ???
Note:	although marked as reserved in versions 0.9 and 1.0 of the DPMI
	  specification, this function is called by MS Windows TASKMAN,
	  PROGMAN, and KERNEL
SeeAlso: AX=0700h,AX=0703h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310702" name="310702"><b>310702</b></a> - INT 31 P - DPMI 0.9+ - MARK PAGE AS DEMAND PAGING CANDIDATE<br />
<pre>
INT 31 P - DPMI 0.9+ - MARK PAGE AS DEMAND PAGING CANDIDATE
	AX = 0702h
	BX:CX = starting linear address
	SI:DI = number of bytes to mark as paging candidates
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8025h) (see #03143)
Notes:	this function is advisory, and does not force immediate paging
	partial pages will not be discarded
SeeAlso: AX=0700h,AX=0703h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310703" name="310703"><b>310703</b></a> - INT 31 P - DPMI 0.9+ - DISCARD PAGE CONTENTS<br />
<pre>
INT 31 P - DPMI 0.9+ - DISCARD PAGE CONTENTS
	AX = 0703h
	BX:CX = starting linear address
	SI:DI = number of bytes to mark as discarded
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8025h) (see #03143)
Notes:	this function is advisory, and may be ignored by DPMI implementations
	partial pages will not be discarded
SeeAlso: AX=0701h,AX=0702h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310800" name="310800"><b>310800</b></a> - INT 31 P - DPMI 0.9+ - PHYSICAL ADDRESS MAPPING<br />
<pre>
INT 31 P - DPMI 0.9+ - PHYSICAL ADDRESS MAPPING
	AX = 0800h
	BX:CX = physical address (should be above 1 MB)
	SI:DI = size in bytes
Return: CF clear if successful
	    BX:CX = linear address which maps the requested physical memory
	CF set on error
	    AX = error code (DPMI 1.0+) (8003h,8021h) (see #03143)
Notes:	implementations may refuse this call because it can circumvent protects
	the caller must build an appropriate selector for the memory
	do not use for memory mapped in the first megabyte
SeeAlso: AX=0002h,AX=0508h,AX=0509h,AX=0801h,INT 21/AX=250Ah,INT 21/AX=EB05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310801" name="310801"><b>310801</b></a> - INT 31 P - DPMI 1.0+ - FREE PHYSICAL ADDRESS MAPPING<br />
<pre>
INT 31 P - DPMI 1.0+ - FREE PHYSICAL ADDRESS MAPPING
	AX = 0801h
	BX:CX = linear address returned by AX=0800h
Return: CF clear if successful
	CF set on error
	    AX = error code (8025h) (see #03143)
Note:	should be called at end of access to device mapped with AX=0800h
SeeAlso: AX=0508h,AX=0509h,AX=0800h,INT 21/AX=EB03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310900" name="310900"><b>310900</b></a> - INT 31 P - DPMI 0.9+ - GET AND DISABLE VIRTUAL INTERRUPT STATE<br />
<pre>
INT 31 P - DPMI 0.9+ - GET AND DISABLE VIRTUAL INTERRUPT STATE
	AX = 0900h
Return: CF clear
	virtual interrupts disabled
	AL = previous interrupt state (00h disabled, 01h enabled)
	AH preserved
Notes:	the previous state may be restored simply by executing another INT 31
	a CLI instruction may be used if the previous state is unimportant,
	  but should be assumed to be very slow due to trapping by the host
SeeAlso: AX=0901h,AX=0902h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310901" name="310901"><b>310901</b></a> - INT 31 P - DPMI 0.9+ - GET AND ENABLE VIRTUAL INTERRUPT STATE<br />
<pre>
INT 31 P - DPMI 0.9+ - GET AND ENABLE VIRTUAL INTERRUPT STATE
	AX = 0901h
Return: CF clear
	virtual interrupts enabled
	AL = previous interrupt state (00h disabled, 01h enabled)
	AH preserved
Notes:	the previous state may be restored simply by executing another INT 31
	a STI instruction may be used if the previous state is unimportant,
	  but should be assumed to be very slow due to trapping by the host
SeeAlso: AX=0900h,AX=0902h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310902" name="310902"><b>310902</b></a> - INT 31 P - DPMI 0.9+ - GET VIRTUAL INTERRUPT STATE<br />
<pre>
INT 31 P - DPMI 0.9+ - GET VIRTUAL INTERRUPT STATE
	AX = 0902h
Return: CF clear
	AL = current interrupt state (00h disabled, 01h enabled)
Note:	should be used rather than PUSHF because that instruction yields the
	  physical interrupt state rather than the per-client virtualized
	  interrupt flag
SeeAlso: AX=0900h,AX=0901h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310A00" name="310A00"><b>310A00</b></a> - INT 31 P - DPMI 0.9+ - GET VENDOR SPECIFIC API ENTRY POINT<br />
<pre>
INT 31 P - DPMI 0.9+ - GET VENDOR SPECIFIC API ENTRY POINT
	AX = 0A00h
	DS:(E)SI -&gt; case-sensitive ASCIZ vendor name or identifier
Return: CF clear if successful
	    ES:(E)DI -&gt; FAR extended API entry point
	    DS, FS, GS, EAX, EBX, ECX, EDX, ESI, EBP destroyed
	CF set on error
	    AX = error code (DPMI 1.0+) (8001h) (see #03143)
Notes:	extended API parameters are vendor-specific
	DPMI 1.0+ supports this function solely for backward compatibility; use
	  INT 2F/AX=168Ah instead
	this function is not supported by MS Windows 3.10, BC++ 3.1 DPMILOAD,
	  or QDPMI v1.0x; use INT 2F/AX=168Ah instead.	It is supported by
	  386MAX v7.01.
SeeAlso: INT 2F/AX=168Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310B00" name="310B00"><b>310B00</b></a> - INT 31 P - DPMI 0.9+ - SET DEBUG WATCHPOINT<br />
<pre>
INT 31 P - DPMI 0.9+ - SET DEBUG WATCHPOINT
	AX = 0B00h
	BX:CX = linear address
	DL = size (1,2,4 bytes)
	DH = type (00h execute, 01h write, 02h read/write)
Return: CF clear if successful
	    BX = watchpoint handle
	CF set on error
	    AX = error code (DPMI 1.0+) (8016h,8021h,8025h) (see #03143)
SeeAlso: AX=0212h,AX=0601h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310B01" name="310B01"><b>310B01</b></a> - INT 31 P - DPMI 0.9+ - CLEAR DEBUG WATCHPOINT<br />
<pre>
INT 31 P - DPMI 0.9+ - CLEAR DEBUG WATCHPOINT
	AX = 0B01h
	BX = watchpoint handle
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8023h) (see #03143)
Note:	the watchpoint handle is freed
SeeAlso: AX=0B00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310B02" name="310B02"><b>310B02</b></a> - INT 31 P - DPMI 0.9+ - GET STATE OF DEBUG WATCHPOINT<br />
<pre>
INT 31 P - DPMI 0.9+ - GET STATE OF DEBUG WATCHPOINT
	AX = 0B02h
	BX = watchpoint handle
Return: CF clear if successful
	    AX = status flags
		bit 0: watch point has been executed since AX=0B00h or AX=0B03h
	CF set on error
	    AX = error code (DPMI 1.0+) (8023h) (see #03143)
SeeAlso: AX=0B00h,AX=0B03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310B03" name="310B03"><b>310B03</b></a> - INT 31 P - DPMI 0.9+ - RESET DEBUG WATCHPOINT<br />
<pre>
INT 31 P - DPMI 0.9+ - RESET DEBUG WATCHPOINT
	AX = 0B03h
	BX = watchpoint handle
Return: CF clear if successful
	CF set on error
	    AX = error code (DPMI 1.0+) (8023h) (see #03143)
SeeAlso: AX=0B02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310C00" name="310C00"><b>310C00</b></a> - INT 31 P - DPMI 1.0+ - INSTALL RESIDENT HANDLER INIT CALLBACK<br />
<pre>
INT 31 P - DPMI 1.0+ - INSTALL RESIDENT HANDLER INIT CALLBACK
	AX = 0C00h
	ES:(E)DI -&gt; resident service provider structure (see #03158)
Return: CF clear if successful
	CF set on error
	    AX = error code (8015h,8021h,8025h) (see #03143 at AX=0000h)
Note:	calling this function declares an intent to provide resident
	  protected mode services after terminating with AX=0C01h
SeeAlso: AX=0303h,AX=0C01h

Format of DPMI resident service provider structure:
Offset	Size	Description	(Table 03158)
 00h	QWORD	descriptor for 16-bit data segment
 08h	QWORD	descriptor for 16-bit code segment (zeros if not supported)
 10h	WORD	offset of 16-bit callback procedure
 12h  2 BYTEs	reserved
 14h	QWORD	descriptor for 32-bit data segment
 1Ch	QWORD	descriptor for 32-bit code segment (zeros if not supported)
 24h	DWORD	offset of 32-bit callback procedure

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310C01" name="310C01"><b>310C01</b></a> - INT 31 P - DPMI 1.0+ - TERMINATE AND STAY RESIDENT<br />
<pre>
INT 31 P - DPMI 1.0+ - TERMINATE AND STAY RESIDENT
	AX = 0C01h
	BL = return code
	DX = number of paragraphs of DOS memory to reserve (0 or &gt;= 6)
Return: never
Notes:	should only be used if the program will only provide services to
	  other DPMI programs
	any protected mode memory remains allocated to the program unless
	  explicitly freed before this call
	must first call AX=0C00h or program will simply be terminated
SeeAlso: AX=0C00h,INT 21/AH=31h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310D00" name="310D00"><b>310D00</b></a> - INT 31 P - DPMI 1.0+ - ALLOCATE SHARED MEMORY<br />
<pre>
INT 31 P - DPMI 1.0+ - ALLOCATE SHARED MEMORY
	AX = 0D00h
	ES:(E)DI -&gt; shared memory allocation request structure (see #03159)
Return: CF clear if successful
	    request structure updated
	CF set on error
	    AX = error code (8012h,8013h,8014h,8016h,8021h) (see #03143)
Note:	first 16 bytes of memory block will be initialized to zeros on the
	  first allocation
SeeAlso: AX=0501h,AX=0D01h,AX=0D02h

Format of DPMI shared memory allocation request structure:
Offset	Size	Description	(Table 03159)
 00h	DWORD	requested length of shared memory block in bytes
 04h	DWORD	(ret) allocated length of block
 08h	DWORD	(ret) shared memory handle
 0Ch	DWORD	(ret) linear address of memory block
 10h	PWORD	selector:offset32 of ASCIZ name for memory block
		(name max 128 bytes)
 16h  2 BYTEs	reserved
 18h  4 BYTEs	reserved (00h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310D01" name="310D01"><b>310D01</b></a> - INT 31 P - DPMI 1.0+ - FREE SHARED MEMORY<br />
<pre>
INT 31 P - DPMI 1.0+ - FREE SHARED MEMORY
	AX = 0D01h
	SI:DI = shared memory block handle
Return: CF clear if successful
	CF set on error
	    AX = error code (8023h) (see #03143)
Notes:	handle becomes invalid after this call
	DPMI maintains separate global and virtual machine use counts for each
	  shared memory block; when the global use counts reaches zero, the
	  block is finally destroyed
SeeAlso: AX=0502h,AX=0D00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310D02" name="310D02"><b>310D02</b></a> - INT 31 P - DPMI 1.0+ - SERIALIZE SHARED MEMORY<br />
<pre>
INT 31 P - DPMI 1.0+ - SERIALIZE SHARED MEMORY
	AX = 0D02h
	SI:DI = shared memory block handle
	DX = flags
	    bit 0: return immediately rather than suspending if serialization
		  unavailable
	    bit 1: shared rather than exclusive serialization
	    bits 2-15 reserved (0)
Return: CF clear if successful
	CF set on error
	    AX = error code (8004h,8005h,8017h-8019h,8023h) (see #03143)
Notes:	an exclusive serialization blocks any other serialization attempts for
	  the same block by another virtual machine; a shared serialization
	  blocks attempts at exclusive serialization by another virtual machine
	hosts are not required to detect deadlock
	a client's interrupt handler can cancel a serialization call which
	  caused it to block by calling AX=0D03h
SeeAlso: AX=0D00h,AX=0D03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310D03" name="310D03"><b>310D03</b></a> - INT 31 P - DPMI 1.0+ - FREE SERIALIZATION ON SHARED MEMORY<br />
<pre>
INT 31 P - DPMI 1.0+ - FREE SERIALIZATION ON SHARED MEMORY
	AX = 0D03h
	SI:DI = shared memory block handle
	DX = flags
	    bit 0: release shared serialization rather than exclusive serialztn
	    bit 1: free pending serialization
	    bits 2-15 reserved (0)
Return: CF clear if successful
	CF set on error
	    AX = error code (8002h,8023h) (see #03143 at AX=0000h)
SeeAlso: AX=0D00h,AX=0D02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310E00" name="310E00"><b>310E00</b></a> - INT 31 P - DPMI 1.0+ - GET COPROCESSOR STATUS<br />
<pre>
INT 31 P - DPMI 1.0+ - GET COPROCESSOR STATUS
	AX = 0E00h
Return: CF clear
	AX = coprocessor status (see #03160)
Note:	supported by 386MAX v6.01, which otherwise only supports DPMI 0.9
SeeAlso: AX=0E01h

Bitfields for DPMI coprocessor status:
Bit(s)	Description	(Table 03160)
 0	numeric coprocessor enabled for current client
 1	client is emulating coprocessor
 2	numeric coprocessor is present
 3	host is emulating coprocessor instructions
 4-7	coprocessor type
	0000 none
	0010 80287
	0011 80387
	0100 80486 with numeric coprocessor
	other reserved
 8-15	not used

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#310E01" name="310E01"><b>310E01</b></a> - INT 31 P - DPMI 1.0+ - SET EMULATION<br />
<pre>
INT 31 P - DPMI 1.0+ - SET EMULATION
	AX = 0E01h
	BX = coprocessor flag bits (see #03161)
Return: CF clear if successful
	CF set on error
	    AX = error code (8026h) (see #03143 at AX=0000h)
Note:	supported by 386MAX v6.01, which otherwise only supports DPMI 0.9
SeeAlso: AX=0E00h

Bitfields for DPMI coprocessor flags:
Bit(s)	Description	(Table 03161)
 0	enable numeric coprocessor for current client
 1	client will emulate coprocessor
 2-15	not used

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#3157" name="3157"><b>3157</b></a> - INT 31 - Netroom3 DPMI.EXE v3.00 - ???<br />
<pre>
INT 31 - Netroom3 DPMI.EXE v3.00 - ???
	AH = 57h
	AL = subfunction (at least 02h,03h,04h,05h,07h,08h,09h,0Ah)
	???
Return: ???
SeeAlso: INT 2C/AX=0000h"Cloaking"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#315702" name="315702"><b>315702</b></a> - INT 31 - Netroom3 DPMI.EXE v3.00 - SWITCH TO PROTECTED MODE<br />
<pre>
INT 31 - Netroom3 DPMI.EXE v3.00 - SWITCH TO PROTECTED MODE
	AX = 5702h
	DX = PSP segment of caller
	STACK: WORD	???
	       WORD	flags (bit 0 set if 32-bit program)
Return: as for DPMI mode-switch entry point (see #02718 at INT 2F/AX=1687h)
Note:	this function is called by the real-mode DPMI mode-switch entry point
SeeAlso: INT 2F/AX=1687h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31EE00" name="31EE00"><b>31EE00</b></a> - INT 31 - DOS32 v3.0+ - GET DOS32 VERSION AND SELECTOR VALUES<br />
<pre>
INT 31 - DOS32 v3.0+ - GET DOS32 VERSION AND SELECTOR VALUES
	AX = EE00h
Return: AL = minor version (BCD)
	AH = major version (BCD)
	DL = system type (1=raw DOS, 2=XMS, 4=VCPI, 8=DPMI)
	BX = selector of 4GB data segment with zero base address
Program: DOS32 is a 32 bit DOS extender by Adam Seychell.
SeeAlso: AX=EE02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31EE02" name="31EE02"><b>31EE02</b></a> - INT 31 - DOS32 v3.0+ - GET DOS32 ADDRESS INFORMATION<br />
<pre>
INT 31 - DOS32 v3.0+ - GET DOS32 ADDRESS INFORMATION
	AX = EE02h
Return: AX = real-mode segment of temporary 8K buffer (v3.1+)
	EBX = 32bit linear address of the program segment
	EDX = Total size in bytes of the programs .EXE file after linking.
	ESI = offset address of PSP
	EDI = offset address of program environment
	ECX = offset address of the program's .EXE ASCIZ file name and path
SeeAlso: AX=EE00h,AX=EE20h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31EE10" name="31EE10"><b>31EE10</b></a> - INT 31 - DOS32 v3.2+ - SET UP A DOS32 LOADABLE LIBRARY<br />
<pre>
INT 31 - DOS32 v3.2+ - SET UP A DOS32 LOADABLE LIBRARY
	AX = EE10h
	EDX -&gt; library ASCIZ path\filename
	EBX = number of bytes to seek from beginning of file
Return: CF clear if successful
	    EAX = size of memory block required to store library
	    EBX = size of library file
	CF set on error
	    AL = error code.
		01h error opening or reading file
		02h bad DOS32 library file
SeeAlso: AX=EE00h,AX=EE11h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31EE11" name="31EE11"><b>31EE11</b></a> - INT 31 - DOS32 v3.2+ - LOAD LIBRARY FILE<br />
<pre>
INT 31 - DOS32 v3.2+ - LOAD LIBRARY FILE
	AX = EE11h
	EDX -&gt; near pointer of memory block to store library
Return: CF clear if successful
	    EDX = near pointer to the dynamic library public
	CF set on error
Note:	must first successfuly call function AX=EE10h before calling this
	  function
SeeAlso: AX=EE00h,AX=EE10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31EE20" name="31EE20"><b>31EE20</b></a> - INT 31 - DOS32 v3.0+ - GET REAL MODE CALL BACK ADDRESS WITH RETF STACK FRAME<br />
<pre>
INT 31 - DOS32 v3.0+ - GET REAL MODE CALL BACK ADDRESS WITH RETF STACK FRAME
	AX = EE20h
	ESI = offset of the real mode call back function
Return: CF clear if successful
	    CX:DX = real mode address to call up to the protected mode
		  procedure
	CF set on error
SeeAlso: AX=EE00h,AX=EE02h,AX=EE21h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31EE21" name="31EE21"><b>31EE21</b></a> - INT 31 - DOS32 v3.0+ - GET REAL MODE CALL BACK ADDRESS WITH IRET STACK FRAME<br />
<pre>
INT 31 - DOS32 v3.0+ - GET REAL MODE CALL BACK ADDRESS WITH IRET STACK FRAME
	AX = EE21h
	ESI = offset of the real mode call back function
Return: CF clear if successful
	    CX:DX = real mode address to call up to the protected mode
		  procedure
	CF set on error
SeeAlso: AX=EE20h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31EE30" name="31EE30"><b>31EE30</b></a> - INT 31 - DOS32 v3.0+ - TERMINATE AND STAY RESIDENT<br />
<pre>
INT 31 - DOS32 v3.0+ - TERMINATE AND STAY RESIDENT
	AX = EE30h
SeeAlso: AX=EE21h,AX=EE40h,INT 21/AH=31h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31EE40" name="31EE40"><b>31EE40</b></a> - INT 31 - DOS32 v3.0+ - UNDO PREVIOUS MEMORY ALLOCATION or DMA BUFFER<br />
<pre>
INT 31 - DOS32 v3.0+ - UNDO PREVIOUS MEMORY ALLOCATION or DMA BUFFER
	AX = EE40h
Return: CF clear if successful
	CF set on error
SeeAlso: AX=EE41h,AX=EE42h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31EE41" name="31EE41"><b>31EE41</b></a> - INT 31 - DOS32 v3.0+ - ALLOCATE 16KB DMA BLOCK<br />
<pre>
INT 31 - DOS32 v3.0+ - ALLOCATE 16KB DMA BLOCK
	AX = EE41h
Return: CF clear if successful
	    EBX -&gt; 16KB DMA block (physical address)
	    EDX -&gt; 16KB DMA block (offset address)
	CF set on error
SeeAlso: AX=EE40h,AX=EE42h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31EE42" name="31EE42"><b>31EE42</b></a> - INT 31 - DOS32 v3.0+ - ALLOCATE MEMORY BLOCK<br />
<pre>
INT 31 - DOS32 v3.0+ - ALLOCATE MEMORY BLOCK
	AX = EE42h
	EDX = size in bytes
Return: CF clear if successful
	    EAX = size in bytes
	    EDX -&gt; memory block
	CF set on error
Note:	size is rounded off to the next 4KB boundary
SeeAlso: AX=EE40h,AX=EE41h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF00" name="31FF00"><b>31FF00</b></a> - INT 31 P - CauseWay - "Info" - GET SYSTEM SELECTORS/FLAGS<br />
<pre>
INT 31 P - CauseWay - "Info" - GET SYSTEM SELECTORS/FLAGS
	AX = FF00h
Return: AX = selector for flag address space (base 00000000h, limit 4GB)
	BX = selector for current PSP segment (limit 0100h)
	(E)CX = size of DOS transfer buffer (max 64K)
	DX = real-mode segment address of DOS transfer buffer
	ES:(E)SI = protected-mode address of DOS transfer buffer
	EDI = system flags (see #03162)
Program: CauseWay is a 386 DOS extender by Michael Devore and John Wildsmith
	  for use with Watcom C++ or assembly language programs
Notes:	the entire transfer buffer can be addressed with a 16-bit offset in
	  protected mode
	CauseWay always maps selector 0040h to the BIOS data segment at
	  real-mode segment 0040h; when not running under a DPMI host, CauseWay
	  also provides selectors A000h, B000h, and B800h mapped to video
	  memory
SeeAlso: AX=FF25h

Bitfields for CauseWay system flags:
Bit(s)	Description	(Table 03162)
 0	32-bit code
 1	virtual memory manage enabled
 3-2	mode: 00 raw extended memory, 01 VCPI, 10 DPMI
 4	DPMI available
 5	VCPI available
 6	no memory managers
 7	application descriptor table type: 0 = GDT, 1 = LDT
 14-8	reserved
 15	debugging engine present

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF01" name="31FF01"><b>31FF01</b></a> - INT 31 P - CauseWay - "IntXX" - SIMULATE REAL-MODE INTERRUPT<br />
<pre>
INT 31 P - CauseWay - "IntXX" - SIMULATE REAL-MODE INTERRUPT
	AX = FF01h
	BL = interrupt number
	ES:(E)DI -&gt; real-mode register list (see #03148 at AX=0300h)
Return: register list updated
Note:	CauseWay fills in the values for SS, SP, and FLAGS itself, and ignores
	  the values specified for CS and IP
SeeAlso: AX=0300h,AX=FF02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF02" name="31FF02"><b>31FF02</b></a> - INT 31 P - CauseWay - "FarCallReal" - SIMULATE REAL-MODE FAR CALL<br />
<pre>
INT 31 P - CauseWay - "FarCallReal" - SIMULATE REAL-MODE FAR CALL
	AX = FF02h
	ES:(E)DI -&gt; real-mode register list (see #03148 at AX=0300h)
Return: register list updated
SeeAlso: AX=0301h,AX=FF01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF03" name="31FF03"><b>31FF03</b></a> - INT 31 P - CauseWay - "GetSel" - ALLOCATE NEW SELECTOR<br />
<pre>
INT 31 P - CauseWay - "GetSel" - ALLOCATE NEW SELECTOR
	AX = FF03h
Return: CF clear if successful
	    BX = new selector
	CF set on error
Note:	the new selector is initialized with a base address of 000000h, a limit
	  of 0000h, and attributes read/write expand-up data
SeeAlso: AX=FF04h,AX=FF05h,AX=FF06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF04" name="31FF04"><b>31FF04</b></a> - INT 31 P - CauseWay - "RelSel" - RELEASE A SELECTOR<br />
<pre>
INT 31 P - CauseWay - "RelSel" - RELEASE A SELECTOR
	AX = FF04h
	BX = selector
Return: CF clear if successful
	CF set on error
SeeAlso: AX=FF03h,AX=FF06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF05" name="31FF05"><b>31FF05</b></a> - INT 31 P - CauseWay - "CodeSel" - CONVERT SELECTOR TO EXECUTABLE CODE SELECTOR<br />
<pre>
INT 31 P - CauseWay - "CodeSel" - CONVERT SELECTOR TO EXECUTABLE CODE SELECTOR
	AX = FF05h
	BX = selector
	CL = default operation size (00h = 16-bit, 01h = 32-bit)
Return: CF clear if successful
	CF set on error
SeeAlso: AX=FF03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF06" name="31FF06"><b>31FF06</b></a> - INT 31 P - CauseWay - "AliasSel" - CREATE READ/WRITE DATA ALIAS SELECTOR<br />
<pre>
INT 31 P - CauseWay - "AliasSel" - CREATE READ/WRITE DATA ALIAS SELECTOR
	AX = FF06h
	BX = original selector
Return: CF clear if successful
	    AX = new data selector aliasing original selector
	CF set on error
SeeAlso: AX=FF03h,AX=FF04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF07" name="31FF07"><b>31FF07</b></a> - INT 31 P - CauseWay - "GetSelDet" - GET SELECTOR BASE AND LIMIT<br />
<pre>
INT 31 P - CauseWay - "GetSelDet" - GET SELECTOR BASE AND LIMIT
	AX = FF07h
	BX = selector
Return: CF clear if successful
	    CX:DX = base address
	    SI:DI = limit (bytes)
	CF set on error
SeeAlso: AX=FF08h,AX=FF09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF08" name="31FF08"><b>31FF08</b></a> - INT 31 P - CauseWay - "GetSelDet32" - GET SELECTOR BASE AND LIMIT (32-bit)<br />
<pre>
INT 31 P - CauseWay - "GetSelDet32" - GET SELECTOR BASE AND LIMIT (32-bit)
	AX = FF08h
Return: CF clear if successful
	    EDX = base address
	    ECX = limit (bytes)
	CF set on error
SeeAlso: AX=FF07h,AX=FF0Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF09" name="31FF09"><b>31FF09</b></a> - INT 31 P - CauseWay - "SetSelDet" - SET SELECTOR BASE AND LIMIT<br />
<pre>
INT 31 P - CauseWay - "SetSelDet" - SET SELECTOR BASE AND LIMIT
	AX = FF09h
	BX = selector
	CX:DX = new base address
	SI:DI = new byte-granular limit
Return: CF clear if successful
	CF set on error
SeeAlso: AX=FF07h,AX=FF0Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF0A" name="31FF0A"><b>31FF0A</b></a> - INT 31 P - CauseWay - "SetSelDet32" - SET SELECTOR BASE AND LIMIT (32-bit)<br />
<pre>
INT 31 P - CauseWay - "SetSelDet32" - SET SELECTOR BASE AND LIMIT (32-bit)
	AX = FF0Ah
	BX = selector
	EDX = new base address
	ECX = new byte-granular limit
Return: CF clear if successful
	CF set on error
SeeAlso: AX=FF08h,AX=FF09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF0B" name="31FF0B"><b>31FF0B</b></a> - INT 31 P - CauseWay - "GetMem" - ALLOCATE BLOCK OF MEMORY<br />
<pre>
INT 31 P - CauseWay - "GetMem" - ALLOCATE BLOCK OF MEMORY
	AX = FF0Bh
	CX:DX = size in bytes (FFFFh:FFFFh to get size of largest available)
Return: CF clear if successful
	    BX = selector for accessing block if requested size not FFFFh:FFFFh
	    CX:DX = size of largest available block if requested FFFFh:FFFFh
	CF set on error
SeeAlso: AX=FF0Ch,AX=FF0Dh,AX=FF0Fh,AX=FF10h,AX=FF2Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF0C" name="31FF0C"><b>31FF0C</b></a> - INT 31 P - CauseWay - "GetMem32" - ALLOCATE BLOCK OF MEMORY (32-bit)<br />
<pre>
INT 31 P - CauseWay - "GetMem32" - ALLOCATE BLOCK OF MEMORY (32-bit)
	AX = FF0Ch
	ECX = size in bytes (FFFFFFFFh to get size of largest available block)
Return: CF clear if successful
	    BX = selector for accessing block if requested size not FFFFh:FFFFh
	    ECX = size of largest available block if requested FFFFh:FFFFh
	CF set on error
SeeAlso: AX=FF0Bh,AX=FF0Eh,AX=FF0Fh,AX=FF11h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF0D" name="31FF0D"><b>31FF0D</b></a> - INT 31 P - CauseWay - "ResMem" - RESIZE MEMORY BLOCK<br />
<pre>
INT 31 P - CauseWay - "ResMem" - RESIZE MEMORY BLOCK
	AX = FF0Dh
	BX = selector for block to be resized
	CX:DX = new size in bytes
Return: CF clear if successful
	CF set on error
Note:	the memory block may have to be copied to another location in order
	  to satisfy the requested new size, in which case the base address
	  of the selector is updated
SeeAlso: AX=FF0Bh,AX=FF0Eh,AX=FF12h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF0E" name="31FF0E"><b>31FF0E</b></a> - INT 31 P - CauseWay - "ResMem32" - RESIZE MEMORY BLOCK (32-bit)<br />
<pre>
INT 31 P - CauseWay - "ResMem32" - RESIZE MEMORY BLOCK (32-bit)
	AX = FF0Eh
	BX = selector for block to be resized
	ECX = new size in bytes
Return: CF clear if successful
	CF set on error
Note:	the memory block may have to be copied to another location in order
	  to satisfy the requested new size, in which case the base address
	  of the selector is updated
SeeAlso: AX=FF0Ch,AX=FF0Dh,AX=FF13h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF0F" name="31FF0F"><b>31FF0F</b></a> - INT 31 P - CauseWay - "RelMem" - RELEASE PREVIOUSLY ALLOCATED MEMORY<br />
<pre>
INT 31 P - CauseWay - "RelMem" - RELEASE PREVIOUSLY ALLOCATED MEMORY
	AX = FF0Fh
	BX = selector for block to be released
Return: CF clear if successful
	CF set on error
SeeAlso: AX=FF0Bh,AX=FF0Ch,AX=FF14h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF10" name="31FF10"><b>31FF10</b></a> - INT 31 P - CauseWay - "GetMemLinear" - ALLOCATE MEMORY WITHOUT SELECTOR<br />
<pre>
INT 31 P - CauseWay - "GetMemLinear" - ALLOCATE MEMORY WITHOUT SELECTOR
	AX = FF10h
	CX:DX = size of block in bytes
Return: CF clear if successful
	    SI:DI = linear address of allocated block
	CF set on error
Note:	this function may return addresses above 16M
SeeAlso: AX=FF0Bh,AX=FF11h,AX=FF12h,AX=FF14h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF11" name="31FF11"><b>31FF11</b></a> - INT 31 P - CauseWay - "GetMemLinear32" - ALLOCATE MEMORY WITHOUT SELECTOR<br />
<pre>
INT 31 P - CauseWay - "GetMemLinear32" - ALLOCATE MEMORY WITHOUT SELECTOR
	AX = FF11h
	ECX = size of block in bytes
Return: CF clear if successful
	    ESI = linear address of allocated block
	CF set on error
Note:	this function may return addresses above 16M
SeeAlso: AX=FF0Ch,AX=FF10h,AX=FF13h,AX=FF14h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF12" name="31FF12"><b>31FF12</b></a> - INT 31 P - CauseWay - "ResMemLinear" - RESIZE LINEAR MEMORY BLOCK<br />
<pre>
INT 31 P - CauseWay - "ResMemLinear" - RESIZE LINEAR MEMORY BLOCK
	AX = FF12h
	CX:DX = new size in bytes
	SI:DI = linear address of block to be resized
Return: CF clear if successful
	   SI:DI = new linear address of block
	CF set on error
SeeAlso: AX=FF0Dh,AX=FF10h,AX=FF13h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF13" name="31FF13"><b>31FF13</b></a> - INT 31 P - CauseWay - "ResMemLinear32" - RESIZE LINEAR MEMORY BLOCK (32-bit)<br />
<pre>
INT 31 P - CauseWay - "ResMemLinear32" - RESIZE LINEAR MEMORY BLOCK (32-bit)
	AX = FF13h
	ECX = new size in bytes
	ESI = linear address of block to be resized
Return: CF clear if successful
	   ESI = new linear address of block
	CF set on error
SeeAlso: AX=FF0Eh,AX=FF11h,AX=FF12h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF14" name="31FF14"><b>31FF14</b></a> - INT 31 P - CauseWay - "RelMemLinear" - RELEASE LINEAR MEMORY BLOCK<br />
<pre>
INT 31 P - CauseWay - "RelMemLinear" - RELEASE LINEAR MEMORY BLOCK
	AX = FF14h
	SI:DI = linear address of block to be released
Return: CF clear if successful
	CF set on error
SeeAlso: AX=FF0Fh,AX=FF10h,AX=FF15h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF15" name="31FF15"><b>31FF15</b></a> - INT 31 P - CauseWay - "RelMemLinear32" - RELEASE LINEAR MEMORY BLOCK (32-bit)<br />
<pre>
INT 31 P - CauseWay - "RelMemLinear32" - RELEASE LINEAR MEMORY BLOCK (32-bit)
	AX = FF15h
	ESI = linear address of block to be released
Return: CF clear if successful
	CF set on error
SeeAlso: AX=FF0Fh,AX=FF11h,AX=FF15h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF16" name="31FF16"><b>31FF16</b></a> - INT 31 P - CauseWay - "GetMemNear" - ALLOCATE APPLICATION-RELATIVE MEMORY<br />
<pre>
INT 31 P - CauseWay - "GetMemNear" - ALLOCATE APPLICATION-RELATIVE MEMORY
	AX = FF16h
	EBX = size in bytes of block to allocate
Return: CF clear if successful
	   ESI = application-relative linear address of allocated block
	CF set on error
SeeAlso: AX=FF17h,AX=FF18h,AX=FF19h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF17" name="31FF17"><b>31FF17</b></a> - INT 31 P - CauseWay - "ResMemNear" - RESIZE APPLICATION-RELATIVE MEMORY BLOCK<br />
<pre>
INT 31 P - CauseWay - "ResMemNear" - RESIZE APPLICATION-RELATIVE MEMORY BLOCK
	AX = FF17h
	EBX = size in bytes of block to allocate
	ESI = application-relative linear address of block
Return: CF clear if successful
	    ESI = new application-relative linear address of block
	CF set on error
SeeAlso: AX=FF16h,AX=FF18h,AX=FF19h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF18" name="31FF18"><b>31FF18</b></a> - INT 31 P - CauseWay - "RelMemNear" - RELEASE APPLICATION-RELATIVE MEMORY BLOCK<br />
<pre>
INT 31 P - CauseWay - "RelMemNear" - RELEASE APPLICATION-RELATIVE MEMORY BLOCK
	AX = FF18h
	ESI = application-relative linear address of block
Return: CF clear if successful
	CF set on error
SeeAlso: AX=FF16h,AX=FF17h,AX=FF19h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF19" name="31FF19"><b>31FF19</b></a> - INT 31 P - CauseWay - "Linear2Near" - CONVERT LINEAR TO APP-RELATIVE ADDRESS<br />
<pre>
INT 31 P - CauseWay - "Linear2Near" - CONVERT LINEAR TO APP-RELATIVE ADDRESS
	AX = FF19h
	ESI = linear address
Return: ESI = application-relative linear address
SeeAlso: AX=FF1Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF1A" name="31FF1A"><b>31FF1A</b></a> - INT 31 P - CauseWay - "Near2Linear" - CONVERT APP-RELATIVE TO LINEAR ADDRESS<br />
<pre>
INT 31 P - CauseWay - "Near2Linear" - CONVERT APP-RELATIVE TO LINEAR ADDRESS
	AX = FF1Ah
	ESI = application-relative linear address
Return: ESI = linear address
SeeAlso: AX=FF19h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF1B" name="31FF1B"><b>31FF1B</b></a> - INT 31 P - CauseWay - "LockMem" - LOCK REGION OF MEMORY<br />
<pre>
INT 31 P - CauseWay - "LockMem" - LOCK REGION OF MEMORY
	AX = FF1Bh
	BX:CX = starting linear address
	SI:DI = size of region in bytes
Return: CF clear if successful
	CF set on error
Desc:	prevent memory from being swapped out by the virtual memory manager
Note:	locks are applied on 4K page boundaries, so memory above and below
	  the specified region may be locked as well
SeeAlso: AX=FF1Ch,AX=FF1Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF1C" name="31FF1C"><b>31FF1C</b></a> - INT 31 P - CauseWay - "LockMem32" - LOCK REGION OF MEMORY (32-bit)<br />
<pre>
INT 31 P - CauseWay - "LockMem32" - LOCK REGION OF MEMORY (32-bit)
	AX = FF1Ch
	ESI = starting linear address
	ECX = size of region in bytes
Return: CF clear if successful
	CF set on error
Desc:	prevent memory from being swapped out by the virtual memory manager
Note:	locks are applied on 4K page boundaries, so memory above and below
	  the specified region may be locked as well
SeeAlso: AX=FF1Bh,AX=FF1Eh,AX=FF1Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF1D" name="31FF1D"><b>31FF1D</b></a> - INT 31 P - CauseWay - "UnLockMem" - UNLOCK REGION OF MEMORY<br />
<pre>
INT 31 P - CauseWay - "UnLockMem" - UNLOCK REGION OF MEMORY
	AX = FF1Dh
	BX:CX = starting linear address
	SI:DI = size of region in bytes
Return: CF clear if successful
	CF set on error
Desc:	allow memory to be swapped out by the virtual memory manager
Note:	locks are applied on 4K page boundaries, so memory above and below
	  the specified region may be unlocked as well
SeeAlso: AX=FF1Bh,AX=FF1Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF1E" name="31FF1E"><b>31FF1E</b></a> - INT 31 P - CauseWay - "UnLockMem32" - UNLOCK REGION OF MEMORY (32-bit)<br />
<pre>
INT 31 P - CauseWay - "UnLockMem32" - UNLOCK REGION OF MEMORY (32-bit)
	AX = FF1Eh
	ESI = starting linear address
	ECX = size of region in bytes
Return: CF clear if successful
	CF set on error
Desc:	allow memory to be swapped out by the virtual memory manager
Note:	locks are applied on 4K page boundaries, so memory above and below
	  the specified region may be unlocked as well
SeeAlso: AX=FF1Ch,AX=FF1Dh,AX=FF20h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF1F" name="31FF1F"><b>31FF1F</b></a> - INT 31 P - CauseWay - "LockMemNear" - LOCK APPLICATION-RELATIVE MEMORY REGION<br />
<pre>
INT 31 P - CauseWay - "LockMemNear" - LOCK APPLICATION-RELATIVE MEMORY REGION
	AX = FF1Fh
	ESI = starting application-relative linear address
	EBX = size of region in bytes
Return: CF clear if successful
	CF set on error
Desc:	prevent memory from being swapped out by the virtual memory manager
Note:	locks are applied on 4K page boundaries, so memory above and below
	  the specified region may be locked as well
SeeAlso: AX=FF1Ch,AX=FF20h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF20" name="31FF20"><b>31FF20</b></a> - INT 31 P - CauseWay - "UnLockMemNear" - UNLOCK APP-RELATIVE MEMORY REGION<br />
<pre>
INT 31 P - CauseWay - "UnLockMemNear" - UNLOCK APP-RELATIVE MEMORY REGION
	AX = FF20h
	ESI = starting application-relative linear address
	ECX = size of region in bytes
Return: CF clear if successful
	CF set on error
Desc:	allow memory to be swapped out by the virtual memory manager
Note:	locks are applied on 4K page boundaries, so memory above and below
	  the specified region may be unlocked as well
SeeAlso: AX=FF1Eh,AX=FF1Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF21" name="31FF21"><b>31FF21</b></a> - INT 31 P - CauseWay - "GetMemDOS" - ALLOCATE CONVENTIONAL MEMORY<br />
<pre>
INT 31 P - CauseWay - "GetMemDOS" - ALLOCATE CONVENTIONAL MEMORY
	AX = FF21h
	BX = number of paragraphs to allocate
Return: CF clear if successful
	    AX = real-mode segment of allocated block
	    DX = initial selector for block
	CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	    BX = size of largest available block
Note:	if the requested size is greater than 64K, contiguous selectors will
	  be allocated, one for each 64K; for 32-bit applications, the first
	  selector's limit will be set to the size of the entire block, while
	  that selector will have a limit of 64K for 16-bit applications.  All
	  selectors after the first one have a limit of 64K except the final
	  one
SeeAlso: AX=FF22h,AX=FF23h,INT 21/AH=48h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF22" name="31FF22"><b>31FF22</b></a> - INT 31 P - CauseWay - "ResMemDOS" - RESIZE CONVENTIONAL MEMORY BLOCK<br />
<pre>
INT 31 P - CauseWay - "ResMemDOS" - RESIZE CONVENTIONAL MEMORY BLOCK
	AX = FF22h
	BX = new size in paragraphs
	DX = initial selector for block
Return: CF clear if successful
	CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
	    BX = maximum number of paragraphs available
Note:	this function will also fail if the block is expanded past a 64K
	  boundary and the next selector is already in use
SeeAlso: AX=FF21h,AX=FF23h,INT 21/AH=49h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF23" name="31FF23"><b>31FF23</b></a> - INT 31 P - CauseWay - "RelMemDOS" - RELEASE CONVENTIONAL MEMORY BLOCK<br />
<pre>
INT 31 P - CauseWay - "RelMemDOS" - RELEASE CONVENTIONAL MEMORY BLOCK
	AX = FF23h
	DX = initial selector for block
Return: CF clear if successful
	CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
Note:	all descriptors allocated for the block are freed
SeeAlso: AX=FF21h,AX=FF22h,INT 21/AH=4Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF24" name="31FF24"><b>31FF24</b></a> - INT 31 P - CauseWay - "ExecOverlay" - LOAD AND OPTIONALLY EXECUTE APP CODE<br />
<pre>
INT 31 P - CauseWay - "ExecOverlay" - LOAD AND OPTIONALLY EXECUTE APP CODE
	AX = FF24h
	EBX = flags
	    bit 0: don't execute (overlay only)
	    bit 1: don't preserve relocation information
	ES:EDX -&gt; filename (see also #03163)
	FS:ESI -&gt; commandline (ESI = 00000000h if no commandline)
	GS:EDI -&gt; name (CW's /o option)
Return: CF clear if successful
	    ---EBX bit 0 set---
	    CX:EDX = program entry point (CS:EIP)
	    SI = segment of PSP
	    ---EBX bit 1 set---
	    BX:EAX = initial SS:ESP
	    EDI high word = base segment
	    EDI low word = number of segments
	    EBP = start of segment definitions
	CF set on error
	    AX = error code
		0001h DOS file access error
		0002h not a CuaseWay 3P file
		0003h not enough memory
SeeAlso: AX=FF2Ah,INT 21/AH=4Bh

Format of CauseWay executable:
Offset	Size	Description	(Table 03163)
 00h  2 BYTEs	signature "3P"
 02h	DWORD	size of header data in bytes
 06h	DWORD	size of EXE image data in bytes
 0Ah	DWORD	number of bytes of program memory required
 0Eh	WORD	number of segment definitions (see #03165)
 10h	DWORD	number of relocation table entries
 14h	DWORD	offset of program entry point
 18h	WORD	segment list entry number for entry point's CS
 1Ah	DWORD	initial ESP
 1Eh	WORD	segment list entry number for initial SS
 20h	DWORD	control flags (see #03164)
 24h	DWORD	automatic stack size in bytes if ESP entry = 00000000h
 28h	BYTE	length of name (name follows program image)
 29h 23 BYTEs	reserved
SeeAlso: #01594,#01609 at INT 21/AH=4Bh

Bitfields for CauseWay executable control flags:
Bit(s)	Description	(Table 03164)
 0	16-bit interrupt stack frame
 7	descriptor table type (0 = GDT, 1 = LDT)
 14	16-bit default data size
 31	compressed EXE image
Note:	bits 0 and 14 should always be equal
SeeAlso: #03163

Format of CauseWay segment definition [array]:
Offset	Size	Description	(Table 03165)
 00h	DWORD	start offset within program image
 04h	DWORD	length and type
		bits 0-19: length
		bit 20:	   granularity (if set, length is in 4K pages)
		bits 21-24: type
			0000 code
			0001 read/write data
			0010 stack
			0011 read-only data
		bit 25: force segment descriptor's D bit to 0
		bit 26: force segmetn descriptor's D bit to 1
SeeAlso: #03163

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF25" name="31FF25"><b>31FF25</b></a> - INT 31 P - CauseWay - "GetDOSTrans" - GET DOS TRANSFER BUFFER<br />
<pre>
INT 31 P - CauseWay - "GetDOSTrans" - GET DOS TRANSFER BUFFER
	AX = FF25h
Return: BX = real-mode segment of transfer buffer
	ECX = transfer buffer size
	DX = protected-mode selector for transfer buffer
Note:	the default buffer size of 8K is sufficient for most applications,
	  but an application performing large amounts of file I/O may benefit
	  from allocating its own, larger buffer
SeeAlso: AX=FF00h,AX=FF26h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF26" name="31FF26"><b>31FF26</b></a> - INT 31 P - CauseWay - "SetDOSTrans" - SET DOS TRANSFER BUFFER<br />
<pre>
INT 31 P - CauseWay - "SetDOSTrans" - SET DOS TRANSFER BUFFER
	AX = FF26h
	BX = real-mode segment of new transfer buffer
	ECX = new transfer buffer size
	DX = protected-mode selector for new transfer buffer
Return: nothing
Note:	the specific buffer must be located in conventional memory; only the
	  first 64K will be used
SeeAlso: AX=FF25h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF27" name="31FF27"><b>31FF27</b></a> - INT 31 P - CauseWay v1.3 - "GetMCBSize" - GET CURRENT MCB ALLOCATION BLOCK SIZE<br />
<pre>
INT 31 P - CauseWay v1.3 - "GetMCBSize" - GET CURRENT MCB ALLOCATION BLOCK SIZE
	AX = FF27h
Return: ECX = current threshold
Desc:	determine the memory allocation size below which CauseWay will use
	  internal MCB chains rather than allocating full 4K pages via DPMI
SeeAlso: AX=FF00h,AX=FF28h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF28" name="31FF28"><b>31FF28</b></a> - INT 31 P - CauseWay v1.3 - "SetMCBSize" - SET MCB MEMORY ALLOCATION BLOCK SIZE<br />
<pre>
INT 31 P - CauseWay v1.3 - "SetMCBSize" - SET MCB MEMORY ALLOCATION BLOCK SIZE
	AX = FF28h
	ECX = new threshold (0000000h to disable MCB memory allocation system)
Return: CF clear if successful
	    threshold unchanged (default 16K)
	CF set on error (threshold &gt; 64K)
Desc:	specify the memory allocation size below which CauseWay will use
	  internal MCB chains rather than allocating full 4K pages via DPMI
Note:	the specified threshold will be rounded up to the next higher multiple
	  of 4K
SeeAlso: AX=FF00h,AX=FF27h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF29" name="31FF29"><b>31FF29</b></a> - INT 31 P - CauseWay v1.3 - "GetSels" - ALLOCATE MULTIPLE SELECTORS<br />
<pre>
INT 31 P - CauseWay v1.3 - "GetSels" - ALLOCATE MULTIPLE SELECTORS
	AX = FF29h
	CX = number of selectors to allocate
Return: BX = base selector
Desc:	allocate multiple contiguous selectors, initializing each to have a
	  base address and limit of zero
SeeAlso: AX=FF00h,AX=FF04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF2A" name="31FF2A"><b>31FF2A</b></a> - INT 31 P - CauseWay v1.3 - "cwLoad" - LOAD ANOTHER CAUSEWAY PROGRAM AS OVERLAY<br />
<pre>
INT 31 P - CauseWay v1.3 - "cwLoad" - LOAD ANOTHER CAUSEWAY PROGRAM AS OVERLAY
	AX = FF2Ah
	DS:EDX -&gt; filename
Return: CF clear if successful
	    CX:EDX = CS:EIP of entry point
	    BX:EAX = initial SS:ESP for program
	    SI = PSP for overlay program
	CF set on error
	    AX = error code (01h file error, 02h not a 3P file, 03h no memory)
Note:	the returned PSP can be given to "RelMem" (AX=FF0Fh) to release the
	  overlay's memory and selectors; only selectors and memory allocated
	  during loading will be freed by RelMem unless one switches PSPs with
	  INT 21/AH=50h
SeeAlso: AX=FF00h,AX=FF24h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF2B" name="31FF2B"><b>31FF2B</b></a> - INT 31 P - CauseWay v1.3 - "cwcInfo" - VALIDATE AND GET SIZE OF CWC FILE<br />
<pre>
INT 31 P - CauseWay v1.3 - "cwcInfo" - VALIDATE AND GET SIZE OF CWC FILE
	AX = FF2Bh
	BX = file handle for CWC-compressed file
Return: CF clear if successful
	    ECX = expanded file size
	CF set on error (not a CWC-compressed file)
SeeAlso: AX=FF00h,AX=FFFBh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF2C" name="31FF2C"><b>31FF2C</b></a> - INT 31 P - CauseWay v1.3 - "GetMemSO" - ALLOCATE MEMORY AND RETURN SEL:OFFSET<br />
<pre>
INT 31 P - CauseWay v1.3 - "GetMemSO" - ALLOCATE MEMORY AND RETURN SEL:OFFSET
	AX = FF2Ch
	CX:DX = block size in bytes
Return: CF clear if successful
	   SI:DI = selector:offset of allocated memory
	CF set on error
Note:	unlike "GetMem" (AX=FF0Bh), this function will reuse selectors until a
	  segment is full, rather than allocating a new selector for each
	  memory block
SeeAlso: AX=FF00h,AX=FF2Dh,AX=FF2Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF2D" name="31FF2D"><b>31FF2D</b></a> - INT 31 P - CauseWay v1.3 - "ResMemSO" - RESIZE SELECTOR:OFFSET MEMORY BLOCK<br />
<pre>
INT 31 P - CauseWay v1.3 - "ResMemSO" - RESIZE SELECTOR:OFFSET MEMORY BLOCK
	AX = FF2Dh
	SI:DI = selector:offset for memory block
	CX:DX = new size of block
Return: CF clear if successful
	   SI:DI = new selector:offset for memory block
	CF set on error
SeeAlso: AX=FF00h,AX=FF2Ch,AX=FF2Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FF2E" name="31FF2E"><b>31FF2E</b></a> - INT 31 P - CauseWay v1.3 - "RelMemSO" - RELEASE SELECTOR:OFFSET MEMORY BLOCK<br />
<pre>
INT 31 P - CauseWay v1.3 - "RelMemSO" - RELEASE SELECTOR:OFFSET MEMORY BLOCK
	AX = FF2Eh
	SI:DI = selector:offset for memory block
SeeAlso: AX=FF00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#31FFFB" name="31FFFB"><b>31FFFB</b></a> - INT 31 P - Causeway v1.3 - "cwcLoad" - LOAD/EXPAND CWC-COMPRESSED FILE<br />
<pre>
INT 31 P - Causeway v1.3 - "cwcLoad" - LOAD/EXPAND CWC-COMPRESSED FILE
	AX = FFFBh
	BX = source file handle
	ES:EDI -&gt; memory buffer into which to expand file
Return: CF clear if successful
	    ECX = expanded data length
	CF set on error
	    EAX = error code (01h file error, 02h bad data, 03h not CWC file)
Note:	the provided file may consist of the concatenation of several CWC
	  files; the one beginning at the current file position will be
	  expanded
SeeAlso: AX=FF2Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE00" name="67DE00"><b>67DE00</b></a> - INT 67 - Virtual Control Program Interface - INSTALLATION CHECK<br />
<pre>
INT 67 - Virtual Control Program Interface - INSTALLATION CHECK
	AX = DE00h
Return: AH = status
	    00h VCPI is present
		BH = major version number
		BL = minor version number
	    nonzero  VCPI not present
BUG:	MS Windows 3.00 is reported to "object violently" to this call.
SeeAlso: INT 2F/AX=1687h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE01" name="67DE01"><b>67DE01</b></a> - INT 67 - Virtual Control Program Interface - GET PROTECTED MODE INTERFACE<br />
<pre>
INT 67 - Virtual Control Program Interface - GET PROTECTED MODE INTERFACE
	AX = DE01h
	ES:DI -&gt; 4K page table buffer
	DS:SI -&gt; three descriptor table entries in GDT
		first becomes code segment descriptor, other two for use by
		  main control program
Return: AH = 00h successful
	    DI -&gt; first unused page table entry in buffer
	    EBX -&gt; protected mode entry point in code segment (see #03664)
	AH = nonzero  failed
Note:	protected mode entry point may be called with AX=DE00h-DE05h and
	  AX=DE0Ch (in each case, all other registers as appropriate for
	  the function)
SeeAlso: INT 2F/AX=1687h,INT 67/AH=3Fh

(Table 03664)
Call QEMM v6.03 protected mode entry point additionally with:
	AX = DF00h ???
		???
		Return: ???
	AX = DF01h ???
		???
		Return: ???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE02" name="67DE02"><b>67DE02</b></a> - INT 67 - Virtual Control Program Interface - GET MAX PHYSICAL MEMORY ADDRESS<br />
<pre>
INT 67 - Virtual Control Program Interface - GET MAX PHYSICAL MEMORY ADDRESS
	AX = DE02h
Return: AH = 00h  successful
	    EDX = physical address of highest 4K memory page
	AH nonzero: failed
SeeAlso: AH=3Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE03" name="67DE03"><b>67DE03</b></a> - INT 67 - Virtual Control Program Interface - GET NUMBER OF FREE 4K PAGES<br />
<pre>
INT 67 - Virtual Control Program Interface - GET NUMBER OF FREE 4K PAGES
	AX = DE03h
Return: AH = 00h  successful
	    EDX = number of free 4K pages
	AH nonzero: failed
Notes:	returns total number of pages available to ALL tasks in system
	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#03664)
SeeAlso: AX=DE04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE04" name="67DE04"><b>67DE04</b></a> - INT 67 - Virtual Control Program Interface - ALLOCATE A 4K PAGE<br />
<pre>
INT 67 - Virtual Control Program Interface - ALLOCATE A 4K PAGE
	AX = DE04h
Return: AH = 00h successful
	    EDX = physical address of allocated page
	AH nonzero: failed
Notes:	the client program is responsible for freeing all memory allocated
	  with this call before terminating
	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#03664)
SeeAlso: AH=3Fh,AX=DE03h,AX=DE05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE05" name="67DE05"><b>67DE05</b></a> - INT 67 - Virtual Control Program Interface - FREE 4K PAGE<br />
<pre>
INT 67 - Virtual Control Program Interface - FREE 4K PAGE
	AX = DE05h
	EDX = physical address of 4K page
Return: AH = status
	    00h successful
	    nonzero failed
Note:	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#03664)
SeeAlso: AH=3Fh,AX=DE04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE06" name="67DE06"><b>67DE06</b></a> - INT 67 - Virtual Control Program Interface - GET PHYS ADDR OF PAGE IN FIRST MB<br />
<pre>
INT 67 - Virtual Control Program Interface - GET PHYS ADDR OF PAGE IN FIRST MB
	AX = DE06h
	CX = page number (linear address shifted right 12 bits)
Return: AH = status
	    00h successful
		EDX = physical address of page
	    nonzero invalid page number (AH = 8Bh recommended)
SeeAlso: AX=5BE0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE07" name="67DE07"><b>67DE07</b></a> - INT 67 - Virtual Control Program Interface - READ CR0<br />
<pre>
INT 67 - Virtual Control Program Interface - READ CR0
	AX = DE07h
Return: AH = 00h
	EBX = value of Control Register 0
SeeAlso: AH=3Fh,AX=DE07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE08" name="67DE08"><b>67DE08</b></a> - INT 67 - Virtual Control Program Interface - READ DEBUG REGISTERS<br />
<pre>
INT 67 - Virtual Control Program Interface - READ DEBUG REGISTERS
	AX = DE08h
	ES:DI -&gt; array of 8 DWORDs
Return: AH = 00h
	buffer filled with DR0 first, DR7 last, DR4 and DR5 unused
SeeAlso: AH=3Fh,AX=DE09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE09" name="67DE09"><b>67DE09</b></a> - INT 67 - Virtual Control Program Interface - SET DEBUG REGISTERS<br />
<pre>
INT 67 - Virtual Control Program Interface - SET DEBUG REGISTERS
	AX = DE09h
	ES:DI -&gt; array of 8 DWORDs holding new values of debug registers
Return: AH = 00h
Note:	values for DR4 and DR5 ignored
SeeAlso: AH=3Fh,AX=DE08h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE0A" name="67DE0A"><b>67DE0A</b></a> - INT 67 - Virtual Control Program Interface - GET 8259 INTERRUPT VECTOR MAPPINGS<br />
<pre>
INT 67 - Virtual Control Program Interface - GET 8259 INTERRUPT VECTOR MAPPINGS
	AX = DE0Ah
Return: AH = 00h successful
	    BX = first vector used by master 8259 (IRQ0)
	    CX = first vector used by slave 8259 (IRQ8)
	AH nonzero: failed
Note:	CX is undefined in systems without a slave 8259
SeeAlso: AX=DE0Bh,INT 21/AX=250Ch,INT 31/AX=0400h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE0B" name="67DE0B"><b>67DE0B</b></a> - INT 67 - Virtual Control Program Interface - SET 8259 INTERRUPT VECTOR MAPPINGS<br />
<pre>
INT 67 - Virtual Control Program Interface - SET 8259 INTERRUPT VECTOR MAPPINGS
	AX = DE0Bh
	BX = first vector used by master 8259
	CX = first vector used by slave 8259
	interrupts disabled
Return: AH = 00h successful
	AH nonzero: failed
Notes:	This call merely informs the server that the client has changed the
	  interrupt mappings.  The client may not change the mappings if they
	  have already been changed by the server or another client, and is
	  responsible for restoring the original mappings before terminating.
SeeAlso: AX=DE0Ah,INT 2C/AX=002Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#67DE0C" name="67DE0C"><b>67DE0C</b></a> - INT 67 - Virtual Control Program Interface - SWITCH TO PROTECTED MODE<br />
<pre>
INT 67 - Virtual Control Program Interface - SWITCH TO PROTECTED MODE
	AX = DE0Ch
	ESI = linear address in first megabyte of values for system
	      registers (see #03665)
	interrupts disabled
Return: interrupts disabled
	GDTR, IDTR, LDTR, TR loaded
	SS:ESP must have at least 16 bytes space, and the entry point is
	      required to set up a new stack before enabling interrupts
	EAX, ESI, DS, ES, FS, GS destroyed
Note:	in protected mode, calling the protected-mode VCPI entry point with
	  AX = DE0Ch
	  DS = segment selector mapping entire linear address space obtained
		  via AX=DE01h
	  SS:ESP in first megabyte of linear memory
	  STACK:QWORD  return address from FAR call to 32-bit segment
		DWORD  EIP
		DWORD  CS
		DWORD  reserved for EFLAGS
		DWORD  ESP
		DWORD  SS
		DWORD  ES
		DWORD  DS
		DWORD  FS
		DWORD  GS
	  and interrupts disabled, will switch to virtual86 mode with
	    interrupts disabled, all segment registers loaded, and EAX
	    destroyed.
SeeAlso: AH=3Fh,INT 15/AH=89h,INT D4/AH=10h

Format of system register values for switch to protected mode:
Offset	Size	Description	(Table 03665)
 00h	DWORD	value for CR3
 04h	DWORD	linear address in first megabyte of value for GDTR
 08h	DWORD	linear address in first megabyte of value for IDTR
 0Ch	WORD	value for LDTR
 0Eh	WORD	value for TR
 10h	PWORD	CS:EIP of protected mode entry-point

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#78" name="78"><b>78</b></a> - INT 78 - UofSalford DBOS DOS extender - API<br />
<pre>
INT 78 - UofSalford DBOS DOS extender - API
	AH = function
	    00h (PB) display 32-bit memory specified by command argument
	    01h (PT) display 32-bit instruction(s) specified by command arg
	    02h specify offset to subsequent PB and PT commands
	    03h switch to protected mode
		DWORD following INT instruction point to map; protected-mode
			  entry point is immediately following the DWORD
		Return: never
		Note:	if bit 31 of the map address is set, only a stub was
			  loaded by DOS and DBOS will load the entire program
	    04h specify that subsequent load (AH=03h) should leave program in
		  memory
	    05h release program from memory
	    06h set break point at address and option count from commandline
	    07h resume program execution
	    08h single-step program
	    09h set read/write breakpoint using 386 debug registers
	    0Ah set write breakpoint using 386 debug register
	    0Bh set memory byte to new value
	    0Ch display CPU registers
	    0Dh run until specified program address reached
	    0Fh print trace from program map
	    10h specify an offset using a map symbol
	    14h print memory without any offset
	    18h switch DBOS into/out of test mode (ON/OFF commandline args)
	    1Dh get address of real/protected-mode communication buffer
		Return: ES:BP -&gt; comm buffer
	    1Eh set real-mode memory size (specify how much real-mode memory
		  to leave free when running FTN77 programs)
	    22h uninstall DBOS
	    24h force DBOS to emulate coprocessor instructions
	    26h set named DBOS switches from commandline
	    27h reset named DBOS switched from commandline
	    2Ah set list of dynamic link libraries to contents of commandline
		  file
	    35h specify that subsequent load (AH=03h) should stop at first
		  instruction
Return: ???
Notes:	DBOS supports functions 00h through 50h; many of these functions
	  provide a low-level debugging interface
	command arguments are read from the calling program's PSP
SeeAlso: INT 79"DBOS"
Index:	uninstall;DBOS DOS extender

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#78_0" name="78_0"><b>78</b></a> - INT 78 - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ0<br />
<pre>
INT 78 - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ0
Program: GO32.EXE is a DOS extender included as part of the 80386 port of the
	  GNU C/C++ compiler by DJ Delorie and distributed as DJGPP
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 08,INT 10/AH=FFh"GO32",INT 79"GO32"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#780000" name="780000"><b>780000</b></a> - INT 78 - HugeRealMode Driver - INSTALLATION CHECK<br />
<pre>
INT 78 - HugeRealMode Driver - INSTALLATION CHECK
	AX = 0000h
Return: AX = DBCAh if installed
Program: the HugeRealMode driver was published in the German DOS Extra Nr. 20
	  (1992), and makes a 4G flat address space (for both data and code)
	  available to real-mode DOS programs
SeeAlso: AX=0001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#780001" name="780001"><b>780001</b></a> - INT 78 - HugeRealMode Driver - GET ENTRY POINT<br />
<pre>
INT 78 - HugeRealMode Driver - GET ENTRY POINT
	AX = 0001h
Return: ES:BX -&gt; far call entry point (see #03788,#03803)
SeeAlso: AX=0000h

(Table 03787)
Values for HugeRealMode Server error code:
 00h	successful
 01h	unknown function
 02h	A20 disabled
 03h	A20 enabled
 04h	memory allocation error
 05h	memory not fixeable (LOCK)
 06h	memory not deallocaable
 07h	memory not moveable (UNLOCK)
 08h	change in memory allocation size not possible
 09h	file error (with .XMF-file)
 0Ah	memory error (with .XMF-file)
 0Bh	unknown procedure (currently Turbo Pascal unit only)

(Table 03788)
Call HugeRealMode Server "Enable A20" function with:
	AL = 00h
Return: AX = error code (see #03787)
Note:	The HugeRealMode Server requires an XMS-driver like HIMEM.SYS loaded
	  before HUGEREAL (for XMS-memory allocation and A20 control). It
	  utilizes some undocumented 386+ features to enable 4G code and data
	  segments (flat memory model) in the CPUs real-mode. It is not
	  compatible with V86-mode (as with most EMM386). For maximum speed
	  and compatibility with DOS it uses a two stage interrupt model
	  (see #03791)
SeeAlso: #03789,#03790,#03791

(Table 03789)
Call HugeRealMode Server "Disable A20" function with:
	AL = 01h
Return: AX = error code (see #03787)
SeeAlso: #03788,#03790

(Table 03790)
Call HugeRealMode Server "Query A20 State" function with:
	AL = 02h
Return: AX = A20 state (0000h disabled, 0001h enabled)
SeeAlso: #03788,#03789

(Table 03791)
Call HugeRealMode Server "Enable Two-Stage Interrupt Model" function with:
	AL = 03h
Return: AX = error code (see #03787)
Notes:	If the two stage interrupt model is disabled, the IP must stay below
	  1MB, because the high word of EIP is not saved correctly by the
	  standard interrupt management in real mode.  Routines in extended
	  memory may only be called with interrupts disabled (only usable for
	  very short routines).
	If the two stage interupt model is enabled, these conventions are not
	  required.  The outer (transparent) ISRs save the higher word of EIP
	  in the high word of CR3 (possible modification: in memory, if this
	  is not safe) and then invoke the standard ISRs.
	Because of this handling, one should use pseudo segmented code even in
	  extended memory (64K blocks located on 64K boundaries) to avoid the
	  misalignment of the saved EIP (in CR3). Another way is to track and
	  realign CR3 each time when jumping over a 64K boundary in extended
	  memory
SeeAlso: #03788,#03792

(Table 03792)
Call HugeRealMode Server "Disable Two-Stage Interrupt Model" function with:
	AL = 04h
Return: AX = error code (see #03787)
SeeAlso: #03788,#03791

(Table 03793)
Call HugeRealMode Server "Get Segment Address Of Server-Management Range" with:
	AL = 05h
Return: AX = error code (see #03787)
	ES = segment address
SeeAlso: #03803

(Table 03794)
Call HugeRealMode Server "Allocate Memory" function with:
	AL = 06h
	DX = length in KB
Return: AX = error code (see #03787)
	DX = handle
	EBX = start address of allocated block
SeeAlso: #03795,#03796

(Table 03795)
Call HugeRealMode Server "Deallocate Memory" function with:
	AL = 07h
	DX = handle
Return: AX = error code (see #03787)
SeeAlso: #03794,#03796

(Table 03796)
Call HugeRealMode Server "Modify Allocated Memory Size" function with:
	AL = 08h
	DX = handle
	BX = new size in KB
Return: AX = error code (see #03787)
	EBX = new address
SeeAlso: #03794,#03795

(Table 03797)
Call HugeRealMode Server "Load .XMF-file" function with:
	AL = 09h
	ES:BX -&gt; filename (see #03798)
Return: AX = error code (see #03787)
	ECX = target address
Notes:	memory must be allocated before loading
	.XMF file format (eXtended Memory executable File format) is supported
	  by the HugeRealMode server for easier handling of XMS-code.
	The utility CONFXMF converts .OBJ-files (.COM 'tiny' model) to
	  .XMF-format
SeeAlso: #03794

Format of .XMF program file header:
Offset	Size	Description	(Table 03798)
 00h	DWORD	signature "XMF_"
 04h	WORD	length of programs code
 06h	WORD	count of 32bit addresses to relocate
 08h	WORD	offset to code start (releative to file start) (see #03799)
 0Ah	WORD	relocation table
Note:	each word contains a 16bit address, where a relocation has to be
	  performed
SeeAlso: #03797,#03799

Format of .XMF-file code header:
Offset	Size	Description	(Table 03799)
 00h	WORD	count of exported functions
 02h  N PWORDs	48bit pointers (16bit segment+32bit offset) to each function
		(16bit segment is always zero)
 var		start of program's code
SeeAlso: #03797,#03798

(Table 03800)
Call HugeRealMode Server "Set Segment Limits" function with:
	AL = 0Ah
	BL = segment limits (see #03801)
Return: AX = error code (see #03787)
SeeAlso: #03793

Bitfields for HugeRealMode Server segment limits:
Bit(s)	Description	(Table 03801)
 7	CS size: 1=4GB, 0=64KB
 6-5	not used
 4	SS size: 1=4GB, 0=64KB
 3	GS size
 2	FS size
 1	ES size
 0	DS size
SeeAlso: #03800

(Table 03802)
Call HugeRealMode Server "Transfer Memory From DOS To XMS" function with:
	AL = 0Bh
	ES:SI = source address
	EDI = target address
	ECX = length
Return: AX = error code
SeeAlso: #03803

(Table 03803)
Call HugeRealMode Server "Transfer Memory From XMS To DOS" function with:
	AL = 0Ch
	ESI = source address
	ES:DI = target address
	ECX = length
Return: AX = error code
SeeAlso: #03802

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#79_0" name="79_0"><b>79</b></a> - INT 79 - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ1<br />
<pre>
INT 79 - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ1
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 09,INT 78"GO32",INT 7A"GO32"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#79_2" name="79_2"><b>79</b></a> - INT 79 - DBOS DOS Extender<br />
<pre>
INT 79 - DBOS DOS Extender
	details not available
Desc:	this interrupt is used by an MS Windows virtual device driver with
	  which the DBOS extender communicates when run inside a Windows
	  Enhanced Mode DOS box
SeeAlso: INT 78"DBOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#7A_1" name="7A_1"><b>7A</b></a> - INT 7A - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ2<br />
<pre>
INT 7A - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ2
Program: GO32.EXE is a DOS extender included as part of the 80386 port of the
	  GNU C/C++ compiler by DJ Delorie and distributed as DJGPP
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 0A"IRQ2",INT 79"GO32",INT 7B"GO32"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#7B_1" name="7B_1"><b>7B</b></a> - INT 7B - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ3<br />
<pre>
INT 7B - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ3
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 0B,INT 10/AH=FFh"GO32",INT 7A"GO32",INT 7C"GO32"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#7C_0" name="7C_0"><b>7C</b></a> - INT 7C - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ4<br />
<pre>
INT 7C - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ4
Program: GO32.EXE is a DOS extender included as part of the 80386 port of the
	  GNU C/C++ compiler by DJ Delorie and distributed as DJGPP
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 0C,INT 7B"GO32",INT 7D"GO32"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#7D_1" name="7D_1"><b>7D</b></a> - INT 7D - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ5<br />
<pre>
INT 7D - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ5
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 0D"IRQ5",INT 7C"GO32",INT 7E"GO32"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#7E_1" name="7E_1"><b>7E</b></a> - INT 7E - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ6<br />
<pre>
INT 7E - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ6
Program: GO32.EXE is a DOS extender included as part of the 80386 port of the
	  GNU C/C++ compiler by DJ Delorie and distributed as DJGPP
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 0E"IRQ6",INT 7D"GO32",INT 7F"GO32"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#7F_4" name="7F_4"><b>7F</b></a> - INT 7F - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ7<br />
<pre>
INT 7F - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ7
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the DOS extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 0F"IRQ7",INT 7E"GO32"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#80_1" name="80_1"><b>80</b></a> - INT 80 - Phar Lap 386|DOS-Extender - RELOCATED PRINT-SCREEN<br />
<pre>
INT 80 - Phar Lap 386|DOS-Extender - RELOCATED PRINT-SCREEN
Note:	the extender relocates INT 05 to here by default, but can be told to
	  leave INT 05 alone with the commandline (or DOSX= environment
	  variable) flag -PRIVEC 5
SeeAlso: INT 05"PRINT SCREEN"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<div class="bottom-nav"><b><a href="./index.html">Home</a></b> <b>Interrupt Index</b>: <a href="./INTERRUP.CAT.HTML">by Category</a> <a href="./INTERRUP.NUM.HTML">by ID</a> <b>TOC</b>: <a href="#__toc">by Order</a> <b><a href="#top">Top</a></b></div>

</body>
</html>
