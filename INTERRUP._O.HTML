
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INTERRUP._O</title>
    <style>
        body {
            font-variant-ligatures: none;
        }
        pre {
            font-family: 'Courier New', Courier, monospace;
        }
        a {
            color: black;
        }
        .bottom-nav {
            position: sticky;
            bottom: 0px;
            background-color: white;
            text-align: right;
        }
        h3, h4 {
            margin: 0;
        }
</style>
</head>
<body>

<b>Interrupt List Release 61 Last change 16jul00</b><br />
<b>Copyright (c) 1989-1999,2000 Ralf Brown</b><br />
<pre>
Index for category O - other operating systems,
</pre>

<p>
<a name="__toc"><b>Table of Contents by Order</b></a><br />

<a href="#1500_1"><b>1500</b> - INT 15 - VMiX v2+ - INSTALLATION CHECK</a><br />
<a href="#1501_1"><b>1501</b> - INT 15 - VMiX - "sys_chanreq" - I/O CHANNEL OBJECT MANAGER</a><br />
<a href="#1502_1"><b>1502</b> - INT 15 - VMiX - "sys_memreq" - MEMORY OBJECT MANAGER</a><br />
<a href="#1503_1"><b>1503</b> - INT 15 - VMiX - "sys_pinput" - PROMPTED CONSOLE INPUT</a><br />
<a href="#1504_1"><b>1504</b> - INT 15 - VMiX - "sys_vprintf" - FORMATTED OUTPUT TO STREAM</a><br />
<a href="#1505_1"><b>1505</b> - INT 15 - VMiX - "sys_getpid" - GET PROCESS ID OF CURRENT PROCESS</a><br />
<a href="#1506_0"><b>1506</b> - INT 15 - VMiX - "sys_getpcb" - GET POINTER TO PROCESS CONTROL BLOCK</a><br />
<a href="#1507"><b>1507</b> - INT 15 - VMiX - "sys_getocb" - GET POINTER TO OBJECT CONTROL BLOCK</a><br />
<a href="#1508"><b>1508</b> - INT 15 - VMiX - "sys_getccb" - GET CHANNEL CONTROL BLOCK</a><br />
<a href="#1509"><b>1509</b> - INT 15 - VMiX - "sys_getqueue" - GET ID OF QUEUED ELEMENT</a><br />
<a href="#150A"><b>150A</b> - INT 15 - VMiX - "sys_qetqnext" - GET ID OF NEXT QUEUED ELEMENT</a><br />
<a href="#150B"><b>150B</b> - INT 15 - VMiX - "sys_sysreq" - SYSTEM CONFIGURATION MANAGER</a><br />
<a href="#150C"><b>150C</b> - INT 15 - VMiX - "sys_getstack" - GET POINTER TO PROCESS TSS STACK</a><br />
<a href="#150D"><b>150D</b> - INT 15 - VMiX - "sys_spawn" - START A CHILD PROCESS JOB SHELL</a><br />
<a href="#150E"><b>150E</b> - INT 15 - VMiX - "sys_kill" - HARD TERMINATE PROCESS</a><br />
<a href="#150F_0"><b>150F</b> - INT 15 - VMiX - "sys_getqkey" - GET KEY FIELD OF QUEUED ELEMENT</a><br />
<a href="#1510"><b>1510</b> - INT 15 - VMiX - "sys_virtual" - EXECUTE CONFORMING FUNCTION IN PROTECTED MODE</a><br />
<a href="#152010"><b>152010</b> - INT 15 - OS HOOK - SETUP SYSREQ ROUTINE (AT,XT286,PS50+)</a><br />
<a href="#152011"><b>152011</b> - INT 15 - OS HOOK - COMPLETION OF SYSREQ FUNCTION (AT,XT286,PS50+)</a><br />
<a href="#20"><b>20</b> - INT 20 - Minix - SEND/RECEIVE MESSAGE</a><br />
<a href="#2118_0"><b>2118</b> - INT 21 - U - PTS-DOS 6.51 & S/DOS 1.0 - EXTENDED RENAME FILE USING FCB</a><br />
<a href="#2120_0"><b>2120</b> - INT 21 - S/DOS 1.0+ & PTS-DOS 6.51+ - GET OEM REVISION</a><br />
<a href="#213000BX3000"><b>213000BX3000</b> - INT 21 - PC-MOS/386 v3.0 - INSTALLATION CHECK/GET VERSION</a><br />
<a href="#214302_0"><b>214302</b> - INT 21 - DR DOS 3.41+ internal - GET ACCESS RIGHTS</a><br />
<a href="#214303"><b>214303</b> - INT 21 - DR DOS 3.41+ internal - SET ACCESS RIGHTS AND PASSWORD</a><br />
<a href="#214304"><b>214304</b> - INT 21 U - DR DOS 5.0-6.0 internal - GET ENCRYPTED PASSWORD</a><br />
<a href="#214305"><b>214305</b> - INT 21 U - DR DOS 5.0-6.0 internal - SET EXTENDED FILE ATTRIBUTES</a><br />
<a href="#214306"><b>214306</b> - INT 21 O - DR DOS 6.0 - GET FILE OWNER</a><br />
<a href="#214307"><b>214307</b> - INT 21 O - DR DOS 6.0 - SET FILE OWNER</a><br />
<a href="#214380"><b>214380</b> - INT 21 - Novell DOS 7 - UNDELETE PENDING DELETE FILE</a><br />
<a href="#214381"><b>214381</b> - INT 21 - Novell DOS 7 - PURGE PENDING DELETE FILE</a><br />
<a href="#214382"><b>214382</b> - INT 21 - DR-DOS >7.03 - RESERVED</a><br />
<a href="#214412"><b>214412</b> - INT 21 O - DR DOS 5.0-6.0 - DETERMINE DOS TYPE</a><br />
<a href="#214414"><b>214414</b> - INT 21 OU - DR DOS 5.0-6.0 - SET GLOBAL PASSWORD</a><br />
<a href="#214416"><b>214416</b> - INT 21 OU - DR DOS 5.0-6.0 - HISTORY BUFFER, SHARE, AND HILOAD CONTROL</a><br />
<a href="#214451"><b>214451</b> - INT 21 - Concurrent DOS v3.2+ - INSTALLATION CHECK</a><br />
<a href="#214452"><b>214452</b> - INT 21 - DR DOS 3.41+ - DETERMINE DOS TYPE/GET DR DOS VERSION</a><br />
<a href="#214454"><b>214454</b> - INT 21 U - DR DOS 3.41+ - SET GLOBAL PASSWORD</a><br />
<a href="#214456"><b>214456</b> - INT 21 U - DR DOS 5.0+ - HISTORY BUFFER CONTROL</a><br />
<a href="#214457"><b>214457</b> - INT 21 U - DR DOS 5.0-6.0 - SHARE/HILOAD CONTROL</a><br />
<a href="#214457DXFFFF"><b>214457DXFFFF</b> - INT 21 OU - DR DOS 6.0 - GET SHARE STATUS</a><br />
<a href="#214458"><b>214458</b> - INT 21 U - DR DOS 5.0+ internal - GET POINTER TO INTERNAL VARIABLE TABLE</a><br />
<a href="#214459"><b>214459</b> - INT 21 - DR Multiuser DOS 5.0 - API</a><br />
<a href="#21445A"><b>21445A</b> - INT 21 U - Concurrent DOS etc. - USER GROUP SUPPORT</a><br />
<a href="#214B80"><b>214B80</b> - INT 21 - DR DOS v3.31+ - RUN ALREADY-LOADED KERNEL FILE</a><br />
<a href="#215702_0"><b>215702</b> - INT 21 - OS/2 v1.1+ Family API - DosQFileInfo</a><br />
<a href="#215702BXFFFF"><b>215702BXFFFF</b> - INT 21 - OS/2 v1.1+ Compatibility Box Family API - DosQPathInfo</a><br />
<a href="#215703_0"><b>215703</b> - INT 21 - OS/2 v1.1+ Family API - DosSetFileInfo</a><br />
<a href="#215703BXFFFF"><b>215703BXFFFF</b> - INT 21 - OS/2 v1.1+ Family API - DosSetPathInfo</a><br />
<a href="#215F05_0"><b>215F05</b> - INT 21 - STARLITE architecture - MAP LOCAL DRIVE LETTER TO REMOTE FILE SYSTEM</a><br />
<a href="#215F06_0"><b>215F06</b> - INT 21 - STARLITE architecture - UNMAP DRIVE LETTER</a><br />
<a href="#215F07_0"><b>215F07</b> - INT 21 - STARLITE architecture - MAKE NAMED OBJECT AVAILABLE ON NETWORK</a><br />
<a href="#215F08_0"><b>215F08</b> - INT 21 - STARLITE architecture - REMOVE GLOBAL NETWORK NAME OF OBJECT</a><br />
<a href="#215F09"><b>215F09</b> - INT 21 - STARLITE architecture - BIND TO NETWORK DEVICE</a><br />
<a href="#215F0A"><b>215F0A</b> - INT 21 - STARLITE architecture - DETACH FROM NETWORK DEVICE</a><br />
<a href="#2161--BP6467"><b>2161--BP6467</b> - INT 21 U - OS/2 v1.x FAPI - OS/2 FILE SYSTEM JOIN/SUBST</a><br />
<a href="#2164--DX0000"><b>2164--DX0000</b> - INT 21 U - OS/2 v2.0+ Virtual DOS Machine - ENABLE AUTOMATIC TITLE SWITCH</a><br />
<a href="#2164--DX0001"><b>2164--DX0001</b> - INT 21 U - OS/2 v2.0+ Virtual DOS Machine - SET SESSION TITLE</a><br />
<a href="#2164--DX0002"><b>2164--DX0002</b> - INT 21 U - OS/2 v2.0+ Virtual DOS Machine - GET SESSION TITLE</a><br />
<a href="#2164--DX0003"><b>2164--DX0003</b> - INT 21 U - OS/2 v2.1 Virtual DOS Machine - GET LASTDRIVE</a><br />
<a href="#2164--DX0004"><b>2164--DX0004</b> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET SIZE OF PTDA JFT</a><br />
<a href="#2164--DX0005"><b>2164--DX0005</b> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET SECOND SFT FLAGS WORD</a><br />
<a href="#2164--DX0006"><b>2164--DX0006</b> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - UNLOAD DOSKRNL SYMBOLS & LOAD PROGR</a><br />
<a href="#2164--DX0007"><b>2164--DX0007</b> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET WinOS2 CALL GATE ADDRESS</a><br />
<a href="#2164--DX0008"><b>2164--DX0008</b> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET LOADING MESSAGE</a><br />
<a href="#2164--CX636C"><b>2164--CX636C</b> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API support</a><br />
<a href="#2164--BX0025"><b>2164--BX0025</b> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API DOS32StartSession</a><br />
<a href="#2164--BX00B6"><b>2164--BX00B6</b> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API DosQFSAttach</a><br />
<a href="#2164--BX00CB"><b>2164--BX00CB</b> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API DosForceDelete</a><br />
<a href="#2169_0"><b>2169</b> - INT 21 - DR DOS 5.0 - NULL FUNCTION</a><br />
<a href="#216C01"><b>216C01</b> - INT 21 U - OS/2 v2.0 - "DosOpen2"</a><br />
<a href="#216D_0"><b>216D</b> - INT 21 U - OS/2 v1.x FAPI - "DosMkDir2"</a><br />
<a href="#216D_1"><b>216D</b> - INT 21 U - Novell DOS 7 - NOP</a><br />
<a href="#216E_0"><b>216E</b> - INT 21 U - OS/2 v1.x FAPI - "DosEnumAttrib"</a><br />
<a href="#216F00_0"><b>216F00</b> - INT 21 U - OS/2 v1.x FAPI - "DosQMaxEASize" - GET MAXIMUM SIZE OF EXTENDED ATTR</a><br />
<a href="#2192_0"><b>2192</b> - INT 21 U - PTS-DOS 6.51 & S/DOS 1.0 - ABORT CURRENT PROCESS VIA INT 23</a><br />
<a href="#21E0"><b>21E0</b> - INT 21 - Digital Research DOS Plus - CALL BDOS</a><br />
<a href="#2C_0"><b>2C</b> - INT 2C - STARLITE architecture - KERNEL API</a><br />
<a href="#2E_0"><b>2E</b> - INT 2E UP - Windows NT - NATIVE API</a><br />
<a href="#2F10FE"><b>2F10FE</b> - INT 2F U - DR DOS 6.0+ DELWATCH.EXE - INSTALLATION CHECK</a><br />
<a href="#2F10FF"><b>2F10FF</b> - INT 2F U - DR DOS 5.0 - FIXUP SHARE STUB TABLE???</a><br />
<a href="#2F1250"><b>2F1250</b> - INT 2F U - PTS-DOS - SET MACHINE ID</a><br />
<a href="#2F1251"><b>2F1251</b> - INT 2F U - PTS-DOS - GET MACHINE ID</a><br />
<a href="#2F1252"><b>2F1252</b> - INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - SET SFT INCREMENT</a><br />
<a href="#2F1253"><b>2F1253</b> - INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - GET SFT INCREMENT</a><br />
<a href="#2F1260"><b>2F1260</b> - INT 2F C - PTS-DOS 6.51, S/DOS 1.0+ - "EMPTY" (RESERVED FOR INPUT STRING)</a><br />
<a href="#2F1261"><b>2F1261</b> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET FIRST UMB</a><br />
<a href="#2F1262"><b>2F1262</b> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET DOS COLOR</a><br />
<a href="#2F1263"><b>2F1263</b> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - SET DOS COLOR</a><br />
<a href="#2F1270"><b>2F1270</b> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - "SYSBELL" - EMIT A BEEP</a><br />
<a href="#2F1271"><b>2F1271</b> - INT 2F C - PTS-DOS, S/DOS - RESERVED FOR BEEP</a><br />
<a href="#2F12F0"><b>2F12F0</b> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - BACKDOOR INTERCEPT INT 2Fh CHAIN</a><br />
<a href="#2F12F1"><b>2F12F1</b> - INT 2F - PTS-DOS, S/DOS - RESERVED</a><br />
<a href="#2F12FFBL00"><b>2F12FFBL00</b> - INT 2F - FreeDOS - FDAK-DDT - INSTALLATION CHECK / STATUS CHECK</a><br />
<a href="#2F12FFBL01"><b>2F12FFBL01</b> - INT 2F - FreeDOS - FDAK-DDT - ENABLE FDAK DRIVERS</a><br />
<a href="#2F12FFBL02"><b>2F12FFBL02</b> - INT 2F - FreeDOS - FDAK-DDT - DISABLE FDAK DRIVERS</a><br />
<a href="#2F12FFBL03"><b>2F12FFBL03</b> - INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-ONLY</a><br />
<a href="#2F12FFBL04"><b>2F12FFBL04</b> - INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-WRITE</a><br />
<a href="#2F12FFBL05"><b>2F12FFBL05</b> - INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR ON</a><br />
<a href="#2F12FFBL06"><b>2F12FFBL06</b> - INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR OFF</a><br />
<a href="#2F12FFBL07"><b>2F12FFBL07</b> - INT 2F - FreeDOS - FDAK-DDT - UNINSTALL</a><br />
<a href="#2F12FFBX0000"><b>2F12FFBX0000</b> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BDOS</a><br />
<a href="#2F12FFBX0001"><b>2F12FFBX0001</b> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BDOS</a><br />
<a href="#2F12FFBX0002"><b>2F12FFBX0002</b> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BIOS</a><br />
<a href="#2F12FFBX0003"><b>2F12FFBX0003</b> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BIOS</a><br />
<a href="#2F12FFBX0005"><b>2F12FFBX0005</b> - INT 2F U - DR DOS 6.0+ - BOOT PHASE BROADCASTS FOR MEMORYMAX/RPLOADER/SECURITY</a><br />
<a href="#2F12FFBX0007"><b>2F12FFBX0007</b> - INT 2F U - Novell DOS 7 - SCRIPT.EXE - GET ???</a><br />
<a href="#2F12FFBX0009"><b>2F12FFBX0009</b> - INT 2F - DR DOS 6.0+ IBMBIO.COM - REGISTER ROOT OF UPPER MEMORY LINK</a><br />
<a href="#2F12FFBX0EDC"><b>2F12FFBX0EDC</b> - INT 2F U - Novell DOS 7 - EMM386.EXE - CHECK IF MULTITASKING SUPPORT LOADED???</a><br />
<a href="#2F4001"><b>2F4001</b> - INT 2F C - OS/2 compatibility box - SWITCHING DOS TO BACKGROUND</a><br />
<a href="#2F4002"><b>2F4002</b> - INT 2F C - OS/2 compatibility box - SWITCHING DOS TO FOREGROUND</a><br />
<a href="#2F4010"><b>2F4010</b> - INT 2F - OS/2 v2.0+ - INSTALLATION CHECK / GET VERSION</a><br />
<a href="#2F4011"><b>2F4011</b> - INT 2F - OS/2 - GET VDD API ENTRY POINT</a><br />
<a href="#2FAD00_0"><b>2FAD00</b> - INT 2F U - DR DOS 3.41-5.0, Novell DOS 7 KEYB - INSTALLATION CHECK</a><br />
<a href="#2FAD01_0"><b>2FAD01</b> - INT 2F U - DR DOS 3.41,5.0 KEYB - GET CONFIGURATION</a><br />
<a href="#2FAD01_1"><b>2FAD01</b> - INT 2F U - Novell DOS 7 KEYB - GET/SET??? CONFIGURATION</a><br />
<a href="#2FAD02_0"><b>2FAD02</b> - INT 2F U - Novell DOS 7 KEYB - ???</a><br />
<a href="#2FAF00"><b>2FAF00</b> - INT 2F - WinDOS v2.11 - INSTALLATION CHECK</a><br />
<a href="#2FAF01"><b>2FAF01</b> - INT 2F - WinDOS v2.11 - TURN ON ONLINE MODE</a><br />
<a href="#2FAF02"><b>2FAF02</b> - INT 2F - WinDOS v2.11 - TURN OFF ONLINE MODE</a><br />
<a href="#2FAF03"><b>2FAF03</b> - INT 2F - WinDOS v2.11 - TURN VIDMEM ON</a><br />
<a href="#2FAF04"><b>2FAF04</b> - INT 2F - WinDOS v2.11 - TURN VIDMEM OFF</a><br />
<a href="#2FAF05"><b>2FAF05</b> - INT 2F - WinDOS v2.11 - GET VIDMEM STATE</a><br />
<a href="#2FAF06"><b>2FAF06</b> - INT 2F - WinDOS v2.11 - MAKE PROGRAM UNBREAKABLE</a><br />
<a href="#2FAF07"><b>2FAF07</b> - INT 2F - WinDOS v2.11 - SIGNAL FATAL OVERLAY FAULT</a><br />
<a href="#2FAF08"><b>2FAF08</b> - INT 2F - WinDOS v2.11 - SIGNAL RECOVERABLE OVERLAY FAULT</a><br />
<a href="#2FAF09"><b>2FAF09</b> - INT 2F - WinDOS v2.11 - GET TERMINATED PSP</a><br />
<a href="#2FAF0A"><b>2FAF0A</b> - INT 2F - WinDOS v2.11 - GET MAIN SHELL PSP</a><br />
<a href="#2FAF0B"><b>2FAF0B</b> - INT 2F - WinDOS v2.11 - SIGNAL FATAL ERROR</a><br />
<a href="#2FAF0C"><b>2FAF0C</b> - INT 2F - WinDOS v2.11 - GET OTHER MAIN SHELL PARAMETERS</a><br />
<a href="#2FAF0D"><b>2FAF0D</b> - INT 2F - WinDOS v2.11 - GET CURRENT PARAMETER</a><br />
<a href="#2FAF0E"><b>2FAF0E</b> - INT 2F - WinDOS v2.11 - SET CURRENT PARAMETER BYTE VALUE</a><br />
<a href="#2FAF0F"><b>2FAF0F</b> - INT 2F - WinDOS v2.11 - GET HISTORY SEGMENT</a><br />
<a href="#2FAF10"><b>2FAF10</b> - INT 2F - WinDOS v2.11 - SET HISTORY SEGMENT</a><br />
<a href="#2FAF11"><b>2FAF11</b> - INT 2F - WinDOS v2.11 - FREE XMS BLOCKS</a><br />
<a href="#2FAF12"><b>2FAF12</b> - INT 2F - WinDOS v2.11 - SET XMS IDENTIFICATION VALUE</a><br />
<a href="#2FAF13"><b>2FAF13</b> - INT 2F - WinDOS v2.11 - SET ASSIGN VALUE</a><br />
<a href="#2FAF14"><b>2FAF14</b> - INT 2F - WinDOS v2.11 - GET ASSIGN VALUE</a><br />
<a href="#2FAF15"><b>2FAF15</b> - INT 2F - WinDOS v2.11 - SIGNAL STACK ERROR</a><br />
<a href="#2FAF16"><b>2FAF16</b> - INT 2F - WinDOS v2.11 - GET SIMPLE TRUENAME</a><br />
<a href="#2FAF17"><b>2FAF17</b> - INT 2F - WinDOS v2.11 - QUERY FOR NEW CURRENT DRIVE</a><br />
<a href="#2FAF18"><b>2FAF18</b> - INT 2F - WinDOS v2.11 - SET CTRL-C/CTRL-BREAK DISABLE FLAG</a><br />
<a href="#2FAF19"><b>2FAF19</b> - INT 2F - WinDOS v2.11 - SET HEAD SETTLE FLAG</a><br />
<a href="#2FAF1A"><b>2FAF1A</b> - INT 2F - WinDOS v2.11 - SEARCH FOR NON-FRAGMENTED DISK AREA</a><br />
<a href="#2FEDC8BX0000"><b>2FEDC8BX0000</b> - INT 2F - Novell DOS 7+ - SECURITY.BIN - INSTALLATION CHECK</a><br />
<a href="#38_0"><b>38</b> - INT 38 - PC-MOS/386 v3.0 - API</a><br />
<a href="#40_1"><b>40</b> - INT 40 - Acorn BBC Master 512 - "OSFIND" - OPEN FILE</a><br />
<a href="#41_2"><b>41</b> - INT 41 - Acorn BBC Master 512 - "OSGBPB" - MULTI-BYTE GET/PUT</a><br />
<a href="#42_3"><b>42</b> - INT 42 - Acorn BBC Master 512 - "OSBPUT" - WRITE SINGLE BYTE TO FILE</a><br />
<a href="#43_2"><b>43</b> - INT 43 - Acorn BBC Master 512 - "OSBGET" - READ SINGLE BYTE FROM FILE</a><br />
<a href="#4400"><b>4400</b> - INT 44 - Acorn BBC Master 512 - "OSARGS" - GET/SET FILE PARAMS FOR OPEN FILE</a><br />
<a href="#44_5"><b>44</b> - INT 44 - Acorn BBC Master 512 - "OSARGS" - GET/SET FILE PARAMS FOR OPEN FILE</a><br />
<a href="#45_1"><b>45</b> - INT 45 - Acorn BBC Master 512 - "OSFILE" - READ/WRITE FILE OR DIRECTORY INFO</a><br />
<a href="#46_2"><b>46</b> - INT 46 - Acorn BBC Master 512 - "OSRDCH" - GET CHARACTER FROM CUR INPUT STREAM</a><br />
<a href="#47_1"><b>47</b> - INT 47 - Acorn BBC Master 512 - "OSWRCH" - WRITE CHARACTER TO CUR OUTPUT STREAM</a><br />
<a href="#48_2"><b>48</b> - INT 48 - Acorn BBC Master 512 - "OSNEWL" - SEND NEWLINE TO OUTPUT STREAM</a><br />
<a href="#49_2"><b>49</b> - INT 49 - Acorn BBC Master 512 - "OSASCI" - WRITE CHARACTER TO CUR OUTPUT STREAM</a><br />
<a href="#4A_2"><b>4A</b> - INT 4A - Acorn BBC Master 512 - "OSWORD" - MISC FUNCTIONS USING CONTROL BLOCK</a><br />
<a href="#4B_2"><b>4B</b> - INT 4B - Acorn BBC Master 512 - "OSBYTE" - MISC FUNCTIONS USING REGISTER PARAMS</a><br />
<a href="#4C_2"><b>4C</b> - INT 4C - Acorn BBC Master 512 - "OSCLI" - INTERPRET COMMAND LINE</a><br />
<a href="#80_3"><b>80</b> - INT 80 - Linux - SYSTEM CALLS</a><br />
<a href="#80_4"><b>80</b> - INT 80 - FreeBSD - SYSTEM CALLS</a><br />
<a href="#81_3"><b>81</b> - INT 81 - Paragon Technology PTS/DOS 6.5x, S/DOS 1.0 - API</a><br />
<a href="#D400"><b>D400</b> - INT D4 O - PC-MOS/386 v5.01 - OBSOLETE FUNCTIONS</a><br />
<a href="#D402"><b>D402</b> - INT D4 - PC-MOS/386 v3.0+ - GET SYSTEM CONTROL BLOCK POINTER</a><br />
<a href="#D403"><b>D403</b> - INT D4 - PC-MOS/386 v5.01 - GET/SET EXTENDED DIRECTORY INFORMATION</a><br />
<a href="#D404"><b>D404</b> - INT D4 - PC-MOS/386 v3.0+ - GET TASK CONTROL BLOCK</a><br />
<a href="#D407"><b>D407</b> - INT D4 - PC-MOS/386 v3.0+ - WAIT FOR EVENT</a><br />
<a href="#D410"><b>D410</b> - INT D4 - PC-MOS/386 v3.0+ - ENTER/LEAVE NATIVE 386 EXECUTION MODE</a><br />
<a href="#D411"><b>D411</b> - INT D4 - PC-MOS/386 v3.0+ - ALLOCATE NATIVE MODE MEMORY BLOCK</a><br />
<a href="#D412"><b>D412</b> - INT D4 - PC-MOS/386 v3.0+ - FREE NATIVE MODE MEMORY BLOCK</a><br />
<a href="#D413"><b>D413</b> - INT D4 - PC-MOS/386 v5.01 - GET ALIAS FOR SELECTOR (NATIVE MODE ONLY)</a><br />
<a href="#D416"><b>D416</b> - INT D4 - PC-MOS/386 v5.01 - SET/CLEAR IRQ RESERVATION</a><br />
<a href="#D419"><b>D419</b> - INT D4 - PC-MOS/386 v5.01 - GET TASK ID</a><br />
<a href="#D41A"><b>D41A</b> - INT D4 - PC-MOS/386 v5.01 - GET/SET TASK PRIORITY</a><br />
<a href="#D41B"><b>D41B</b> - INT D4 - PC-MOS/386 v5.01 - GET/SET TIME SLICE</a><br />
<a href="#D41C"><b>D41C</b> - INT D4 - PC-MOS/386 v5.01 - GET/SET KEYBOARD MODE</a><br />
<a href="#D41D"><b>D41D</b> - INT D4 - PC-MOS/386 v5.01 - GET CURRENT PROGRAM NAME</a><br />
<a href="#D41E"><b>D41E</b> - INT D4 - PC-MOS/386 v5.01 - GET CURRENT USERNAME AND SECURITY CLASS</a><br />
<a href="#D41F"><b>D41F</b> - INT D4 - PC-MOS/386 v5.01 - GET TASK PARTITION INFORMATION</a><br />
<a href="#D420"><b>D420</b> - INT D4 - PC-MOS/386 v5.01 - GET PORT AND BAUDRATE INFORMATION</a><br />
<a href="#D421"><b>D421</b> - INT D4 - PC-MOS/386 v5.01 - REMOVE A TASK</a><br />
<a href="#D422"><b>D422</b> - INT D4 - PC-MOS/386 v5.01 - ADD A TASK TO THE SYSTEM</a><br />
<a href="#D423"><b>D423</b> - INT D4 - PC-MOS/386 v5.01 - CHANGE TERMINAL DRIVER</a><br />
<a href="#D424"><b>D424</b> - INT D4 U - PC-MOS/386 v5.01 - GET OPERATING SYSTEM SERIAL NUMBER</a><br />
<a href="#D425"><b>D425</b> - INT D4 - PC-MOS/386 v5.01 - IDENTIFY LOAD ADDRESS OF DEVICE DRIVER LOCATION</a><br />
<a href="#D426"><b>D426</b> - INT D4 - PC-MOS/386 v5.01 - GET SYSTEM CONTROL BLOCK SEGMENT/SELECTOR</a><br />
<a href="#D427"><b>D427</b> - INT D4 - PC-MOS/386 v5.01 - GET TASK CONTROL BLOCK SEGMENT/SELECTOR</a><br />
<a href="#D428"><b>D428</b> - INT D4 - PC-MOS/386 v5.01 - GET CONTROL BLOCK DATA FROM SCB OR TCB</a><br />
<a href="#D429"><b>D429</b> - INT D4 - PC-MOS/386 v5.01 - WRITE CONTROL BLOCK DATA INTO SCB OR TCB</a><br />
<a href="#D42A"><b>D42A</b> - INT D4 - PC-MOS/386 v5.01 - SWAP CONTROL BLOCK DATA OF SCB OR TCB</a><br />
<a href="#D42C"><b>D42C</b> - INT D4 - PC-MOS/386 v5.01 - GET/SET SPOOLER PARAMETERS</a><br />
<a href="#D42D"><b>D42D</b> - INT D4 - PC-MOS/386 v5.01 - GET MAXIMUM TASK SIZE</a><br />
<a href="#E0_3"><b>E0</b> - INT E0 - CP/M-86, Concurrent CP/M, DR Multiuser DOS - FUNCTION CALLS</a><br />
<a href="#E0----CL00"><b>E0----CL00</b> - INT E0 - REAL/32 - "P_TERMCPM" - TERMINATE CALLING PROCESS</a><br />
<a href="#E0----CL01"><b>E0----CL01</b> - INT E0 - REAL/32 - "C_READ" - FETCH CHARACTER FROM THE DEFAULT CONSOLE</a><br />
<a href="#E0----CL02"><b>E0----CL02</b> - INT E0 - REAL/32 - "C_WRITE" - WRITE CHARACTER TO DEFAULT CONSOLE</a><br />
<a href="#E0----CL03"><b>E0----CL03</b> - INT E0 - DR Multiuser DOS - "A_READ" - READ CHARACTER FROM DEFAULT AUX DEVICE</a><br />
<a href="#E0----CL04"><b>E0----CL04</b> - INT E0 - DR Multiuser DOS - "A_WRITE" - WRITE CHARACTER TO DEFAULT AUX DEVICE</a><br />
<a href="#E0----CL05"><b>E0----CL05</b> - INT E0 - REAL/32 - "L_WRITE" - WRITE CHARACTER TO DEFAULT LIST DEVICE</a><br />
<a href="#E0----CL06"><b>E0----CL06</b> - INT E0 - REAL/32 - "C_RAWIO" - PERFORM RAW I/O WITH DEFAULT CONSOLE</a><br />
<a href="#E0----CL07"><b>E0----CL07</b> - INT E0 - DR Multiuser DOS - "A_STATIN" - GET INPUT STATUS OF AUX DEVICE</a><br />
<a href="#E0----CL08"><b>E0----CL08</b> - INT E0 - DR Multiuser DOS - "A_STATOUT" - GET OUTPUT STATUS OF AUX DEVICE</a><br />
<a href="#E0----CL09"><b>E0----CL09</b> - INT E0 - REAL/32 - "C_WRITESTR" - WRITE STRING TO DEFAULT CONSOLE</a><br />
<a href="#E0----CL0A"><b>E0----CL0A</b> - INT E0 - REAL/32 - "C_READSTR" - READ STRING FROM DEFAULT CONSOLE</a><br />
<a href="#E0----CL0B"><b>E0----CL0B</b> - INT E0 - REAL/32 - "C_STAT" - RETURN DEFAULT CONSOLE INPUT STATUS</a><br />
<a href="#E0----CL0C"><b>E0----CL0C</b> - INT E0 - REAL/32 - "S_BDOSVER" - GET BDOS VERSION</a><br />
<a href="#E0----CL2F"><b>E0----CL2F</b> - INT E0 - REAL/32 - "P_CHAIN" - CHAIN PROCESS</a><br />
<a href="#E0----CL35"><b>E0----CL35</b> - INT E0 R - REAL/32 - "MC_MAX" - CP-M/86 ALLOCATE MAXIMUM MEMORY</a><br />
<a href="#E0----CL36"><b>E0----CL36</b> - INT E0 R - REAL/32 - "MC_ABSMAX" - ALLOCATE MAXIMUM MEMORY SEGMENT ABSOLUTE</a><br />
<a href="#E0----CL37"><b>E0----CL37</b> - INT E0 R - REAL/32 - "MC_ALLOC" - CP-M/86 ALLOCATE MEMORY SEGMENT</a><br />
<a href="#E0----CL38"><b>E0----CL38</b> - INT E0 R - REAL/32 - "MC_ABSALLOC" - ALLOCATE MEMORY SEGMENT ABSOLUTE</a><br />
<a href="#E0----CL39"><b>E0----CL39</b> - INT E0 R - REAL/32 - "MC_FREE" - CP-M/86 FREE SPECIFIED MEMORY SEGMENT</a><br />
<a href="#E0----CL3A"><b>E0----CL3A</b> - INT E0 R - REAL/32 - "MC_ALLFREE" - CP-M/86 FREE ALL MEMORY</a><br />
<a href="#E0----CL3B"><b>E0----CL3B</b> - INT E0 u - REAL/32 - "P_LOAD" - LOAD .CMD FILE INTO MEMORY</a><br />
<a href="#E0----CL40"><b>E0----CL40</b> - INT E0 - REAL/32 - "N_LOGON" - LOG ONTO A SERVER</a><br />
<a href="#E0----CL41"><b>E0----CL41</b> - INT E0 - REAL/32 - "N_LOGON" - LOG OFF A SERVER</a><br />
<a href="#E0----CL44"><b>E0----CL44</b> - INT E0 - REAL/32 - "N_STAT" - GET NETWORK STATUS</a><br />
<a href="#E0----CL45"><b>E0----CL45</b> - INT E0 - REAL/32 - "N_RCT" - GET REQUESTOR CONFIGURATION TABLE</a><br />
<a href="#E0----CL47"><b>E0----CL47</b> - INT E0 - REAL/32 - "N_SCT" - GET SERVER CONFIGURATION TABLE</a><br />
<a href="#E0----CL48"><b>E0----CL48</b> - INT E0 - REAL/32 - "N_ERRMODE" - SET NETWORK ERROR MODE</a><br />
<a href="#E0----CL59"><b>E0----CL59</b> - INT E0 - ConcCP/M,DR Multiuser DOS - "S_MEMORY" - RESERVE MEMORY IN GLOBAL AREA</a><br />
<a href="#E0----CL5C"><b>E0----CL5C</b> - INT E0 - REAL/32 - "P_PATH" - SCAN PATH FOR EXECUTABLE FILE</a><br />
<a href="#E0----CL5D"><b>E0----CL5D</b> - INT E0 - REAL/32 - "P_EXEC" - EXECUTE CHILD PROCESS</a><br />
<a href="#E0----CL5E"><b>E0----CL5E</b> - INT E0 - REAL/32 - "P_EXITCODE" - GET/SET PROCESS EXIT CODE</a><br />
<a href="#E0----CL6B"><b>E0----CL6B</b> - INT E0 - REAL/32 - "S_SERIAL" - GET OS SERIAL NUMBER</a><br />
<a href="#E0----CL6D"><b>E0----CL6D</b> - INT E0 - REAL/32 - "C_MODE" - GET/SET CONSOLE MODE</a><br />
<a href="#E0----CL6E"><b>E0----CL6E</b> - INT E0 - REAL/32 - "C_DELIMIT" - GET/SET STRING DELIMITER</a><br />
<a href="#E0----CL6F"><b>E0----CL6F</b> - INT E0 - REAL/32 - "C_WRITEBLK" - WRITE BLOCK TO DEFAULT CONSOLE</a><br />
<a href="#E0----CL70"><b>E0----CL70</b> - INT E0 - REAL/32 - "L_WRITEBLK" - WRITE BLOCK TO DEFAULT LIST (PRINTER) DEVICE</a><br />
<a href="#E0----CL71"><b>E0----CL71</b> - INT E0 R - ConcCP/M,DR Multiuser DOS - EXECUTE DOS-COMPATIBLE FUNCTIONS</a><br />
<a href="#E0----CL73"><b>E0----CL73</b> - INT E0 - GSX-86, GEM/1, GEM/2 - API</a><br />
<a href="#E0----CL80"><b>E0----CL80</b> - INT E0 - REAL/32 - "M_ALLOC" - ALLOCATE MEMORY</a><br />
<a href="#E0----CL81"><b>E0----CL81</b> - INT E0 - REAL/32 - "M_FREE" - DEALLOCATE MEMORY</a><br />
<a href="#E0----CL84"><b>E0----CL84</b> - INT E0 - REAL/32 - "DEV_WAITFLAG" - WAIT ON SYSTEM FLAG</a><br />
<a href="#E0----CL85"><b>E0----CL85</b> - INT E0 - REAL/32 - "DEV_SETFLAG" - SET SYSTEM FLAG</a><br />
<a href="#E0----CL86"><b>E0----CL86</b> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_MAKE" - CREATE MESSAGE QUEUE</a><br />
<a href="#E0----CL87"><b>E0----CL87</b> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_OPEN" - OPEN MESSAGE QUEUE</a><br />
<a href="#E0----CL88"><b>E0----CL88</b> - INT E0 - REAL/32 - "Q_DELETE" - DELETE SYSTEM QUEUE</a><br />
<a href="#E0----CL89"><b>E0----CL89</b> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_READ" - READ MESSAGE QUEUE</a><br />
<a href="#E0----CL8A"><b>E0----CL8A</b> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_CREAD" - CONDITIONALLY READ MSG QUEUE</a><br />
<a href="#E0----CL8B"><b>E0----CL8B</b> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_WRITE" - WRITE MESSAGE QUEUE</a><br />
<a href="#E0----CL8C"><b>E0----CL8C</b> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_CWRITE" - CONDITIONALLY WRITE MSG QUEUE</a><br />
<a href="#E0----CL8E"><b>E0----CL8E</b> - INT E0 - ConcCP/M,DR Multiuser DOS - "P_DISPATCH" - CALL DISPATCHER</a><br />
<a href="#E0----CL8F"><b>E0----CL8F</b> - INT E0 - REAL/32 - "P_TERM" - TERMINATE CALLING PROCESS</a><br />
<a href="#E0----CL90"><b>E0----CL90</b> - INT E0 - REAL/32 - "P_CREATE" - CREATE A PROCESS</a><br />
<a href="#E0----CL91"><b>E0----CL91</b> - INT E0 - ConcCP/M,DR Multiuser DOS - "P_PRIORITY" - SET PROCESS PRIORITY</a><br />
<a href="#E0----CL92"><b>E0----CL92</b> - INT E0 - ConcCP/M,DR Multiuser DOS - "C_ATTACH" - ATTACH TO DEFAULT CONSOLE</a><br />
<a href="#E0----CL93"><b>E0----CL93</b> - INT E0 - ConcCP/M,DR Multiuser DOS - "C_DETACH" - DETACH FROM DEFAULT CONSOLE</a><br />
<a href="#E0----CL94"><b>E0----CL94</b> - INT E0 - REAL/32 - "C_SET" - SET PROCESS'S DEFAULT CONSOLE</a><br />
<a href="#E0----CL95"><b>E0----CL95</b> - INT E0 - REAL/32 - "C_ASSIGN" - ASSIGN DEFAULT CONSOLE TO ANOTHER PROCESS</a><br />
<a href="#E0----CL96"><b>E0----CL96</b> - INT E0 - REAL/32 - "P_CLI" - RUN COMMAND LINE INTERFACE</a><br />
<a href="#E0----CL99"><b>E0----CL99</b> - INT E0 - REAL/32 - "C_GET" - GET DEFAULT CONSOLE</a><br />
<a href="#E0----CL9A"><b>E0----CL9A</b> - INT E0 - REAL/32 - "S_SYSDAT" - GET SYSTEM DATA AREA</a><br />
<a href="#E0----CL9C"><b>E0----CL9C</b> - INT E0 - REAL/32 - "P_PDADR" - GET ADDRESS OF PROCESS DESCRIPTOR</a><br />
<a href="#E0----CL9D"><b>E0----CL9D</b> - INT E0 - REAL/32 - "P_ABORT" - ABORT PROCESS BY NAME OR DESCRIPTOR</a><br />
<a href="#E0----CL9E"><b>E0----CL9E</b> - INT E0 - REAL/32 - "L_ATTACH" - ATTACH TO DEFAULT LIST DEVICE</a><br />
<a href="#E0----CL9F"><b>E0----CL9F</b> - INT E0 - REAL/32 - "L_DETACH" - DETACH FROM DEFAULT LIST DEVICE</a><br />
<a href="#E0----CLA0"><b>E0----CLA0</b> - INT E0 - REAL/32 - "L_SET" - SET DEFAULT LIST DEVICE</a><br />
<a href="#E0----CLA1"><b>E0----CLA1</b> - INT E0 - REAL/32 - "L_CATTACH" - CONDITIONALLY ATTACH TO DEFAULT LIST DEVICE</a><br />
<a href="#E0----CLA2"><b>E0----CLA2</b> - INT E0 - REAL/32 - "C_CATTACH" - CONDITIONALLY ATTACH TO DEFAULT CONSOLE</a><br />
<a href="#E0----CLA3"><b>E0----CLA3</b> - INT E0 - ConcCP/M,DR Multiuser DOS,REAL/32 - "S_OSVER" - GET OS VERSION</a><br />
<a href="#E0----CLA4"><b>E0----CLA4</b> - INT E0 - REAL/32 - "L_GET" - GET DEFAULT LIST (PRINTER) DEVICE</a><br />
<a href="#E0----CLA5"><b>E0----CLA5</b> - INT E0 - DR Multiuser DOS - "A_ATTACH" - ATTACH AUX DEVICE</a><br />
<a href="#E0----CLA6"><b>E0----CLA6</b> - INT E0 - DR Multiuser DOS - "A_DETACH" - DETACH FROM AUX DEVICE</a><br />
<a href="#E0----CLA7"><b>E0----CLA7</b> - INT E0 - DR Multiuser DOS - "A_CATTACH" - CONDITIONALLY ATTACH TO AUX DEVICE</a><br />
<a href="#E0----CLA8"><b>E0----CLA8</b> - INT E0 - DR Multiuser DOS - "A_SET" - SET DEFAULT AUX DEVICE NUMBER</a><br />
<a href="#E0----CLA9"><b>E0----CLA9</b> - INT E0 - DR Multiuser DOS - "A_GET" - GET DEFAULT AUX DEVICE NUMBER</a><br />
<a href="#E0----CLAC"><b>E0----CLAC</b> - INT E0 - DR Multiuser DOS - "A_READBLK" - READ STRING FROM AUX DEVICE</a><br />
<a href="#E0----CLAD"><b>E0----CLAD</b> - INT E0 - DR Multiuser DOS - "A_WRITEBLK" - WRITE STRING TO AUX DEVICE</a><br />
<a href="#E0----CLB0"><b>E0----CLB0</b> - INT E0 - DR Multiuser DOS - "A_CONFIG" - GET/SET AUX DEVICE PARAMETERS</a><br />
<a href="#E0----CLB1"><b>E0----CLB1</b> - INT E0 - DR Multiuser DOS - "A_CONTROL" - GET/SET AUX CONTROL PARAMETERS</a><br />
<a href="#E0----CLB2"><b>E0----CLB2</b> - INT E0 - DR Multiuser DOS - "A_BREAK" - SEND BREAK TO AUX DEVICE</a><br />
<a href="#E0----CLB3"><b>E0----CLB3</b> - INT E0 R - REAL/32 - "MP_ALLOC" - ALLOCATE PHYSICAL MEMORY</a><br />
<a href="#E0----CLB4"><b>E0----CLB4</b> - INT E0 R - REAL/32 - "MP_FREE" - DEALLOCATE PHYSICAL MEMORY</a><br />
<a href="#E0----CLB5"><b>E0----CLB5</b> - INT E0 R - REAL/32 - "MP_MAP" - MAP PHYSICAL MEMORY</a><br />
<a href="#E0----CLB6"><b>E0----CLB6</b> - INT E0 - REAL/32 - "Q_NCREAD" - CONDITIONALLY NONDESTRUCTIVELY READ QUEUE</a><br />
<a href="#E0----CLB7"><b>E0----CLB7</b> - INT E0 - REAL/32 - "DEV_TWAITFLAG" - TIMED WAIT ON SYSTEM FLAG</a><br />
<a href="#E0----CLB8"><b>E0----CLB8</b> - INT E0 - REAL/32 - "DEV_MAP" - GET/SET SERIAL/PARALLEL PORT MAPPINGS</a><br />
<a href="#E0----CLB9"><b>E0----CLB9</b> - INT E0 - REAL/32 - "L_TIMEOUT" - SET LIST DEVICE TIMEOUT</a><br />
<a href="#E0----CLBA"><b>E0----CLBA</b> - INT E0 - REAL/32 - "A_TIMEOUT" - SET AUX DEVICE TIMEOUT</a><br />
<a href="#E0----CLBD"><b>E0----CLBD</b> - INT E0 - DR Multiuser DOS - "P_DELAY" - DELAY EXECUTION</a><br />
<a href="#E1_1"><b>E1</b> - INT E1 - MP/M-86, - ALTERNATE CP/M-86 FUNCTION CALLS</a><br />
<a href="#E6_0"><b>E6</b> - INT E6 C - CP/M-86 v1.1 - XIOS INTERRUPT / UNKNOWN DISK DRIVE</a><br />
<a href="#E600"><b>E600</b> - INT E6 - Linux DOSEMU - INSTALLATION CHECK</a><br />
<a href="#E601"><b>E601</b> - INT E6 - Linux DOSEMU - REGISTER DUMP</a><br />
<a href="#E602"><b>E602</b> - INT E6 - Linux DOSEMU - SET I/O PORT PERMISSIONS</a><br />
<a href="#E605"><b>E605</b> - INT E6 - Linux DOSEMU - STARTUP BANNER</a><br />
<a href="#E612"><b>E612</b> - INT E6 - Linux DOSEMU - SET "HOGTHRESHOLD"</a><br />
<a href="#E622"><b>E622</b> - INT E6 - Linux DOSEMU - GET EMS STATUS</a><br />
<a href="#E630"><b>E630</b> - INT E6 - Linux DOSEMU - SET BOOTDISK FLAG</a><br />
<a href="#E650"><b>E650</b> - INT E6 - Linux DOSEMU - EXECUTE UNIX COMMAND</a><br />
<a href="#E651"><b>E651</b> - INT E6 - Linux DOSEMU - EXECUTE DOS COMMAND FROM UNIX</a><br />
<a href="#E680"><b>E680</b> - INT E6 - Linux DOSEMU - GET CURRENT UNIX DIRECTORY</a><br />
<a href="#E681"><b>E681</b> - INT E6 - Linux DOSEMU - CHANGE CURRENT UNIX DIRECTORY</a><br />
<a href="#E6FF"><b>E6FF</b> - INT E6 - Linux DOSEMU - TERMINATE</a><br />
<a href="#EF----CX00C8"><b>EF----CX00C8</b> - INT EF - GEM - AES INTERFACE</a><br />
<a href="#EF----CX00C9"><b>EF----CX00C9</b> - INT EF - GEM - AES INTERFACE</a><br />
<a href="#EF----CX0473"><b>EF----CX0473</b> - INT EF - GEM - VDI INTERFACE</a><br />

<hr />

<a href="#1500_1" name="1500_1"><b>1500</b></a> - INT 15 - VMiX v2+ - INSTALLATION CHECK<br />
<pre>
INT 15 - VMiX v2+ - INSTALLATION CHECK
	AH = 00h
Return: DX = 0798h if installed
	    AX = version (AH = major, AL = minor)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1501_1" name="1501_1"><b>1501</b></a> - INT 15 - VMiX - "sys_chanreq" - I/O CHANNEL OBJECT MANAGER<br />
<pre>
INT 15 - VMiX - "sys_chanreq" - I/O CHANNEL OBJECT MANAGER
	AH = 01h
	STACK:	WORD	object ID of requestor
		DWORD	pointer to ASCIZ name of requested method
			"assign" assign channel to object
			"deassign" deassign channel
			"cursor" set cursor on/off
			"init" initialize comm port
			"open" open I/O channel
			"position" set cursor position
			"receive" get buffered packet from comm port
			"send" send buffered packet to comm port
			"vio" set current virtual I/O to specified channel
			"window" make window at cursor position
		---if "assign"---
		 WORD	object UID
		 WORD	caller UID/PID
		 DWORD	CSL with port
		---if "deassign"---
		 WORD	channel ID
		---if "cursor"---
		 WORD	channel ID (must be a SRCSINK)
		 WORD	new state (0000h off, 0001h on)
		---if "init"---
		 WORD	channel ID (must be a SRCSINK)
		 WORD	comm port number (00h-03h)
		 WORD	UART init code
		---if "open"---
		 WORD	channel ID
		---if "position"---
		 WORD	channel ID (must be a SRCSINK)
		 WORD	position (high byte = row, low byte = column)
		---if "receive"---
		 DWORD	pointer to buffer
		---if "send"---
		 WORD	length of buffer
		 DWORD	pointer to buffer
		---if "vio"---
		 WORD	channel ID (must be a SRCSINK)
		---if "window"---
		 WORD	top left (high byte = row, low byte = column)
		 WORD	bottom right (high byte = row, low byte = column)
Return: DX:AX -&gt; IRP structure or 0000h:0000h
SeeAlso: AH=00h"VMiX",AH=02h"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1502_1" name="1502_1"><b>1502</b></a> - INT 15 - VMiX - "sys_memreq" - MEMORY OBJECT MANAGER<br />
<pre>
INT 15 - VMiX - "sys_memreq" - MEMORY OBJECT MANAGER
	AH = 02h
	STACK:	WORD	object ID of requestor
		DWORD	pointer to ASCIZ name of requested method
			"assign" allocate low memory block
			"assign extended" allocate extended memory pages
			"assign gdt" allocate GDT selector
			"paged" allocate low paged memory
			"paged extended" alllocate extended memory pages
			"deassign" free memory block
			"deassign gdt" free GDT selector
			"getvpage" get physical address for virtual page
			"setvpage" set physical address for virtual page
			"info" get VMiX memory usage info block
			"move" move contents of 32-bit memory
			"newmcb" make new DOS memory control block
			"owner" get process ID of MCB or PSP owner
			"umb" allocate upper memory block
			"video" toggle system use of video memory and get stat
		---if "assign"---
		 WORD	number of objects
		 WORD	size in bytes (multiple of 512 bytes)
		---if "assign extended"---
		 WORD	number of objects
		 WORD	size in bytes (multiple of 4K)
		---if "assign gdt"---
		 WORD	access type (low byte)
		 WORD	segment size in paragraphs
		 DWORD	pointer to start of physical segment
		---if "paged"---
		 WORD	number of 512-byte pages
		---if "paged extended"
		 WORD	number of 4K pages
		---if "deassign"---
		 DWORD	pointer returned by previous allocation call
		---if "deassign gdt"---
		 WORD	GDT selector
		---if "getvpage"---
		 WORD	owner's process ID
		 DWORD	pointer to buffer for page structure (struct VPGE)
		---if "setvpage"---
		 WORD	owner's process ID
		 DWORD	pointer to new page structure (struct VPGE)
		---if "info"---
		 no additional arguments
		---if "move"
		 DWORD	32-bit source address
		 DWORD	32-bit destination address
		 WORD	number of words to move
		---if "newmcb"---
		 DWORD	pointer to new MCB's location
		 WORD	size of memory block
		 DWORD	pointer to ASCIZ name string (max 8 chars)
		---if "owner"---
		 WORD	MCB or PSP segment
		---if "umb"---
		 WORD	size in paragraphs
		---if "video"---
		 no additional arguments
Return: DX:AX -&gt; memory block or VPGE struct or 0000h:0000h
SeeAlso: AH=00h"VMiX",AH=01h"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1503_1" name="1503_1"><b>1503</b></a> - INT 15 - VMiX - "sys_pinput" - PROMPTED CONSOLE INPUT<br />
<pre>
INT 15 - VMiX - "sys_pinput" - PROMPTED CONSOLE INPUT
	AH = 03h
	STACK:	DWORD	pointer to ASCII prompt
		WORD	field outline character
		WORD	length of input field (max 7Fh)
		DWORD	address of pointer to input buffer
Return: AX = length of input (input buffer is padded with blanks)
SeeAlso: AH=04h"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1504_1" name="1504_1"><b>1504</b></a> - INT 15 - VMiX - "sys_vprintf" - FORMATTED OUTPUT TO STREAM<br />
<pre>
INT 15 - VMiX - "sys_vprintf" - FORMATTED OUTPUT TO STREAM
	AH = 04h
	STACK:	DWORD	control string
		DWORD	array of arguments
Return: nothing
SeeAlso: AH=03h"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1505_1" name="1505_1"><b>1505</b></a> - INT 15 - VMiX - "sys_getpid" - GET PROCESS ID OF CURRENT PROCESS<br />
<pre>
INT 15 - VMiX - "sys_getpid" - GET PROCESS ID OF CURRENT PROCESS
	AH = 05h
Return: AX = process ID
SeeAlso: AH=06h"VMiX",AH=0Bh"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1506_0" name="1506_0"><b>1506</b></a> - INT 15 - VMiX - "sys_getpcb" - GET POINTER TO PROCESS CONTROL BLOCK<br />
<pre>
INT 15 - VMiX - "sys_getpcb" - GET POINTER TO PROCESS CONTROL BLOCK
	AH = 06h
	STACK:	WORD	process ID
Return: DX:AX -&gt; process control block
SeeAlso: AH=05h"VMiX",AH=07h"VMiX",AH=08h"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1507" name="1507"><b>1507</b></a> - INT 15 - VMiX - "sys_getocb" - GET POINTER TO OBJECT CONTROL BLOCK<br />
<pre>
INT 15 - VMiX - "sys_getocb" - GET POINTER TO OBJECT CONTROL BLOCK
	AH = 07h
	STACK:	WORD	object type
Return: DX:AX -&gt; object control block
SeeAlso: AH=06h"VMiX",AH=08h"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1508" name="1508"><b>1508</b></a> - INT 15 - VMiX - "sys_getccb" - GET CHANNEL CONTROL BLOCK<br />
<pre>
INT 15 - VMiX - "sys_getccb" - GET CHANNEL CONTROL BLOCK
	AH = 08h
	STACK:	WORD	channel ID
Return: DX:AX -&gt; channel control block
SeeAlso: AH=06h"VMiX",AH=07h"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1509" name="1509"><b>1509</b></a> - INT 15 - VMiX - "sys_getqueue" - GET ID OF QUEUED ELEMENT<br />
<pre>
INT 15 - VMiX - "sys_getqueue" - GET ID OF QUEUED ELEMENT
	AH = 09h
	STACK:	WORD	queue ID (0 = process queue, 1 = object, 3 = type)
		WORD	subqueue ID
Return: AX = queue ID
SeeAlso: AH=0Ah"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#150A" name="150A"><b>150A</b></a> - INT 15 - VMiX - "sys_qetqnext" - GET ID OF NEXT QUEUED ELEMENT<br />
<pre>
INT 15 - VMiX - "sys_qetqnext" - GET ID OF NEXT QUEUED ELEMENT
	AH = 0Ah
	STACK:	WORD	queue ID (0 = process queue, 1 = object, 3 = type)
		WORD	ID of current element in queue chain
Return: AX = ID of next element
SeeAlso: AH=09h"VMiX",AH=0Fh"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#150B" name="150B"><b>150B</b></a> - INT 15 - VMiX - "sys_sysreq" - SYSTEM CONFIGURATION MANAGER<br />
<pre>
INT 15 - VMiX - "sys_sysreq" - SYSTEM CONFIGURATION MANAGER
	AH = 0Bh
	STACK:	WORD	caller's UID
		DWORD	pointer to ASCIZ name of requested method
			"abort" abort current send/receive on comm port
			"block" start/end critical section
			"close" terminate interrupt-drive comm I/O
			"open" prepare comm port for interrupt-driven I/O
			"delay" set delay timer and wait
			"hibernate" put process to sleep
			"ints" enable/disable interrupt-driven INT 14h
			"length" get current send/receive buffer offsets
			"kswitch" switch stacks
			"numproc" get number of active processes
			"protocol" set protocol function for comm interrupts
			"relocate" set/reset VMiX flag for relocating to himem
			"status" get current open comm port status
			"wake" awaken a process
			"xport" get comm port polled for logins
		---if "abort"---
		 no additional arguments
		---if "block"---
		 WORD	0000h end, 0001h start
		---if "close"---
		 no additional arguments
		---if "open"---
		 WORD	comm port (00h-03h)
		 WORD	BIOS parameter byte (see #00300 at INT 14/AH=00h),
			except bits 7-5: 000 = 19200, 001 = 38400, 011 = 115200
		---if "delay"---
		 WORD	time in seconds
		---if "hibernate"---
		 WORD	process ID
		---if "ints"---
		 WORD	0000h if no, 0001h if yes
		---if "length","numproc","relocate","status","xport"---
		 no additional arguments
		---if "kswitch"---
		 DWORD	pointer to new stack
		---if "protocol"---
		 DWORD	pointer to function (must be in low "assign"ed memory
			when in 386 mode)
		---if "wake"---
		 WORD	process ID
Return: DX:AX -&gt; result or 0000h:0000h
		---if "length"---
		 BYTE	receive offset
		 BYTE	send offset
		---if "kswitch"---
		 DWORD	old stack pointer
		---if "numproc"---
		 WORD	number of active processes
		---if "status"---
		 current open comm port status
		---if "xport"---
		 current comm port being polled for logins
Note:	the "delay" command reportedly disables the keyboard until the delay
	  completes
SeeAlso: AH=05h"VMiX",AH=0Eh"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#150C" name="150C"><b>150C</b></a> - INT 15 - VMiX - "sys_getstack" - GET POINTER TO PROCESS TSS STACK<br />
<pre>
INT 15 - VMiX - "sys_getstack" - GET POINTER TO PROCESS TSS STACK
	AH = 0Ch
	STACK:	WORD	process ID
Return: DX:AX -&gt; TSS stack store
SeeAlso: AH=00h"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#150D" name="150D"><b>150D</b></a> - INT 15 - VMiX - "sys_spawn" - START A CHILD PROCESS JOB SHELL<br />
<pre>
INT 15 - VMiX - "sys_spawn" - START A CHILD PROCESS JOB SHELL
	AH = 0Dh
	STACK:	DWORD	ASCIZ string starting with requested I/O channel and
			followed by standard VMiX shell command string
Return: AX = process ID or error code "SYS_ERROR"
Note:	the maximum string length is 7Fh characters
SeeAlso: AH=0Eh"VMIX",AH=11h"VMiX",INT 21/AH=4Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#150E" name="150E"><b>150E</b></a> - INT 15 - VMiX - "sys_kill" - HARD TERMINATE PROCESS<br />
<pre>
INT 15 - VMiX - "sys_kill" - HARD TERMINATE PROCESS
	AH = 0Eh
	STACK:	WORD	process ID
Return: AX = status (SYS_OK or SYS_ERROR)
SeeAlso: AH=0Bh"VMiX",AH=0Dh"VMIX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#150F_0" name="150F_0"><b>150F</b></a> - INT 15 - VMiX - "sys_getqkey" - GET KEY FIELD OF QUEUED ELEMENT<br />
<pre>
INT 15 - VMiX - "sys_getqkey" - GET KEY FIELD OF QUEUED ELEMENT
	AH = 0Fh
	STACK:	WORD	queue ID (0 = process queue, 1 = object q, 3 = type q)
		WORD	ID of element in queue chain
Return: AX = key
SeeAlso: AH=0Ah"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#1510" name="1510"><b>1510</b></a> - INT 15 - VMiX - "sys_virtual" - EXECUTE CONFORMING FUNCTION IN PROTECTED MODE<br />
<pre>
INT 15 - VMiX - "sys_virtual" - EXECUTE CONFORMING FUNCTION IN PROTECTED MODE
	AH = 10h
	STACK:	DWORD	pointer to function
	      N WORDs	function args
Return: AX = function's return value??? (not specified in documentation)
Note:	while the function is executing, the following global descriptors are
	  available:
		20h stack segment
		38h code segment of function
		40h data alias for function's code segment
	  additional GDT descriptors can be allocated using AH=02h with
	  function "assign gdt"
SeeAlso: AH=02h"VMiX",AH=51h"VMiX"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#152010" name="152010"><b>152010</b></a> - INT 15 - OS HOOK - SETUP SYSREQ ROUTINE (AT,XT286,PS50+)<br />
<pre>
INT 15 - OS HOOK - SETUP SYSREQ ROUTINE (AT,XT286,PS50+)
	AX = 2010h
	???
Return: ???
SeeAlso: AX=2011h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#152011" name="152011"><b>152011</b></a> - INT 15 - OS HOOK - COMPLETION OF SYSREQ FUNCTION (AT,XT286,PS50+)<br />
<pre>
INT 15 - OS HOOK - COMPLETION OF SYSREQ FUNCTION (AT,XT286,PS50+)
	AX = 2011h
	???
Return: ???
SeeAlso: AX=2010h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#20" name="20"><b>20</b></a> - INT 20 - Minix - SEND/RECEIVE MESSAGE<br />
<pre>
INT 20 - Minix - SEND/RECEIVE MESSAGE
	AX = process ID of other process
	BX -&gt; message
	CX = operation (1 send, 2 receive, 3 send&receive)
Program: Minix is a Version 7 Unix-compatible operating system by Andrew
	  Tanenbaum
Note:	the message contains the system call number (numbered as in V7
	  Unix(tm)) and the call parameters

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2118_0" name="2118_0"><b>2118</b></a> - INT 21 - U - PTS-DOS 6.51 & S/DOS 1.0 - EXTENDED RENAME FILE USING FCB<br />
<pre>
INT 21 - U - PTS-DOS 6.51 & S/DOS 1.0 - EXTENDED RENAME FILE USING FCB
	AH = 18h
	DS:DX -&gt; modified FCB (see also #01345)
Return: AL = status
	     00h successfully renamed
	     FFh no matching files,file is read-only, or new name already exists
Notes:	This function is provided by Paragon Technology Systems S/DOS 1.0
	  (and most probably also PTS-DOS 6.51, maybe even earlier). It uses
	  the same code as for function INT 21/AH=17h, but additionally sets
	  an internal "SERVER" flag on entry. Apparently this results in
	  different usage of attributes and wildcards.
	It is currently unknown if this function is also supported by
	  PhysTechSoft's PTS-DOS 6.60, 6.70, or 2000.
SeeAlso: AH=17h,AH=0Fh,AH=13h,AX=4303h,AH=56h,INT 2F/AX=1111h,INT21/AH=5Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2120_0" name="2120_0"><b>2120</b></a> - INT 21 - S/DOS 1.0+ & PTS-DOS 6.51+ - GET OEM REVISION<br />
<pre>
INT 21 - S/DOS 1.0+ & PTS-DOS 6.51+ - GET OEM REVISION
	AH = 20h
	AL = which OEM code to retrieve
	    00h get PTS OEM code
		Return: CF cleared
			AL = OEM code (currently always 00h)
	    01h get PTS OEM revision code
		Return: CF cleared
			AL = revision code (default is 00h, but may vary)
Desc:	S/DOS is a reduced and modified PTS-DOS 6.51 release with source code
	  on CD
Note:	This function is provided by S/DOS 1.0 (and is most probably also
	  supported with PTS-DOS 6.51+, maybe even earlier).  It clears the
	  CF flag for all other AL arguments, too. However, AL = 00h and 01h
	  are handled separately. The revision code can be individually defined
	  in the MAKEFILE at compilation time.
	The PTS OEM code does not correlate with the DOS OEM code returned
	  by INT 21/AH=30h, likewise the PTS OEM revision does not correlate
	  with the DOS revision returned by INT 21/AX=3306h.
SeeAlso: INT 21/AH=30h,INT 21/AX=3306h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#213000BX3000" name="213000BX3000"><b>213000BX3000</b></a> - INT 21 - PC-MOS/386 v3.0 - INSTALLATION CHECK/GET VERSION<br />
<pre>
INT 21 - PC-MOS/386 v3.0 - INSTALLATION CHECK/GET VERSION
	AX = 3000h
	BX = 3000h
	CX = DX = 3000h
Return: AX = PC-MOS version
Program: PC-MOS/386 is a multitasking/multiuser MS-DOS-compatible operating
	  system by The Software Link, Inc.
SeeAlso: AH=30h,INT D4/AH=02h,INT D4/AH=10h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214302_0" name="214302_0"><b>214302</b></a> - INT 21 - DR DOS 3.41+ internal - GET ACCESS RIGHTS<br />
<pre>
INT 21 - DR DOS 3.41+ internal - GET ACCESS RIGHTS
	AX = 4302h
	DS:DX -&gt; ASCIZ pathname
Return: CF clear if successful
	    CX = access rights (see #01421)
	    AX = CX (DR DOS 5.0)
	CF set on error
	    AX = error code
Desc:	Determine which operations the calling program may perform on a
	  specified file without being required to provide a password.
Notes:	this protection scheme has been coordinated on all current Digital
	  Research/Novell operating systems (DR DOS 3.41+, DRMDOS 5.x, and
	  FlexOS 2+)
	this function is documented in DR DOS 6.0 and corresponds to the
	  "Get/Set File Attributes" function, subfunction 2, documented in
	  Concurrent DOS.
	only FlexOS actually uses the "execution" bits; DR DOS 3.41+ treats
	  them as "read" bits.
	DR DOS 3.41-5.x only use bits 0-3.  Only DR DOS 6.0 using a
	  DRMDOS 5.x security system allowing for users and groups uses bits
	  4-11.
SeeAlso: AX=4303h,#01354 at INT 21/AH=11h

Bitfields for DR DOS file access rights:
Bit(s)	Description	(Table 01421)
 0	owner delete requires password
 1	owner execution requires password (FlexOS)
 2	owner write requires password
 3	owner read requires password
 4	group delete requires password
 5	group execution requires password (FlexOS)
 6	group write requires password
 7	group read requires password
 8	world delete requires password
 9	world execution requires password (FlexOS)
 10	world write requires password
 11	world read requires password

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214303" name="214303"><b>214303</b></a> - INT 21 - DR DOS 3.41+ internal - SET ACCESS RIGHTS AND PASSWORD<br />
<pre>
INT 21 - DR DOS 3.41+ internal - SET ACCESS RIGHTS AND PASSWORD
	AX = 4303h
	CX = access rights
	     bits 11-0: access rights (see #01421)
	     bit 15: new password is to be set
	DS:DX -&gt; ASCIZ pathname
	[DTA] = new password if CX bit 15 is set (blank-padded to 8 characters)
Return: CF clear if successful
	CF set on error
	    AX = error code
Notes:	if the file is already protected, the old password must be added after
	  the pathname, separated by a ";".  As with all password handling in
	  DR DOS, the old password is processed by the kernel, not any
	  applications or utilities making the call.
	this function is documented in DR DOS 6.0 and corresponds to the
	  "Get/Set File Attributes" function, subfunction 3, documented in
	  Concurrent DOS.
SeeAlso: AH=0Fh,AH=17h,AX=4302h"DR DOS",AX=4305h,AX=4454h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214304" name="214304"><b>214304</b></a> - INT 21 U - DR DOS 5.0-6.0 internal - GET ENCRYPTED PASSWORD<br />
<pre>
INT 21 U - DR DOS 5.0-6.0 internal - GET ENCRYPTED PASSWORD
	AX = 4304h
	DS:DX -&gt; ASCIZ filename
	???
Return: CF clear if successful
	    CX = AX = 0000h if no password assigned to file
	CF set on error
	    AX = error code (see #01680 at AH=59h/BX=0000h)
Note:	this function is only supported by DR DOS 5.0 and 6.0 and DRMDOS 5.1
SeeAlso: AX=4303h,AX=4305h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214305" name="214305"><b>214305</b></a> - INT 21 U - DR DOS 5.0-6.0 internal - SET EXTENDED FILE ATTRIBUTES<br />
<pre>
INT 21 U - DR DOS 5.0-6.0 internal - SET EXTENDED FILE ATTRIBUTES
	AX = 4305h
	DS:DX -&gt; ASCIZ filename
	???
Return: CF clear if successful
	CF set on error
	    AX = error code (see #01680 at AH=59h/BX=0000h)
Desc:	this function allows the extended attributes, and optionally the
	  encrypted password, of a file to be set.
Note:	this function is only supported by DR DOS 5.0 and 6.0 and DRMDOS 5.1
SeeAlso: AX=4304h,AX=4311h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214306" name="214306"><b>214306</b></a> - INT 21 O - DR DOS 6.0 - GET FILE OWNER<br />
<pre>
INT 21 O - DR DOS 6.0 - GET FILE OWNER
	AX = 4306h
	DS:DX -&gt; ASCIZ filename
Return: CF clear if successful
	    AX = CX = value set with AX=4307h
	CF set on error
	    AX = error code (see #01680 at AH=59h/BX=0000h)
Note:	no longer supported by Novell DOS 7 / OpenDOS
SeeAlso: AX=4307h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214307" name="214307"><b>214307</b></a> - INT 21 O - DR DOS 6.0 - SET FILE OWNER<br />
<pre>
INT 21 O - DR DOS 6.0 - SET FILE OWNER
	AX = 4307h
	CX = ??? (owner identification number?)
	DS:DX -&gt; ASCIZ filename
Return: CF clear if successful
	CF set on error
	    AX = error code (see #01680 at AH=59h/BX=0000h)
Note:	no longer supported by Novell DOS 7 / OpenDOS
SeeAlso: AX=4306h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214380" name="214380"><b>214380</b></a> - INT 21 - Novell DOS 7 - UNDELETE PENDING DELETE FILE<br />
<pre>
INT 21 - Novell DOS 7 - UNDELETE PENDING DELETE FILE
	AX = 4380h
	???
Return: ???
SeeAlso: AH=41h,AX=4381h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214381" name="214381"><b>214381</b></a> - INT 21 - Novell DOS 7 - PURGE PENDING DELETE FILE<br />
<pre>
INT 21 - Novell DOS 7 - PURGE PENDING DELETE FILE
	AX = 4381h
	???
Return: ???
SeeAlso: AH=41h,AX=4380h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214382" name="214382"><b>214382</b></a> - INT 21 - DR-DOS >7.03 - RESERVED<br />
<pre>
INT 21 - DR-DOS &gt;7.03 - RESERVED
	AX = 4382h-438Fh
Notes:	These previously unused functions are reserved for future versions of
	  DR-DOS (post 7.03).
	AX=4382h will be identical to the previous AX=4302h, which is now also
	  used by MS-DOS 7+ for a different purpose.
SeeAlso: INT 21h/4302h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214412" name="214412"><b>214412</b></a> - INT 21 O - DR DOS 5.0-6.0 - DETERMINE DOS TYPE<br />
<pre>
INT 21 O - DR DOS 5.0-6.0 - DETERMINE DOS TYPE
	AX = 4412h
	CF set
Return: CF set if not DR DOS
	    AX = error code (see #01680 at AH=59h/BX=0000h)
	CF clear if DR DOS
	    DX = AX = version code (see #01580)
Note:	this obsolete call, which is no longer supported in Novell DOS 7, is
	  identical to AX=4452h
SeeAlso: AX=4452h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214414" name="214414"><b>214414</b></a> - INT 21 OU - DR DOS 5.0-6.0 - SET GLOBAL PASSWORD<br />
<pre>
INT 21 OU - DR DOS 5.0-6.0 - SET GLOBAL PASSWORD
	AX = 4414h
	DS:DX -&gt; password string (blank-padded to 8 characters)
Desc:	Specify the master password for accessing files.
Note:	this obsolete call, which is no longer supported in Novell DOS 7, is
	  identical to AX=4454h
SeeAlso: AX=4454h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214416" name="214416"><b>214416</b></a> - INT 21 OU - DR DOS 5.0-6.0 - HISTORY BUFFER, SHARE, AND HILOAD CONTROL<br />
<pre>
INT 21 OU - DR DOS 5.0-6.0 - HISTORY BUFFER, SHARE, AND HILOAD CONTROL
	AX = 4416h to 4418h
Note:	these obsolete subfunctions (which are no longer supported in Novell
	  DOS 7) are identical to AX=4456h through 4458h
SeeAlso: AX=4456h,AX=4457h,AX=4458h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214451" name="214451"><b>214451</b></a> - INT 21 - Concurrent DOS v3.2+ - INSTALLATION CHECK<br />
<pre>
INT 21 - Concurrent DOS v3.2+ - INSTALLATION CHECK
	AX = 4451h
Return: CF set if not Concurrent DOS
	    AX = error code (see #01680 at AH=59h/BX=0000h)
	CF clear if successful
	    AH = single-user/multiuser nature (see #01581)
		10h single-user
		    AL = operating system version ID (see #01580)
		14h multiuser
		    AL = operating system version ID (see #01579)
Notes:	as of Concurrent DOS/XM 5.0 (possibly earlier), the version is stored
	  in the environment variable VER and the OS type in variable OS
	use this function if you are looking for multiuser capabilities,
	  AX=4452h for single-user
	this function should never return the single-user values; however, an
	  application should be prepared to accept single-user values, i.e. it
	  should check the returned AH and AL separately
	CCI Multiuser DOS 7.22 returns AX=DX=1466h.
	DR DOS 3.31+ error returns with AX=0001h
SeeAlso: AX=4452h,AX=4459h

(Table 01579)
Values for Digital Research operating system version ID:
 32h	Concurrent PC DOS 3.2
 41h	Concurrent DOS 4.1
 50h	Concurrent DOS/XM 5.0 or Concurrent DOS/386 1.1
 60h	Concurrent DOS/XM 6.0 or Concurrent DOS/386 2.0
 62h	Concurrent DOS/XM 6.2 or Concurrent DOS/386 3.0
 66h	DR Multiuser DOS 5.1, CCT Multiuser DOS 7.x
 67h	Concurrent DOS 5.1
SeeAlso: #01581,#04023

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214452" name="214452"><b>214452</b></a> - INT 21 - DR DOS 3.41+ - DETERMINE DOS TYPE/GET DR DOS VERSION<br />
<pre>
INT 21 - DR DOS 3.41+ - DETERMINE DOS TYPE/GET DR DOS VERSION
	AX = 4452h ("DR")
	CF set
Return: CF set if not DR DOS
	    AX = error code (see #01680 at AH=59h/BX=0000h)
	CF clear if DR DOS
	    AX = version code
	    AH = single-user/multiuser nature (see #01581)
		10h single-user
		    AL = operating system version ID (see #01580)
		14h multiuser
		    AL = operating system version ID (see #01579)
	    DX modified (refer to note below)
Notes:	the DR DOS version is stored in the environment variable VER
	use this function if looking for single-user capabilities, AX=4451h
	  if looking for multiuser; this call should never return multiuser
	  values
	in DR DOS 3.41-6.0, DX=AX on return; for Novell DOS 7, DH=AH but DL=00h
	  (reportedly, DH=00h when booting NWDOS7 from installation disks)
	Novell DOS 7 returns error code 0001h if SETVER x.255 is in effect for
	  the calling program, or SETVER /G x.255 is in effect
	although based on DR DOS, CCI Multiuser DOS 7.xx,
	  IMS Multiuser DOS 7.x, and IMS REAL/32 7.50+ do not support this call
	With OpenDOS 7.02 BETA 2 and DR-OpenDOS 7.02+, the install check
	  in most tools has been changed to run with both, AH=10h and AH=14h
	  to support possible future "client side" multiuser releases of
	  DR-DOS which may return 14h instead of 10h. Tools should also strip
	  off the CP/Net bit before checking the kernel version.
	  Often used version checks like &gt;= 1070h are invalid, therefore,
	  hence the AH and AL must be checked seperately.
	In DR DOS 3.31-6.0, and DR PalmDOS, DX=AX on return.
	For Novell DOS 7 - DR DOS 7.03 the DX value returned by this function
	  is the same as the DX value returned by INT 21/AX=3306h, and
	  represents the DOS revision (bits 7-0, currently always DL=00h) and
	  the version flags (bits 15-8, with bit 12 = DOS in HMA, bit 11 = DOS
	  in ROM) of the "patch_version" field in the PCM_HEADER structure in
	  the IBMDOS.COM file. The version flags, however, are updated at
	  runtime to reflect the actual system status, resulting, for example,
	  in DH=10h for DOS in HMA, and DH=0 when booting Novell DOS 7 from
	  installation disks.
	The operating system version ID represents the BDOS (Basic Disk
	  Operating System) kernel version (of the DRBDOS.SYS aka IBMDOS.COM
	  file), and the two nibbles can actually be read as CP/M version
	  and sub-version, that is DR-DOS 7.03 (version code 1073h) is
	  actually CP/M-86 version 7.3.
	Due to lost original patch sources from the backups, Caldera OpenDOS
	  7.01 merely represented Novell DOS 7 Update 10 with minor changes.
	For Caldera DR-OpenDOS 7.02, all the Novell DOS 7 patches up to
	  including Update 15.2 have been re-incorporated into the system
	  from other sources, while the missing patches for IBMBIO.COM were
	  independently re-implemented by Matthias Paul in 07/1997-10/1997.
	Novell DOS 7 (since 1993-11-08), OpenDOS 7.01 and OpenDOS 7.02 BETA
	  IBMDOS.COM return error code 0001h if SETVER x.255 is in effect
	  for the calling program, or SETVER /G x.255 is in effect.
	Since Caldera DR-OpenDOS 7.02 the SHARE 2.05+ (1998-01-05) driver
	  uses INT 21/AX=65A2h as an *additional* BDOS version check: If the
	  "FUCASE char" function is functional on a DR-DOS BDOS kernel 72h+,
	  SHARE assumes it is running on an OpenDOS 7.02 BETA 1 (73h) kernel
	  (or later) even if the BDOS version returned by INT 21/AX=4452h would
	  indicate an earlier issue of the kernel. Some 3rd party drivers
	  (like HPFS_DOS.EXE) were hardwired to detect Novell DOS 7 only,
	  and so the kernel version had to be patched back on such systems
	  to allow such drivers to work properly. The BDOS version and DOS
	  revision are stored in PCM_HEADER of the IBMDOS.COM file, see
	  table XXXX below.
	However, this is no longer necessary with the introduction of the
	  DR-DOS 7.02+ IBMDOS.COM (since 1998-01-10) and SETVER 1.01+
	  (since 1998-01-12) because they allow to fake BDOS versions as well
	  as faking DOS versions. In /X mode, a set sub-version of y = 100..127
	  will be used as BDOS version instead (64h..7Fh), while the DOS
	  revision will be used to report the DOS sub-version instead. For
	  example, given a DOS revision of 0, SETVER 6.114 would be the proper
	  value to fake Novell DOS 7 (114=72h) on a DR-DOS 7.02+ system,
	  reporting a DOS version of "IBM" 6.00. Sub-versions 128..255 will
	  completely disable this BDOS version check, and report a DOS sub-
	  version of 0..127. This is to work around problems with possibly
	  hostile programs, that try to detect DR-DOS to not run on this OS.
	Additional version check for 1072h kernels: At API level, there
	  is no known way to distinguish Novell DOS 7 from OpenDOS 7.01,
	  however, an IBMBIO.COM/IBMDOS.COM file date since 1997 and the
	  existance of an environment variable %OS%=OPENDOS usually indicates
	  an OpenDOS system (but not the other way around; some OpenDOS
	  BETAs still used %OS%=NWDOS!).
	Additional version checks for 1073h kernels: A functional test of
	  INT 21/AX=65A2h (see above for SHARE) can be used to distinguish
	  OpenDOS 7.02 BETA 1 from the later (OpenDOS 7.02 BETA 2+ and)
	  DR-OpenDOS 7.02 and DR-DOS 7.02 releases, which are both the
	  same, except for the name change and minor bug fixes. Testing
	  for the INT 21/AX=6601h/BX=0000h bug can be used to differentiate the
	  original release of DR-DOS 7.02 from later 7.02 updates and
	  DR-DOS 7.03.
	The DR DOS version is stored in the environment variable VER.
SeeAlso: AX=4412h,AX=4451h,AX=4459h

(Table 01580)
Values for Digital Research operating system version ID:
 41h	DOS Plus 1.2
 60h	DOS Plus 2.0 or 2.1
 63h	DR DOS 3.41
 64h	DR DOS 3.42
 65h	DR DOS 5.0
 67h	DR DOS 6.0
 70h	PalmDOS
 71h	DR DOS 6.0 March 1993 "business update"
 72h	Novell DOS 7.0
 73h	OpenDOS 7.02
SeeAlso: #01579,#01581,#04088,#04023

(Table 04088)
Values for Digital Research operating system ID codes (full AX return value):
 ??41h	- DOS Plus 1.2
 1060h	- DOS Plus 2.0 or 2.1 (1988-03-09???)
	  (this was basically a Concurrent CP/M-86 with built-in DOS emulation
	   developed between 1983-1986)
 1060h	- DR DOS 3.31 (OEM) (1988-04-27???, 06/1988)
	- DR DOS 3.32 (OEM) (1988-08-17)
	- DR DOS 3.33 (OEM) (1988-09-01)
	- DR DOS 3.34 (OEM)
	- DR DOS 3.35 (OEM) (1988-10-21)
	  for example: at least an issue for "Prism System 232" (10/1988)
	  and a French issue existed.
 106?h	- DR DOS 3.40 BETA 1 (1988-11-11)
	- DR DOS 3.40
	  (This is the first issue for sure known to be ROMmable, although
	  DR DOS should have been ROMmable right from the start (1987).)
 1063h	- DR DOS 3.41 various OEM and retail releases (06/1989-07/1989)
	- DR DOS 3.41T
 1064h	- DR DOS 3.42
	  (It is not clear, if this issue was actually released, since Lineo
	  recently (fall 1999) released some historical kernels, and one of
	  them is sailing under the name DR DOS 5.0 "Leopard" BETA 1 and has
	  copyright strings from 1990, while it still identifies itself as
	  being DR DOS 3.41... Unfortunately the uploaded archive is broken,
	  hence it is not possible to find out easily. Maybe DR DOS 3.42 was
	  nothing more than this early "Leopard" BETA???)
 1065h	- DR DOS ??? (1990-02-01)
	- DR DOS 5.0 "Leopard" BETA 2 (1990-03-16),
	- DR DOS 5.0 "Leopard" BETA 2B
	  (This was the first issue to use the new IBMBIO.COM/IBMDOS.COM
	  names instead of DRBIOS.SYS/DRBDOS.SYS.)
	- DR DOS 5.0 "Leopard" BETA 3
	  (This issue still uses separate boot sectors for floppies and
	  harddisks. The boot sector OEM label is still "DIGITAL".)
	- DR DOS 5.0 release (06/1990, 08/1990)
	  (This issue has a combined boot sector for both, floppies and
	  harddisks. The boot sector OEM label has changed to "IBM  3.3".
	  DR DOS 5.0 was the first DOS to introduce high-load capabilities.)
 1066h	- DR DOS ??? (1990-08-09)
	- DR DOS 6.0 "Buxton" ALPHA (02/1991-03/1991)
 1067h	- DR DOS ??? (1991-03-15)
 106?h	- DR DOS 6.0 "Buxton" BETA 2 (??/1991)
 106?h	- DR DOS 6.0 "Buxton" BETA 3 (05/1991, 1991-06-27, 1991-06-28)
 1067h	- DR DOS 6.0 release (05/1991, 08/1991)
	- DR DOS 6.0 BDOS patch "PAT304" English (1991-11-29, XDIR /C: 9D8Ch)
	  fix for "\\" in cmdline by Quick Basic 4.5/MS PDS 7.1 on Lantastic 4.0
	- DR DOS 6.0 BDOS patch "PAT303" English (1991-12-03, XDIR /C: 66B0h)
	  This patch makes INT 21/AH=4Eh (Search First) compatible with MS-DOS
	  when the Volume Label attribute is set. Previously under DR DOS the
	  volume label was only searched for if bit 3 was the only bit set in
	  the attribute whereas MS-DOS searches for the volume label if bit 3
	  is set, irrespective of any other bits in the attribute.
	- DR DOS 6.0 BDOS patch "PAT306" English (1991-12-11, XDIR /C: 8DE5h)
	  This patch fixes a problem with OPTASM which would give error 8
	  if there were not enough handles available. This patch forces the
	  system to check for available handles before it opens a file.
	- DR DOS 6.0 BDOS patch "PAT312" English (1992-01-07, XDIR /C: A0C6h)
	  This patch fixes a problem with INT 21/AH=26h (create PSP) the
	  segment from which the PSP was copied was incorrect so the the PSP
	  was not filled correctly and did not contain the command tail.
	- DR DOS 6.0 BDOS patch "PAT314" English (1992-01-10, XDIR /C: C964h)
	  This patch modifies INT 21/AX=33xxh, the Ctrl Break handler to
	  support undocumented MS-DOS function INT 21/AX=3302h.
	- DR DOS 6.0 BIOS patch "PAT315" English (1992-01-10, XDIR /C: DBAAh)
	  This patch fixes a problem where, when booting from a Bernoulli
	  drive, any DEVICE= statement in CONFIG.SYS failed if it was placed
	  after the device driver RCD.SYS v7.x and DOSOAD.SYS v1.x
	- DR DOS 6.0 BDOS patch "PAT317" English (1992-01-27, XDIR /C: B701h)
	  This patch fixes a problem where attempting to close a changed file
	  on a write protected disk seems to work after the first retry.
	  This was caused because when the retry is attempted the file has been
	  marked as not changed, so the attempt to write to disk is not made.
	- DR DOS 6.0 BDOS patch "PAT321" English (1992-02-19, XDIR /C: 947Bh)
	  This patch fixes a problem where the error codes returned from
	  INT 25h and INT 26h for "drive not ready" and "write protect"
	  errors were incorrect.
	- DR DOS 6.0 BDOS patch "PAT323" English (1992-02-20, XDIR /C: E1B0h)
	  This patch fixes a problem where, if the first command entered after
	  booting the machine is a single character, any use of the command
	  line recall keys will only recall the first command.
	- DR DOS 6.0 ??? German (1992-02-21)
	- DR DOS 6.0 update (02/1992)
	- DR DOS 6.0 BDOS patch "PAT326" English (1992-03-05, XDIR /C: 8EF2h)
	  This is an optional patch to prevent DRDOS from padding the
	  environment of EXEPACKed applications or utilities.
	- DR DOS 6.0 ??? German (1992-03-27)
	- DR DOS 6.0 BDOS patch "PAT334" English (1992-03-27, XDIR /C: 2AFEh)
	  This patch fixes a problem where selecting (R)etry after hitting ^P
	  while the printer is offline caused the system to hang.
	- DR DOS 6.0 "Windows 3.1 update, April 1992" "dr6win" (03/1992,
	  1992-04-07). This public update only includes patches addressing
	  full Windows 3.1 compatiblity. There should have been a full
	  "business update" for registered users, shipping a little bit later.
	- DR DOS 6.0 ??? English (1992-04-07)
	- DR DOS 6.0 BDOS patch "pat354" English (1992-07-28, XDIR /C: 3398h)
	  This patch for Beame and Whiteside Networks: On opening a duplicate
	  file handle which describes a device, a device open call is made to
	  inform the device driver that a new file handle has been opened.
	  This patch is current and up to date as of 1992-11-10.
	- DR DOS 6.0 update (07/1992)
	- DR DOS 6.0 BDOS patch "PAT301" English (1992-10-28, XDIR /C: 959Bh)
	  This patch fixes a problem with apps that opens a file, with Share
	  loaded, but then cannot delete the file until the file is closed.
	  This causes "Money Manager" to fail.
	- DR DOS 6.0 update (11/1992)
	Note: There is no known method to distinguish these different kernels
	       at runtime, except for - maybe - checksumming the IBMBIO.COM/
	       IBMDOS.COM files.
	      The listed patches only address a single problem, while the
	       listed updates are full rebuilds, also including all previous
	       fixes.
 1070h	- multitasking "Vladivar" kernel architecture and introduction of
	  DOS-like structures (1991-07-26, 08/1991)
	- DR DOS ??? (1991-09-26)
	- DR PalmDOS "Merlin" BETA 1-2
	- DR PalmDOS "Merlin" BETA 3 (1992-06-23)
	- DR PalmDOS "Merlin" Evaluation Release (1992-08-25)
	- DR PalmDOS Release Candidates 1-2 (1992-08-26)
	- DR PalmDOS/NetWare PalmDOS 1.0 (06/1992-11/1992)
	  (DR PalmDOS was the first DR DOS re-incarnation that supported
	  a genuine CDS, but still pretended to be DOS 3.31. Much of the
	  former CP/M stuff was stripped out to reduce the code size to meet
	  early Palmtop PC requirements. It introduced the patented dynamic
	  idle detection method (by Roger Gross), a special issue of the
	  TASKMAX program switcher (MINIMAX) to support Personal Information
	  Modules (PIM) plug-in executables, supported Flash/ROM disk,
	  XIP "Execute in Place" applications, and came with PCMCIA Card
	  Services and Service Stack (SS) partially written by Ian Cullimore
	  (ex-Poquet Computer Corporation founder).
	- DR DOS "Panther" BETA 1 (1992-10-16)
	  (This issue already supported DPMS, had the "Vladivar" pre-emptive
	  multitasker, DPMS-SuperStor disk compression, Multiuser-security
	  (World/Group/Owner), and much improved multi-windowing ViewMAX/3 GUI
	  which looked alot more like Windows than GEM. It pretended to be
	  PC DOS 5. However, this issue was never released and later partially
	  merged into the Novell DOS 7 project (without Multiuser-security and
	  ViewMAX/3). In 1999, Caldera Thin Clients released ViewMAX/3 under
	  GPL, see http://www.gemworld.com.)
 1070h??? - DR DOS "StarTrek" (STDOS) (07/1992-05/1993)
	  (A never released, though reportedly fully functional result of
	  a Novell and Apple team-up utilizing the DR DOS "Vladivar" multi-
	  tasker to run Apple's Intel-port of MacOS 7.1 on an issue of DR DOS
	  "Panther", even emulating HFS and Mac resources on DOS FAT file-
	  systems.)
 1071h	- DR DOS ??? (1992-11-26)
	- DR DOS 6.0 "business update" "DRDOS493" English for
	  Windows for Workgroups 3.1 (1993-03-19)
	- DR DOS 6.0 patch "PATDR6" English (1993-03-19) for NetWare
	- DR DOS 6.0 patch "PAT394" English (1993-09-17)
	- Apparently also some issues of DR DOS "Panther"???
 1072h	- Novell DOS 7/PNW "Smirnoff" BETA 1 (??/1993, probably 1993-04-26)
	- Novell DOS 7 "Panther" BETA 2 (08/1993)
	  (This "Panther" issue is much different from the early 10/1992
	  "Panther" BETA 1.)
	- Novell DOS 7 "Panther/Smirnoff" BETA 2 (08/1993)
	- Novell DOS 7 "Panther/Smirnoff" BETA 3 (09/1993)
	  (This issue does not have workarounds for Windows 3.1 "AARD" code)
	- Novell DOS 7 "Panther/Smirnoff" BETA 4 (10/1993)
	- Novell DOS 7 code freeze 1993-12-03???)
	- Novell DOS 7 release (12/1993-04/1994)
	  (also known as NWDOS or ND7, sometimes erroneously called NDOS)
	- Novell DOS 7 German release (1994-02-22)
	  (This issue is known to have workarounds for Windows 3.1 "AARD" code)
	- Novell DOS 7 updates 1-3 (???/1994)
	- Novell DOS 7 update 4 (1994-05-31)
	- Novell DOS 7 updates 5-9 (???/1994)
	- Novell DOS 7 update 10 (12/1994)
	- Novell DOS 7 update 11 (01/1995)
	- Novell DOS 7 update 12 (04/1995)
	- Novell DOS 7 update 13 (05/1995)
	- Novell DOS 7 update 14 (08-09/1995)
	- Novell DOS 7 update 15 (12/1995)
	- Novell DOS 7 update 15.2 (01/1996)
	  Note: The Novell DOS 7 updates 4-15.2 are full rebuilds, not patched
	   binaries.
	- Caldera OpenDOS 7.01 BETA (02/1997)
	  (basically representing Novell DOS 7 update 10 with minor
	  changes here and there)
	- Caldera OpenDOS 7.01 (02-03/1997)
	- Caldera OpenDOS 7.01 M.R.S. (05/1997)
	  (release of the kernel source code)
	- Matthias Paul's enhanced OpenDOS 7.02 ALPHA 1-4 kernels (07-11/1997)
 1073h	- Caldera OpenDOS 7.02 BETA 1 (09/1997)
	  (incorporating most the Novell DOS 7 update 15.2 changes,
	  except for IBMBIO.COM changes, plus a few other enhancements)
	- Caldera OpenDOS 7.02 BETA 2 (11/1997)
	  (now also incorporating Matthias Paul's ALPHA 4 enhancements,
	  the Novell DOS update 15.2 IBMBIO.COM patches have been
	  re-implemented)
	- Caldera OpenDOS 7.02 BETA 2A (12/1997)
	  (now incorporating all Novell DOS 7 update 15.2 changes)
	- Caldera DR-OpenDOS 7.02 (1997-12-2x)
	  (now for the first time the product name is written with a hyphen!!!)
	- Caldera DR-DOS 7.02 internal build (02/1998)
	- Caldera DR-DOS 7.02 release (03/1998)
	- Caldera DR-DOS 7.02A release (06/1998)
	- DR-DOS 7.02 Update 1 (08/1998)
	- DR-DOS 7.02 Update 2 (09/1998)
	- Caldera (Thin Clients) DR-DOS 7.03 BETA (1998-12-03),
	  sometimes referred to as "DR-DOS 7.03 BETA 3"
	- Caldera (Thin Clients) DR-DOS 7.03 release (1998-12-24, 1999-01-06)
	- Lineo DR-DOS 7.03 release (1999-06-07, 1999-09-09)
	  (this issue has no functional changes compared to the 1999-01-06
	  issue of DR-DOS 7.03)
SeeAlso: #01580,#01579,#01581,#04023

Bitfields for CP/M type indicator:
Bit(s)	Description	(Table 01581)
 7-4	CPU type
	0000 = 8080
	0001 = 8086
 3-0	OS type
	0000 = CP/M
	0001 = MP/M
	0002 = CP/Net
	0004 = multiuser
Notes:	Usually 10h (single-user) or 14h (multi-user).
	While earlier releases of the system utilities performed a test for
	  a version code of (&gt;)= (10)xxh, this was changed with
	  DR-OpenDOS 7.02+ (now taking a possible multi-user version into
	  account): Most utilities now test for AH being either 10h or 14h,
	  and a BDOS version &gt;=xxh to allow them to properly run on possible
	  future multi-user releases of DR-DOS. Before doing this test, some
	  of them strip off the CP/Net bit.
SeeAlso: #01580

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214454" name="214454"><b>214454</b></a> - INT 21 U - DR DOS 3.41+ - SET GLOBAL PASSWORD<br />
<pre>
INT 21 U - DR DOS 3.41+ - SET GLOBAL PASSWORD
	AX = 4454h
	DS:DX -&gt; password string (blank-padded to 8 characters)
Desc:	Specify the master password for accessing files.
SeeAlso: AX=4303h,AX=4414h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214456" name="214456"><b>214456</b></a> - INT 21 U - DR DOS 5.0+ - HISTORY BUFFER CONTROL<br />
<pre>
INT 21 U - DR DOS 5.0+ - HISTORY BUFFER CONTROL
	AX = 4456h
	DL = control flags (see #01582)
Return: AL = previous value of state flags (see #01583)
Note:	DR DOS 6.0 only checks bit 0 and ignores the rest of DL
SeeAlso: #01584

Bitfields for control flags:
Bit(s)	Description	(Table 01582)
 0	whose buffer: 0=application, 1=COMMAND.COM
---Novell DOS 7---
 1	toggle HISTORY usage
 2	toggle INSERT state
Note:	only one bit at a time may be used

Bitfields for state flags:
Bit(s)	Description	(Table 01583)
 0	HISTORY buffer enabled
 1	INSERT enabled
 2-5	unused
 7	whose buffer: 0=application, 1=COMMAND.COM

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214457" name="214457"><b>214457</b></a> - INT 21 U - DR DOS 5.0-6.0 - SHARE/HILOAD CONTROL<br />
<pre>
INT 21 U - DR DOS 5.0-6.0 - SHARE/HILOAD CONTROL
	AX = 4457h
	DH = subfunction
	    00h enable/disable SHARE
		DL = 00h disable
		   = 01h enable
		   else Return: AX = ???
	    01h get HILOAD status
		Return: AX = status
			    0000h off
			    0001h on
	    02h set HILOAD status
		DL = new state (00h off, 01h on)
		Return: AX = ???
	    other
		Return: AX = ???
Note:	This was seen called by COMMAND.COM of DR DOS 6.0; it does not seem
	  to be supported by Novell DOS 7
SeeAlso: AX=4457h/DX=FFFFh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214457DXFFFF" name="214457DXFFFF"><b>214457DXFFFF</b></a> - INT 21 OU - DR DOS 6.0 - GET SHARE STATUS<br />
<pre>
INT 21 OU - DR DOS 6.0 - GET SHARE STATUS
	AX = 4457h
	DX = FFFFh
Return: AX = SHARE status
Note:	not supported by Novell DOS 7
SeeAlso: INT 2F/AX=1000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214458" name="214458"><b>214458</b></a> - INT 21 U - DR DOS 5.0+ internal - GET POINTER TO INTERNAL VARIABLE TABLE<br />
<pre>
INT 21 U - DR DOS 5.0+ internal - GET POINTER TO INTERNAL VARIABLE TABLE
	AX = 4458h
Return: ES:BX -&gt; internal variable table (see #01584,#01585)
	AX = ??? (0B50h for DR DOS 5.0, 0A56h for DR DOS 6.0, 0FE4h for
		  Novell DOS 7)
SeeAlso: AX=4452h

Format of DR DOS 5.0-6.0 internal variable table:
Offset	Size	Description	(Table 01584)
 00h	WORD	???
 02h	WORD	segment of ???
 04h	WORD	offset within DOS data segment of history control structure
		  for COMMAND.COM history buffer (see #01586)
 06h	WORD	offset within DOS data segment of history control structure
		  for application history buffer (see #01586)
 08h	BYTE	initial history state flags (see #01583)
 09h  2 BYTEs	???
 0Bh	WORD	KB of extended memory at startup
 0Dh	BYTE	number of far jump entry points
 0Eh	WORD	segment containing far jumps to DR DOS entry points (see #01587)
 10h	WORD	(only if kernel loaded in HMA) offset in HMA of first free HMA
		  memory block (see #01588) or 0000h if none; segment is FFFFh
 12h	WORD	pointer to segment of environment variables set in CONFIG,
		  or 0000h if already used
---DR DOS 6.0---
 14h	WORD	(only if kernel loaded in HMA) offset in HMA of first used HMA
		memory block (see #01588) or 0000h if none; segment is FFFFh
 16h  8 BYTEs	???
 1Eh	WORD	offset in DOS data segment of full COUNTRY.SYS filename
 20h  8 BYTEs	???
 28h	WORD	offset in DOS data segment of SHARE hook table
 2Ah  2 BYTEs	???
 2Ch	WORD	offset in DOS data segment of far pointer to INT 2F/AX=1000h
		  handler
Notes:	the segment used for the DR DOS 6.0 CONFIG environment variables
	  (excluding COMSPEC, VER and OS) is only useful for programs/drivers
	  called from CONFIG.SYS. The word is set to zero later when the area
	  is copied to the COMMAND.COM environment space.  This allows
	  CONFIG.SYS to pass information to AUTOEXEC.BAT.
	the Novell DOS 7 KEYB uses offsets 10h,14h, and 2Ch in the same was
	  as for DR DOS 6.0, so it is likely that the entire table is the same

Format of Novell DOS 7 internal variable table:
Offset	Size	Description	(Table 01585)
 00h	???
 1Eh	WORD	offset of COUNTRY.SYS filename
 42h 16 DWORDs	pointers to ??? entry points
	???

Format of history control structure:
Offset	Size	Description	(Table 01586)
 00h	WORD	segment of buffer
 02h	WORD	size of buffer in bytes
 04h	WORD	???

Format of kernel entry jump table for DR DOS 5.0-6.0:
Offset	Size	Description	(Table 01587)
 00h  5 BYTEs	far jump to kernel entry point for CP/M CALL 5
 05h  5 BYTEs	far jump to kernel entry point for INT 20
 0Ah  5 BYTEs	far jump to kernel entry point for INT 21
 0Fh  5 BYTEs	far jump to kernel entry point for INT 22 (RETF)
 14h  5 BYTEs	far jump to kernel entry point for INT 23 (RETF)
 19h  5 BYTEs	far jump to kernel entry point for INT 24
 1Eh  5 BYTEs	far jump to kernel entry point for INT 25
 23h  5 BYTEs	far jump to kernel entry point for INT 26
 28h  5 BYTEs	far jump to kernel entry point for INT 27
 2Dh  5 BYTEs	far jump to kernel entry point for INT 28
 32h  5 BYTEs	far jump to kernel entry point for INT 2A (IRET)
 37h  5 BYTEs	far jump to kernel entry point for INT 2B (IRET)
 3Ch  5 BYTEs	far jump to kernel entry point for INT 2C (IRET)
 41h  5 BYTEs	far jump to kernel entry point for INT 2D (IRET)
 46h  5 BYTEs	far jump to kernel entry point for INT 2E (IRET)
 4Bh  5 BYTEs	far jump to kernel entry point for INT 2F
Notes:	all of these entry points are indirected through this jump table
	  to allow the kernel to be relocated into high memory while leaving
	  the actual entry addresses in low memory for maximum compatibility
	some of these entry points (22h,23h,24h,2Eh,2Fh) are replaced as soon
	  as COMMAND.COM is loaded, and return immediately to the caller, some
	  returning an error code (the original handler for INT 2F returns
	  AL=03h [fail]).

Format of HMA Memory Block (DR DOS 6.0 kernel loaded in HMA):
Offset	Size	Description	(Table 01588)
 00h	WORD	offset of next HMA Memory Block (0000h if last block)
 02h	WORD	size of this block in bytes (at least 10h)
 04h	BYTE	type of HMA Memory Block (interpreted by MEM)
		00h system
		01h KEYB
		02h NLSFUNC
		03h SHARE
		04h TaskMAX
		05h COMMAND
 05h	var	TSR (or system) code and data. DR DOS TSR's, such as KEYB,
		  hooks interrupts using segment FFFEh instead FFFFh.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214459" name="214459"><b>214459</b></a> - INT 21 - DR Multiuser DOS 5.0 - API<br />
<pre>
INT 21 - DR Multiuser DOS 5.0 - API
	AX = 4459h
	CL = function (see #04019 at INT E0"CP/M-86")
	DS,DX = parameters
Notes:	DR DOS 5.0 and Novell DOS 7 return CF set and AX=0001h
	this API is also available on INT E0
SeeAlso: AX=4452h,INT E0"CP/M-86"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21445A" name="21445A"><b>21445A</b></a> - INT 21 U - Concurrent DOS etc. - USER GROUP SUPPORT<br />
<pre>
INT 21 U - Concurrent DOS etc. - USER GROUP SUPPORT
	AX = 445Ah
	CX = operation type
	    00h get default file access rights
	    01h set default file access rights
	    02h get user/group
	    03h get security version
	    04h set security key (needs key)
	    05h set user/group (needs key)
	DX = data for operation if set
	BX = key (if required)
Return: AX = result
Note:	This function was introduced on 1990/06/04 for CDOS.  It has been
	  supported by DR PalmDOS and DR DOS "Panther" (BDOS 1070h),
	  but it is not supported by Novell DOS 7 - DR-DOS 7.03.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#214B80" name="214B80"><b>214B80</b></a> - INT 21 - DR DOS v3.31+ - RUN ALREADY-LOADED KERNEL FILE<br />
<pre>
INT 21 - DR DOS v3.31+ - RUN ALREADY-LOADED KERNEL FILE
	AX = 4B80h
	DS:DX -&gt; ASCIZ name of program to EXEC
	ES = segment of PSP for kernel file
Return: only if call failed
Note:	DR DOS uses this call after an AX=4B01h to load the kernel file into
	  memory and patch the program's parent-PSP field to point at itself
SeeAlso: AH=4Bh"EXEC"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#215702_0" name="215702_0"><b>215702</b></a> - INT 21 - OS/2 v1.1+ Family API - DosQFileInfo<br />
<pre>
INT 21 - OS/2 v1.1+ Family API - DosQFileInfo
	AX = 5702h
	BX = file handle
	CX = size of buffer for information
	DX = level of information
	    0001h standard file information (see #01672)
	    0002h Query EA Size (see #01672)
	    0003h Query EAs from List (see #01673)
	    0004h Query All EAs (see #01673)
	ES:DI -&gt; buffer for information (see #01672,#01673)
Return: CF clear if successful
	CF set on error
	    AX = error code
SeeAlso: AX=5702h/BX=FFFFh,AX=5703h"OS/2",AH=6Dh"OS/2"

Format of OS/2 DosQFileInfo:
Offset	Size	Description	(Table 01672)
 00h	WORD	creation date
 02h	WORD	creation time
 04h	WORD	last access date
 06h	WORD	last access time
 08h	WORD	last write date
 0Ah	WORD	last write time
 0Ch	DWORD	file size in bytes
 10h	DWORD	allocated space in bytes
 14h	WORD	file attributes
---level 2 only---
 16h	DWORD	size of Extended Attributes in byte
SeeAlso: #01673,#01676

Format of OS/2 DosQFileInfo, EAOP structure:
Offset	Size	Description	(Table 01673)
 00h	DWORD	pointer to general EA list (see #01674)
 04h	DWORD	pointer to buffer for full EA list, with length field set
 08h	DWORD	(ret) error
Note:	for info level 3, the first pointer must contain the address of a
	  list of the Extended Attributes to be retrieved; for info level 4,
	  it should be 0000h:0000h
SeeAlso: #01672,#01676

Format of OS/2 DosQFileInfo, General EA List:
Offset	Size	Description	(Table 01674)
 00h	DWORD	(call) total size of list in bytes (including this field)
		(ret) number of bytes actually used (including this field)
 04h	var	Extended Attribute entries (see #01675) [packed arrray]

Format of OS/2 DosQFileInfo, General EA entry:
Offset	Size	Description	(Table 01675)
 00h	BYTE	length of Extended Attribute name (excluding terminating NUL)
 01h  N BYTEs	EA name
	BYTE	00h
SeeAlso: #01674

Format of OS/2 DosQFileInfo, Full EA List:
Offset	Size	Description	(Table 01676)
 00h	DWORD	(call) total size of list in bytes (including this field)
		(ret) number of bytes actually used (including this field)
 04h	var	Extended Attribute data (see #01677) [packed array]
SeeAlso: #01672,#01673

Format of OS/2 Extended Attribute data (struct FEA):
Offset	Size	Description	(Table 01677)
 00h	BYTE	flags
		bit 7: critical EA
 01h	BYTE	length of Extended Attribute name (excluding terminating NUL)
 02h	WORD	length of Extended Attribute value
 04h  N BYTEs	EA name
	BYTE	00h
      M BYTEs	EA value

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#215702BXFFFF" name="215702BXFFFF"><b>215702BXFFFF</b></a> - INT 21 - OS/2 v1.1+ Compatibility Box Family API - DosQPathInfo<br />
<pre>
INT 21 - OS/2 v1.1+ Compatibility Box Family API - DosQPathInfo
	AX = 5702h
	BX = FFFFh
	CX = size of buffer for information
	DX = level of information (0002h)
	DS:SI -&gt; filename
	ES:DI -&gt; buffer for FAPI path information (see #01678)
Return: CF clear if successful
	    AL = 00h
	CF set on error
	    AX = error code
SeeAlso: AX=5702h"OS/2",AX=5703h/BX=FFFFh

Format of FAPI path information:
Offset	Size	Description	(Table 01678)
 00h 22 BYTEs	???
 16h	DWORD	extended attribute size (none present if less than 5)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#215703_0" name="215703_0"><b>215703</b></a> - INT 21 - OS/2 v1.1+ Family API - DosSetFileInfo<br />
<pre>
INT 21 - OS/2 v1.1+ Family API - DosSetFileInfo
	AX = 5703h
	BX = file handle
	CX = size of information buffer
	DX = level of information
	ES:DI -&gt; information buffer
Return: CF clear if successful
	CF set on error
	    AX = error code
SeeAlso: AX=5702h"OS/2",AX=5703h/BX=FFFFh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#215703BXFFFF" name="215703BXFFFF"><b>215703BXFFFF</b></a> - INT 21 - OS/2 v1.1+ Family API - DosSetPathInfo<br />
<pre>
INT 21 - OS/2 v1.1+ Family API - DosSetPathInfo
	AX = 5703h
	BX = FFFFh
	CX = size of information buffer
	DX = level of information
	DS:SI -&gt; filename
	ES:DI -&gt; information buffer
Return: CF clear if successful
	CF set on error
	    AX = error code
SeeAlso: AX=5702h/BX=FFFFh,AX=5703h"OS/2"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#215F05_0" name="215F05_0"><b>215F05</b></a> - INT 21 - STARLITE architecture - MAP LOCAL DRIVE LETTER TO REMOTE FILE SYSTEM<br />
<pre>
INT 21 - STARLITE architecture - MAP LOCAL DRIVE LETTER TO REMOTE FILE SYSTEM
	AX = 5F05h
	DL = drive number (0=A:)
	DS:SI -&gt; ASCIZ name of the object to map the drive to
Return: CF set on error
	    AX = error code (see #01680 at AH=59h/BX=0000h)
	CF clear if successful
SeeAlso: AX=5F06h"STARLITE",INT 60/AX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#215F06_0" name="215F06_0"><b>215F06</b></a> - INT 21 - STARLITE architecture - UNMAP DRIVE LETTER<br />
<pre>
INT 21 - STARLITE architecture - UNMAP DRIVE LETTER
	AX = 5F06h
	DL = drive to be unmapped (0=A:)
Return: CF set on error
	    AX = error code (see #01680 at AH=59h/BX=0000h)
	CF clear if successful
SeeAlso: AX=5F05h"STARLITE",INT 60/AX=0003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#215F07_0" name="215F07_0"><b>215F07</b></a> - INT 21 - STARLITE architecture - MAKE NAMED OBJECT AVAILABLE ON NETWORK<br />
<pre>
INT 21 - STARLITE architecture - MAKE NAMED OBJECT AVAILABLE ON NETWORK
	AX = 5F07h
	DS:SI -&gt; ASCIZ name of object to offer to network
	ES:DI -&gt; ASCIZ name under which object will be known on the network
		MUST begin with three slashes
Return: CF set on error
	    AX = error code (see #01680 at AH=59h/BX=0000h)
	CF clear if successful
SeeAlso: AX=5F08h"STARLITE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#215F08_0" name="215F08_0"><b>215F08</b></a> - INT 21 - STARLITE architecture - REMOVE GLOBAL NETWORK NAME OF OBJECT<br />
<pre>
INT 21 - STARLITE architecture - REMOVE GLOBAL NETWORK NAME OF OBJECT
	AX = 5F08h
	DS:SI -&gt; ASCIZ network name (not local name) of object to unshare
Return: CF set on error
	    AX = error code (see #01680 at AH=59h/BX=0000h)
	CF clear if successful
SeeAlso: AX=5F07h"STARLITE"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#215F09" name="215F09"><b>215F09</b></a> - INT 21 - STARLITE architecture - BIND TO NETWORK DEVICE<br />
<pre>
INT 21 - STARLITE architecture - BIND TO NETWORK DEVICE
	AX = 5F09h
	DS:DX -&gt; ASCIZ name of the device driver to attach to
Return: CF set on error
	    AX = error code (see #01680 at AH=59h/BX=0000h)
	CF clear if successful
Note:	the STARLITE distributed file system can attach to multiple networks
	  simultaneously
SeeAlso: AX=5F0Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#215F0A" name="215F0A"><b>215F0A</b></a> - INT 21 - STARLITE architecture - DETACH FROM NETWORK DEVICE<br />
<pre>
INT 21 - STARLITE architecture - DETACH FROM NETWORK DEVICE
	AX = 5F0Ah
	DS:DX -&gt; ASCIZ name of device driver to detach from
Return: CF set on error
	    AX = error code (see #01680 at AH=59h/BX=0000h)
	CF clear if successful
SeeAlso: AX=5F09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2161--BP6467" name="2161--BP6467"><b>2161--BP6467</b></a> - INT 21 U - OS/2 v1.x FAPI - OS/2 FILE SYSTEM JOIN/SUBST<br />
<pre>
INT 21 U - OS/2 v1.x FAPI - OS/2 FILE SYSTEM JOIN/SUBST
	AH = 61h
	BP = 6467h ("dg")
	AL = function
	    00h list (i.e. get)
	    01h add
	    02h delete
	BX = drive number
	CX = size of buffer
	SI = type (0002h JOIN, 0003h SUBST)
	ES:DI -&gt; buffer
Return: CF clear if successful
	    AX = 0000h
	    ES:DI buffer filled, if appropriate
	CF set on error
	    AX = error code
Notes:	used by JOIN and SUBST to communicate with the OS/2 file system
	for function 00h (list), the ES:DI buffer is filled with the ASCIZ
	  JOIN/SUBST path or an empty string if the drive is not JOINed/SUBSTed
	also supported by OS/2 v2.0+ Virtual DOS Machines

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--DX0000" name="2164--DX0000"><b>2164--DX0000</b></a> - INT 21 U - OS/2 v2.0+ Virtual DOS Machine - ENABLE AUTOMATIC TITLE SWITCH<br />
<pre>
INT 21 U - OS/2 v2.0+ Virtual DOS Machine - ENABLE AUTOMATIC TITLE SWITCH
	AH = 64h
	DX = 0000h (function number)
	CX = 636Ch (magic value, "cl")
	BX = 0000h (indicates special request)
Note:	if CX is not 636Ch on entry, INT 21/AH=6Ch is invoked, because a bug
	  in OS/2 1.x FAPI erroneously called AH=64h instead of AH=6Ch
SeeAlso: AH=64h/DX=0001h,INT 21/AH=4Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--DX0001" name="2164--DX0001"><b>2164--DX0001</b></a> - INT 21 U - OS/2 v2.0+ Virtual DOS Machine - SET SESSION TITLE<br />
<pre>
INT 21 U - OS/2 v2.0+ Virtual DOS Machine - SET SESSION TITLE
	AH = 64h
	DX = 0001h (function number)
	CX = 636Ch (magic value, "cl")
	BX = 0000h (indicates special request)
	ES:DI -&gt; new ASCIZ title (max 12 char) or "" to restore default title
Note:	if CX is not 636Ch on entry, INT 21/AH=6Ch is invoked, because a bug
	  in OS/2 1.x FAPI erroneously called AH=64h instead of AH=6Ch
SeeAlso: AH=64h/DX=0000h,AH=64h/DX=0002h,INT 15/AH=12h/BH=05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--DX0002" name="2164--DX0002"><b>2164--DX0002</b></a> - INT 21 U - OS/2 v2.0+ Virtual DOS Machine - GET SESSION TITLE<br />
<pre>
INT 21 U - OS/2 v2.0+ Virtual DOS Machine - GET SESSION TITLE
	AH = 64h
	DX = 0002h (function number)
	CX = 636Ch (magic value, "cl")
	BX = 0000h (indicates special request)
	ES:DI -&gt; 13-byte buffer for current title
Return: buffer filled (single 00h if title never changed)
Note:	if CX is not 636Ch on entry, INT 21/AH=6Ch is invoked, because a bug
	  in OS/2 1.x FAPI erroneously called AH=64h instead of AH=6Ch
SeeAlso: AH=64h/DX=0000h,AH=64h/DX=0001h,INT 15/AH=12h/BH=05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--DX0003" name="2164--DX0003"><b>2164--DX0003</b></a> - INT 21 U - OS/2 v2.1 Virtual DOS Machine - GET LASTDRIVE<br />
<pre>
INT 21 U - OS/2 v2.1 Virtual DOS Machine - GET LASTDRIVE
	AH = 64h
	DX = 0003h (function number)
	CX = 636Ch (magic value, "cl")
	BX = 0000h (indicates special request)
Return: AL = highest drive supported
Notes:	if CX is not 636Ch on entry, INT 21/AH=6Ch is invoked, because a bug
	  in OS/2 1.x FAPI erroneously called AH=64h instead of AH=6Ch
	used by WinOS2
	not supported by OS/2 Warp 3.0, check list of lists instead (see #01627)
SeeAlso: AH=52h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--DX0004" name="2164--DX0004"><b>2164--DX0004</b></a> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET SIZE OF PTDA JFT<br />
<pre>
INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET SIZE OF PTDA JFT
	AH = 64h
	DX = 0004h (function number)
	CX = 636Ch (magic value, "cl")
	BX = 0000h (indicates special request)
Return: AX = number of entries in OS/2 JFT for VDM
Notes:	if CX is not 636Ch on entry, INT 21/AH=6Ch is invoked, because a bug
	  in OS/2 1.x FAPI erroneously called AH=64h instead of AH=6Ch
	in an OS/2 VDM, the DOS Job File Table in the PSP contains an index
	  into the OS/2 JFT in the Per-Task Data Area rather than an SFT index
	  because the OS/2 SFT can contain more than 255 entries

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--DX0005" name="2164--DX0005"><b>2164--DX0005</b></a> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET SECOND SFT FLAGS WORD<br />
<pre>
INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET SECOND SFT FLAGS WORD
	AH = 64h
	DX = 0005h (function number)
	CX = 636Ch (magic value, "cl")
	BX = 0000h (indicates special request)
	DI = DOS file handle
Return: AX = value of second flags word from OS/2 SFT entry for file
Notes:	if CX is not 636Ch on entry, INT 21/AH=6Ch is invoked, because a bug
	  in OS/2 1.x FAPI erroneously called AH=64h instead of AH=6Ch
	the OS/2 SFT has two flags words rather than DOS's one word, and this
	  function provides access to the word which is not present in DOS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--DX0006" name="2164--DX0006"><b>2164--DX0006</b></a> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - UNLOAD DOSKRNL SYMBOLS & LOAD PROGR<br />
<pre>
INT 21 U - OS/2 v2.1+ Virtual DOS Machine - UNLOAD DOSKRNL SYMBOLS & LOAD PROGR
	AH = 64h
	DX = 0006h (function number)
	CX = 636Ch (magic value, "cl")
	BX = 0000h (indicates special request)
	ES:DI -&gt; ASCIZ filespec
	DS = base address for loading
Notes:	if CX is not 636Ch on entry, INT 21/AH=6Ch is invoked, because a bug
	  in OS/2 1.x FAPI erroneously called AH=64h instead of AH=6Ch
	this function is only supported by the kernel debugging version of
	  OS2KRNL

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--DX0007" name="2164--DX0007"><b>2164--DX0007</b></a> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET WinOS2 CALL GATE ADDRESS<br />
<pre>
INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET WinOS2 CALL GATE ADDRESS
	AH = 64h
	DX = 0007h (function number)
	CX = 636Ch (magic value, "cl")
	BX = 0000h (indicates special request)
Return: AX = call gate address
Notes:	if CX is not 636Ch on entry, INT 21/AH=6Ch is invoked, because a bug
	  in OS/2 1.x FAPI erroneously called AH=64h instead of AH=6Ch
	used by WinOS2 to make direct calls to OS2KRNL, bypassing the overhead
	  of DOSKRNL

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--DX0008" name="2164--DX0008"><b>2164--DX0008</b></a> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET LOADING MESSAGE<br />
<pre>
INT 21 U - OS/2 v2.1+ Virtual DOS Machine - GET LOADING MESSAGE
	AH = 64h
	DX = 0008h (function number)
	CX = 636Ch (magic value, "cl")
	BX = 0000h (indicates special request)
Return: DS:DX -&gt; '$'-terminated message "Loading.  Please wait."
Notes:	if CX is not 636Ch on entry, INT 21/AH=6Ch is invoked, because a bug
	  in OS/2 1.x FAPI erroneously called AH=64h instead of AH=6Ch
	this function permits National Language Support for the initial message
	  displayed while WinOS2 starts a full-screen session

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--CX636C" name="2164--CX636C"><b>2164--CX636C</b></a> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API support<br />
<pre>
INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API support
	AH = 64h
	CX = 636Ch ("cl")
	BX = API ordinal (see #01747)
	other registers as appropriate for API call
Return: as appropriate for API call
SeeAlso: AH=64h/BX=0025h,AH=64h/BX=00B6h,AH=64h/BX=00CBh

(Table 01747)
Values for OS/2 API ordinal:
 0025h	DOS32StartSession
 0082h	DosGetCP
 00B6h	DosQFSAttach
 00BFh	DosEditName
 00CBh	DosForceDelete
 0144h	Dos32CreateEventSem
 0145h	Dos32OpenEvenSem
 0146h	Dos32CloseEventSem
 0147h	Dos32ResetEventSem
 0148h	Dos32PostEventSem
 0149h	Dos32WaitEventSem
 014Ah	Dos32QueryEventSem
 014Bh	Dos32CreateMutexSem
 014Ch	Dos32OpenMutexSem
 014Dh	Dos32CloseMutexSem
 014Eh	Dos32RequestMutexSem
 014Fh	Dos32ReleaseMutexSem
 0150h	Dos32QueryMutexSem
 0151h	Dos32CreateMuxWaitSem
 0152h	Dos32OpenMuxWaitSem
 0153h	Dos32CloseMuxWaitSem
 0154h	Dos32WaitMuxWaitSem
 0155h	Dos32AddMuxWaitSem
 0156h	Dos32DeleteMuxWaitSem
 0157h	Dos32QueryMuxWaitSem

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--BX0025" name="2164--BX0025"><b>2164--BX0025</b></a> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API DOS32StartSession<br />
<pre>
INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API DOS32StartSession
	AH = 64h
	BX = 0025h (API ordinal)
	CX = 636Ch ("cl")
	DS:SI -&gt; STARTDATA structure (see #01748)
Return: AX = return code
SeeAlso: AH=64h/CX=636Ch,AH=64h/BX=00B6h

Format of OS/2 Virtual DOS Machine STARTDATA structure:
Offset	Size	Description	(Table 01748)
 00h	WORD	length of structure (must be 0018h,001Eh,0020h,0032h,or 003Ch)
 02h	WORD	relation of new process to caller (00h independent, 01h child)
 04h	WORD	fore/background (00h foreground, 01h background)
 06h	WORD	trace options (00h-02h, 00h = no trace)
 08h	DWORD	pointer to ASCIZ program title (max 62 chars) or 0000h:0000h
 0Ch	DWORD	pointer to ASCIZ program name (max 128 chars) or 0000h:0000h
 10h	DWORD	pointer to ASCIZ program args (max 144 chars) or 0000h:0000h
 14h	DWORD	"TermQ" (currently reserved, must be 00000000h)
 18h	DWORD	pointer to environment (max 486 bytes) or 0000h:0000h
 1Ch	WORD	inheritance (00h or 01h)
 1Eh	WORD	session type
		00h OS/2 session manager determines type (default)
		01h OS/2 full-screen
		02h OS/2 window
		03h PM
		04h VDM full-screen
		07h VDM window
 20h	DWORD	pointer to ASCIZ icon filename (max 128 chars) or 0000h:0000h
 24h	DWORD	"PgmHandle" (currently reserved, must be 00000000h)
 28h	WORD	"PgmControl"
 2Ah	WORD	initial column
 2Ch	WORD	initial row
 2Eh	WORD	initial width
 30h	WORD	initial height
 32h	WORD	reserved (0)
 34h	DWORD	"ObjectBuffer" (currently reserved, must be 00000000h)
 38h	DWORD	"ObjectBufferLen" (currently reserved, must be 00000000h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--BX00B6" name="2164--BX00B6"><b>2164--BX00B6</b></a> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API DosQFSAttach<br />
<pre>
INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API DosQFSAttach
	AH = 64h
	BX = 00B6h (API ordinal)
	CX = 636Ch (magic value "cl")
	DS = user's data segment
	ES:DI -&gt; FSQAttachStruc (see #01749)
Return: CF set on error
	    AX = error code (see #01680 at AH=59h/BX=0000h)
	CF clear if successful
	    AX = 0000h
	    data buffer filled
SeeAlso: AH=64h/CX=636Ch

Format of OS/2 Virtual DOS Machine FSQAttachStruc:
Offset	Size	Description	(Table 01749)
 00h	DWORD	reserved
 04h	DWORD	pointer to the offset of the data buffer length
 08h	DWORD	pointer to the offset of the data buffer
 0Ch	WORD	FSA Info level
 0Eh	WORD	ordinal index into table
 10h	DWORD	pointer to the offset of the device name
Notes:	The segment value of the buffer, buffer length, and device
	  name MUST all be the same.  It is defined on entry in the DS
	  register.  The details of each info level are defined in the
	  OS/2 CP Reference.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2164--BX00CB" name="2164--BX00CB"><b>2164--BX00CB</b></a> - INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API DosForceDelete<br />
<pre>
INT 21 U - OS/2 v2.1+ Virtual DOS Machine - OS/2 API DosForceDelete
	AH = 64h
	BX = 00CBh (API ordinal)
	CX = 636Ch (magic value "cl")
	DS:DX -&gt; ASCIZ filename
Return: CF clear if successful
	    AX destroyed
	CF set on error
	    AX = error code (02h,03h,05h) (see #01680 at AH=59h/BX=0000h)
Desc:	delete a file without saving it to the undelete directory
SeeAlso: AH=41h,AH=64h/CX=636Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2169_0" name="2169_0"><b>2169</b></a> - INT 21 - DR DOS 5.0 - NULL FUNCTION<br />
<pre>
INT 21 - DR DOS 5.0 - NULL FUNCTION
	AH = 69h
Return: AL = 00h
SeeAlso: AH=18h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#216C01" name="216C01"><b>216C01</b></a> - INT 21 U - OS/2 v2.0 - "DosOpen2"<br />
<pre>
INT 21 U - OS/2 v2.0 - "DosOpen2"
	AX = 6C01h
	BL = open mode as in AL for normal open (see also AH=3Dh)
	    bit 7: inheritance
	    bits 4-6: sharing mode
	    bit 3 reserved
	    bits 0-2: access mode
	BH = flags
	    bit 6 = auto commit on every write (see also AH=68h)
	    bit 5 = return error rather than doing INT 24h
	CX = create attribute (see #01769)
	DL = action if file exists/does not exist (see #01770)
	DH = 00h (reserved)
	DS:SI -&gt; ASCIZ file name
	ES:DI -&gt; EAOP structure
Return: CF set on error
	   AX = error code (see #01680 at AH=59h/BX=0000h)
	CF clear if successful
	   AX = file handle
	   CX = status (see #01768)
Note:	this function is virtually identical to AX=6C00h, but supports OS/2's
	  extended attributes
SeeAlso: AX=5704h,AX=6C00h,AH=6Fh"OS/2"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#216D_0" name="216D_0"><b>216D</b></a> - INT 21 U - OS/2 v1.x FAPI - "DosMkDir2"<br />
<pre>
INT 21 U - OS/2 v1.x FAPI - "DosMkDir2"
	AH = 6Dh
	???
Return: ???
Desc:	create a new directory, with extended attribute information
Note:	also supported by OS/2 v2.0+ Virtual DOS Machines
BUG:	does not work under OS/2 v2.0 because MVDM does not translate the
	  real-mode segment pointer in the Extended Attribute structure
	  (see #01673) into a protected-mode selector; use AH=39h followed by
	  AX=5703h instead
SeeAlso: AH=39h,AX=5702h"OS/2",AX=5703h"OS/2"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#216D_1" name="216D_1"><b>216D</b></a> - INT 21 U - Novell DOS 7 - NOP<br />
<pre>
INT 21 U - Novell DOS 7 - NOP
	AH = 6Dh
Return: AX = 0000h
Note:	this function invokes the same code as other NOP functions such as
	  AH=18h and AH=61h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#216E_0" name="216E_0"><b>216E</b></a> - INT 21 U - OS/2 v1.x FAPI - "DosEnumAttrib"<br />
<pre>
INT 21 U - OS/2 v1.x FAPI - "DosEnumAttrib"
	AH = 6Eh
	DS:SI -&gt; parameter packet (see #01772)
Return: CF clear if successful
	    AX = 0000h
	    DS:SI buffer updated
	CF set on error
	    AX = error code
Note:	also supported by OS/2 v2.0+ Virtual DOS Machines
SeeAlso: AX=5703h,AH=6Fh"OS/2",INT 2F/AX=112Dh

Format of OS/2 DosEnumAttrib parameter packet:
Offset	Size	Description	(Table 01772)
 00h	DWORD	reserved (0)
 04h	DWORD	info level (always 00000001h)
 08h	DWORD	(call) number of entries requested
		(ret) actual number of entries returned
 0Ch	DWORD	length of buffer
 10h	DWORD	pointer to buffer for results
 14h	DWORD	number of first entry to return
 18h	DWORD	-&gt; file handle or ASCIZ pathname
 1Ch	WORD	flag: 00h = previous field is file handle, 01h = pathname

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#216F00_0" name="216F00_0"><b>216F00</b></a> - INT 21 U - OS/2 v1.x FAPI - "DosQMaxEASize" - GET MAXIMUM SIZE OF EXTENDED ATTR<br />
<pre>
INT 21 U - OS/2 v1.x FAPI - "DosQMaxEASize" - GET MAXIMUM SIZE OF EXTENDED ATTR
	AX = 6F00h
	DS:SI -&gt; DWORD buffer for maximum size of an extended attribute
Return: CF clear if successful
	    AX = 0000h
	    buffer filled
	CF set on error
	    AX = error code
Note:	also supported by OS/2 v2.0+ Virtual DOS Machines
SeeAlso: AX=5703h,AX=6C01h,AH=6Eh"OS/2"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2192_0" name="2192_0"><b>2192</b></a> - INT 21 U - PTS-DOS 6.51 & S/DOS 1.0 - ABORT CURRENT PROCESS VIA INT 23<br />
<pre>
INT 21 U - PTS-DOS 6.51 & S/DOS 1.0 - ABORT CURRENT PROCESS VIA INT 23
	AH = 92h
Desc:	This function is provided by Paragon Technology Systems S/DOS 1.0+
	  (and most probably also by PTS-DOS 6.51+, maybe even earlier).
	  It allows terminating programs via the CTRL+BREAK method.
Note:	It is currently unknown if this function is also supported by
	  PhysTechSoft PTS-DOS 6.60, 6.70, or 2000.
SeeAlso: INT 23,INT 24

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#21E0" name="21E0"><b>21E0</b></a> - INT 21 - Digital Research DOS Plus - CALL BDOS<br />
<pre>
INT 21 - Digital Research DOS Plus - CALL BDOS
	AH = E0h
	CL = BDOS function number (see #04019 at INT E0"CP/M-86")
	other registers as appropriate for function
Return: as appropriate for function
SeeAlso: AX=4459h,INT E0"CP/M-86"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2C_0" name="2C_0"><b>2C</b></a> - INT 2C - STARLITE architecture - KERNEL API<br />
<pre>
INT 2C - STARLITE architecture - KERNEL API
Note:	STARLITE is an architecture by General Software for a series of MS-DOS
	  compatible operating systems (OEM DOS, NETWORK DOS, and SMP DOS) to
	  be released in 1991.	The interrupt number is subject to change
	  before the actual release.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2E_0" name="2E_0"><b>2E</b></a> - INT 2E UP - Windows NT - NATIVE API<br />
<pre>
INT 2E UP - Windows NT - NATIVE API
	EAX = function number (see #02586)
	EDX = address of parameter block
Return: ???

(Table 02586)
Values for Windows NT NTOS function number:
 000h	AcceptConnectPort	(24 bytes of parameters)
 001h	AccessCheck		(32 bytes of parameters)
 002h	AccessCheckAndAuditAlarm	(44 bytes of parameters)
 003h	AddAtom			(8 bytes of parameters)
 004h	AdjustGroupsToken	(24 bytes of parameters)
 005h	AdjustPrivilegesToken	(24 bytes of parameters)
 006h	AlertResumeThread	(8 bytes of parameters)
 007h	AlertThread		(4 bytes of parameters)
 008h	AllocateLocallyUniqueId	(4 bytes of parameters)
 009h	AllocateUuids		(12 bytes of parameters)
 00Ah	AllocateVirtualMemory	(24 bytes of parameters)
 00Bh	CallbackReturn		(12 bytes of parameters)
 00Ch	CancelIoFile		(8 bytes of parameters)
 00Dh	CancelTimer		(8 bytes of parameters)
 00Eh	ClearEvent		(4 bytes of parameters)
 00Fh	Close			(4 bytes of parameters)
 010h	CloseObjectAuditAlarm	(12 bytes of parameters)
 011h	CompleteConnectPort	(4 bytes of parameters)
 012h	ConnectPort		(32 bytes of parameters)
 013h	Continue		(8 bytes of parameters)
 014h	CreateDirectoryObject	(12 bytes of parameters)
 015h	CreateEvent		(20 bytes of parameters)
 016h	CreateEventPair		(12 bytes of parameters)
 017h	CreateFile		(44 bytes of parameters)
 018h	CreateIoCompletion	(16 bytes of parameters)
 019h	CreateKey		(28 bytes of parameters)
 01Ah	CreateMailslotFile	(32 bytes of parameters)
 01Bh	CreateMutant		(16 bytes of parameters)
 01Ch	CreateNamedPipeFile	(56 bytes of parameters)
 01Dh	CreatePagingFile	(16 bytes of parameters)
 01Eh	CreatePort		(20 bytes of parameters)
 01Fh	CreateProcess		(32 bytes of parameters)
 020h	CreateProfile		(36 bytes of parameters)
 021h	CreateSection		(28 bytes of parameters)
 022h	CreateSemaphore		(20 bytes of parameters)
 023h	CreateSymbolicLinkObject	(16 bytes of parameters)
 024h	CreateThread		(32 bytes of parameters)
 025h	CreateTimer		(16 bytes of parameters)
 026h	CreateToken		(52 bytes of parameters)
 027h	DelayExecution		(8 bytes of parameters)
 028h	DeleteAtom		(4 bytes of parameters)
 029h	DeleteFile		(4 bytes of parameters)
 02Ah	DeleteKey		(4 bytes of parameters)
 02Bh	DeleteObjectAuditAlarm	(12 bytes of parameters)
 02Ch	DeleteValueKey		(8 bytes of parameters)
 02Dh	DeviceIoControlFile	(40 bytes of parameters)
 02Eh	DisplayString		(4 bytes of parameters)
 02Fh	DuplicateObject		(28 bytes of parameters)
 030h	DuplicateToken		(24 bytes of parameters)
 031h	EnumerateKey		(24 bytes of parameters)
 032h	EnumerateValueKey	(24 bytes of parameters)
 033h	ExtendSection		(8 bytes of parameters)
 034h	FindAtom		(8 bytes of parameters)
 035h	FlushBuffersFile	(8 bytes of parameters)
 036h	FlushInstructionCache	(12 bytes of parameters)
 037h	FlushKey		(4 bytes of parameters)
 038h	FlushVirtualMemory	(16 bytes of parameters)
 039h	FlushWriteBuffer	(no parameters)
 03Ah	FreeVirtualMemory	(16 bytes of parameters)
 03Bh	FsControlFile		(40 bytes of parameters)
 03Ch	GetContextThread	(8 bytes of parameters)
 03Dh	GetPlugPlayEvent	(16 bytes of parameters)
 03Eh	GetTickCount		(no parameters)
 03Fh	ImpersonateClientOfPort	(8 bytes of parameters)
 040h	ImpersonateThread	(12 bytes of parameters)
 041h	InitializeRegistry	(4 bytes of parameters)
 042h	ListenPort		(8 bytes of parameters)
 043h	LoadDriver		(4 bytes of parameters)
 044h	LoadKey	(8 bytes of parameters)
 045h	LoadKey2		(12 bytes of parameters)
 046h	LockFile		(40 bytes of parameters)
 047h	LockVirtualMemory	(16 bytes of parameters)
 048h	MakeTemporaryObject	(4 bytes of parameters)
 049h	MapViewOfSection	(40 bytes of parameters)
 04Ah	NotifyChangeDirectoryFile	(36 bytes of parameters)
 04Bh	NotifyChangeKey		(40 bytes of parameters)
 04Ch	OpenDirectoryObject	(12 bytes of parameters)
 04Dh	OpenEvent		(12 bytes of parameters)
 04Eh	OpenEventPair		(12 bytes of parameters)
 04Fh	OpenFile		(24 bytes of parameters)
 050h	OpenIoCompletion	(12 bytes of parameters)
 051h	OpenKey			(12 bytes of parameters)
 052h	OpenMutant		(12 bytes of parameters)
 053h	OpenObjectAuditAlarm	(48 bytes of parameters)
 054h	OpenProcess		(16 bytes of parameters)
 055h	OpenProcessToken	(12 bytes of parameters)
 056h	OpenSection		(12 bytes of parameters)
 057h	OpenSemaphore		(12 bytes of parameters)
 058h	OpenSymbolicLinkObject	(12 bytes of parameters)
 059h	OpenThread		(16 bytes of parameters)
 05Ah	OpenThreadToken		(16 bytes of parameters)
 05Bh	OpenTimer		(12 bytes of parameters)
 05Ch	PlugPlayControl		(16 bytes of parameters)
 05Dh	PrivilegeCheck		(12 bytes of parameters)
 05Eh	PrivilegedServiceAuditAlarm	(20 bytes of parameters)
 05Fh	PrivilegeObjectAuditAlarm	(24 bytes of parameters)
 060h	ProtectVirtualMemory	(20 bytes of parameters)
 061h	PulseEvent		(8 bytes of parameters)
 062h	QueryInformationAtom	(20 bytes of parameters)
 063h	QueryAttributesFile	(8 bytes of parameters)
 064h	QueryDefaultLocale	(8 bytes of parameters)
 065h	QueryDirectoryFile	(44 bytes of parameters)
 066h	QueryDirectoryObject	(28 bytes of parameters)
 067h	QueryEaFile		(36 bytes of parameters)
 068h	QueryEvent		(20 bytes of parameters)
 069h	QueryFullAttributesFile	(8 bytes of parameters)
 06Ah	QueryInformationFile	(20 bytes of parameters)
 06Bh	QueryIoCompletion	(20 bytes of parameters)
 06Ch	QueryInformationPort	(20 bytes of parameters)
 06Dh	QueryInformationProcess	(20 bytes of parameters)
 06Eh	QueryInformationThread	(20 bytes of parameters)
 06Fh	QueryInformationToken	(20 bytes of parameters)
 070h	QueryIntervalProfile	(8 bytes of parameters)
 071h	QueryKey		(20 bytes of parameters)
 072h	QueryMultipleValueKey	(24 bytes of parameters)
 073h	QueryMutant		(20 bytes of parameters)
 074h	QueryObject		(20 bytes of parameters)
 075h	QueryOleDirectoryFile	(44 bytes of parameters)
 076h	QueryPerformanceCounter	(8 bytes of parameters)
 077h	QuerySection		(20 bytes of parameters)
 078h	QuerySecurityObject	(20 bytes of parameters)
 079h	QuerySemaphore		(20 bytes of parameters)
 07Ah	QuerySymbolicLinkObject	(12 bytes of parameters)
 07Bh	QuerySystemEnvironmentValue	(16 bytes of parameters)
 07Ch	QuerySystemInformation	(16 bytes of parameters)
 07Dh	QuerySystemTime		(4 bytes of parameters)
 07Eh	QueryTimer		(20 bytes of parameters)
 07Fh	QueryTimerResolution	(12 bytes of parameters)
 080h	QueryValueKey		(24 bytes of parameters)
 081h	QueryVirtualMemory	(24 bytes of parameters)
 082h	QueryVolumeInformationFile	(20 bytes of parameters)
 083h	QueueApcThread		(20 bytes of parameters)
 084h	RaiseException		(12 bytes of parameters)
 085h	RaiseHardError		(24 bytes of parameters)
 086h	ReadFile		(36 bytes of parameters)
 087h	ReadFileScatter		(36 bytes of parameters)
 088h	ReadRequestData		(24 bytes of parameters)
 089h	ReadVirtualMemory	(20 bytes of parameters)
 08Ah	RegisterThreadTerminatePort	(4 bytes of parameters)
 08Bh	ReleaseMutant		(8 bytes of parameters)
 08Ch	ReleaseSemaphore	(12 bytes of parameters)
 08Dh	RemoveIoCompletion	(20 bytes of parameters)
 08Eh	ReplaceKey		(12 bytes of parameters)
 08Fh	ReplyPort		(8 bytes of parameters)
 090h	ReplyWaitReceivePort	(16 bytes of parameters)
 091h	ReplyWaitReplyPort	(8 bytes of parameters)
 092h	RequestPort		(8 bytes of parameters)
 093h	RequestWaitReplyPort	(12 bytes of parameters)
 094h	ResetEvent		(8 bytes of parameters)
 095h	RestoreKey		(12 bytes of parameters)
 096h	ResumeThread		(8 bytes of parameters)
 097h	SaveKey	(8 bytes of parameters)
 098h	SetIoCompletion		(20 bytes of parameters)
 099h	SetContextThread	(8 bytes of parameters)
 09Ah	SetDefaultHardErrorPort	(4 bytes of parameters)
 09Bh	SetDefaultLocale	(8 bytes of parameters)
 09Ch	SetEaFile		(16 bytes of parameters)
 09Dh	SetEvent		(8 bytes of parameters)
 09Eh	SetHighEventPair	(4 bytes of parameters)
 09Fh	SetHighWaitLowEventPair	(4 bytes of parameters)
 0A0h	???			(??? bytes of parameters)
 0A1h	SetInformationFile	(20 bytes of parameters)
 0A2h	SetInformationKey	(16 bytes of parameters)
 0A3h	SetInformationObject	(16 bytes of parameters)
 0A4h	SetInformationProcess	(16 bytes of parameters)
 0A5h	SetInformationThread	(16 bytes of parameters)
 0A6h	SetInformationToken	(16 bytes of parameters)
 0A7h	SetIntervalProfile	(8 bytes of parameters)
 0A8h	SetLdtEntries		(24 bytes of parameters)
 0A9h	SetLowEventPair		(4 bytes of parameters)
 0AAh	SetLowWaitHighEventPair	(4 bytes of parameters)
 0ABh	???			(??? bytes of parameters)
 0ACh	SetSecurityObject	(12 bytes of parameters)
 0ADh	SetSystemEnvironmentValue	(8 bytes of parameters)
 0AEh	SetSystemInformation	(12 bytes of parameters)
 0AFh	SetSystemPowerState	(12 bytes of parameters)
 0B0h	SetSystemTime		(8 bytes of parameters)
 0B1h	SetTimer		(28 bytes of parameters)
 0B2h	SetTimerResolution	(12 bytes of parameters)
 0B3h	SetValueKey		(24 bytes of parameters)
 0B4h	SetVolumeInformationFile	(20 bytes of parameters)
 0B5h	ShutdownSystem		(4 bytes of parameters)
 0B6h	SignalAndWaitForSingleObject	(16 bytes of parameters)
 0B7h	StartProfile		(4 bytes of parameters)
 0B8h	StopProfile		(4 bytes of parameters)
 0B9h	SuspendThread		(8 bytes of parameters)
 0BAh	SystemDebugControl	(24 bytes of parameters)
 0BBh	TerminateProcess	(8 bytes of parameters)
 0BCh	TerminateThread		(8 bytes of parameters)
 0BDh	TestAlert		(no parameters)
 0BEh	UnloadDriver		(4 bytes of parameters)
 0BFh	UnloadKey		(4 bytes of parameters)
 0C0h	UnlockFile		(20 bytes of parameters)
 0C1h	UnlockVirtualMemory	(16 bytes of parameters)
 0C2h	UnmapViewOfSection	(8 bytes of parameters)
 0C3h	VdmControl		(8 bytes of parameters)
 0C4h	WaitForMultipleObjects	(20 bytes of parameters)
 0C5h	WaitForSingleObject	(12 bytes of parameters)
 0C6h	WaitHighEventPair	(4 bytes of parameters)
 0C7h	WaitLowEventPair	(4 bytes of parameters)
 0C8h	WriteFile		(36 bytes of parameters)
 0C9h	WriteFileGather		(36 bytes of parameters)
 0CAh	WriteRequestData	(24 bytes of parameters)
 0CBh	WriteVirtualMemory	(20 bytes of parameters)
 0CCh	W32Call			(20 bytes of parameters)
 0CDh	CreateChannel		(8 bytes of parameters)
 0CEh	ListenChannel		(8 bytes of parameters)
 0CFh	OpenChannel		(8 bytes of parameters)
 0D0h	ReplyWaitSendChannel	(12 bytes of parameters)
 0D1h	SendWaitReplyChannel	(16 bytes of parameters)
 0D2h	SetContextChannel	(4 bytes of parameters)
 0D3h	YieldExecution		(no parameters)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F10FE" name="2F10FE"><b>2F10FE</b></a> - INT 2F U - DR DOS 6.0+ DELWATCH.EXE - INSTALLATION CHECK<br />
<pre>
INT 2F U - DR DOS 6.0+ DELWATCH.EXE - INSTALLATION CHECK
	AX = 10FEh
Return: AL = FFh if installed and active
	    AH = internal version number
	        10h for DR DOS 6.0 DELWATCH 1.0 / 1.1 (through 1993/03/19)
		20h for Novell DOS 7+ DELWATCH 2.0+
	    DX:BX -&gt; private entry point (see #02605)
Notes:	The DR DOS 6.0 DELWATCH 1.x used to store information about deleted
	  files in a hidden file named @DLWATCH.DAT, however the Novell DOS 7+
	  DELWATCH 2.0+ stores all the info in previously unused fields in
	  the files' directory entries. (See table !!! at INT 21h/11h for
	  details). This, however, now causes problems on systems also running
	  Windows 9x since Microsoft decided to use a rather similar but
	  incompatible method to store long filenames etc. in these entries.
	Running DELWATCH 2.x on a system which previously used DELWATCH 1.x,
	  the @DLWATCH.DAT file will be abandoned and converted to the new
	  method.
SeeAlso: #01352,INT 21/AX=4306h,INT 21/AX=5704h,INT 2F/AX=1001h

(Table 02605)
Call DELWATCH private entry point with:
	AH = function
	    00h (OS hook) installation check
		AL = 00h required for DELWATCH 1.x
		Return: CF clear
			AX = 0000h
			CX = 0004h (unsupported function)
	    01h (DELWATCH 1.x) New Disk
	        ???
	    01h (DELWATCH 2.0+) disable DELWATCH on drive
		AL = drive number (00h = A:)
		Return: AX = status (0000h if failed, FFFFh if successful)
	    02h (OS hook) Delete File
		AL = drive number (00h = A:)
		DX = directory cluster number (0000h for root directory)
		CX = directory entry number
		DS:BX -&gt; directory entry
		ES,DS must be valid selectors if called in protected mode
		Return: DS:BX -&gt; updated directory entry
			CF set if file is to be deleted by the OS
			CF clear if DELWATCH has placed the file in its queue
		Note:	deletes the directory entry
	    03h	(OS hook) Free Clusters
		AL = drive number (00h = A:)
		CX = number of clusters currently free (do not free if &gt; 1)
		DX = preferred 'search from cluster' (ignored by DELWATCH 2.0)
		Return: CF clear if clusters freed
			CF set if no clusters freed
			DX = new 'search from' cluster (one before first free)
	    04h (OS hook) free root directory entry
		AL = drive number (00h = A:)
		Return: CF set if no directory entry freed
	    05h (OS hook) return free space
		AL = drive number (00h = A:)
		CX = number of free clusters
		Return:	CX = updated number of free clusters
		Notes:	adds space used by "deleted" files to free space
			call is chained
	    06h enable DELWATCH on drive
		AL = drive number with bit 7 set (80h = A:, etc.)
			(DELWATCH 2.0+: set bit 6 for removable drives)
		BX = maximum files of same name in one directory to save
		CX = maximum files to save on this disk
		DS:DX -&gt; MEMDESC??? for drive data (see #04104)
		DS:SI -&gt; MEMDESC??? for DWLIST (see #04104)
		ES,DS must contain valid selectors if called in protected mode
		Return: AX = status
			    0000h failed
			    FFFFh successful
			CX = error code on failure (see #04102)
			    (0004h "wrong version" if AL &lt; 80h on entry)
	    07h (DELWATCH 1.x) disable DELWATCH on drive
		???
	    07h (DELWATCH 2.0+) (OS hook) new disk
		AL = drive (00h = A:, etc.)
		ES:BX -&gt; DOS DDSC structure
		CF set if not enabled
		Return: ???
	    08h set file extensions list
		AL = sense (00h exclude named extensions, 01h only named ext.)
		DS:BX -&gt; 31-byte ASCIZ extension list (three blank-padded bytes
			  per extension)
		Return: AX = FFFFh (successful)
	    09h	adjust pending delete space
		AL = drive number (00h = A:)
		CX = number of clusters being freed
		Return: AX = 0000h if drive not enabled
	    0Ah remove DELWATCH entry
		AL = drive number (00h = A:)
		DX = directory cluster number (0000h if root directory)
		CX = directory entry number
		BX:SI -&gt; filename
		ES,DS must contain valid selectors if called in protected mode
		Return: AX &gt; 0000h if entry found in DWLIST
	    0Bh enable NEWDISK
		Return: AX &gt; 0000h if successful (FFFFh for DELWATCH 2.0)
		see also function 0Dh
	    0Ch (DELWATCH 1.x) drive status
		AL = drive number (00h = A:, etc.)
		Return: AX = drive data segment, 0000h if not enabled
			CX = pending delete space, if drive enabled
	    0Ch (DELWATCH 2.0+) check if drive enabled
		AL = drive number with bit 7 set (80h = A:, etc.)
		DS:DX -&gt; MEMDESC for drive data (see #04104)
			(DX = 0000h if not required)
		DS:SI -&gt; MEMDESC for DWLIST (see #04104)
			(SI = 0000h if not required)
		ES,DS must contain valid selectors if called in protected mode
		Return: AX = drive status (see also #04103)
			    0000h disabled or error
				CX = error code (see #04102)
			    0001h drive enabled
				CX = pending delete space, FFFFh if NEWDISK
				      not yet called
	    0Dh disable NEWDISK
		BX = segment address of bitmap buffer
		Return: AX &gt; 0000h if successful (FFFFh for DELWATCH 2.0)
		see also function 0Bh
	    0Eh (DELWATCH 2.0+) (OS hook) purge file
		AL = drive number (00h = A:)
		DX = directory cluster number (0000h if root directory)
		CX = directory entry number
		Return: CF set if drive not enabled
			CF clear
			    AX = status
				0000h successfully purged
				else error code (see #04102)
	    0Fh (DELWATCH 2.0+) (OS hook) undelete file
		AL = drive number (00h = A:)
		DX = directory cluster number (0000h if root directory)
		CX = directory entry number
		Return: CF set if drive not enabled
			CF clear
			    AX = status
				0000h successfully undeleted
				else error code (see #04102)
Return: AX = 0000h, CX = 0001h (see #04102) if DELWATCH busy
	registers unchanged if AH &gt; 0Fh on entry
Notes:	functions marked "OS hook" must under no circumstances by called by
	  external applications, as this would bypass the serialization
	  performed by the kernel and cause problems at least in multitasking
	  environments.
	two functions have been swapped between DELWATCH 1.x and DELWATCH 2.0
	  to ensure that DELWATCH 1.x calls will not do anything under newer
	  versions of the OS; for the same reason, the drive number in AL
	  sometimes requires that bit 7 be set for DELWATCH 2.0+.
SeeAlso: AX=1001h,AX=1010h

(Table 04102)
Values for DELWATCH error codes:
 0001h	reentered (DELWATCH busy)
 0002h	not enabled
 0003h	not found
 0004h	wrong version of DELWATCH
 0005h	memory allocation
SeeAlso: #04103

(Table 04103)
Values for DELWATCH drive status:
 0000h	drive not enabled
 0001h	OK
 0002h	no bitmap
 0003h	zero files
 0004h	cross-linked files
SeeAlso: #04102

Format of DELWATCH MEMDESC structure:
Offset	Size	Description	(Table 04104)
 00h	BYTE	memory type
		01h protected mode (DPMS)
		02h XMS
		03h upper (high) memory
		04h low memory
 01h	DWORD	location
		(conventional memory) WORD: segment base address
		(XMS) WORD: XMS handle
		(DPMS) DWORD: DPMS memory 32-bit base address
 05h	DWORD	length in bytes
 09h	DWORD	allocation
		(conventional memory) WORD: memory block segment
		(XMS) WORD: XMS handle (same as location handle)
		(DPMS) DWORD: DPMS 32-bit handle

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F10FF" name="2F10FF"><b>2F10FF</b></a> - INT 2F U - DR DOS 5.0 - FIXUP SHARE STUB TABLE???<br />
<pre>
INT 2F U - DR DOS 5.0 - FIXUP SHARE STUB TABLE???
	AX = 10FFh
	ES:BX -&gt; new SHARE stub table to use???
Return: DS destroyed???
Notes:	Sets a pointer in the kernel. ES:BX points to a structure in SHARE's
	  segment, which presumeably contains a number (4 or 11???) of entries
	  of 5 bytes each and is probably part of some kind of share stub
	  dispatcher that gets fixed up by this call.
	This was seen called by DR DOS 5.0 SHARE 1.00 (when INT 2F/AX=1000h
	  revealed that SHARE was not installed) before it hooked INT 2Fh
	  via INT 21/AH=35h to provide its install check function. It preserved
	  the DS register before calling.
	However, the DR DOS 6.0+ SHARE 1.02+ uses INT 2F/AX=1001h to hook
	  into the OS, DR PalmDOS SHARE 2.00 directly fixes up the share stubs
	  in table !!! at INT 21h/52h, and Novell DOS 7 - DR-DOS 7.03
	  SHARE 2.01-2.05 maintains the private set of share stubs in
	  Table !!! at INT 21/AX=4458h).
	This function was probably used between 1990/02/09 and 1991/03/15.
SeeAlso: INT 2F/AX=1001h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1250" name="2F1250"><b>2F1250</b></a> - INT 2F U - PTS-DOS - SET MACHINE ID<br />
<pre>
INT 2F U - PTS-DOS - SET MACHINE ID
	AX = 1250h
	???
Return: ???
Note:	This is known to be supported by Paragon Technology Systems PTS-DOS
	  sometime before 6.51, but is known not to be supported by S/DOS 1.0
	  (which derived from PTS-DOS 6.51)
SeeAlso: AX=1251h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1251" name="2F1251"><b>2F1251</b></a> - INT 2F U - PTS-DOS - GET MACHINE ID<br />
<pre>
INT 2F U - PTS-DOS - GET MACHINE ID
	AX = 1251h
	???
Return: ???
Note:	This is known to be supported by Paragon Technology Systems PTS-DOS
	  sometime before 6.51, but is known not to be supported by S/DOS 1.0
	  (which derived from PTS-DOS 6.51)
SeeAlso: AX=1250h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1252" name="2F1252"><b>2F1252</b></a> - INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - SET SFT INCREMENT<br />
<pre>
INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - SET SFT INCREMENT
	AX = 1252h
	BX = new SFT increment
Return: ???
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0 and probably was also supported
	  in earlier releases.
SeeAlso: AX=1253h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1253" name="2F1253"><b>2F1253</b></a> - INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - GET SFT INCREMENT<br />
<pre>
INT 2F U - PTS-DOS 6.51, S/DOS 1.0+ - GET SFT INCREMENT
	AX = 1253h
Return: BX = current SFT increment
	AX = ???
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0 and probably was also supported
	  in earlier releases.
SeeAlso: AX=1252h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1260" name="2F1260"><b>2F1260</b></a> - INT 2F C - PTS-DOS 6.51, S/DOS 1.0+ - "EMPTY" (RESERVED FOR INPUT STRING)<br />
<pre>
INT 2F C - PTS-DOS 6.51, S/DOS 1.0+ - "EMPTY" (RESERVED FOR INPUT STRING)
	AX = 1260h
	ES:DI -&gt; string buffer (see getstr)
	DL = extended keystroke code or FFh if ENTER
Return: AX = 0000h (default handler in the kernel)
	CF set if action done, all registers preserved
Notes:	This function is known to be handled by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also handled
	  in earlier releases.
	The default handler in the kernel justs XORs AX,AX and returns.
	This is reserved to be invoked in input string

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1261" name="2F1261"><b>2F1261</b></a> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET FIRST UMB<br />
<pre>
INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET FIRST UMB
	AX = 1261h
Return: AX = address of first UMB or 1 if invalid function.
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also supported
	  in earlier releases.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1262" name="2F1262"><b>2F1262</b></a> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET DOS COLOR<br />
<pre>
INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - GET DOS COLOR
	AX = 1262h
Return: AL = current video attribute used by DOS functions
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also supported
	  in earlier releases.
SeeAlso: AX=1263h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1263" name="2F1263"><b>2F1263</b></a> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - SET DOS COLOR<br />
<pre>
INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - SET DOS COLOR
	AX = 1263h
	DL = new video attribute to be used by DOS functions
Return: ???
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also supported
	  in earlier releases.
SeeAlso: AX=1262h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1270" name="2F1270"><b>2F1270</b></a> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - "SYSBELL" - EMIT A BEEP<br />
<pre>
INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - "SYSBELL" - EMIT A BEEP
	AX = 1270h
Return: ???
Note:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also supported
	  in earlier releases.
SeeAlso: AX=1271h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F1271" name="2F1271"><b>2F1271</b></a> - INT 2F C - PTS-DOS, S/DOS - RESERVED FOR BEEP<br />
<pre>
INT 2F C - PTS-DOS, S/DOS - RESERVED FOR BEEP
	AX = 1271h
Return: ???
Note:	According to the Paragon Technology Systems S/DOS 1.0 sources,
	  which derived from PTS-DOS 6.51, this is reserved for a "BEEP"
	  function. However, S/DOS 1.0 does not handle this function by
	  itself.
SeeAlso: AX=1270h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12F0" name="2F12F0"><b>2F12F0</b></a> - INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - BACKDOOR INTERCEPT INT 2Fh CHAIN<br />
<pre>
INT 2F - PTS-DOS 6.51, S/DOS 1.0+ - BACKDOOR INTERCEPT INT 2Fh CHAIN
	AX = 12F0h
	CX:DX -&gt; user INT 2F handler
	CF set
Return: CF clear if successful
	    CX:DX -&gt; previous INT 2F handler
	CF set on error
Notes:	This function is known to be supported by Paragon Technology Systems
	  PTS-DOS 6.51 and S/DOS 1.0, and probably was also supported
	  in earlier releases.  It is handled from within the kernel's
	  INT 2Fh dispatcher.
	Resident system extensions should call INT 2Fh/12F0h to intercept
	  the INT 2Fh chain. The main idea of this call is to allow them to
	  be moved to the HMA and intercept INT 2Fh without querying A20 state
	  and without interception of the INT2Fh vector. This is why the
	  "Chain2F" variable must be instanced by placing it to the SDA.
	On chain entry of the far procedure, CF must be set.  All registers
	  except for AX, BP, and DS remain unchanged. If a handler cannot
	  process the call, it must set CF and do a far jump to the previous
	  one in the chain in order to indicate an error.  If CF is still set
	  on exit, the call will be ignored.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12F1" name="2F12F1"><b>2F12F1</b></a> - INT 2F - PTS-DOS, S/DOS - RESERVED<br />
<pre>
INT 2F - PTS-DOS, S/DOS - RESERVED
	AX = 12F1h-12FFh
Return: ???
Note:	According to the Paragon Technology Systems S/DOS 1.0 sources,
	  which derived from PTS-DOS 6.51, these functions are reserved for
	  future use. However, S/DOS 1.0 does not make use of them itself.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL00" name="2F12FFBL00"><b>2F12FFBL00</b></a> - INT 2F - FreeDOS - FDAK-DDT - INSTALLATION CHECK / STATUS CHECK<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - INSTALLATION CHECK / STATUS CHECK
	AX = 12FFh
	BL = 00h
Return: AL = DDh if installed
	    BH = state (00h disabled, nonzero enabled)
	    BL = readonly flag (00h writable, nonzero read-only)
Program: FDAK-DDT is the FreeDOS Alternative Kernel Device Drivers Testing
	  release by Yury A. Semenov
SeeAlso: AX=12FFh/BL=07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL01" name="2F12FFBL01"><b>2F12FFBL01</b></a> - INT 2F - FreeDOS - FDAK-DDT - ENABLE FDAK DRIVERS<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - ENABLE FDAK DRIVERS
	AX = 12FFh
	BL = 01h
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL02" name="2F12FFBL02"><b>2F12FFBL02</b></a> - INT 2F - FreeDOS - FDAK-DDT - DISABLE FDAK DRIVERS<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - DISABLE FDAK DRIVERS
	AX = 12FFh
	BL = 02h
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL03" name="2F12FFBL03"><b>2F12FFBL03</b></a> - INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-ONLY<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-ONLY
	AX = 12FFh
	BL = 03h
	???
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL04" name="2F12FFBL04"><b>2F12FFBL04</b></a> - INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-WRITE<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - SWITCH BLOCK DEVICE TO READ-WRITE
	AX = 12FFh
	BL = 04h
	???
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL05" name="2F12FFBL05"><b>2F12FFBL05</b></a> - INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR ON<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR ON
	AX = 12FFh
	BL = 05h
Note:	not yet implemented as of January 1996
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL06" name="2F12FFBL06"><b>2F12FFBL06</b></a> - INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR OFF<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - TURN ACTIVITY INDICATOR OFF
	AX = 12FFh
	BL = 06h
Note:	not yet implemented as of January 1996
SeeAlso: AX=12FFh/BL=00h,AX=12FFh/BL=05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBL07" name="2F12FFBL07"><b>2F12FFBL07</b></a> - INT 2F - FreeDOS - FDAK-DDT - UNINSTALL<br />
<pre>
INT 2F - FreeDOS - FDAK-DDT - UNINSTALL
	AX = 12FFh
	BL = 07h
Return: ES = segment of FDAK memory block
Note:	the caller must free the memory block returned in ES
	  (via INT 21/AH=49h)
SeeAlso: AX=12FFh/BL=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0000" name="2F12FFBX0000"><b>2F12FFBX0000</b></a> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BDOS<br />
<pre>
INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BDOS
	AX = 12FFh
	BX = 0000h
Return: AX = 0000h if supported
	DX = size of the BDOS in paragraphs
	Flags trashed
	ES,CL destroyed (DR PalmDOS)
Note:	This API is provided by IBMBIO.COM for the initialization phase
	  of drivers loaded via DEVICE=/HIDEVICE=/DEVICEHIGH= directives and
	  is only available during these short time intervals.  It is called
	  by DR DOS 6.0 EMM386.SYS and Novell DOS 7+ EMM386.EXE to query the
	  size of the BDOS kernel (the resident code of IBMDOS.COM).
SeeAlso: AX=12FFh/BX=0001h,AX=12FFh/BX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0001" name="2F12FFBX0001"><b>2F12FFBX0001</b></a> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BDOS<br />
<pre>
INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BDOS
	AX = 12FFh
	BX = 0001h
	CX = 0000h (DR PalmDOS)
	DX = segment to relocate to (FFFFh for HMA)
Return: AX = 0000h if supported
	Flags trashed
	BX,CX,DX,DI,SI,DS,ES destroyed (DR PalmDOS)
Notes:	This API is provided by IBMBIO.COM for the initialization phase
	  of drivers loaded via DEVICE=/HIDEVICE=/DEVICEHIGH= directives and
	  is only available during these short time intervals.  It is initiated
	  by DR DOS 6.0 EMM386.SYS and Novell DOS 7+ EMM386.EXE to relocate
	  the BDOS kernel (e.g. into the HMA).
	This call is also issued by DR PalmDOS IBMBIO.COM which explicitly
	  clears CX.
	Under Novell DOS 7+ the actual relocation takes place at a later
	  stage, but under DR PalmDOS the BDOS is relocated immediately.
SeeAlso: AX=12FFh/BX=0000h,AX=12FFh/BX=0003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0002" name="2F12FFBX0002"><b>2F12FFBX0002</b></a> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BIOS<br />
<pre>
INT 2F U - DR DOS 6.0+ IBMBIO.COM - QUERY SIZE OF THE BIOS
	AX = 12FFh
	BX = 0002h
Return: AX = 0000h if supported
	DX = size of the DOS BIOS in paragraphs
	CL and flags trashed
Note:	This API is provided by IBMBIO.COM for the initialization phase
	  of drivers loaded via DEVICE=/HIDEVICE=/DEVICEHIGH= directives and
	  is only available during these short time intervals. It is called
	  by DR DOS 6.0 EMM386.SYS and Novell DOS 7 EMM386.EXE to query the
	  size of the DOS BIOS (the resident code of IBMBIO.COM).
SeeAlso: AX=12FFh/BX=0000h,AX=12FFh/BX=0003h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0003" name="2F12FFBX0003"><b>2F12FFBX0003</b></a> - INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BIOS<br />
<pre>
INT 2F U - DR DOS 6.0+ IBMBIO.COM - RELOCATE THE BIOS
	AX = 12FFh
	BX = 0003h
	CX = 0000h (DR PalmDOS)
	DX = segment to relocate to (FFFFh for HMA)
Return: AX = 0000h if supported
	Flags trashed
Notes:	This API is provided by IBMBIO.COM for the initialization phase
	  is only available during these short time intervals.  It is initiated
	  by DR DOS 6.0 EMM386.SYS and Novell DOS 7 EMM386.EXE to relocate the
	  resident part of the DOS BIOS.  The actual relocation takes place at
	  a later stage.
	This call is also issued by DR PalmDOS IBMBIO.COM which explicitly
	  clears CX.
SeeAlso: AX=12FFh/BX=0001h,AX=12FFh/BX=0002h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0005" name="2F12FFBX0005"><b>2F12FFBX0005</b></a> - INT 2F U - DR DOS 6.0+ - BOOT PHASE BROADCASTS FOR MEMORYMAX/RPLOADER/SECURITY<br />
<pre>
INT 2F U - DR DOS 6.0+ - BOOT PHASE BROADCASTS FOR MEMORYMAX/RPLOADER/SECURITY
	AX = 12FFh
	BX = 0005h
	CX = 0000h
	DX = function
	    0000h MemoryMAX cleanup broadcast
	    0001h RPLOADER broadcast
	    !!! details to follow
Note:	called at three separate points inside IBMBIO.COM

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0007" name="2F12FFBX0007"><b>2F12FFBX0007</b></a> - INT 2F U - Novell DOS 7 - SCRIPT.EXE - GET ???<br />
<pre>
INT 2F U - Novell DOS 7 - SCRIPT.EXE - GET ???
	AX = 12FFh
	BX = 0007h
	CX = 0000h
Return: CF clear if installed
	    AX = 0000h
	    BX = ??? (4426h)
	    CX = ??? (0068h)
	    DX = PSP segment of resident code???
	    SI = ??? (4AFAh)
	    ES = resident code segment

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0009" name="2F12FFBX0009"><b>2F12FFBX0009</b></a> - INT 2F - DR DOS 6.0+ IBMBIO.COM - REGISTER ROOT OF UPPER MEMORY LINK<br />
<pre>
INT 2F - DR DOS 6.0+ IBMBIO.COM - REGISTER ROOT OF UPPER MEMORY LINK
	AX = 12FFh
	BX = 0009h
	DX = new value for root segment of upper memory link
Return: AX = 0000h if supported
	ES:BX modified
Notes:	the DX value is stored at offset 66h in SYSVARS (see INT 21h/AH=52h)
	  and offset 18h in the Novell DOS 7 internal variable table
	  (see INT 21/AX=4458h)
	This API is provided by IBMBIO.COM for the initialization phase
	  of drivers loaded via DEVICE=/HIDEVICE=/DEVICEHIGH= directives and
	  is only available during these short time intervals.  It is probably
	  initiated by the Novell DOS 7+ EMM386.EXE.
	this function has apparently been supported since DR DOS 6.0 "Buxton"
	  of 1991/03/19
	for Novell DOS 7, ES:BX points at the internal variable table DRDAT,
	  but this may change in future releases

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F12FFBX0EDC" name="2F12FFBX0EDC"><b>2F12FFBX0EDC</b></a> - INT 2F U - Novell DOS 7 - EMM386.EXE - CHECK IF MULTITASKING SUPPORT LOADED???<br />
<pre>
INT 2F U - Novell DOS 7 - EMM386.EXE - CHECK IF MULTITASKING SUPPORT LOADED???
	AX = 12FFh
	BX = 0EDCh ('EDC' = Novell European Development Center)
Return: AX = 0000h if ??? loaded
	    CF clear
	    BX = 0000h
Notes:	called by Novell DOS 7 TaskMgr
	if this function returns with AX=0000h, then the code necessary to
	  support the API on INT 2F/AX=2780h is loaded and that API becomes
	  available for use
	because the request is handled on the initial trap to the memory
	  manager caused by INT instructions, this function must be invoked
	  with an actual INT 2F instruction instead of some simulation such
	  as a far call to the address in the interrupt vector table
SeeAlso: AX=2780h/CL=01h,AX=2780h/CL=02h,AX=2780h/CL=03h,AX=2780h/CL=04h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4001" name="2F4001"><b>2F4001</b></a> - INT 2F C - OS/2 compatibility box - SWITCHING DOS TO BACKGROUND<br />
<pre>
INT 2F C - OS/2 compatibility box - SWITCHING DOS TO BACKGROUND
	AX = 4001h
Note:	called by OS/2 when the DOS box is about to be placed in the background
	  and the video driver should save any necessary state
SeeAlso: AX=4002h,AX=4005h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4002" name="2F4002"><b>2F4002</b></a> - INT 2F C - OS/2 compatibility box - SWITCHING DOS TO FOREGROUND<br />
<pre>
INT 2F C - OS/2 compatibility box - SWITCHING DOS TO FOREGROUND
	AX = 4002h
Note:	called by OS/2 when the DOS box is about to be placed in the foreground
	  and the video driver should restore the previously-saved state
SeeAlso: AX=4001h,AX=4006h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4010" name="2F4010"><b>2F4010</b></a> - INT 2F - OS/2 v2.0+ - INSTALLATION CHECK / GET VERSION<br />
<pre>
INT 2F - OS/2 v2.0+ - INSTALLATION CHECK / GET VERSION
	AX = 4010h
Return: AX = 4010h if OS/2 not installed
	AX = 0000h for OS/2 Warp 3.0
	BX = OS/2 version if installed
Note:	OS/2 Warp 3.0
SeeAlso: INT 21/AH=30h,INT 21/AX=3306h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2F4011" name="2F4011"><b>2F4011</b></a> - INT 2F - OS/2 - GET VDD API ENTRY POINT<br />
<pre>
INT 2F - OS/2 - GET VDD API ENTRY POINT
	AX = 4011h
	DS:(E)SI -&gt; ASCIZ name of VDD registered with VDHRegisterAPI
Return: ES:DI -&gt; breakpoint address to call for VDD API, or 0000h:0000h
Note:	this function may be invoked from either V86 or protected mode, and
	  will return the appropriate address to call for invoking the VDD
	  in that mode
SeeAlso: AX=1684h"DEVICE API"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD00_0" name="2FAD00_0"><b>2FAD00</b></a> - INT 2F U - DR DOS 3.41-5.0, Novell DOS 7 KEYB - INSTALLATION CHECK<br />
<pre>
INT 2F U - DR DOS 3.41-5.0, Novell DOS 7 KEYB - INSTALLATION CHECK
	AX = AD00h
Return: AX = FFFFh if installed
	flags destroyed
Note:	the Novell DOS 7 KEYB driver only checks AL to determine whether it
	  is already installed
SeeAlso: AX=AD80h"Novell"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD01_0" name="2FAD01_0"><b>2FAD01</b></a> - INT 2F U - DR DOS 3.41,5.0 KEYB - GET CONFIGURATION<br />
<pre>
INT 2F U - DR DOS 3.41,5.0 KEYB - GET CONFIGURATION
	AX = AD01h
Return: BX = current code page (see #01757 at INT 21/AX=6602h)
	CX = current keyboard layout (0100h = US, 0102h = foreign)
	ES = resident code segment
SeeAlso: AX=AD01h"Novell",AX=AD00h"KEYB",AX=AD02h"KEYB",AX=AD83h"KEYB"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD01_1" name="2FAD01_1"><b>2FAD01</b></a> - INT 2F U - Novell DOS 7 KEYB - GET/SET??? CONFIGURATION<br />
<pre>
INT 2F U - Novell DOS 7 KEYB - GET/SET??? CONFIGURATION
	AX = AD01h
	CX = ??? (0000h)
Return: AX = FFFFh if Novell DOS 7 KEYB installed
	BX = current code page (see #01757 at INT 21/AX=6602h)
	CX = current keyboard layout (0100h = US, 0102h = foreign)
	ES = resident code segment
SeeAlso: AX=AD01h"DR DOS",AX=AD00h"KEYB",AX=AD02h"KEYB",AX=AD83h"KEYB"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAD02_0" name="2FAD02_0"><b>2FAD02</b></a> - INT 2F U - Novell DOS 7 KEYB - ???<br />
<pre>
INT 2F U - Novell DOS 7 KEYB - ???
	AX = AD02h
	DX = ??? (0000h)
Return: AX = FFFFh if installed
	flags destroyed
SeeAlso: AX=AD01h"KEYB"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF00" name="2FAF00"><b>2FAF00</b></a> - INT 2F - WinDOS v2.11 - INSTALLATION CHECK<br />
<pre>
INT 2F - WinDOS v2.11 - INSTALLATION CHECK
	AX = AF00h
Return: AL = FFh if installed
Program: WinDOS is a DOS clone (claimed to be mostly MS-DOS 5.0 API compatible)
	  written by Heiko Goemann
SeeAlso: AX=AF01h"WinDOS",INT 21/AH=30h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF01" name="2FAF01"><b>2FAF01</b></a> - INT 2F - WinDOS v2.11 - TURN ON ONLINE MODE<br />
<pre>
INT 2F - WinDOS v2.11 - TURN ON ONLINE MODE
	AX = AF01h
Return: nothing
Desc:	indicate that the user will not exchange floppy disks, allowing WinDOS
	  to cache disk sectors in memory and avoid writing modified sectors
	  back out to the floppy disk
SeeAlso: AX=AF00h"WinDOS",AX=AF02h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF02" name="2FAF02"><b>2FAF02</b></a> - INT 2F - WinDOS v2.11 - TURN OFF ONLINE MODE<br />
<pre>
INT 2F - WinDOS v2.11 - TURN OFF ONLINE MODE
	AX = AF02h
Return: nothing
Desc:	indicate that the floppy disk may be removed, and that WinDOS should
	  write all buffered sectors out to the floppy disk
SeeAlso: AX=AF00h"WinDOS",AX=AF01h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF03" name="2FAF03"><b>2FAF03</b></a> - INT 2F - WinDOS v2.11 - TURN VIDMEM ON<br />
<pre>
INT 2F - WinDOS v2.11 - TURN VIDMEM ON
	AX = AF03h
Return: AX = status
	    0000h successful
	    0001h CPU not in mode set by DOS386=On
	    0002h video adapter in graphics mode
	    0003h memory chain corrupted
SeeAlso: AX=AF00h"WinDOS",AX=AF04h"WinDOS",AX=AF05h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF04" name="2FAF04"><b>2FAF04</b></a> - INT 2F - WinDOS v2.11 - TURN VIDMEM OFF<br />
<pre>
INT 2F - WinDOS v2.11 - TURN VIDMEM OFF
	AX = AF04h
Return: AX = status
	    0000h successful
	    0001h video memory is in use
SeeAlso: AX=AF00h"WinDOS",AX=AF03h"WinDOS",AX=AF05h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF05" name="2FAF05"><b>2FAF05</b></a> - INT 2F - WinDOS v2.11 - GET VIDMEM STATE<br />
<pre>
INT 2F - WinDOS v2.11 - GET VIDMEM STATE
	AX = AF05h
Return: AX = status (0000h off, 0001h on)
SeeAlso: AX=AF00h"WinDOS",AX=AF03h"WinDOS",AX=AF04h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF06" name="2FAF06"><b>2FAF06</b></a> - INT 2F - WinDOS v2.11 - MAKE PROGRAM UNBREAKABLE<br />
<pre>
INT 2F - WinDOS v2.11 - MAKE PROGRAM UNBREAKABLE
	AX = AF06h
	DS:DX -&gt; break handler
	DI:BX = stack to use for break handler
Return: nothing
Desc:	set a handler which should be invoked when Ctrl-C is pressed instead of
	  aborting the program
SeeAlso: AX=AF00h"WinDOS",AX=AF0Ah"WinDOS",AX=AF0Ch"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF07" name="2FAF07"><b>2FAF07</b></a> - INT 2F - WinDOS v2.11 - SIGNAL FATAL OVERLAY FAULT<br />
<pre>
INT 2F - WinDOS v2.11 - SIGNAL FATAL OVERLAY FAULT
	AX = AF07h
Return: never -- system reset
Desc:	pop up a window indicating that the system overlay file can not be
	  loaded
SeeAlso: AX=AF00h"WinDOS",AX=AF08h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF08" name="2FAF08"><b>2FAF08</b></a> - INT 2F - WinDOS v2.11 - SIGNAL RECOVERABLE OVERLAY FAULT<br />
<pre>
INT 2F - WinDOS v2.11 - SIGNAL RECOVERABLE OVERLAY FAULT
	AX = AF08h
Return: nothing
Desc:	pop up a window requesting that a disk containing SH.OVL be inserted
SeeAlso: AX=AF00h"WinDOS",AX=AF07h"WinDOS",AX=AF0Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF09" name="2FAF09"><b>2FAF09</b></a> - INT 2F - WinDOS v2.11 - GET TERMINATED PSP<br />
<pre>
INT 2F - WinDOS v2.11 - GET TERMINATED PSP
	AX = AF09h
Return: DS = PSP segment of most recently ended TSR
SeeAlso: AX=AF00h"WinDOS",AX=AF0Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0A" name="2FAF0A"><b>2FAF0A</b></a> - INT 2F - WinDOS v2.11 - GET MAIN SHELL PSP<br />
<pre>
INT 2F - WinDOS v2.11 - GET MAIN SHELL PSP
	AX = AF0Ah
Return: AX = shell's PSP (same as DS on last call to AX=AF06h)
Desc:	get the PSP address of the last program to call AX=AF06h (normally
	  the main command interpreter)
SeeAlso: AX=AF00h"WinDOS",AX=AF06h"WinDOS",AX=AF09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0B" name="2FAF0B"><b>2FAF0B</b></a> - INT 2F - WinDOS v2.11 - SIGNAL FATAL ERROR<br />
<pre>
INT 2F - WinDOS v2.11 - SIGNAL FATAL ERROR
	AX = AF0Bh
Return: never -- system reset
Desc:	pop up a window indicating a terminal system error
SeeAlso: AX=AF00h"WinDOS",AX=AF07h,AX=AF08h,AX=AF15h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0C" name="2FAF0C"><b>2FAF0C</b></a> - INT 2F - WinDOS v2.11 - GET OTHER MAIN SHELL PARAMETERS<br />
<pre>
INT 2F - WinDOS v2.11 - GET OTHER MAIN SHELL PARAMETERS
	AX = AF0Ch
Return: DI:AX = stack
	SI = offset of break handler
Desc:	retrieve the parameters last set by AX=AF06h (normally by the main
	  command interpreter)
SeeAlso: AX=AF00h"WinDOS",AX=AF06h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0D" name="2FAF0D"><b>2FAF0D</b></a> - INT 2F - WinDOS v2.11 - GET CURRENT PARAMETER<br />
<pre>
INT 2F - WinDOS v2.11 - GET CURRENT PARAMETER
	AX = AF0Dh
	BX = offset of desired parameter in global data area
Return: AX = current value of parameter (AH undefined if byte value)
SeeAlso: AX=AF00h"WinDOS",AX=AF0Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0E" name="2FAF0E"><b>2FAF0E</b></a> - INT 2F - WinDOS v2.11 - SET CURRENT PARAMETER BYTE VALUE<br />
<pre>
INT 2F - WinDOS v2.11 - SET CURRENT PARAMETER BYTE VALUE
	AX = AF0Eh
	BX = offset of desired parameter in global data area
	DL = new value of parameter
Return: nothing
SeeAlso: AX=AF00h"WinDOS",AX=AF0Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF0F" name="2FAF0F"><b>2FAF0F</b></a> - INT 2F - WinDOS v2.11 - GET HISTORY SEGMENT<br />
<pre>
INT 2F - WinDOS v2.11 - GET HISTORY SEGMENT
	AX = AF0Fh
Return: AX = segment of buffer for input history, or 0000h if none
SeeAlso: AX=AF00h"WinDOS",AX=AF10h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF10" name="2FAF10"><b>2FAF10</b></a> - INT 2F - WinDOS v2.11 - SET HISTORY SEGMENT<br />
<pre>
INT 2F - WinDOS v2.11 - SET HISTORY SEGMENT
	AX = AF10h
	BX = segment of new buffer for input history
Return: nothing
Note:	the buffer must have been allocated with INT 21/AH=48h
SeeAlso: AX=AF00h"WinDOS",AX=AF0Fh"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF11" name="2FAF11"><b>2FAF11</b></a> - INT 2F - WinDOS v2.11 - FREE XMS BLOCKS<br />
<pre>
INT 2F - WinDOS v2.11 - FREE XMS BLOCKS
	AX = AF11h
Return: nothing
Desc:	free all XMS blocks whose XMS identification value (see AX=AF12h)
	  equals the current PSP
SeeAlso: AX=AF00h"WinDOS",AX=AF12h"WinDOS",INT 21/AH=50h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF12" name="2FAF12"><b>2FAF12</b></a> - INT 2F - WinDOS v2.11 - SET XMS IDENTIFICATION VALUE<br />
<pre>
INT 2F - WinDOS v2.11 - SET XMS IDENTIFICATION VALUE
	AX = AF12h
	DS = new XMS identification value (normally caller's PSP segment)
Return: nothing
SeeAlso: AX=AF00h"WinDOS",AX=AF11h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF13" name="2FAF13"><b>2FAF13</b></a> - INT 2F - WinDOS v2.11 - SET ASSIGN VALUE<br />
<pre>
INT 2F - WinDOS v2.11 - SET ASSIGN VALUE
	AX = AF13h
	BL = number of drive to remap (00h = A:)
	DL = number of drive to be accessed via drive number BL
Return: nothing
Desc:	remap a drive letter
Note:	the remapping can be canceled by specifying DL=BL
SeeAlso: AX=AF00h"WinDOS",AX=AF14h"WinDOS",AX=0601h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF14" name="2FAF14"><b>2FAF14</b></a> - INT 2F - WinDOS v2.11 - GET ASSIGN VALUE<br />
<pre>
INT 2F - WinDOS v2.11 - GET ASSIGN VALUE
	AX = AF14h
	BL = drive number (00h = A:)
Return: DL = drive number which is actually accessed by drive number BL
Desc:	determine the current mapping for a drive
SeeAlso: AX=AF00h"WinDOS",AX=AF13h"WinDOS",AX=0601h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF15" name="2FAF15"><b>2FAF15</b></a> - INT 2F - WinDOS v2.11 - SIGNAL STACK ERROR<br />
<pre>
INT 2F - WinDOS v2.11 - SIGNAL STACK ERROR
	AX = AF15h
Return: never -- system reset
Desc:	pop up a window indicating a stack overflow
SeeAlso: AX=AF00h"WinDOS",AX=AF0Bh"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF16" name="2FAF16"><b>2FAF16</b></a> - INT 2F - WinDOS v2.11 - GET SIMPLE TRUENAME<br />
<pre>
INT 2F - WinDOS v2.11 - GET SIMPLE TRUENAME
	AX = AF16h
	DS:SI -&gt; path to be canonicalized
	ES:DI -&gt; buffer for canonicalized filename/pathname
Return: CF clear if successful
	    AX = 0000h
	CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
Desc:	partially canonicalize a path, omitting SUBST, JOIN, ASSIGN, and
	  network redirections
SeeAlso: AX=AF00h"WinDOS",INT 21/AH=60h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF17" name="2FAF17"><b>2FAF17</b></a> - INT 2F - WinDOS v2.11 - QUERY FOR NEW CURRENT DRIVE<br />
<pre>
INT 2F - WinDOS v2.11 - QUERY FOR NEW CURRENT DRIVE
	AX = AF17h
Return: nothing
Desc:	pop up a dialog allowing the user to select a new default drive
SeeAlso: AX=AF00h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF18" name="2FAF18"><b>2FAF18</b></a> - INT 2F - WinDOS v2.11 - SET CTRL-C/CTRL-BREAK DISABLE FLAG<br />
<pre>
INT 2F - WinDOS v2.11 - SET CTRL-C/CTRL-BREAK DISABLE FLAG
	AX = AF18h
	DL = new break-checking state (00h enabled, 01h disabled)
Return: nothing
SeeAlso: AX=AF00h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF19" name="2FAF19"><b>2FAF19</b></a> - INT 2F - WinDOS v2.11 - SET HEAD SETTLE FLAG<br />
<pre>
INT 2F - WinDOS v2.11 - SET HEAD SETTLE FLAG
	AX = AF19h
	DL = new state
	    00h diskette head settling time reset to 15ms before each access
	    01h no additional head settling time used between accesses
Return: nothing
SeeAlso: AX=AF00h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FAF1A" name="2FAF1A"><b>2FAF1A</b></a> - INT 2F - WinDOS v2.11 - SEARCH FOR NON-FRAGMENTED DISK AREA<br />
<pre>
INT 2F - WinDOS v2.11 - SEARCH FOR NON-FRAGMENTED DISK AREA
	AX = AF1Ah
	BL = drive (00h = current, 01h = A:, etc.)
	CX = number of clusters desired
Return: CF clear if successful
	    DI = first free cluster on logical drive
	    BP = first cluster of contiguous free area
	    AX destroyed
	CF set on error
	    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)
Desc:	attempt to find an area of the disk containing the specified number
	  of contiguous unallocated clusters
SeeAlso: AX=AF00h"WinDOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#2FEDC8BX0000" name="2FEDC8BX0000"><b>2FEDC8BX0000</b></a> - INT 2F - Novell DOS 7+ - SECURITY.BIN - INSTALLATION CHECK<br />
<pre>
INT 2F - Novell DOS 7+ - SECURITY.BIN - INSTALLATION CHECK
	AX = EDC8h ('EDC' = Novell European Development Centre)
	BX = 0000h
	CX = 0000h
	DX = 1234h
Return: ???
Note:	called by Novell DOS 7 LOCK command during installation

(Table 04107)
Call Novell DOS SECURITY.BIN API with:
	AX??? = function
	    0000h get status
	    0001h authenticate password hash
	    0002h get / change encrypted master key password???
	    0003h ??? Set encrypted master key password
	    0004h ??? Get logged-in user ID
	    0005h ??? Set logged-in user ID
	    0006h Get device restriction mask
	    0007h Set device restriction mask
	    0008h Disable PNW DB access
	    0009h Enable PNW DB access
	    000Ah Get user name
	    000Bh Set user name
	    000Ch Change user password hash
	    000Dh Get last function
	    000Eh Get Encoded ASCII password
	    000Fh Set Encoded ASCII password
	    0010h Get user seed
	    0011h Set user seed
	    !!! more info to follow

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#38_0" name="38_0"><b>38</b></a> - INT 38 - PC-MOS/386 v3.0 - API<br />
<pre>
INT 38 - PC-MOS/386 v3.0 - API
Note:	this API was been moved to INT D4h sometime between versions 3.0 and
	  5.01; v3.0 supported at least functions 02h,04h,0703h,10h,11h, and
	  12h
SeeAlso: INT D4/AH=02h,INT D4/AH=04h,INT D4/AH=07h,INT D4/AH=10h,INT D4/AH=11h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#40_1" name="40_1"><b>40</b></a> - INT 40 - Acorn BBC Master 512 - "OSFIND" - OPEN FILE<br />
<pre>
INT 40 - Acorn BBC Master 512 - "OSFIND" - OPEN FILE
	AL = operation
	    00h close file
	    40h open file for reading
	    80h open file for writing
	    C0h open file for random access
	DS:BX -&gt; CR-terminated filename
Return: AL = file handle (00h if file closed or could not be opened)
Note:	the Acorn BBC Master 512 is an 80186-based add-on board for the
	  6502-based Master 128 which uses the original CPU as an I/O processor
SeeAlso: INT 41"Acorn",INT 42"Acorn",INT 43"Acorn",INT 44"Acorn",INT 4C"Acorn"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#41_2" name="41_2"><b>41</b></a> - INT 41 - Acorn BBC Master 512 - "OSGBPB" - MULTI-BYTE GET/PUT<br />
<pre>
INT 41 - Acorn BBC Master 512 - "OSGBPB" - MULTI-BYTE GET/PUT
	AL = function
	    01h put bytes sequentially
	    02h put bytes, ignoring sequential pointer
	    03h get bytes sequentially
	    04h get bytes, ignoring sequential pointer
	    05h get media title and boot option
	    06h get current device and directory
	    07h get current library and device
	    08h search directory
	DS:BX -&gt; control block (see #03199)
Return: CF clear if successful
	CF set on error
	AL = 00h if operation attempted
	AL unchanged if unsupported function
SeeAlso: INT 40"Acorn",INT 42"Acorn",INT 43"Acorn"

Format of BBC Master control block:
Offset	Size	Description	(Table 03199)
 00h	BYTE	file handle
 01h	DWORD	pointer to data in either I/O processor or Tube processor
 05h	DWORD	number of bytes to be transferred
 09h	DWORD	transfer address

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#42_3" name="42_3"><b>42</b></a> - INT 42 - Acorn BBC Master 512 - "OSBPUT" - WRITE SINGLE BYTE TO FILE<br />
<pre>
INT 42 - Acorn BBC Master 512 - "OSBPUT" - WRITE SINGLE BYTE TO FILE
	AL = byte to be written
	BH = file handle
Return: flags destroyed
SeeAlso: INT 40"Acorn",INT 41"Acorn",INT 43"Acorn",INT 47"Acorn",INT 49"Acorn"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#43_2" name="43_2"><b>43</b></a> - INT 43 - Acorn BBC Master 512 - "OSBGET" - READ SINGLE BYTE FROM FILE<br />
<pre>
INT 43 - Acorn BBC Master 512 - "OSBGET" - READ SINGLE BYTE FROM FILE
	BH = file handle
Return: CF clear if successful
	    AL = byte read from file
	CF set on error
SeeAlso: INT 40"Acorn",INT 41"Acorn",INT 42"Acorn",INT 46"Acorn"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#4400" name="4400"><b>4400</b></a> - INT 44 - Acorn BBC Master 512 - "OSARGS" - GET/SET FILE PARAMS FOR OPEN FILE<br />
<pre>
INT 44 - Acorn BBC Master 512 - "OSARGS" - GET/SET FILE PARAMS FOR OPEN FILE
	AH = 00h
	AL = function
	    00h get current filing system
		Return: AL = filing system (see #03200)
	    01h get address of commandline tail
		Return: BX buffer filled with address of command tail in I/O
			      processor address space (use INT 4A/AL=05h to
			      retrieve)
	    FFh flush all files onto secondary storage
	BX -&gt; 4-byte data buffer
Note:	the commandline tail is terminated with a carriage return (0Dh)
SeeAlso: INT 40"Acorn",INT 45"Acorn"

(Table 03200)
Values for BBC Master filing system:
 00h	none
 01h	1200 bps cassette
 02h	300 bps cassette
 03h	ROM FS
 04h	DFS
 05h	ANFS/NFS
 06h	TFS
 08h	ADFS

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#44_5" name="44_5"><b>44</b></a> - INT 44 - Acorn BBC Master 512 - "OSARGS" - GET/SET FILE PARAMS FOR OPEN FILE<br />
<pre>
INT 44 - Acorn BBC Master 512 - "OSARGS" - GET/SET FILE PARAMS FOR OPEN FILE
	AH = nonzero file handle
	AL = function
	    00h get sequential pointer for file
	    01h set sequential pointer for file
	    02h get length of file
	BX -&gt; 4-byte data buffer
Return: BX buffer updated if appropriate
SeeAlso: INT 40"Acorn",INT 41"Acorn",INT 44/AH=00h,INT 45"Acorn",INT 4A"Acorn"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#45_1" name="45_1"><b>45</b></a> - INT 45 - Acorn BBC Master 512 - "OSFILE" - READ/WRITE FILE OR DIRECTORY INFO<br />
<pre>
INT 45 - Acorn BBC Master 512 - "OSFILE" - READ/WRITE FILE OR DIRECTORY INFO
	AL = function
	    00h save block of memory as file
	    01h update directory entry for existing file
	    02h set load address for existing file
	    03h set execution address for existing file
	    04h set attributes for existing file
	    05h read directory
	    06h delete file
	    FFh load file
	DS:BX -&gt; control block (see #03201)
Return: FLAGS destroyed
	AL = file type
	    00h not found
	    01h file found
	    02h directory found
	    FFh protected file
SeeAlso: INT 40"Acorn",INT 41"Acorn",INT 44"Acorn",INT 46"Acorn"

Format of BBC Master control block:
Offset	Size	Description	(Table 03201)
 00h	WORD	address of CR-terminated filename
 02h	DWORD	load address of file
 06h	DWORD	execution address of file
 0Ah	DWORD	start address of data to save
 0Eh	DWORD	end address of data to save, or file attributes
		file attributes in low byte (see #03202)
		other three bytes are filing-system specific file attributes

Bitfields for BBC Master file attributes:
Bit(s)	Description	(Table 03202)
 0	no owner read access
 1	no owner write access
 2	not executable by owner
 3	not deletable by owner
 4	no public read access
 5	no public write access
 6	not executable with public access
 7	not deletable with public access

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#46_2" name="46_2"><b>46</b></a> - INT 46 - Acorn BBC Master 512 - "OSRDCH" - GET CHARACTER FROM CUR INPUT STREAM<br />
<pre>
INT 46 - Acorn BBC Master 512 - "OSRDCH" - GET CHARACTER FROM CUR INPUT STREAM
Return: CF clear if successful
	    AL = character read
	CF set on error
	    AL = error code
SeeAlso: INT 40"Acorn",INT 43"Acorn",INT 47"Acorn",INT 49"Acorn"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#47_1" name="47_1"><b>47</b></a> - INT 47 - Acorn BBC Master 512 - "OSWRCH" - WRITE CHARACTER TO CUR OUTPUT STREAM<br />
<pre>
INT 47 - Acorn BBC Master 512 - "OSWRCH" - WRITE CHARACTER TO CUR OUTPUT STREAM
	AL = character to be written
Return: FLAGS destroyed
SeeAlso: INT 40"Acorn",INT 46"Acorn",INT 49"Acorn"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#48_2" name="48_2"><b>48</b></a> - INT 48 - Acorn BBC Master 512 - "OSNEWL" - SEND NEWLINE TO OUTPUT STREAM<br />
<pre>
INT 48 - Acorn BBC Master 512 - "OSNEWL" - SEND NEWLINE TO OUTPUT STREAM
Return: FLAGS destroyed
Note:	writes a carriage return (0Dh) followed by a linefeed (0Ah)
SeeAlso: INT 40"Acorn",INT 47"Acorn",INT 49"Acorn"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#49_2" name="49_2"><b>49</b></a> - INT 49 - Acorn BBC Master 512 - "OSASCI" - WRITE CHARACTER TO CUR OUTPUT STREAM<br />
<pre>
INT 49 - Acorn BBC Master 512 - "OSASCI" - WRITE CHARACTER TO CUR OUTPUT STREAM
	AL = character to be written
Return: FLAGS destroyed
Note:	converts carriage return (0Dh) into CRLF sequence (0Dh 0Ah)
SeeAlso: INT 40"Acorn",INT 46"Acorn",INT 47"Acorn",INT 48"Acorn"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#4A_2" name="4A_2"><b>4A</b></a> - INT 4A - Acorn BBC Master 512 - "OSWORD" - MISC FUNCTIONS USING CONTROL BLOCK<br />
<pre>
INT 4A - Acorn BBC Master 512 - "OSWORD" - MISC FUNCTIONS USING CONTROL BLOCK
	AL = function code
	    FAh transfer data between 80186 and 65C12 I/O processor
	DS:BX -&gt; control block (see #03211)
Return: FLAGS destroyed
	control block updated
Note:	there are more functions than are listed here, but details are not
	  available
SeeAlso: INT 40"Acorn",INT 4B"Acorn",INT 4C"Acorn"

Format of BBC Master control block for function FAh:
Offset	Size	Description	(Table 03211)
 00h	BYTE	number of parameters sent to I/O processor (0Dh,0Eh)
 01h	BYTE	number of parameters read from I/O processor (01h)
 02h	DWORD	I/O processor address
 06h	DWORD	80186 segment:offset address
 0Ah	WORD	number of bytes to transfer
 0Ch	BYTE	operation type
		00h write to 65C12 at 24 us/byte
		01h read from 65C12 at 24 us/byte
		02h write to 65C12 at 26 us/word
		03h read from 65C12 at 26 us/word
		04h write to 65C12 at 10 us/byte using 256-byte blocks
		05h read from 65C12 at 10 us/byte using 256-byte blocks
 0Dh	BYTE	65C12 memory access control (only used if offset 00h = 0Eh)
		(see #03212)

Bitfields for 65C12 memory access control:
Bit(s)	Description	(Table 03212)
 7	unused
 6	always use main screen memory if I/O addr 3000h-7FFFh (overrides bit 5)
 5	use shadow screen memory if screen address specified
 4	use current ROM rather than ROM selected by bits 3-0 (only if I/O
	  address between 8000h and BFFFh)
 3-0	paged ROM number

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#4B_2" name="4B_2"><b>4B</b></a> - INT 4B - Acorn BBC Master 512 - "OSBYTE" - MISC FUNCTIONS USING REGISTER PARAMS<br />
<pre>
INT 4B - Acorn BBC Master 512 - "OSBYTE" - MISC FUNCTIONS USING REGISTER PARAMS
	AL = function code
	BL = first parameter
	BH = second parameter (if needed)
Return: BL = first return parameter
	BH = second return parameter
	CF depends on function
SeeAlso: INT 40"Acorn",INT 4A"Acorn",INT 4C"Acorn"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#4C_2" name="4C_2"><b>4C</b></a> - INT 4C - Acorn BBC Master 512 - "OSCLI" - INTERPRET COMMAND LINE<br />
<pre>
INT 4C - Acorn BBC Master 512 - "OSCLI" - INTERPRET COMMAND LINE
	DS:BX -&gt; CR-terminated command string
Return: FLAGS destroyed
SeeAlso: INT 40"Acorn",INT 4A"Acorn",INT 4B"Acorn"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#80_3" name="80_3"><b>80</b></a> - INT 80 - Linux - SYSTEM CALLS<br />
<pre>
INT 80 - Linux - SYSTEM CALLS
	parameters in registers

(Table 04086)
Values for system call number:
 00h	???
 01h	exit
 02h	fork
 03h	read
 04h	write
 05h	open
 06h	close
 07h	waitpid
 08h	creat
 09h	link
 0Ah	unlink
 0Bh	execve
 0Ch	chdir
 0Dh	time
 0Eh	mknod
 0Fh	chmod
 10h	lchown
 11h	break
 12h	oldstat (obsolete)
 13h	lseek
 14h	getpid
 15h	mount
 16h	umount
 17h	setuid
 18h	getuid
 19h	stime
 1Ah	ptrace
 1Bh	alarm
 1Ch	oldfstat
 1Dh	pause
 1Eh	utime
 1Fh	stty
 20h	gtty
 21h	access
 22h	nice
 23h	ftime
 24h	sync
 25h	kill
 26h	rename
 27h	mkdir
 28h	rmdir
 29h	dup
 2Ah	pipe
 2Bh	times
 2Ch	prof
 2Dh	brk
 2Eh	setgid
 2Fh	getgid
 30h	signal
 31h	geteuid
 32h	getegid
 33h	acct
 34h	umount2
 35h	lock
 36h	ioctl
 37h	fcntl
 38h	mpx
 39h	setpgid
 3Ah	ulimit
 3Bh	oldolduname (obsolete)
 3Ch	umask
 3Dh	chroot
 3Eh	ustat
 3Fh	dup2
 40h	getppid
 41h	getpgrp
 42h	setsid
 43h	sigaction
 44h	sgetmask
 45h	ssetmask
 46h	setreuid
 47h	setregid
 48h	sigsuspend
 49h	sigpending
 4Ah	sethostname
 4Bh	setrlimit
 4Ch	getrlimit
 4Dh	getrusage
 4Eh	gettimeofday
 4Fh	settimeofday
 50h	getgroups
 51h	setgroups
 52h	select
 53h	symlink
 54h	oldlstat (obsolete)
 55h	readlink
 56h	uselib
 57h	swapon
 58h	reboot
 59h	readdir
 5Ah	mmap
 5Bh	munmap
 5Ch	truncate
 5Dh	ftruncate
 5Eh	fchmod
 5Fh	fchown
 60h	getpriority
 61h	setpriority
 62h	profil
 63h	statfs
 64h	fstatfs
 65h	ioperm
 66h	socketcall
 67h	syslog
 68h	setitimer
 69h	getitimer
 6Ah	stat
 6Bh	lstat
 6Ch	fstat
 6Dh	olduname (obsolete)
 6Eh	iopl
 6Fh	vhangup
 70h	idle
 71h	vm86old
 72h	wait4
 73h	swapoff
 74h	sysinfo
 75h	ipc
 76h	fsunc
 77h	sigreturn
 78h	clone
 79h	setdomainname
 7Ah	uname
 7Bh	modify_ldt
 7Ch	adjtimex
 7Dh	mprotect
 7Eh	sigprocmask
 7Fh	create_module
 80h	init_module
 81h	delete_module
 82h	get_kernel_syms
 83h	quotactl
 84h	getpgid
 85h	fchdir
 86h	bdflush
 87h	sysfs
 88h	personality
 89h	afs_syscall
 8Ah	setfsuid
 8Bh	setfsgid
 8Ch	llseek
 8Dh	getdents
 8Eh	newselect
 8Fh	flock
 90h	msync
 91h	readv
 92h	writev
 93h	getsid
 94h	fdatasync
 95h	sysctl
 96h	mlock
 97h	munlock
 98h	mlockall
 99h	munlockall
!!! http://home.snafu.de/phpr/lhpsysc0.html

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#80_4" name="80_4"><b>80</b></a> - INT 80 - FreeBSD - SYSTEM CALLS<br />
<pre>
INT 80 - FreeBSD - SYSTEM CALLS
	parameters on stack

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#81_3" name="81_3"><b>81</b></a> - INT 81 - Paragon Technology PTS/DOS 6.5x, S/DOS 1.0 - API<br />
<pre>
INT 81 - Paragon Technology PTS/DOS 6.5x, S/DOS 1.0 - API

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D400" name="D400"><b>D400</b></a> - INT D4 O - PC-MOS/386 v5.01 - OBSOLETE FUNCTIONS<br />
<pre>
INT D4 O - PC-MOS/386 v5.01 - OBSOLETE FUNCTIONS
	AH = 00h and 01h
Return: nothing
Desc:	PC-MOS/386 v5.01 reports that these functions are no longer supported
	  and enters an endless loop
Program: PC-MOS/386 is a multitasking/multiuser MS-DOS-compatible operating
	  system by The Software Link, Inc.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D402" name="D402"><b>D402</b></a> - INT D4 - PC-MOS/386 v3.0+ - GET SYSTEM CONTROL BLOCK POINTER<br />
<pre>
INT D4 - PC-MOS/386 v3.0+ - GET SYSTEM CONTROL BLOCK POINTER
	AH = 02h
Return: AX = 0000h
	ES:BX -&gt; System Control Block in V86 mode (see #04004)
	ES:EBX -&gt; System Control Block in native mode (see #04004)
Note:	superseded by AH=26h
SeeAlso: AH=04h,AH=10h,AH=26h,AH=28h,AH=29h,AH=2Ah,INT 21/AX=3000h,INT 38

Format of PC-MOS/386 System Control Block:
Offset	Size	Description	(Table 04004)
 00h	WORD	pointer to first TCB in chain
 02h 17 BYTEs	reserved
 13h	WORD	pointer to current task's TCB
 15h	WORD	pointer to TCB of visible (console) task

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D403" name="D403"><b>D403</b></a> - INT D4 - PC-MOS/386 v5.01 - GET/SET EXTENDED DIRECTORY INFORMATION<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET/SET EXTENDED DIRECTORY INFORMATION
	AH = 03h
	AL = subfunction (00h get, 01h set)
	DS:(E)DX -&gt; pathname
	ES:(E)BX -&gt; 10-byte buffer for directory information (see #04005)
Return: CF clear if successful
	    AL = permitted access level for file (00h-03h)
	    ES:(E)BX -&gt; modified buffer (AL=01h on entry)
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
Notes:	BX/DX are used in V86 mode, EBX/EDX in native mode
	the file class cannot be changed for files because it affects the
	  encryption method, but directories can have their classes changed

Format of PC-MOS/386 directory information:
Offset	Size	Description	(Table 04005)
 00h	BYTE	reserved (0)
 01h	BYTE	file class ('A'-'Z' or 00h)
 02h	DWORD	user ID of file creator
 06h	WORD	file creation time (see #01665 at INT 21/AX=5700h)
 08h	WORD	file creation date (see #01666 at INT 21/AX=5700h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D404" name="D404"><b>D404</b></a> - INT D4 - PC-MOS/386 v3.0+ - GET TASK CONTROL BLOCK<br />
<pre>
INT D4 - PC-MOS/386 v3.0+ - GET TASK CONTROL BLOCK
	AH = 04h
	BX = task ID or FFFFh for calling task
Return: CF clear if successful
	    ES = segment of Task Control Block (TCB) (see #04006)
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
Note:	superseded by AH=27h
SeeAlso: AH=02h,AH=27h,AH=28h,AH=29h,AH=2Ah,INT 38

Format of PC-MOS/386 Task Control Block:
Offset	Size	Description	(Table 04006)
 00h	BYTE	signature byte "H" if allocated from system memory pool
 01h	BYTE	header block ID, "T" = TCB
 02h	WORD	length of block in paragraphs
 04h	WORD	segment address of next header block (0000h if last)
 06h	WORD	segment address of previous header block (0000h if first)
 08h	WORD	pointer to next TCB
 0Ah	WORD	pointer to previous TCB
 0Ch	WORD	pointer to associated TCB (if applicable)
 0Eh	WORD	reserved
---TCB---
 10h	WORD	TCB task ID
 12h	WORD	native context save area
 14h	WORD	start address of task
 16h	WORD	end address of task
 18h	BYTE	task priority
 19h	BYTE	task time slice
 1Ah	BYTE	"TCBWAIT" run status of task
 1Bh	BYTE	"TCBSTAT" what the task is waiting for
 1Ch	DWORD	address of polling routine
 20h	BYTE	error code from last function call
 21h 11 BYTEs	name of currently executing task
 2Ch  4 BYTEs	???
 30h	BYTE	keyboard disabled if bit 1 set
 31h	BYTE	current shift state and toggles
 32h  2 BYTEs	???
 34h	BYTE	current video mode
 35h	BYTE	current video page
 36h	BYTE	number of text columns per screen
 37h	BYTE	number of text rows per screen
 38h	WORD	length of video buffer
 3Ah	WORD	video page length
 3Ch	WORD	apge start address in video RAM
 3Eh  4 WORDs	current cursor positions for four screen pages
 46h  8 BYTEs	???
 4Eh	WORD	current cursor type
 50h	BYTE	current palette setting
 51h	BYTE	original video mode
 52h	BYTE	start CRT row (00h or 01h)
 53h	BYTE	video RAM in task active
 54h	WORD	handle of video save area
 56h	WORD	page count of video save area
 58h	WORD	segment address of video save area
 5Ah	WORD	poitner to first Task File Block (see #04009)
 5Ch	WORD	pointer to first Current Directory Block (see #04012)
 5Eh	WORD	pointer to active Current Directory Block (see #04012)
 60h	BYTE	number of drives
 61h	BYTE	current drive (0=A:, etc.)
 62h	DWORD	disk transfer address
 66h  4 BYTEs	???
 6Ah	BYTE	verify flag (nonzero = on)
 6Bh	BYTE	break flag (nonzero = on)
 6Ch	WORD	share/lock retry count
 6Eh	WORD	ticks between share/lock retries
 70h	BYTE	remote printer flags (see #04007)
 71h	BYTE	ETX/ACK delay count
 72h	WORD	spooler segment address
 74h  2 BYTEs	???
 76h  3 BYTEs	remote printer redirection for LPT1 through LPT3 (see #04008)
 79h  2 BYTEs	???
 7Bh	DWORD	offset of username in TCB
 7Fh	BYTE	current output class
 80h  7 BYTEs	protection access rights, 2 bits per class (writeable!)
 87h 122 BYTEs	???
101h	BYTE	TCB sleep downcounter value
102h 20 BYTEs	???
116h	BYTE	last scan code
	...
5D0h	DWORD	far pointer to Device Driver Terminal's entry point
5D4h	WORD	offset of logical screen
5D6h	WORD	segment of logical screen
5D8h	WORD	cursor offset within page
5DAh	BYTE	screen columns
5DBh	WORD	async port number (0000h = none)
5DDh	DWORD	physical baudrate
5E1h 19 BYTEs	reserved for Device Driver Terminal (DDT)
	...
7A6h	DWORD	far pointer to unregister calling chain

Bitfields for PC-MOS/386 remote printer flags:
Bit(s)	Description	(Table 04007)
 0	LPT1 to terminal
 1	LPT2 to terminal
 2	LPT3 to terminal
 3	escape to printer pending
 4	use XON/XOFF
 5	use ETX/ACK
 6	waiting for ACK or XON
 7	transparent printing on

(Table 04008)
Values for PC-MOS/386 remote printer redirection:
 00h	not redirected
 01h	redirected to COM1
 ...
 18h	redirected to COM24
 51h	redirected to LPT1
 52h	redirected to LPT2
 53h	redirected to LPT3

Format of PC-MOS/386 Task File Block:
Offset	Size	Description	(Table 04009)
 00h	BYTE	signature byte "H" if allocated from system memory pool
 01h	BYTE	header block ID, "F" = task file block
 02h	WORD	length of block in paragraphs
 04h	WORD	segment address of next header block (0000h if last)
 06h	WORD	segment address of previous header block (0000h if first)
 08h	WORD	pointer to next TCB
 0Ah	WORD	pointer to previous TCB
 0Ch	WORD	pointer to associated TCB (if applicable)
 0Eh	WORD	reserved
---TFB---
 10h	WORD	segment address of next TFB
 12h	WORD	segment address of previous TFB
 14h	WORD	segment address of TFB's Global File Block (see #04011)
 16h	WORD	segment address of owner's PSP
 18h	WORD	file handle
 1Ah  3 BYTEs	???
 1Dh	DWORD	file position
 21h  4 BYTEs	???
 25h	BYTE	IOCTL flags (see #04010)
 26h  2 BYTEs	???

Bitfields for PC-MOS/386 IOCTL flags:
Bit(s)	Description	(Table 04010)
 0	stdin
 1	stdout
 2	null device
 3	clock device
 4	reserved
 5	ASCII mode instead of binary
 6	EOF encountered on input
 7	device rather than file

Format of PC-MOS/386 Global File Block:
Offset	Size	Description	(Table 04011)
 00h	BYTE	signature byte "H" if allocated from system memory pool
 01h	BYTE	header block ID, "G" = global file block
 02h	WORD	length of block in paragraphs
 04h	WORD	segment address of next header block (0000h if last)
 06h	WORD	segment address of previous header block (0000h if first)
 08h	WORD	pointer to next TCB
 0Ah	WORD	pointer to previous TCB
 0Ch	WORD	pointer to associated TCB (if applicable)
 0Eh	WORD	reserved
---GFB---
 10h 10 BYTEs	???
 1Ah	WORD	file attribute
 1Ch	BYTE	???
 1Dh	DWORD	address of device driver
 21h	WORD	first cluster
 23h	WORD	time of last modification
 25h	WORD	date of last modification
 27h	DWORD	size of file in bytes
 2Bh 11 BYTEs	???
 36h 11 BYTEs	device name or FCB-format filename
 41h	WORD	segment address of TFB list
 43h	WORD	segment address of first RLB (see #04014) (0000h = none)
 45h	BYTE	flag: nonzero if GFB refers to character device
 46h	WORD	address of Block Device Block (see #04013)
 48h	WORD	sector of file's directory entry (see #01352)
 4Ah	WORD	high word of file's directory entry
 4Ch	WORD	ofsset of directory entry within sector

Format of PC-MOS/386 Current Directory Block:
Offset	Size	Description	(Table 04012)
 00h	BYTE	signature byte "H" if allocated from system memory pool
 01h	BYTE	header block ID, "C" = current directory block
 02h	WORD	length of block in paragraphs
 04h	WORD	segment address of next header block (0000h if last)
 06h	WORD	segment address of previous header block (0000h if first)
 08h	WORD	pointer to next TCB
 0Ah	WORD	pointer to previous TCB
 0Ch	WORD	pointer to associated TCB (if applicable)
 0Eh	WORD	reserved
---CDB---
 10h	BYTE	drive number
 11h	BYTE	???
 12h 64 BYTEs	directory name
 52h	WORD	first directory cluster (0000h = root)

Format of PC-MOS/386 Block Device Block:
Offset	Size	Description	(Table 04013)
 00h	BYTE	signature byte "H" if allocated from system memory pool
 01h	BYTE	header block ID, "B" = block device block
 02h	WORD	length of block in paragraphs
 04h	WORD	segment address of next header block (0000h if last)
 06h	WORD	segment address of previous header block (0000h if first)
 08h	WORD	pointer to next TCB
 0Ah	WORD	pointer to previous TCB
 0Ch	WORD	pointer to associated TCB (if applicable)
 0Eh	WORD	reserved
---BDB---
 10h	BYTE	logical drive
 11h	BYTE	unit passed to driver
 12h	WORD	sector size
 14h	BYTE	cluster mask
 15h	BYTE	cluster shift count
 16h	WORD	starting sector of first FAT
 18h	BYTE	number of FATs
 19h	WORD	number of root directories
 1Bh	WORD	sector number of first data sector (cluster 0002h)
 1Dh	WORD	number of clusters + 1 (number of highest data cluster)
 1Fh	BYTE	number of sectors in FAT
 20h	WORD	beginning root directory sector number
 22h	DWORD	device driver address
 26h	BYTE	media descriptor byte
 27h  5 BYTEs	???
 2Ch	BYTE	flag: volume &gt; 32MB
 2Dh	BYTE	???
 2Eh	BYTE	number of sectors per cluster
 2Fh	WORD	number of clusters on device
 31h	WORD	number of free clusters (FFFFh = unknown)
 33h	WORD	root directory cluster number
 35h	WORD	pointer to alias/subst string
 37h	WORD	TCB segment address of owner (0000h = none)

Format of PC-MOS/386 Record Lock Block:
Offset	Size	Description	(Table 04014)
 00h	BYTE	signature byte "H" if allocated from system memory pool
 01h	BYTE	header block ID, "R" = record lock block
 02h	WORD	length of block in paragraphs
 04h	WORD	segment address of next header block (0000h if last)
 06h	WORD	segment address of previous header block (0000h if first)
 08h	WORD	pointer to next TCB
 0Ah	WORD	pointer to previous TCB
 0Ch	WORD	pointer to associated TCB (if applicable)
 0Eh	WORD	reserved
---RLB---
 10h	WORD	segment address of owner's PSP
 12h	WORD	segment address of Global File Block (see #04011)
 14h	WORD	segment address of owner's Task File Block (see #04009)
 16h	DWORD	file offset of locked region start
 1Ah	DWORD	length of locked region
 1Eh	WORD	owner's handle for file

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D407" name="D407"><b>D407</b></a> - INT D4 - PC-MOS/386 v3.0+ - WAIT FOR EVENT<br />
<pre>
INT D4 - PC-MOS/386 v3.0+ - WAIT FOR EVENT
	AH = 07h
	AL = events to monitor (see #04015)
	BX = number of timer ticks until timeout if AL bit 1 set
	CX = bitmap of IRQs to monitor if AL bit 2 set
		(bit 0 = IRQ0 .. bit 15 = IRQ15)
	DX = port to monitor if AL bit 3 set
Return: CF clear if successful
	    AL = type of event which woke up task (see #04015)
	    CX = IRQ (if any) which awakened task
	    DX = port (if any) which awakened task
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
Note:	a device driver may make this call with AL=00h, which indicates that
	  the driver is responsible for setting and clearing the TCBWAIT field
	  in the TCB.  To put task to sleep, set TCBWAIT bits 2-0 to 001; to
	  reawaken it, set bit 1 (leaving other bits unchanged)
SeeAlso: AH=04h,INT 16/AH=00h,INT 38

Bitfields for PC-MOS/386 events to monitor:
Bit(s)	Description	(Table 04015)
 0	keystroke
 1	timeout
 2	IRQ
 3	port access
 7	return status of user poll routine (other ignored if set)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D410" name="D410"><b>D410</b></a> - INT D4 - PC-MOS/386 v3.0+ - ENTER/LEAVE NATIVE 386 EXECUTION MODE<br />
<pre>
INT D4 - PC-MOS/386 v3.0+ - ENTER/LEAVE NATIVE 386 EXECUTION MODE
	AH = 10h
	AL = direction (00h return to V86 mode, 01h enter native mode)
	CX = length in bytes of Native Context Area ( &gt;=1024 )
	DX = segment of Native Context Area
Return: CF clear if successful
	    running in desired mode at instruction following INT D4 call
	    all segment registers converted to appropriate selectors/segments
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
Note:	MS-DOS calls are available in protected mode
SeeAlso: AH=11h,AH=12h,AH=13h,INT 2F/AX=1687h,INT 67/AX=DE0Ch,INT 38

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D411" name="D411"><b>D411</b></a> - INT D4 - PC-MOS/386 v3.0+ - ALLOCATE NATIVE MODE MEMORY BLOCK<br />
<pre>
INT D4 - PC-MOS/386 v3.0+ - ALLOCATE NATIVE MODE MEMORY BLOCK
	AH = 11h
	EBX = block length in bytes
Return: CF clear if successful
	    EBX = number of bytes actually allocated
	    ES = selector for allocated block
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
Program: PC-MOS/386 is a multitasking/multiuser MS-DOS-compatible operating
	  system by The Software Link, Inc.
Note:	the memory must be released before the program terminates
SeeAlso: AH=10h,AH=12h,INT 38

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D412" name="D412"><b>D412</b></a> - INT D4 - PC-MOS/386 v3.0+ - FREE NATIVE MODE MEMORY BLOCK<br />
<pre>
INT D4 - PC-MOS/386 v3.0+ - FREE NATIVE MODE MEMORY BLOCK
	AH = 12h
	ES = selector for block to free
Return: CF clear if successful
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
SeeAlso: AH=10h,AH=11h,AH=13h,INT 38

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D413" name="D413"><b>D413</b></a> - INT D4 - PC-MOS/386 v5.01 - GET ALIAS FOR SELECTOR (NATIVE MODE ONLY)<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET ALIAS FOR SELECTOR (NATIVE MODE ONLY)
	AH = 13h
	AL = type of alias selector (00h data, 01h stack, 02h code)
	BX = selector
Return: CF clear if successful
	    AX = new selector or 0000h if BX selector not found
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
SeeAlso: AH=11h,AH=12h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D416" name="D416"><b>D416</b></a> - INT D4 - PC-MOS/386 v5.01 - SET/CLEAR IRQ RESERVATION<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - SET/CLEAR IRQ RESERVATION
	AH = 16h
	AL = function (00h clear, 01h set reservation)
	CX = IRQ number
Return: AX = status
	    (0000h successful, 0001h currently reserved by another task)
SeeAlso: AH=07h,INT 14/AH=11h"PC-MOS"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D419" name="D419"><b>D419</b></a> - INT D4 - PC-MOS/386 v5.01 - GET TASK ID<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET TASK ID
	AH = 19h
Return: BX = caller's task ID
Program: PC-MOS/386 is a multitasking/multiuser MS-DOS-compatible operating
	  system by The Software Link, Inc.
SeeAlso: AH=1Dh,AH=1Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D41A" name="D41A"><b>D41A</b></a> - INT D4 - PC-MOS/386 v5.01 - GET/SET TASK PRIORITY<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET/SET TASK PRIORITY
	AH = 1Ah
	AL = subfunction (00h read, 01h set, 02h get and set)
	BX = task ID (FFFFh for current task)
	CL = new priority value
Return: CF clear if successful
	    CL = current priority value
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
SeeAlso: AH=1Bh,AH=1Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D41B" name="D41B"><b>D41B</b></a> - INT D4 - PC-MOS/386 v5.01 - GET/SET TIME SLICE<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET/SET TIME SLICE
	AH = 1Bh
	AL = subfunction (00h read, 01h set, 02h get and set)
	BX = task ID (FFFFh for current task) (see AH=19h)
	CL = new time slice value
Return: CF clear if successful
	    CL = current time slice value
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
SeeAlso: AH=1Ah,AH=1Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D41C" name="D41C"><b>D41C</b></a> - INT D4 - PC-MOS/386 v5.01 - GET/SET KEYBOARD MODE<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET/SET KEYBOARD MODE
	AH = 1Ch
	AL = subfunction (00h enable, 01h disable, 02h get mode)
	BX = task ID (FFFFh for current task)
Return: CF clear if successful
	    CL = current keyboard state
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
Program: PC-MOS/386 is a multitasking/multiuser MS-DOS-compatible operating
	  system by The Software Link, Inc.
SeeAlso: AH=1Ah,AH=1Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D41D" name="D41D"><b>D41D</b></a> - INT D4 - PC-MOS/386 v5.01 - GET CURRENT PROGRAM NAME<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET CURRENT PROGRAM NAME
	AH = 1Dh
	BX = task ID (FFFFh for current task) (see AH=19h)
	ES:DI -&gt; buffer for program name (see #04016)
Return: CF clear if successful
	    ES:DI buffer filled
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
SeeAlso: AH=19h,AH=1Eh

Format of PC-MOS/386 program name buffer:
Offset	Size	Description	(Table 04016)
 00h  8 BYTEs	filename
 08h  3 BYTEs	extension

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D41E" name="D41E"><b>D41E</b></a> - INT D4 - PC-MOS/386 v5.01 - GET CURRENT USERNAME AND SECURITY CLASS<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET CURRENT USERNAME AND SECURITY CLASS
	AH = 1Eh
	BX = task ID (FFFFh for current task)
	ES:DI -&gt; 4-byte buffer for username
Return: CF clear if successful
	    CL = security class
		20h (' ') none
		41h-5Ah ('A'-'Z') security level
	    ES:DI buffer filled
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
SeeAlso: AH=19h,AH=1Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D41F" name="D41F"><b>D41F</b></a> - INT D4 - PC-MOS/386 v5.01 - GET TASK PARTITION INFORMATION<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET TASK PARTITION INFORMATION
	AH = 1Fh
	BX = task ID (FFFFh for current task) (see AH=19h)
Return: CF clear if successful
	    CX = start segment of task
	    DX = ending segment of task
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
Program: PC-MOS/386 is a multitasking/multiuser MS-DOS-compatible operating
	  system by The Software Link, Inc.
SeeAlso: AH=2Dh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D420" name="D420"><b>D420</b></a> - INT D4 - PC-MOS/386 v5.01 - GET PORT AND BAUDRATE INFORMATION<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET PORT AND BAUDRATE INFORMATION
	AH = 20h
	BX = task ID (FFFFh for current task) (see AH=19h)
Return: CF clear if successful
	    CX = port number (0000h if none)
	    DI:SI = baudrate (if CX nonzero)
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
SeeAlso: INT 14/AH=0Ch"FOSSIL"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D421" name="D421"><b>D421</b></a> - INT D4 - PC-MOS/386 v5.01 - REMOVE A TASK<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - REMOVE A TASK
	AH = 21h
	BX = task ID (FFFFh for current task) (see AH=19h)
Return: CF clear if successful
	    AX = ASCII percentage of System Memory Pool used
		(AH = tens digit, AL = ones digit)
	    DS,SI destroyed
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
Program: PC-MOS/386 is a multitasking/multiuser MS-DOS-compatible operating
	  system by The Software Link, Inc.
SeeAlso: AH=22h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D422" name="D422"><b>D422</b></a> - INT D4 - PC-MOS/386 v5.01 - ADD A TASK TO THE SYSTEM<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - ADD A TASK TO THE SYSTEM
	AH = 22h
	DS:SI -&gt; addtask data structure (see #04018)
Return: CF clear if successful
	    ES = segment address of the new task's TCB data structure
	CF set on error
	    AX = error code (see #04017)
SeeAlso: AH=21h

(Table 04017)
Values for PC-MOS/386 error code:
 08h	insufficient memory
 0Bh	invalid addtask structure format
 12h	insufficient available space in system memory pool
 1Fh	general failure
 55h	already allocated
 57h	if task already in use or invalid parameter

Format of PC-MOS/386 addtask data structure:
Offset	Size	Description	(Table 04018)
 00h	WORD	task size in KB (min 16KB)
 02h	WORD	task ID (0000h for automatic selection)
 04h	BYTE	task class (' ' or 'A'-'Z')
 05h	DWORD	-&gt; ASCIZ name of task startup batchfile
 09h	DWORD	-&gt; task's terminal driver (0000000h = background task)
 0Dh	WORD	task port
 0Fh	DWORD	task baud rate
 13h	DWORD	(ret) total extended memory
 17h	DWORD	(ret) number of 4K extended memory pages allocated
 1Bh	WORD	(ret) paragraphs of system memory pool allocated
 1Dh	WORD	(ret) system memory pool size in paragraphs
 1Fh	WORD	(ret) ASCII task percentage of system memory pool
 21h  3 BYTEs	reserved

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D423" name="D423"><b>D423</b></a> - INT D4 - PC-MOS/386 v5.01 - CHANGE TERMINAL DRIVER<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - CHANGE TERMINAL DRIVER
	AH = 23h
	BX = task ID (FFFFh for current task)
	DS:SI -&gt; entry point of the new Device Driver Terminal
Return: CF clear if successful
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D424" name="D424"><b>D424</b></a> - INT D4 U - PC-MOS/386 v5.01 - GET OPERATING SYSTEM SERIAL NUMBER<br />
<pre>
INT D4 U - PC-MOS/386 v5.01 - GET OPERATING SYSTEM SERIAL NUMBER
	AH = 24h
Return: DS:DX -&gt; '$'-terminated string containing the serial number

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D425" name="D425"><b>D425</b></a> - INT D4 - PC-MOS/386 v5.01 - IDENTIFY LOAD ADDRESS OF DEVICE DRIVER LOCATION<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - IDENTIFY LOAD ADDRESS OF DEVICE DRIVER LOCATION
	AH = 25h
	DX = driver's CS value
Return: AX = segment address of driver in system memory pool
	    (0000h if the driver is not within the system memory pool)
Program: PC-MOS/386 is a multitasking/multiuser MS-DOS-compatible operating
	  system by The Software Link, Inc.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D426" name="D426"><b>D426</b></a> - INT D4 - PC-MOS/386 v5.01 - GET SYSTEM CONTROL BLOCK SEGMENT/SELECTOR<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET SYSTEM CONTROL BLOCK SEGMENT/SELECTOR
	AH = 26h
Return: DX = segment/selector of the System Control Block (see #04004)
Note:	this function supersedes AH=02h
SeeAlso: AH=02h,AH=27h,AH=28h,AH=29h,AH=2Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D427" name="D427"><b>D427</b></a> - INT D4 - PC-MOS/386 v5.01 - GET TASK CONTROL BLOCK SEGMENT/SELECTOR<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET TASK CONTROL BLOCK SEGMENT/SELECTOR
	AH = 27h
	BX = task ID (FFFFh if current task) (see AH=19h)
Return: CF clear if successful
	    DX = segment/selector for the Task Control Block (see #04006)
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
Note:	this function supersedes AH=04h
SeeAlso: AH=26h,AH=28h,AH=29h,AH=2Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D428" name="D428"><b>D428</b></a> - INT D4 - PC-MOS/386 v5.01 - GET CONTROL BLOCK DATA FROM SCB OR TCB<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET CONTROL BLOCK DATA FROM SCB OR TCB
	AH = 28h
	BX = offset into control block at which to start reading
	CX = number of bytes to read
	DX = segment/selector of control block obtained via AH=26h or AH=27h
	ES:DI -&gt; buffer for data
Return: CF clear if successful
	CF set on error
	    AX = error code (see also #01680 at INT 21/AH=59h/BX=0000h)
		05h access denied due to an invalid segment/selector
SeeAlso: AH=26h,AH=27h,AH=29h,AH=2Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D429" name="D429"><b>D429</b></a> - INT D4 - PC-MOS/386 v5.01 - WRITE CONTROL BLOCK DATA INTO SCB OR TCB<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - WRITE CONTROL BLOCK DATA INTO SCB OR TCB
	AH = 29h
	BX = offset into control block at which to start writing
	CX = number of bytes to write
	DX = segment/selector of control block obtained via AH=26h or AH=27h
	DS:SI -&gt; buffer containing data to be written
Return: CF clear if successful
	CF set on errro
	    AX = error code (see also #01680 at INT 21/AH=59h/BX=0000h)
		05h access denied due to an invalid segment/selector
Note:	 this function performs no bounds checking
Program: PC-MOS/386 is a multitasking/multiuser MS-DOS-compatible operating
	  system by The Software Link, Inc.
SeeAlso: AH=26h,AH=27h,AH=28h,AH=2Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D42A" name="D42A"><b>D42A</b></a> - INT D4 - PC-MOS/386 v5.01 - SWAP CONTROL BLOCK DATA OF SCB OR TCB<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - SWAP CONTROL BLOCK DATA OF SCB OR TCB
	AH = 2Ah
	BX = offset into control block at which to start swap
	CX = number of bytes to swap
	DX = segment/selector of control block obtained via AH=26h or AH=27h
	DS:SI -&gt; buffer containing new data and to receive current data
Return: CF clear if successful
	CF set on error
	    AX = error code (see also #01680 at INT 21/AH=59h/BX=0000h)
		05h access denied due to an invalid segment/selector
Note:	the interrupts are disabled during the swap to prevent corruption
SeeAlso: AH=26h,AH=27h,AH=28h,AH=29h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D42C" name="D42C"><b>D42C</b></a> - INT D4 - PC-MOS/386 v5.01 - GET/SET SPOOLER PARAMETERS<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET/SET SPOOLER PARAMETERS
	AH = 2Ch
	AL = function
	    00h set spooler timeout
		CX = timout value in seconds
	    01h get spooler timeout
		Return: CX = current timeout in seconds
	    02h get spooler parameters
		Return: CH = priority (00h-09h)
			CL = disposition (d, h, i, n, s)
			SI = class (a - z)
	    03h set spooler parameters
		CH = priority (00h-09h)
		CL = disposition (d, h, i, n, s)
		SI = class (a - z)
		BX = task ID (FFFFh for current task)
		DX = LPT number
Return: CF clear if successful
	CF set on error
	    AX = error code (see #01680 at INT 21/AH=59h/BX=0000h)
SeeAlso: AH=00h,AH=02h,AH=03h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#D42D" name="D42D"><b>D42D</b></a> - INT D4 - PC-MOS/386 v5.01 - GET MAXIMUM TASK SIZE<br />
<pre>
INT D4 - PC-MOS/386 v5.01 - GET MAXIMUM TASK SIZE
	AH = 2Dh
Return: DX = maximum task size in paragraphs
	BX = start address of task space
Program: PC-MOS/386 is a multitasking/multiuser MS-DOS-compatible operating
	  system by The Software Link, Inc.
SeeAlso: AH=1Fh,AH=22h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0_3" name="E0_3"><b>E0</b></a> - INT E0 - CP/M-86, Concurrent CP/M, DR Multiuser DOS - FUNCTION CALLS<br />
<pre>
INT E0 - CP/M-86, Concurrent CP/M, DR Multiuser DOS - FUNCTION CALLS
	CL = function number (see #04019,#04020)
	DS,DX contain parameter(s):
		DL = byte parameter
		DX = word parameter
		DS:DX -&gt; structure
Return: as appropriate for function:
		AL = byte result
		AX = word
		ES:AX -&gt; structure (and BX=ES)
	CX is often the error code (see #04021)
Notes:	several functions are covered in more detail in following entries
	most of these calls are also supported by Digital Research's DOS Plus
	  v2.1; the unsupported functions are 26h,29h-2Bh,3Ah,3Dh-62h,71h-8Ch,
	  90h-92h,94h-97h,9Bh-ABh, and AEh-FFh
SeeAlso: INT 21/AX=4459h,INT 21/AH=E0h"DOS Plus",INT E6"CP/M-86"

(Table 04019)
Values for CP/M-86,DR Multiuser DOS function number:
 00h	terminate calling process			(see INT E0/CL=00h)
 01h	read a character				(see INT E0/CL=01h)
 02h	write character to default console		(see INT E0/CL=02h)
 03h	read character from default AUX			(see INT E0/CL=03h)
 04h	write character to default AUX			(see INT E0/CL=04h)
 05h	write character to default list device		(see INT E0/CL=05h)
 06h	perform raw I/O on default console		(see INT E0/CL=06h)
 07h	return default AUX input status			(see INT E0/CL=07h)
 08h	return default AUX output status		(see INT E0/CL=08h)
 09h	write string to default console			(see INT E0/CL=09h)
 0Ah	read string from default console		(see INT E0/CL=0Ah)
 0Bh	return default console input status		(see INT E0/CL=0Bh)
 0Ch	get BDOS release ID				(see INT E0/CL=0Ch)
 0Dh	reset all disk drives		(see also INT 21/AH=0Dh)
 0Eh	set default drive		(see also INT 21/AH=0Eh"DOS 1+")
 0Fh	open file via FCB		(see also INT 21/AH=0Fh,#01345)
 10h	close file via FCB		(see also INT 21/AH=10h)
 11h	search for first matching file with FCB (see also INT 21/AH=11h)
 12h	search for next matching file with FCB (see also INT 21/AH=12h)
 13h	delete file via FCB		(see also INT 21/AH=13h)
 14h	sequential read via FCB		(see also INT 21/AH=14h)
 15h	sequential write via FCB	(see also INT 21/AH=15h)
 16h	create file via FCB		(see also INT 21/AH=16h)
 17h	rename file via FCB		(see also INT 21/AH=17h)
 18h	get bit map of logged drives
 19h	get default drive		(see also INT 21/AH=19h)
 1Ah	set DMA address offset
 1Bh	get default disk allocation vector (see also INT 21/AH=1Bh)
 1Ch	set default drive to read-only
 1Dh	get bit map of read-only drives
 1Eh	set file attributes via FCB	(see also INT 21/AX=4301h)
 1Fh	get address of disk parameter block (see also INT 21/AH=1Fh)
 20h	get/set default user number
 21h	read random record via FCB	(see also INT 21/AH=21h)
 22h	write random record via FCB	(see also INT 21/AH=22h)
 23h	compute file size with FCB	(see also INT 21/AH=23h)
 24h	get FCB random record number	(see also INT 21/AH=24h)
 25h	reset specified drives
 26h	access specified drives (not in DR DOS Plus v2.1)
 27h	free specified drives
 28h	write random with FCB, zero fill (see also INT 21/AH=28h)
 2Ah	lock records in FCB file	(see also INT 21/AH=5Ch)
 2Bh	unlock records in FCB file	(see also INT 21/AH=5Ch)
 2Ch	set BDOS multisector count
 2Dh	set BDOS error mode
 2Eh	get free space on disk
 2Fh	load, initialize, and jump to process ("chain process")
	(see INT E0/CL=2Fh,INT 21/AH=4Bh)
 30h	flush write-deferred buffers
 31h	get/set system variable (DOS Plus v2.1)
 32h	call BIOS (XIOS) character routine (see #04020)
 33h	set DMA address segment
 34h	get DMA buffer address
 35h	CP/M-86 allocate maximum memory			(see INT E0/CL=35h)
 36h	allocate maximum memory at specified segment	(see INT E0/CL=36h)
 37h	CP/M-86 allocate memory segment (see INT E0/CL=37h,INT 21/AH=48h)
 38h	allocate memory at specified segment		(see INT E0/CL=38h)
 39h	CP/M-86 free specified memory segment (see INT E0/CL=39h,INT 21/AH=49h)
 3Ah	CP/M-86 free all memory (not in DOS Plus v2.1)	(see INT E0/CL=3Ah)
 3Bh	load .CMD file into memory			(see INT E0/CL=3Bh)
 3Ch	(DOS Plus v2.1) call RSX program
 40h	(DR-NET, REAL/32) log on a server		(see INT E0/CL=40h)
 41h	(DR-NET, REAL/32) log off a server		(see INT E0/CL=41h)
 42h	(DR-NET) send a message
 43h	(DR-NET) receive a message
 44h	(DR-NET, REAL/32) get network status		(see INT E0/CL=44h)
 45h	(DR-NET, REAL/32) get requestor config table	(see INT E0/CL=45h)
 46h	(DR-NET) set compatibility attributes
 47h	(DR-NET, REAL/32) get server configuration table (see INT E0/CL=47h)
 48h	(DR-NET, REAL/32) set network error mode	(see INT E0/CL=48h)
 49h	(DR-NET, REAL/32) attach network
 4Ah	(DR-NET, REAL/32) detach network
 4Bh	(DR-NET, REAL/32) set default password
 4Ch	(DR-NET, REAL/32) get-set long timeout
 4Dh	(DR-NET, REAL/32) get parameter table
 4Fh	(REAL/32) get extended network error
 50h	(DR-NET, REAL/32) get network information
 53h	get current time			(see also INT 21/AH=2Ch)
 54h	set current time			(see also INT 21/AH=2Dh)
 55h	get binary system date			(see also INT 21/AH=2Ah)
 56h	set system date				(see also INT 21/AH=2Bh"DATE")
 57h	allocate system flag
 58h	deallocate system flag
 59h	reserve memory in global area			(see INT E0/CL=59h)
 5Ah	lock physical drive
 5Bh	unlock physical drive
 5Ch	search path for executable file			(see INT E0/CL=5Ch)
 5Dh	load and execute command			(see INT E0/CL=5Dh)
 5Eh	get/set process exit code			(see INT E0/CL=5Eh)
 5Fh	set country information
 60h	get country information
 63h	truncate FCB file (see also INT 21/AH=28h)
 64h	create/update directory label
 65h	get directory label
 66h	get FCB date stamp and password mode
 67h	write extended FCB
 68h	set system date and time
 69h	get system date and time in binary
 6Ah	establish password for file access
 6Bh	get OS serial number				(see INT E0/CL=6Bh)
 6Ch	(DOS Plus v2.1) get/set program return code
 6Dh	get/set console mode				(see INT E0/CL=6Dh)
 6Eh	get/set string delimiter			(see INT E0/CL=6Eh)
 6Fh	write block to default console			(see INT E0/CL=6Fh)
 70h	write block to default list device		(see INT E0/CL=70h)
 71h	execute DOS-compatible function			(see INT E0/CL=71h)
 74h	set FCB time and date stamps
 80h	allocate memory					(see INT E0/CL=80h)
 82h	deallocate memory				(see INT E0/CL=81h)
 83h	poll I/O device
 84h	wait on system flag				(see INT E0/CL=84h)
 85h	set system flag					(see INT E0/CL=85h)
 86h	create message queue				(see INT E0/CL=86h)
 87h	open message queue				(see INT E0/CL=87h)
 88h	delete message queue				(see INT E0/CL=88h)
 89h	read from message queue				(see INT E0/CL=89h)
 8Ah	conditionally read from message queue		(see INT E0/CL=8Ah)
 8Bh	write to message queue				(see INT E0/CL=8Bh)
 8Ch	conditionally write to message queue		(see INT E0/CL=8Ch)
 8Dh	delay calling process				(see INT E0/CL=8Dh)
 8Eh	call process dispatcher (yield CPU)		(see INT E0/CL=8Eh)
 8Fh	terminate calling process (same as func 00h)	(see INT E0/CL=8Fh)
 90h	create a process				(see INT E0/CL=90h)
 91h	set calling process' priority			(see INT E0/CL=91h)
 92h	attach to default console			(see INT E0/CL=92h)
 93h	detach from default console			(see INT E0/CL=93h)
 94h	(REAL/32) set the process' default console	(see INT E0/CL=94h)
 95h	assign default console to process		(see INT E0/CL=95h)
 96h	interpret and execute commandline		(see INT E0/CL=96h)
 97h	resident procedure library
 98h	parse ASCII string into FCB (see also INT 21/AH=29h)
 99h	return default console				(see INT E0/CL=99h)
 9Ah	get address of system data (SYSDAT)		(see INT E0/CL=9Ah)
 9Bh	get system time and date
 9Ch	return calling process' descriptor		(see INT E0/CL=9Ch)
 9Dh	terminate process by name or PD address		(see INT E0/CL=9Dh)
 9Eh	attach to default list device			(see INT E0/CL=9Eh)
 9Fh	detach from default list device			(see INT E0/CL=9Fh)
 A0h	select default list device			(see INT E0/CL=A0h)
 A1h	conditionally attach to default list device	(see INT E0/CL=A1h)
 A2h	conditionally attach to default console		(see INT E0/CL=A2h)
 A3h	get OS version number				(see INT E0/CL=A3h)
 A4h	get default list device				(see INT E0/CL=A4h)
 A5h	attach to default AUX				(see INT E0/CL=A5h)
 A6h	detach from default AUX				(see INT E0/CL=A6h)
 A7h	conditionally attach to default AUX		(see INT E0/CL=A7h)
 A8h	set default AUX					(see INT E0/CL=A8h)
 A9h	return default AUX				(see INT E0/CL=A9h)
 ACh	read block from default AUX			(see INT E0/CL=ACh)
 ADh	(DOS Plus v2.1) write block to default AUX	(see INT E0/CL=ADh)
 B0h	configure default AUX				(see INT E0/CL=B0h)
 B1h	get/set device control parameters		(see INT E0/CL=B1h)
 B2h	send Break through default AUX			(see INT E0/CL=B2h)
 B3h	allocate physical memory			(see INT E0/CL=B3h)
 B4h	free physical memory				(see INT E0/CL=B4h)
 B5h	map physical memory				(see INT E0/CL=B5h)
 B6h	nondestructive conditional message queue read	(see INT E0/CL=B6h)
 B7h	timed wait on system flag			(see INT E0/CL=B7h)
 B8h	get/set I/O port mapping			(see INT E0/CL=B8h)
 B9h	set list device timeout				(see INT E0/CL=B9h)
 BAh	set AUX timeout value				(see INT E0/CL=BAh)
 BBh	execute XIOS service
 BDh	(DR Multiuser DOS) delay			(see INT E0/CL=BDh)
 FFh	return 80386 to native mode
SeeAlso: #04020,#04021

(Table 04020)
Values for DOS Plus v2.1 XIOS functions:
 00h	terminate program
 01h	???
 02h	check for console input status
 03h	read character from console
 04h	write character to console
 05h	write character to list device
 06h	write character to auxiliary device
 07h	read character from auxiliary device
 0Fh	get list device status
 10h-14h reserved
 15h	device initialization
 16h	check console output status
 17h-7Fh reserved
---BBC Acorn---
 80h	get XIOS version
 81h	get Tube semaphore
 82h	release Tube semaphore
 83h	select text/graphics
 84h	update B&W graphics rectangle
 85h	update color graphics rectangle
 86h	get/release/update mouse
 87h	get system error info
 88h	entry in CLOCK called by WatchDog RSP
 89h	BBC OSBYTE function
 8Ah	BBC OSWORD function
SeeAlso: #04019

(Table 04021)
Values for DR Multiuser DOS Error Return Code:
 00h	no error
 01h	system call not implemented
 02h	illegal system call number
 03h	cannot find memory
 04h	illegal flag number
 05h	flag overrun
 06h	flag underrun
 07h	no unused Queue Descriptors
 08h	no free queue buffer
 09h	cannot find queue
 0Ah	queue in use
 0Ch	no free Process Descriptors
 0Dh	no queue access
 0Eh	empty queue
 0Fh	full queue
 10h	CLI queue missing
 11h	no 8087 in system
 12h	no unused Memory Descriptors
 13h	illegal console number
 14h	no Process Descriptor match
 15h	no console match
 16h	no CLI process
 17h	illegal disk number
 18h	illegal filename
 19h	illegal filetype
 1Ah	character not ready
 1Bh	illegal Memory Descriptor
 1Ch	bad return from BDOS load
 1Dh	bad return from BDOS read
 1Eh	bad return from BDOS open
 1Fh	null command
 20h	not owner of resource
 21h	no CSEG in load file
 22h	process Descriptor exists on Thread Root
 23h	could not terminate process
 24h	cannot attach to process
 25h	illegal list device number
 26h	illegal password
 28h	external termination occurred
 29h	fixup error upon load
 2Ah	flag set ignored
 2Bh	illegal auxilliary device number
SeeAlso: #04019

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL00" name="E0----CL00"><b>E0----CL00</b></a> - INT E0 - REAL/32 - "P_TERMCPM" - TERMINATE CALLING PROCESS<br />
<pre>
INT E0 - REAL/32 - "P_TERMCPM" - TERMINATE CALLING PROCESS
	CL = 00h
Return: AX = error code
	    FFFFh on failure
	may destroy SI,DI???
Program: REAL/32 is the descendant of IMS Multiuser DOS, which in turn is
	  derived from DR Multiuser DOS and its predecessors (Concurrent DOS,
	  etc.)
Notes:	sets the exit code (ERRORLEVEL) to 00h
	INT E0h is officially reserved for Digital Research by Intel.
	Apparently some Borland products also used this interrupt, which forced
	  Digital Research to indirect calls through other interrupt entry
	  points.
	This is also supported by IMS Multiuser DOS and IMS REAL/32.
SeeAlso: INT 21/AH=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL01" name="E0----CL01"><b>E0----CL01</b></a> - INT E0 - REAL/32 - "C_READ" - FETCH CHARACTER FROM THE DEFAULT CONSOLE<br />
<pre>
INT E0 - REAL/32 - "C_READ" - FETCH CHARACTER FROM THE DEFAULT CONSOLE
	CL = 01h
Return: AX = character
	may destroy SI,DI???
Notes:	this function echos the character to the screen, expanding Tab
	  characters to the next multiple of eight columns; Ctrl-C is
	  ignored if the calling process can not terminate
	the calling process is suspended until a character is available; if
	  the caller does not own the console, it is suspended until it
	  can attach to the console
SeeAlso: INT E0/CL=02h,INT E0/CL=06h,INT 21/AH=01h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL02" name="E0----CL02"><b>E0----CL02</b></a> - INT E0 - REAL/32 - "C_WRITE" - WRITE CHARACTER TO DEFAULT CONSOLE<br />
<pre>
INT E0 - REAL/32 - "C_WRITE" - WRITE CHARACTER TO DEFAULT CONSOLE
	CL = 02h
	DX = character
Return: nothing
	may destroy SI,DI???
Note:	Tab characters are expanded to blanks up to the next multiple of
	  eight columns
SeeAlso: INT E0/CL=01h,INT E0/CL=06h,INT 21/AH=02h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL03" name="E0----CL03"><b>E0----CL03</b></a> - INT E0 - DR Multiuser DOS - "A_READ" - READ CHARACTER FROM DEFAULT AUX DEVICE<br />
<pre>
INT E0 - DR Multiuser DOS - "A_READ" - READ CHARACTER FROM DEFAULT AUX DEVICE
	CL = 03h
Return: AL = ASCII character
	may destroy SI,DI???
Notes:	A_READ reads the next 8-bit character from the logical auxilliary
	  input device (AUXn:); control is not returned to the calling
	  process until a character has been read.
	if another process owns AUX, this call blocks until the device becomes
	  available
	this function is also supported by REAL/32
SeeAlso: INT 21/AH=03h,INT E0/CL=04h,INT E0/CL=07h,INT E0/CL=A5h,INT E0/CL=ACh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL04" name="E0----CL04"><b>E0----CL04</b></a> - INT E0 - DR Multiuser DOS - "A_WRITE" - WRITE CHARACTER TO DEFAULT AUX DEVICE<br />
<pre>
INT E0 - DR Multiuser DOS - "A_WRITE" - WRITE CHARACTER TO DEFAULT AUX DEVICE
	CL = 04h
	DL = BYTE to write
Return: nothing
	may destroy SI,DI,DH???
Note:	if another process owns AUX, this call blocks until the device becomes
	  available
SeeAlso: INT 21/AH=04h,INT E0/CL=03h,INT E0/CL=08h,INT E0/CL=A5h,INT E0/CL=ADh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL05" name="E0----CL05"><b>E0----CL05</b></a> - INT E0 - REAL/32 - "L_WRITE" - WRITE CHARACTER TO DEFAULT LIST DEVICE<br />
<pre>
INT E0 - REAL/32 - "L_WRITE" - WRITE CHARACTER TO DEFAULT LIST DEVICE
	CL = 05h
	DL = char to write
Return: nothing
	may destroy SI,DI???
Note:	if another process owns the list device, this call blocks until the
	  device becomes available
SeeAlso: INT 21/AH=05h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL06" name="E0----CL06"><b>E0----CL06</b></a> - INT E0 - REAL/32 - "C_RAWIO" - PERFORM RAW I/O WITH DEFAULT CONSOLE<br />
<pre>
INT E0 - REAL/32 - "C_RAWIO" - PERFORM RAW I/O WITH DEFAULT CONSOLE
	CL = 06h
	DL = mode describing the operation to be performed
	    FFh get console input/status
	    FEh get console status
	    FDh get console input (blocking)
	    else output DL to the console as a character
Return: AX = returned value
	    for DL = FFh, the character or 00h if none available
	    for DL = FEh, 00h if no characters available, FFh if any available
	    for DL = FDh, the character read from the console
	    else AX = 0000h
	may destroy SI,DI???
Notes:	during raw I/O, the special characters ^C, ^O, ^P, and ^S are not
	  interpreted, but are passed through
	if the virtual console is in ^S mode and the owning process calls
	  this function, the ^S state is cleared
SeeAlso: INT E0/CL=01h,INT E0/CL=02h,INT 21/AH=06h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL07" name="E0----CL07"><b>E0----CL07</b></a> - INT E0 - DR Multiuser DOS - "A_STATIN" - GET INPUT STATUS OF AUX DEVICE<br />
<pre>
INT E0 - DR Multiuser DOS - "A_STATIN" - GET INPUT STATUS OF AUX DEVICE
	CL = 07h
Return: AL = status
	    00h not ready
	    FFh character available
Desc:	determine whether the current AUX device has input available
SeeAlso: INT E0/CL=03h,INT E0/CL=08h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL08" name="E0----CL08"><b>E0----CL08</b></a> - INT E0 - DR Multiuser DOS - "A_STATOUT" - GET OUTPUT STATUS OF AUX DEVICE<br />
<pre>
INT E0 - DR Multiuser DOS - "A_STATOUT" - GET OUTPUT STATUS OF AUX DEVICE
	CL = 08h
Return: AL = status
	    00h not ready
	    FFh ready for output
Desc:	determine whether the current AUX device is able to accept more output
SeeAlso: INT E0/CL=04h,INT E0/CL=07h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL09" name="E0----CL09"><b>E0----CL09</b></a> - INT E0 - REAL/32 - "C_WRITESTR" - WRITE STRING TO DEFAULT CONSOLE<br />
<pre>
INT E0 - REAL/32 - "C_WRITESTR" - WRITE STRING TO DEFAULT CONSOLE
	CL = 09h
	DS:DX -&gt; string
Return: nothing
	may destroy SI,DI,DS???
Note:	the string terminated with a '$' character (24h) by default; the
	  terminator may be changed with C_DELIMIT
	tabs are expanded to the next multiple of eight columns
SeeAlso: INT E0/CL=6Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL0A" name="E0----CL0A"><b>E0----CL0A</b></a> - INT E0 - REAL/32 - "C_READSTR" - READ STRING FROM DEFAULT CONSOLE<br />
<pre>
INT E0 - REAL/32 - "C_READSTR" - READ STRING FROM DEFAULT CONSOLE
	CL = 0Ah
	DS:DX -&gt; buffer for string (see #04022)
Return: nothing

Format of REAL/32 "C_READSTR" buffer:
Offset	Size	Description	(Table 04022)
 00h	BYTE	maximum number of characters buffer can hold
 01h	BYTE	actual number of buffers read
 02h  N BYTEs	input line

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL0B" name="E0----CL0B"><b>E0----CL0B</b></a> - INT E0 - REAL/32 - "C_STAT" - RETURN DEFAULT CONSOLE INPUT STATUS<br />
<pre>
INT E0 - REAL/32 - "C_STAT" - RETURN DEFAULT CONSOLE INPUT STATUS
	CL = 0Bh
Return: AX = status
	    0000h no characters ready
	    0001h character available
	may destroy SI,DI???
Note:	after setting bit 0 of the console mode word with C_MODE, this function
	  will only return AX=0001h when the user presses Ctrl-C.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL0C" name="E0----CL0C"><b>E0----CL0C</b></a> - INT E0 - REAL/32 - "S_BDOSVER" - GET BDOS VERSION<br />
<pre>
INT E0 - REAL/32 - "S_BDOSVER" - GET BDOS VERSION
	CL = 0Ch
Return: AX = version (see #04023)
	may destroy SI,DI???
SeeAlso: INT E0/CL=A3h,INT 21/AX=4451h

(Table 04023)
Values for REAL/32 BDOS version:
 1432h	- DR Concurrent PC DOS Version 3.2
 1441h	- DR Concurrent DOS Version 4.1
 1450h	- DR Concurrent DOS/XM Version 5.0
 1463h	- DR Multiuser DOS Release 5.0
 1465h	- DR Multiuser DOS Release 5.01
 1466h	- DR Multiuser DOS Release 5.1, IMS Multiuser DOS Enhanced Release 5.1
 1467h	- IMS Multiuser DOS Version 7.0, 7.1
 1468h	- IMS REAL/32 Version 7.50, 7.51
 1469h	- IMS REAL/32 Version 7.52, 7.53
 14??h	- IMS REAL/32 Version 7.6
SeeAlso: #01579,#01580,#01581

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL2F" name="E0----CL2F"><b>E0----CL2F</b></a> - INT E0 - REAL/32 - "P_CHAIN" - CHAIN PROCESS<br />
<pre>
INT E0 - REAL/32 - "P_CHAIN" - CHAIN PROCESS
	CL = 2Fh
	[DTA] = ASCIZ command line for process to start
Return: AX = return code
	    0000h successful
	    FFFFh failed
	may destroy SI,DI???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL35" name="E0----CL35"><b>E0----CL35</b></a> - INT E0 R - REAL/32 - "MC_MAX" - CP-M/86 ALLOCATE MAXIMUM MEMORY<br />
<pre>
INT E0 R - REAL/32 - "MC_MAX" - CP-M/86 ALLOCATE MAXIMUM MEMORY
	CL = 35h
	DS:DX -&gt; MCB (see #04024)
Return: AX = status
	may destroy SI,DI,DS???
SeeAlso: INT E0/CL=39h

Format of REAL/32 MCB (Memory Control Block):
Offset	Size	Description	(Table 04024)
 00h	WORD	segment address of memory block
 02h	WORD	length of block in paragraphs
 04h	BYTE	reserved (0)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL36" name="E0----CL36"><b>E0----CL36</b></a> - INT E0 R - REAL/32 - "MC_ABSMAX" - ALLOCATE MAXIMUM MEMORY SEGMENT ABSOLUTE<br />
<pre>
INT E0 R - REAL/32 - "MC_ABSMAX" - ALLOCATE MAXIMUM MEMORY SEGMENT ABSOLUTE
	CL = 36h
	DS:DX -&gt; MCB (see #04024)
Return: AX = status
	may destroy SI,DI,DS???
SeeAlso: INT E0/CL=39h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL37" name="E0----CL37"><b>E0----CL37</b></a> - INT E0 R - REAL/32 - "MC_ALLOC" - CP-M/86 ALLOCATE MEMORY SEGMENT<br />
<pre>
INT E0 R - REAL/32 - "MC_ALLOC" - CP-M/86 ALLOCATE MEMORY SEGMENT
	CL = 37h
	DS:DX -&gt; MCB (see #04024)
Return: AX = status
	may destroy SI,DI,DS???
SeeAlso: INT E0/CL=39h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL38" name="E0----CL38"><b>E0----CL38</b></a> - INT E0 R - REAL/32 - "MC_ABSALLOC" - ALLOCATE MEMORY SEGMENT ABSOLUTE<br />
<pre>
INT E0 R - REAL/32 - "MC_ABSALLOC" - ALLOCATE MEMORY SEGMENT ABSOLUTE
	CL = 38h
	DS:DX -&gt; MCB (see #04024)
Return: AX = status
	may destroy SI,DI,DS???
SeeAlso: INT E0/CL=39h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL39" name="E0----CL39"><b>E0----CL39</b></a> - INT E0 R - REAL/32 - "MC_FREE" - CP-M/86 FREE SPECIFIED MEMORY SEGMENT<br />
<pre>
INT E0 R - REAL/32 - "MC_FREE" - CP-M/86 FREE SPECIFIED MEMORY SEGMENT
	CL = 39h
	DS:DX -&gt; MCB (see #04024)
Return: AX = status
	may destroy SI,DI,DS???
SeeAlso: INT E0/CL=3Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL3A" name="E0----CL3A"><b>E0----CL3A</b></a> - INT E0 R - REAL/32 - "MC_ALLFREE" - CP-M/86 FREE ALL MEMORY<br />
<pre>
INT E0 R - REAL/32 - "MC_ALLFREE" - CP-M/86 FREE ALL MEMORY
	CL = 3Ah
Return: nothing???
Desc:	release all of the calling process's memory except the User Data Area
SeeAlso: INT E0/CL=39h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL3B" name="E0----CL3B"><b>E0----CL3B</b></a> - INT E0 u - REAL/32 - "P_LOAD" - LOAD .CMD FILE INTO MEMORY<br />
<pre>
INT E0 u - REAL/32 - "P_LOAD" - LOAD .CMD FILE INTO MEMORY
	CL = 3Bh
	???
Return: ???
Note:	IMS does not document the details of this call because .CMD files are
	  supported for backward compatibility only

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL40" name="E0----CL40"><b>E0----CL40</b></a> - INT E0 - REAL/32 - "N_LOGON" - LOG ONTO A SERVER<br />
<pre>
INT E0 - REAL/32 - "N_LOGON" - LOG ONTO A SERVER
	CL = 40h
	DS:DX -&gt; LPB (see #04025)
Return: AX = status (0000h,00FFh,07FFh,0DFFh,0EFFh,FFFFh) (see #04030)
	may destroy SI,DI,DS???
SeeAlso: INT E0/CL=41h

Format of REAL/32 Logon/Logoff Parameter Block:
Offset	Size	Description	(Table 04025)
 00h	BYTE	node ID
 01h  8 BYTEs	password for server access
 09h	DWORD	-&gt; process descriptor of process to be logged on (see #04026)

Format of REAL/32 Process Descriptor:
Offset	Size	Description	(Table 04026)
 00h	WORD	offset of next entry in current descriptor list
 02h	WORD	offset of thread list
 04h	BYTE	current processor status (see #04027)
 05h	BYTE	priority
 06h	WORD	runtime flags (see #04028)
 08h  8 BYTEs	process name
 10h	WORD	segment of User Data Area (UDA) (256 or 352 bytes)
 12h	BYTE	current default disk drive
 13h	BYTE	drive from which process was loaded
 14h	WORD	reserved (0)
 16h	WORD	offset of memory descriptor list for memory owned by process
 18h  6 BYTEs	reserved
 1Eh	WORD	offset of process descriptor for parent process
		0000h if parent has already terminated
 20h	BYTE	number of default console
 21h	BYTE	number of default AUX device
 22h  2 BYTEs	reserved
 24h	BYTE	number of default list device
 25h	BYTE	reserved
 26h	WORD	flags (see #04029)
 28h 12 BYTEs	reserved
 34h	WORD	offset of memory page allocation root
 36h 22 BYTEs	reserved
Note:	At least offset 10h (UDA) is also supported by MDOS 5.00, 5.01, 5.10,
	  as the DR DOS MEM utility retrieves this UDA segment through
	  INT E0/CL=9Ah when INT 21/AX=4451h returns 1463h, 1465h, or 1466h.
SeeAlso: #04025

(Table 04027)
Values for REAL/32 processor status:
 00h	process is ready to run
 01h	process is polling a device
 02h	delaying for a number of ticks
 03h	in swap list
 04h	terminating
 05h	asleep
 06h	waiting to read a message from a queue
 07h	waiting to write a message
 08h	waiting on system flag or semaphore
 09h	waiting to attach to an I/O device
 0Ah	waiting on sync block
 0Bh	waiting for system flag or semaphore with timeout
 0Ch	forced dispatch
SeeAlso: #04026

Bitfields for REAL/32 process flags:
Bit(s)	Description	(Table 04028)
 0	system process
 1	do not terminate
 2	special rsp process
 3	from process descriptor table
 14-4	unused???
 15	uses math coprocessor
SeeAlso: #04026,#04029

Bitfields for REAL/32 secondary flags:
Bit(s)	Description	(Table 04029)
 0	suspend when in background
 1	???
 2	in foreground
 3	enable APPEND processing on file opens
 4	Ctrl-C was typed
 5	Ctrl-C will reset disk system
 6	OK to read locked record
 7	???
 8	do not perform banking
SeeAlso: #04026,#04028

(Table 04030)
Values for REAL/32 "N_LOGON" status:
 0000h	successful
 00FFh	server could not create shadow process
 07FFh	incorrect password
 0CFFh	not logged into specified server
 0DFFh	process already logged onto 16 servers,
	LPB process not attached to network
 0EFFh	physical transmission prevented message or response from getting thru
	network error during logoff
 FFFFh	calling process not attached to network

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL41" name="E0----CL41"><b>E0----CL41</b></a> - INT E0 - REAL/32 - "N_LOGON" - LOG OFF A SERVER<br />
<pre>
INT E0 - REAL/32 - "N_LOGON" - LOG OFF A SERVER
	CL = 41h
	DS:DX -&gt; LPB (see #04025)
Return: AX = status (0000h,0CFFh,0DFFh,0EFFh,FFFFh) (see #04030)
	may destroy SI,DI,DS???
SeeAlso: INT E0/CL=40h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL44" name="E0----CL44"><b>E0----CL44</b></a> - INT E0 - REAL/32 - "N_STAT" - GET NETWORK STATUS<br />
<pre>
INT E0 - REAL/32 - "N_STAT" - GET NETWORK STATUS
	CL = 44h
Return: AX = network status or 0FFFh on error
	    bit 8: calling process is attached to network
	may destroy SI,DI???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL45" name="E0----CL45"><b>E0----CL45</b></a> - INT E0 - REAL/32 - "N_RCT" - GET REQUESTOR CONFIGURATION TABLE<br />
<pre>
INT E0 - REAL/32 - "N_RCT" - GET REQUESTOR CONFIGURATION TABLE
	CL = 45h
	DS:DX -&gt; RCT Control Block (see #04031,#04032)
Return: AX = status or error code (see #04033,#04030)
	may destroy SI,DI,DS???
SeeAlso: INT E0/CL=47h

Format of REAL/32 RCT Control Block for Drives:
Offset	Size	Description	(Table 04031)
 00h	BYTE	command byte
		00h map disk drive
		02h map list device
 01h	BYTE	local resource ID
 02h	BYTE	remote resource ID
 03h	BYTE	server node ID number
Note:	the RCT Control Block is a union of two possible structures; this
	  variant is used when mapping disk drives and list devices
SeeAlso: #04032

Format of REAL/32 RCT Control Block for Queues:
Offset	Size	Description	(Table 04032)
 00h	BYTE	command byte
		03h map local queue to server
		04h unmap queue
 01h  8 BYTEs	local queue name (case-sensitive)
 09h  8 BYTEs	remote queue name (case-sensitive)
 11h	BYTE	server node ID number
Note:	the RCT Control Block is a union of two possible structures; this
	  variant is used when mapping queues
SeeAlso: #04031

(Table 04033)
Values for REAL/32 "N_RCT" status:
 0000h	successful
 0001h	invalid local device
 0002h	invalid remote device
 0003h	no queue entry space

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL47" name="E0----CL47"><b>E0----CL47</b></a> - INT E0 - REAL/32 - "N_SCT" - GET SERVER CONFIGURATION TABLE<br />
<pre>
INT E0 - REAL/32 - "N_SCT" - GET SERVER CONFIGURATION TABLE
	CL = 47h
	DS:DX -&gt; 112-byte buffer for Server Configuration Table (see #04034)
Return: AX = status (0000h successful, else error code)
	may destroy SI,DI,DS???
Note:	the first byte of the SCT buffer is set to the desired server number
	  prior to calling this function
SeeAlso: INT E0/CL=45h

Format of REAL/32 Server Configuration Table:
Offset	Size	Description	(Table 04034)
 00h	BYTE	server's default physical drive ID
 01h	BYTE	network status
 02h	BYTE	server node ID number
 03h	BYTE	maximum number of requesters supported by server
 04h	BYTE	current number of shadow processes
 05h 108 BYTEs	six logon structures, each:
		Offset	Size	Description
		 00h	WORD	bit vector of logged-in nodes
		 02h 16 BYTEs	list of requester node IDs

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL48" name="E0----CL48"><b>E0----CL48</b></a> - INT E0 - REAL/32 - "N_ERRMODE" - SET NETWORK ERROR MODE<br />
<pre>
INT E0 - REAL/32 - "N_ERRMODE" - SET NETWORK ERROR MODE
	CL = 48h
	DL = new error mode
	    FFh return error in registers AX,BX,CX
	    FEh display message and return error
	    FDh display message and abort (default)
Return: CX = error code (0000h successful, FFFFh failed)
	may destroy SI,DI???
Desc:	specify how the REAL/32 Net Server responds to error numbers 0CFFh,
	  0DFFh, and 0EFFh (see #04030)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL59" name="E0----CL59"><b>E0----CL59</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS - "S_MEMORY" - RESERVE MEMORY IN GLOBAL AREA<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS - "S_MEMORY" - RESERVE MEMORY IN GLOBAL AREA
	CL = 59h
	DX = size in bytes
Return: AX = status
	    FFFFh failed
	    other successful
		ES:BX -&gt; reserved memory

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL5C" name="E0----CL5C"><b>E0----CL5C</b></a> - INT E0 - REAL/32 - "P_PATH" - SCAN PATH FOR EXECUTABLE FILE<br />
<pre>
INT E0 - REAL/32 - "P_PATH" - SCAN PATH FOR EXECUTABLE FILE
	CL = 5Ch
	DS:DX -&gt; Exec Parameter Block (EPB) (see #04035)
Return:	AX = status
	    FFFEh file not found
	    FFFDh path not found
	    FFFCh too many handles open
	    FFFBh access denied
	    FFF6h invalid environment
	    FFDCh sharing conflict
	    FFAAh invalid password
	EPB updated (if successful)
	may destroy SI,DI,DS
SeeAlso: INT E0/CL=5Dh,INT E0/CL=5Eh,INT 21/AH=4Bh

Format of REAL/32 Exec Parameter Block (EPB):
Offset	Size	Description	(Table 04035)
 00h	DWORD	-&gt; ASCIZ command to be executed
 04h	BYTE	type of exec
		00h .CMD
		01h .COM
		02h .EXE
		03h .BAT
		04h RSP-type queue
 05h	BYTE	flags
		bit 0: overlay existing program
		bit 1: don't assign console to child
		bit 2: allocate memory for .CMD within parent's memory space
		bit 3: make full banked window available while loading child
 06h	DWORD	32-bit offset to ASCIZ command line
 0Ah	WORD	selector for ASCIZ command line

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL5D" name="E0----CL5D"><b>E0----CL5D</b></a> - INT E0 - REAL/32 - "P_EXEC" - EXECUTE CHILD PROCESS<br />
<pre>
INT E0 - REAL/32 - "P_EXEC" - EXECUTE CHILD PROCESS
	CL = 5Dh
	DS:DX -&gt; Exec Parameter Block (EPB) (see #04035)
Return:	AX = status
	    FFFEh file not found
	    FFFDh path not found
	    FFFCh too many handles open
	    FFFBh access denied
	    FFF6h invalid environment
	    FFDCh sharing conflict
	    FFAAh invalid password
	EPB updated (if successful)
	may destroy SI,DI,DS
SeeAlso: INT E0/CL=5Ch,INT E0/CL=5Eh,INT 21/AH=4Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL5E" name="E0----CL5E"><b>E0----CL5E</b></a> - INT E0 - REAL/32 - "P_EXITCODE" - GET/SET PROCESS EXIT CODE<br />
<pre>
INT E0 - REAL/32 - "P_EXITCODE" - GET/SET PROCESS EXIT CODE
	CL = 5Eh
	DX = exit code or FFFFh to get
	    DH ignored when setting code
	    DL = process exit code
Return: AX = status (FFFFh on error)
	if getting:
	    AH = termination reason
		00h normal
		01h external termination via Ctrl-C or P_ABORT
		02h hardware (critical) error abort
		03h child did not terminate
		FFh illegal request (no child, or exit code already retrieved)
	    AL = process exit code
SeeAlso: INT E0/CL=5Dh,INT 21/AH=4Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL6B" name="E0----CL6B"><b>E0----CL6B</b></a> - INT E0 - REAL/32 - "S_SERIAL" - GET OS SERIAL NUMBER<br />
<pre>
INT E0 - REAL/32 - "S_SERIAL" - GET OS SERIAL NUMBER
	CL = 6Bh
	DS:DX -&gt; 6-byte buffer for ASCII serial number
Return: nothing???

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL6D" name="E0----CL6D"><b>E0----CL6D</b></a> - INT E0 - REAL/32 - "C_MODE" - GET/SET CONSOLE MODE<br />
<pre>
INT E0 - REAL/32 - "C_MODE" - GET/SET CONSOLE MODE
	CL = 6Dh
	DX = new console mode (see #04036), or FFFFh to get current mode
Return: AX = status if setting (0000h = success)
	AX = current console mode if DX=FFFFh on entry

Bitfields for REAL/32 console mode:
Bit(s)	Description	(Table 04036)
 0	C_STAT function will return 01h only when Ctrl-C is pressed
 1	disable support for stop/start scroll (Ctrl-S/Ctrl-Q)
 2	raw console output (no tab expansion, no printer echo)
 3	disable program termination on Ctrl-C
 7	disable Ctrl-O console bit-bucket
 10	enable Esc as end-of-line character

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL6E" name="E0----CL6E"><b>E0----CL6E</b></a> - INT E0 - REAL/32 - "C_DELIMIT" - GET/SET STRING DELIMITER<br />
<pre>
INT E0 - REAL/32 - "C_DELIMIT" - GET/SET STRING DELIMITER
	CL = 6Eh
	DX = new delimiter, or FFFFh to get current string delimiter
Return: AX = status (0000h success) if setting
	AX = current string delimiter (default is 24h '$' at process start)
SeeAlso: INT E0/CL=09h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL6F" name="E0----CL6F"><b>E0----CL6F</b></a> - INT E0 - REAL/32 - "C_WRITEBLK" - WRITE BLOCK TO DEFAULT CONSOLE<br />
<pre>
INT E0 - REAL/32 - "C_WRITEBLK" - WRITE BLOCK TO DEFAULT CONSOLE
	CL = 6Fh
	DS:DX -&gt; Character Control Block (see #04051,#04052)
Return: nothing???
SeeAlso: INT E0/CL=70h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL70" name="E0----CL70"><b>E0----CL70</b></a> - INT E0 - REAL/32 - "L_WRITEBLK" - WRITE BLOCK TO DEFAULT LIST (PRINTER) DEVICE<br />
<pre>
INT E0 - REAL/32 - "L_WRITEBLK" - WRITE BLOCK TO DEFAULT LIST (PRINTER) DEVICE
	CL = 70h
	DS:DX -&gt; Character Control Block (see #04051,#04052)
Return: nothing???
SeeAlso: INT E0/CL=6Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL71" name="E0----CL71"><b>E0----CL71</b></a> - INT E0 R - ConcCP/M,DR Multiuser DOS - EXECUTE DOS-COMPATIBLE FUNCTIONS<br />
<pre>
INT E0 R - ConcCP/M,DR Multiuser DOS - EXECUTE DOS-COMPATIBLE FUNCTIONS
	CL = 71h
	DS:DX -&gt; parameter block (see #04038)
Return: AX = status (0000h successful, else error code)
	may destroy SI,DI,DS

(Table 04037)
Values for DR "execute DOS-compatible function" function number:
 00h	"fd_getdpb"	get disk information (see also INT 21/AH=32h)
 01h	"fd_mkdir"	create directory (see also INT 21/AH=39h)
 02h	"fd_rmdir"	remove directory (see also INT 21/AH=3Ah)
 03h	"fd_chdir"	change directory (see also INT 21/AH=3Bh)
 04h	"fd_creat"	create file (see also INT 21/AH=3Ch)
 05h	"fd_open"	open existing file (see also INT 21/AH=3Dh)
 06h	"fd_close"	close file (see also INT 21/AH=3Eh)
 07h	"fd_read"	read from file (see also INT 21/AH=3Fh)
 08h	"fd_write"	write to file (see also INT 21/AH=40h)
 09h	"fd_delete"	delete file (see also INT 21/AH=41h)
 0Ah	"fd_lseek"	get/set file position (see also INT 21/AH=42h)
 0Bh	"fd_chmod"	get/set file attributes (see also INT 21/AH=43h)
 0Ch	"fd_curdir"	get current directory (see also INT 21/AH=47h)
 0Dh	"fd_sfirst"	find first matching file (see also INT 21/AH=4Eh)
 0Eh	"fd_snext"	find next matching file (see also INT 21/AH=4Fh)
 0Fh	"fd_rename"	rename file (see also INT 21/AH=56h)
 10h	"fd_gsfdate"	get/set file date (see also INT 21/AX=5700h)
 11h	"fd_mktemp"	make temporary file (see also INT 21/AH=5Ah)
 12h	"fd_mknew"	create new file (see also INT 21/AH=5Bh)
 13h	"fd_lock"	lock/unlock file data (see also INT 21/AH=5Ch)
 14h	"fd_dup"	duplicate file handle (see also INT 21/AH=45h)
 15h	"fd_dup2"	force duplicate file handle (see also INT 21/AH=46h)
 16h-19h ???
 1Ah	"fd_ioctl"	I/O control emulation
 1Bh	"fd_commit"	commit file to disk (see also INT 21/AH=68h)
 1Ch	"fd_expand"	expand file name (see also INT 21/AH=60h)
 1Dh	???
 1Eh	???
 1Fh	"fd_sethandles" set number of handles for calling process
SeeAlso: #04038

Format of DR "execute DOS-compatible function" parameter block:
Offset	Size	Description	(Table 04038)
 00h	WORD	function number (see #04037)
---function 00h---
 02h	WORD	drive
 04h	DWORD	-&gt; DPB (see #04039)
---function 01h,02h,03h---
 02h	DWORD	-&gt; ASCIZ directory name
---function 04h---
 02h	DWORD	-&gt; ASCIZ filename
 06h	WORD	file attributes
---function 05h---
 02h	DWORD	-&gt; ASCIZ filename
 06h	WORD	open mode (see INT 21/AH=3Dh)
---function 06h---
 02h	WORD	file handle
---function 07h,08h---
 02h	WORD	file handle
 04h	DWORD	-&gt; buffer
 08h	WORD	number of bytes to read or write
---function 09h---
 02h	DWORD	-&gt; ASCIZ filename
---function 0Ah---
 02h	WORD	file handle
 04h	DWORD	(call) desired offset
		(ret) new file position if function is successful
 08h	WORD	seek origin (offset is calculated from specified position)
		00h start of file
		01h current position
		02h end of file
---function 0Bh---
 02h	DWORD	-&gt; ASCIZ filename
 06h	WORD	(call) new file attributes or new file owner
		(ret) current/new file attributes, depending on function
 08h	WORD	subfunction
		00h get attribute
		01h set attribute
		02h get extended attributes
		03h set extended attributes (and password)
		04h get encrypted password
		05h set extended attributes (and encrypted password)
		06h get file owner
		07h set file owner
		Note: the password is taken from the first 8 bytes of the DTA
---function 0Ch---
 02h	WORD	drive
 04h	DWORD	-&gt; 64-byte buffer for ASCIZ current directory path
---function 0Dh---
 02h	DWORD	-&gt; ASCIZ filespec
 06h	WORD	file attributes
 08h	WORD	(call) size of buffer pointed at by current DTA
		(ret) number of matching files returned???
		Note:	if the volume label attribute is specified, the root
			  directory will be searched
			if the buffer is at least 47 bytes, multiple matching
			  entries will be stored in the DTA (at 21 bytes per
			  entry)
---function 0Eh---
 02h	WORD	number of additional matches to store in DTA
		(normally set to 0, but if DTA is at least 47 bytes, can be
		  set to (DTAsize-21)/26 to return multiple matches)
---function 0Fh---
 02h	DWORD	-&gt; ASCIZ filename
 06h	DWORD	-&gt; ASCIZ new name
---function 10h---
 02h	WORD	file handle
 04h	WORD	subfunction
		00h get date and time
		01h set date and time
 06h	WORD	file date
 08h	WORD	file time
---function 11h---
 02h	DWORD	-&gt; ASCIZ pathname + 13 extra bytes for generated filename
		(if pathname does not end in backslash, one will be appended)
 06h	WORD	file attributes
---function 12h---
 02h	DWORD	-&gt; ASCIZ filename
 06h	WORD	file attributes
---function 13h---
 02h	WORD	file handle
 04h	DWORD	offset of start of region
 08h	DWORD	length of region to lock/unlock
 0Ch	WORD	subfunction (00h = lock, 01h = unlock)
---function 14h---
 02h	WORD	file handle to be duplicated
		(new file handle is returned as function return value)
---function 15h---
 02h	WORD	file handle to be duplicated
 04h	WORD	file handle which is to become the duplicate
---function 1Ah, form 1---
 02h	WORD	file handle
 04h	WORD	IOCTL function number (00h,01h,06h,07h,0Ah)
 06h	WORD	(ret) status
---function 1Ah, form 2---
 02h	WORD	drive number
 04h	WORD	IOCTL function number (08h,09h,0Eh,0Fh)
 06h	WORD	(ret) status
---function 1Ah, form 3---
 02h	WORD	file handle
 04h	WORD	IOCTL function number (02h,03h,54h)
 06h	DWORD	-&gt; buffer
 0Ah	WORD	(call) size of buffer in bytes
		(ret) size of returned data
---function 1Ah, form 4---
 02h	WORD	drive number
 04h	WORD	IOCTL function number (04h,05h)
 06h	DWORD	-&gt; buffer
 0Ah	WORD	(call) size of buffer in bytes
		(ret) size of returned data
---function 1Bh---
 02h	WORD	file handle of file to be committed to disk
---function 1Ch---
 02h	DWORD	-&gt; ASCIZ relative filename
 06h	DWORD	-&gt; buffer for absolute filename
---function 1Fh---
 02h	WORD	desired number of file handles for process

Format of DR Multiuser DOS Disk Parameter Block (DPB):
Offset	Size	Description	(Table 04039)
 00h	BYTE	drive number (00h = A:)
 01h	BYTE	relative unit number
 02h	WORD	sector size in bytes
 04h	BYTE	sectors per cluster - 1
 05h	BYTE	shift count to convert clusters into sectors
 06h	WORD	number of reserved sectors at beginning of drive
 08h	BYTE	number of FATs
 09h	WORD	number of root directory entries
 0Bh	WORD	number of first sector containing user data
 0Dh	WORD	number of clusterse on disk
 0Fh	BYTE	number of sectors per FAT
 10h	WORD	sector number of first directory sector
 12h  4 BYTEs	reserved
 16h	BYTE	media ID byte (see #01356)
 17h	BYTE	00h if disk accessed, FFh if not
 18h  6 BYTEs	reserved
 1Eh	WORD	number of free clusters on drive
Note:	this structure is a subset of the MS-DOS 3.x Drive Parameter Block
SeeAlso: #04038,#01357 at INT 21/AH=1Fh,#01395 at INT 21/AH=32h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL73" name="E0----CL73"><b>E0----CL73</b></a> - INT E0 - GSX-86, GEM/1, GEM/2 - API<br />
<pre>
INT E0 - GSX-86, GEM/1, GEM/2 - API
	CL = 73h
	CH = 04h
	DS:DX -&gt; parameter block

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL80" name="E0----CL80"><b>E0----CL80</b></a> - INT E0 - REAL/32 - "M_ALLOC" - ALLOCATE MEMORY<br />
<pre>
INT E0 - REAL/32 - "M_ALLOC" - ALLOCATE MEMORY
	CL = 80h
	DS:DX -&gt; Memory Parameter Block (MPB) (see #04040)
Return: AX = status (0000h success, else error code)
SeeAlso: INT E0/CL=81h

Format of REAL/32 Memory Parameter Block (MPB):
Offset	Size	Description	(Table 04040)
 00h	WORD	(call) desired starting paragraph of block, or
		  0000h for anywhere
		(ret) starting paragraph of allocated block
 02h	WORD	(call) minimum number of paragraphs required
		(ret) actual number of paragraphs allocated
 04h	WORD	(call) maximum number of paragraphs to allocate
		(ret) actual number of paragraphs allocated
 06h	WORD	process descriptor (see #04026) of memory's owner or 0000h
 08h	WORD	flags (normally set to 0000h on call)
SeeAlso: #04041

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL81" name="E0----CL81"><b>E0----CL81</b></a> - INT E0 - REAL/32 - "M_FREE" - DEALLOCATE MEMORY<br />
<pre>
INT E0 - REAL/32 - "M_FREE" - DEALLOCATE MEMORY
	CL = 81h
	DS:DX -&gt; Memory Free Parameter Block (MFPB) (see #04041)
Return: AX = status (0000h success, else error code)
SeeAlso: INT E0/CL=81h

Format of REAL/32 Memory Free Parameter Block (MFPB) :
Offset	Size	Description	(Table 04041)
 00h	WORD	starting segment of block to be freed
 02h	WORD	reserved (0)
SeeAlso: #04040

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL84" name="E0----CL84"><b>E0----CL84</b></a> - INT E0 - REAL/32 - "DEV_WAITFLAG" - WAIT ON SYSTEM FLAG<br />
<pre>
INT E0 - REAL/32 - "DEV_WAITFLAG" - WAIT ON SYSTEM FLAG
	CL = 84h
	DX = system flag ID
Return: AX = status (0000h success, else error code)
	if successful, this function does not return until the system flag has
	  been set by an interrupt handler (see INT E0/CL=85h); if the flag was
	  already set, this call returns immediately
SeeAlso: INT E0/CL=85h,INT E0/CL=B7h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL85" name="E0----CL85"><b>E0----CL85</b></a> - INT E0 - REAL/32 - "DEV_SETFLAG" - SET SYSTEM FLAG<br />
<pre>
INT E0 - REAL/32 - "DEV_SETFLAG" - SET SYSTEM FLAG
	CL = 85h
	DX = system flag ID
Return: AX = status (0000h success, else error code)
Note:	REAL/32 returns an error if the flag was already set, which indicates
	  that a previous logical interrupt has not yet been serviced
SeeAlso: INT E0/CL=84h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL86" name="E0----CL86"><b>E0----CL86</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_MAKE" - CREATE MESSAGE QUEUE<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS - "Q_MAKE" - CREATE MESSAGE QUEUE
	CL = 86h
	DS:DX -&gt; queue descriptor (see #04042)
Return: AX = status (0000h success, FFFFh failure)
	CX = error code (see #04021)
Note:	also supported by REAL/32
SeeAlso: INT E0/CL=87h

Format of DR Multiuser DOS queue descriptor:
Offset	Size	Description	(Table 04042)
 00h  2 WORDs	internal use, initialize to zeros
 04h	WORD	queue flags (see #04043)
 06h  8 BYTEs	queue name
 0Eh	WORD	length of message
 10h	WORD	number of messages
 12h  4 WORDs	internal use, initialize to zeros
 1Ah	WORD	offset in system area of buffer for messages

Bitfields for REAL/32 queue flags:
Bit(s)	Description	(Table 04043)
 0	mutual exclusion queue
 1	can not be deleted
 2	restricted to system processes
 3	RSP message queue
 4	reserved for internal use
 5	RPL address queue
 7-6	reserved for internal use
 15-8	reserved for future use
SeeAlso: #04042

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL87" name="E0----CL87"><b>E0----CL87</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_OPEN" - OPEN MESSAGE QUEUE<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS - "Q_OPEN" - OPEN MESSAGE QUEUE
	CL = 87h
	DS:DX -&gt; queue parameter block (QPB) (see #04044,#04045)
Return: AX = status (0000h success, FFFFh failure)
	CX = error code (see #04021)
Note:	also supported by REAL/32
SeeAlso: INT E0/CL=86h,INT E0/CL=88h,INT E0/CL=89h

Format of DR Multiuser DOS queue parameter block:
Offset	Size	Description	(Table 04044)
 00h	WORD	internal use, initialize to zero
 02h	WORD	queue ID (set by INT E0/CL=87h)
 04h	WORD	internal use, initialize to zero
 06h	WORD	offset of queue message buffer
		(REAL/32) if FFFFh, then full address of buffer is stored at
		  offest 10h
 08h  8 BYTEs	queue name
---REAL/32 only----
 10h	DWORD	segment:offset of queue message buffer
SeeAlso: #04045

Format of protected-mode REAL/32 Queue Parameter Block (QPB):
Offset	Size	Description	(Table 04045)
 00h	WORD	internal use
 02h	WORD	queue ID
 04h	WORD	internal use
 06h	DWORD	32-bit offset to buffer
 0Ah	WORD	selector for buffer
 0Ch  8 BYTEs	queue name
SeeAlso: #04044

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL88" name="E0----CL88"><b>E0----CL88</b></a> - INT E0 - REAL/32 - "Q_DELETE" - DELETE SYSTEM QUEUE<br />
<pre>
INT E0 - REAL/32 - "Q_DELETE" - DELETE SYSTEM QUEUE
	CL = 88h
	DS:DX -&gt; queue parameter block (QPB) (see #04044,#04045)
Return: AX = status (0000h success, FFFFh failure)
SeeAlso: INT E0/CL=87h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL89" name="E0----CL89"><b>E0----CL89</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_READ" - READ MESSAGE QUEUE<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS - "Q_READ" - READ MESSAGE QUEUE
	CL = 89h
	DS:DX -&gt; queue parameter block (QPB) (see #04044,#04045)
Return: AX = status (0000h success, FFFFh failure)
	CX = error code (see #04021)
Note:	also supported by REAL/32
SeeAlso: INT E0/CL=87h,INT E0/CL=8Ah,INT E0/CL=8Bh,INT E0/CL=B6h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL8A" name="E0----CL8A"><b>E0----CL8A</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_CREAD" - CONDITIONALLY READ MSG QUEUE<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS - "Q_CREAD" - CONDITIONALLY READ MSG QUEUE
	CL = 8Ah
	DS:DX -&gt; queue parameter block (QPB) (see #04044,#04045)
Return: AX = status (0000h success, FFFFh failure)
	CX = error code (see #04021)
Note:	also supported by REAL/32
SeeAlso: INT E0/CL=87h,INT E0/CL=89h,INT E0/CL=8Ch,INT E0/CL=B6h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL8B" name="E0----CL8B"><b>E0----CL8B</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_WRITE" - WRITE MESSAGE QUEUE<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS - "Q_WRITE" - WRITE MESSAGE QUEUE
	CL = 8Bh
	DS:DX -&gt; queue parameter block (QPB) (see #04044,#04045)
Return: AX = status (0000h success, FFFFh failure)
	CX = error code (see #04021)
Note:	also supported by REAL/32
SeeAlso: INT E0/CL=89h,INT E0/CL=8Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL8C" name="E0----CL8C"><b>E0----CL8C</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS - "Q_CWRITE" - CONDITIONALLY WRITE MSG QUEUE<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS - "Q_CWRITE" - CONDITIONALLY WRITE MSG QUEUE
	CL = 8Ch
	DS:DX -&gt; queue parameter block (QPB) (see #04044,#04045)
Return: AX = status (0000h success, FFFFh failure)
	CX = error code (see #04021)
Note:	also supported by REAL/32
SeeAlso: INT E0/CL=8Ah,INT E0/CL=8Bh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL8E" name="E0----CL8E"><b>E0----CL8E</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS - "P_DISPATCH" - CALL DISPATCHER<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS - "P_DISPATCH" - CALL DISPATCHER
	CL = 8Eh
	DX = FFFFh (optional) to force dispatch
Return: nothing
Desc:	allow other processes of the same or higher priority to run if they
	  are ready
Notes:	if DX=FFFFh, a dispatch is forced even if no other process is ready
	also supported by REAL/32
SeeAlso: INT E0/CL=91h,INT 15/AX=1000h,INT 2F/AX=1680h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL8F" name="E0----CL8F"><b>E0----CL8F</b></a> - INT E0 - REAL/32 - "P_TERM" - TERMINATE CALLING PROCESS<br />
<pre>
INT E0 - REAL/32 - "P_TERM" - TERMINATE CALLING PROCESS
	CL = 8Fh
	DX = termination code
Return: never if successful
	AX = FFFFh on failure
Note:	this function can not terminate processes whose KEEP flag is set
	if the termination code is FFh, this function can terminate the process
	  even if its SYSTEM flag is on; otherwise, only user processes can
	  terminate themselves
SeeAlso: INT E0/CL=90h,INT 21/AH=4Ch

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL90" name="E0----CL90"><b>E0----CL90</b></a> - INT E0 - REAL/32 - "P_CREATE" - CREATE A PROCESS<br />
<pre>
INT E0 - REAL/32 - "P_CREATE" - CREATE A PROCESS
	CL = 90h
	DS:DX -&gt; process descriptor in calling process' system memory area
		(see #04026)
Return: AX = status
Notes:	this call can create more than one process if the specied process
	  descriptor's link (next-process) field is nonzero
	all reserved and unused fields in the process descriptor should be
	  filled with zeros; passing an invalid descriptor or pointer may
	  crash the system because the descriptor is not checked by the OS
	the newly-created process(es) is always a native process, which can not
	  make DOS calls
SeeAlso: INT E0/CL=8Fh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL91" name="E0----CL91"><b>E0----CL91</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS - "P_PRIORITY" - SET PROCESS PRIORITY<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS - "P_PRIORITY" - SET PROCESS PRIORITY
	CL = 91h
	DL = new priority (00h highest to FFh lowest)
Return: nothing
Notes:	sets priority of calling process; transient processes are initialized
	  to priority C8h
	also supported by REAL/32
SeeAlso: INT E0/CL=8Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL92" name="E0----CL92"><b>E0----CL92</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS - "C_ATTACH" - ATTACH TO DEFAULT CONSOLE<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS - "C_ATTACH" - ATTACH TO DEFAULT CONSOLE
	CL = 92h
Return: AX = status
Notes:	also supported by REAL/32
	if the console is currently owned by another process, this function
	  waits until the console is available
SeeAlso: INT E0/CL=93h,INT E0/CL=94h,INT E0/CL=99h,INT E0/CL=9Eh,INT E0/CL=A2h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL93" name="E0----CL93"><b>E0----CL93</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS - "C_DETACH" - DETACH FROM DEFAULT CONSOLE<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS - "C_DETACH" - DETACH FROM DEFAULT CONSOLE
	CL = 93h
Return: AX = status
	    0000h successfully detached
	    FFFFh detach failed
Note:	also supported by REAL/32
SeeAlso: INT E0/CL=92h,INT E0/CL=A6h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL94" name="E0----CL94"><b>E0----CL94</b></a> - INT E0 - REAL/32 - "C_SET" - SET PROCESS'S DEFAULT CONSOLE<br />
<pre>
INT E0 - REAL/32 - "C_SET" - SET PROCESS'S DEFAULT CONSOLE
	CL = 94h
	DX = console ID
Return: AX = status (0000h success, else error code)
SeeAlso: INT E0/CL=92h,INT E0/CL=95h,INT E0/CL=99h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL95" name="E0----CL95"><b>E0----CL95</b></a> - INT E0 - REAL/32 - "C_ASSIGN" - ASSIGN DEFAULT CONSOLE TO ANOTHER PROCESS<br />
<pre>
INT E0 - REAL/32 - "C_ASSIGN" - ASSIGN DEFAULT CONSOLE TO ANOTHER PROCESS
	CL = 95h
	DS:DX -&gt; Assign Control Parameter Block (ACPB) (see #04046)
Return: AX = status
SeeAlso: INT E0/CL=94h,INT E0/CL=99h

Format of REAL/32 Assign Control Parameter Block (ACPB):
Offset	Size	Description	(Table 04046)
 00h	BYTE	ID of console to assign
 01h	BYTE	flag: if FFh, new process must have CNS as console for this
		  call to succeed
 02h	DWORD	-&gt; process descriptor (see #04026) or 00000000h
 06h  8 BYTEs	name of process to search for if descriptor field above is zero

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL96" name="E0----CL96"><b>E0----CL96</b></a> - INT E0 - REAL/32 - "P_CLI" - RUN COMMAND LINE INTERFACE<br />
<pre>
INT E0 - REAL/32 - "P_CLI" - RUN COMMAND LINE INTERFACE
	CL = 96h
	DS:DX -&gt; Command Line Buffer (CLBUF) (see #04047)
Return: AX = status
Desc:	execute the indicated command concurrently with the calling process;
	  system queue commands, .BAT, .CMD, .COM, and .EXE files can be
	  executed
Note:	the calling process will lose its virtual console and must reattach it
	  before attempting any I/O
SeeAlso: INT E0/CL=92h

Format of REAL/32 Command Line Buffer (CLBUF):
Offset	Size	Description	(Table 04047)
 00h	BYTE	reserved (0)
 01h 128 BYTEs	ASCIZ command line
 81h	BYTE	(0)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL99" name="E0----CL99"><b>E0----CL99</b></a> - INT E0 - REAL/32 - "C_GET" - GET DEFAULT CONSOLE<br />
<pre>
INT E0 - REAL/32 - "C_GET" - GET DEFAULT CONSOLE
	CL = 99h
Return: AX = default console ID
SeeAlso: INT E0/CL=94h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL9A" name="E0----CL9A"><b>E0----CL9A</b></a> - INT E0 - REAL/32 - "S_SYSDAT" - GET SYSTEM DATA AREA<br />
<pre>
INT E0 - REAL/32 - "S_SYSDAT" - GET SYSTEM DATA AREA
	CL = 9Ah
Return: ES:AX -&gt; system data area (see #04048)
	may destroy SI,DI

Format of REAL/32 system data area:
Offset	Size	Description	(Table 04048)
 00h	DWORD	address of supervisor entry point
 04h 36 BYTEs	reserved
 28h	DWORD	address of XIOS entry point
 2Ch	DWORD	address of XIOS initialization point
 30h  8 BYTEs	reserved
 38h	DWORD	address of IRET dispatcher entry point
 3Ch	DWORD	address of RETF dispatcher entry point
 40h	WORD	segment of operating system code
 42h	WORD	paragraph address of first Resident System Process (RSP)
 44h	WORD	paragraph after OS system area
 46h	BYTE	reserved
 47h	BYTE	number of system console devices
 48h	BYTE	number of system list (printer) devices
 49h	BYTE	number of Character Control blocks
 4Ah	BYTE	number of system flags
 4Bh	BYTE	current search disk
 4Ch	WORD	maximum memory per process
 4Eh	BYTE	reserved
 4Fh	BYTE	"dayfile" (flag, true if FFh)
 50h	BYTE	default disk for temporary files
 51h	BYTE	system ticks per second (typically 60)
 52h	WORD	offset of Locked Unused list
 54h	WORD	offset of CCB table
 56h	WORD	offset of system flag table
 58h	WORD	offset of root of Memory Descriptor Unused list
 5Ah	WORD	offset of Memory Free list
 5Ch	WORD	offset of Process Unused list
 5Eh	WORD	offset of Queue Unused list
 60h  4 WORDs	(no longer used) QMAU
 68h	WORD	offset of root of Ready List
 6Ah	WORD	offset of root of Delay List
 6Ch	WORD	offset of Dispatcher Ready list
 6Eh	WORD	offset of root of Poll List
 70h	WORD	reserved
 72h	WORD	offset of root of Thread List
 74h	WORD	offset of root of Queue List
 76h	WORD	offset of Memory Allocation list
 78h	WORD	segment of version string
 7Ah	WORD	BDOS version number
 7Ch	WORD	OS version number
 7Eh	WORD	number of days since 1978/01/01
 80h	BYTE	current time: hour
 81h	BYTE	current time: minute
 82h	BYTE	current time: second
 83h	BYTE	number of XIOS consoles
 84h	BYTE	number of XIOS list (printer) devices
 85h	BYTE	total number of character devices
 86h	WORD	offset of LCB table
 88h	WORD	bitmap of open files
 8Ah	BYTE	maximum locked records per process
 8Bh	BYTE	maximum open files per process
 8Ch	WORD	offset of process descriptor for math coprocessor's owner
 8Eh	WORD	offset of Auxiliary Control Block
 90h  8 BYTEs	reserved
 98h	WORD	offset of root Memory Window Descriptor
 9Ah	WORD	reserved
 9Ch	BYTE	number of Auxiliary Control Blocks
 9Dh	BYTE	default search disk
 9Eh	BYTE	reserved
 9Fh	BYTE	number of physical consoles
 A0h	DWORD	address of 8087 interrupt handler
 A4h	DWORD	address of default 8087 exception handler
 ...		reserved
C00h 82 BYTEs	XIOS header structure (see #04049)

Format of REAL/32 XIOS header structure:
Offset	Size	Description	(Table 04049)
 00h  3 BYTEs	XIOS initialization entry point
 03h  3 BYTEs	XIOS service entry point
 06h	WORD	segment address of system data
 08h	DWORD	address of supervisor entry point
 0Ch	BYTE	set tick flag
 0Dh	BYTE	ticks per second
 0Eh	BYTE	global Door Open interrupt flag
 0Fh	BYTE	number of Auxiliary Control Blocks
 10h	BYTE	number of physical consoles
 11h	BYTE	number of virtual consoles
 12h	BYTE	number of logical consoles
 13h	BYTE	number of list control blocks
 14h	WORD	offset of CCB table
 16h	WORD	offset of LCB table
 18h 16 WORDs	offsets into DPH for drives A-P
 38h	WORD	buffer size in paragraphs
 3Ah	WORD	offset of ACB table
 3Ch	WORD	used by OEM
 3Eh	WORD	offset of CCB pointer array
 40h	WORD	offset of LCB pointer array
 42h	WORD	offset of ACB pointer array
 44h	BYTE	'first' flag
 45h	BYTE	unused
 46h	WORD	offset of print device support table
 48h	WORD	offset of aux device support table
 4Ah	WORD	XIOS extra segment
 4Ch	WORD	segment of save end address for debug
 4Eh	WORD	segment of save start address for debug
 50h	BYTE	number of main virtual console
 51h	WORD	segment of XIOS code
SeeAlso: #04048

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL9C" name="E0----CL9C"><b>E0----CL9C</b></a> - INT E0 - REAL/32 - "P_PDADR" - GET ADDRESS OF PROCESS DESCRIPTOR<br />
<pre>
INT E0 - REAL/32 - "P_PDADR" - GET ADDRESS OF PROCESS DESCRIPTOR
	CL = 9Ch
Return: ES:AX -&gt; caller's process descriptor (see #04026)
	may destroy SI,DI
Note:	This function is also called by the DR DOS MEM utility when
	  INT 21/AX=4451h returns either 1463h (MDOS 5.00), 1465h (MDOS 5.01),
	  or 1466h (MDOS 5.10).
SeeAlso: INT E0/CL=8Fh,INT E0/CL=90h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL9D" name="E0----CL9D"><b>E0----CL9D</b></a> - INT E0 - REAL/32 - "P_ABORT" - ABORT PROCESS BY NAME OR DESCRIPTOR<br />
<pre>
INT E0 - REAL/32 - "P_ABORT" - ABORT PROCESS BY NAME OR DESCRIPTOR
	CL = 9Dh
	DS:DX -&gt; Abort Parameter Block (see #04050)
Return: AX = status
	may destroy SI,DI,DS
SeeAlso: INT E0/CL=8Fh,INT E0/CL=9Ch

Format of REAL/32 Abort Parameter Block:
Offset	Size	Description	(Table 04050)
 00h	WORD	process descriptor of process to abort, or 0000h
 02h	WORD	termination code
 04h	BYTE	default console number
 05h	BYTE	reserved (0)
 06h  8 BYTEs	name of process to abort, if descriptor at offset 00h is 0000h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL9E" name="E0----CL9E"><b>E0----CL9E</b></a> - INT E0 - REAL/32 - "L_ATTACH" - ATTACH TO DEFAULT LIST DEVICE<br />
<pre>
INT E0 - REAL/32 - "L_ATTACH" - ATTACH TO DEFAULT LIST DEVICE
	CL = 9Eh
Return: AX = status
	may destroy SI,DI
SeeAlso: INT E0/CL=92h,INT E0/CL=9Fh,INT E0/CL=A0h,INT E0/CL=A1h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CL9F" name="E0----CL9F"><b>E0----CL9F</b></a> - INT E0 - REAL/32 - "L_DETACH" - DETACH FROM DEFAULT LIST DEVICE<br />
<pre>
INT E0 - REAL/32 - "L_DETACH" - DETACH FROM DEFAULT LIST DEVICE
	CL = 9Fh
Return: AX = status
	may destroy SI,DI
SeeAlso: INT E0/CL=92h,INT E0/CL=9Eh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLA0" name="E0----CLA0"><b>E0----CLA0</b></a> - INT E0 - REAL/32 - "L_SET" - SET DEFAULT LIST DEVICE<br />
<pre>
INT E0 - REAL/32 - "L_SET" - SET DEFAULT LIST DEVICE
	CL = A0h
	DX = ID of list (printer) device
Return: AX = status (0000h success, FFFFh if invalid printer number)
	may destroy SI,DI
SeeAlso: INT E0/CL=92h,INT E0/CL=9Eh,INT E0/CL=A4h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLA1" name="E0----CLA1"><b>E0----CLA1</b></a> - INT E0 - REAL/32 - "L_CATTACH" - CONDITIONALLY ATTACH TO DEFAULT LIST DEVICE<br />
<pre>
INT E0 - REAL/32 - "L_CATTACH" - CONDITIONALLY ATTACH TO DEFAULT LIST DEVICE
	CL = A1h
Return: AX = status (00h = successful, FFh = unable to attach)
	may destroy SI,DI
Desc:	attach the default list device to the calling process only if it is
	  currently available
SeeAlso: INT E0/CL=92h,INT E0/CL=9Eh,INT E0/CL=A0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLA2" name="E0----CLA2"><b>E0----CLA2</b></a> - INT E0 - REAL/32 - "C_CATTACH" - CONDITIONALLY ATTACH TO DEFAULT CONSOLE<br />
<pre>
INT E0 - REAL/32 - "C_CATTACH" - CONDITIONALLY ATTACH TO DEFAULT CONSOLE
	CL = A2h
Return: AL = status (FFh = console attached to another process)
Note:	if the console is currently owned by another process, this function
	  will return an error code instead of attaching or waiting
SeeAlso: INT E0/CL=93h,INT E0/CL=94h,INT E0/CL=99h,INT E0/CL=92h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLA3" name="E0----CLA3"><b>E0----CLA3</b></a> - INT E0 - ConcCP/M,DR Multiuser DOS,REAL/32 - "S_OSVER" - GET OS VERSION<br />
<pre>
INT E0 - ConcCP/M,DR Multiuser DOS,REAL/32 - "S_OSVER" - GET OS VERSION
	CL = A3h
Return: AX = operating system version (see #04023) (see also INT 21/AX=4451h)
SeeAlso: INT E0/CL=0Ch,INT 21/AX=4451h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLA4" name="E0----CLA4"><b>E0----CLA4</b></a> - INT E0 - REAL/32 - "L_GET" - GET DEFAULT LIST (PRINTER) DEVICE<br />
<pre>
INT E0 - REAL/32 - "L_GET" - GET DEFAULT LIST (PRINTER) DEVICE
	CL = A4h
Return: AL = number of default list device
SeeAlso: INT E0/CL=A0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLA5" name="E0----CLA5"><b>E0----CLA5</b></a> - INT E0 - DR Multiuser DOS - "A_ATTACH" - ATTACH AUX DEVICE<br />
<pre>
INT E0 - DR Multiuser DOS - "A_ATTACH" - ATTACH AUX DEVICE
	CL = A5h
Return: nothing (DR)
	AX = status (REAL/32)
Desc:	attaches the default auxiliary device to the calling process unless
	  it is already attached to another process, in which case the call
	  blocks until the device becomes available
Notes:	this call should be used before attempting to read or write from
	  the AUX device; however, the I/O calls internally call this function
	  to ensure device ownership
	also supported by REAL/32
SeeAlso: INT E0/CL=03h,INT E0/CL=04h,INT E0/CL=A6h,INT E0/CL=A7h,INT E0/CL=A8h
SeeAlso: INT E0/CL=ACh,INT E0/CL=ADh,INT E0/CL=B0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLA6" name="E0----CLA6"><b>E0----CLA6</b></a> - INT E0 - DR Multiuser DOS - "A_DETACH" - DETACH FROM AUX DEVICE<br />
<pre>
INT E0 - DR Multiuser DOS - "A_DETACH" - DETACH FROM AUX DEVICE
	CL = A6h
Return: AX = status
	    0000h successfully detached
	    FFFFh detach failed
	CX = error code
Note:	also supported by REAL/32
SeeAlso: INT E0/CL=93h,INT E0/CL=A5h,INT E0/CL=A7h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLA7" name="E0----CLA7"><b>E0----CLA7</b></a> - INT E0 - DR Multiuser DOS - "A_CATTACH" - CONDITIONALLY ATTACH TO AUX DEVICE<br />
<pre>
INT E0 - DR Multiuser DOS - "A_CATTACH" - CONDITIONALLY ATTACH TO AUX DEVICE
	CL = A7h
Return: AX = status
	    0000h attached
	    FFFFh unable to attach
Desc:	attaches the default auxiliary device to the calling process if it is
	  available
Notes:	does not block if the device is already in use
	also supported by REAL/32
SeeAlso: INT E0/CL=A5h,INT E0/CL=A6h,INT E0/CL=A8h,INT E0/CL=B0h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLA8" name="E0----CLA8"><b>E0----CLA8</b></a> - INT E0 - DR Multiuser DOS - "A_SET" - SET DEFAULT AUX DEVICE NUMBER<br />
<pre>
INT E0 - DR Multiuser DOS - "A_SET" - SET DEFAULT AUX DEVICE NUMBER
	CL = A8h
	DL = auxiliary device number
Return: AX = status
	    0000h successful
	    FFFFh failed
	CX = error code
Desc:	specify which physical device will become AUX
SeeAlso: INT E0/CL=A5h,INT E0/CL=A9h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLA9" name="E0----CLA9"><b>E0----CLA9</b></a> - INT E0 - DR Multiuser DOS - "A_GET" - GET DEFAULT AUX DEVICE NUMBER<br />
<pre>
INT E0 - DR Multiuser DOS - "A_GET" - GET DEFAULT AUX DEVICE NUMBER
	CL = A9h
Return: AL = current default auxiliary device number
Desc:	determine which physical device is currently AUX
SeeAlso: INT E0/CL=A8h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLAC" name="E0----CLAC"><b>E0----CLAC</b></a> - INT E0 - DR Multiuser DOS - "A_READBLK" - READ STRING FROM AUX DEVICE<br />
<pre>
INT E0 - DR Multiuser DOS - "A_READBLK" - READ STRING FROM AUX DEVICE
	CL = ACh
	DS:DX -&gt; character control block (CHCB) (see #04051,#04052)
Return: AX = number of characters read
Desc:	read characters from the default auxiliary (AUXn:) device into a buffer
	  until the buffer is full or the device is no longer ready
Notes:	if the device is initially not ready, blocks until at least one
	  character has been read
	if another process owns AUX, this call blocks until the device becomes
	  available
	also supported by REAL/32
SeeAlso: INT E0/CL=03h,INT E0/CL=A5h,INT E0/CL=ADh

Format of DR Multiuser DOS character control block (CHCB):
Offset	Size	Description	(Table 04051)
 00h	DWORD	pointer to character buffer
 04h	WORD	length of character buffer
Note:	this version of the structure is used by REAL/32 in real mode
SeeAlso: #04059

Format of REAL/32 protected-mode Character Control Block (CHCB):
Offset	Size	Description	(Table 04052)
 00h	DWORD	32-bit offset of character buffer
 04h	WORD	selector for character buffer
 06h	WORD	length of character buffer
SeeAlso: #04051

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLAD" name="E0----CLAD"><b>E0----CLAD</b></a> - INT E0 - DR Multiuser DOS - "A_WRITEBLK" - WRITE STRING TO AUX DEVICE<br />
<pre>
INT E0 - DR Multiuser DOS - "A_WRITEBLK" - WRITE STRING TO AUX DEVICE
	CL = ADh
	DS:DX -&gt; character control block (see #04051,#04052)
Return: AX = number of characters written
Notes:	does not return until at least one character has been written
	also supported by REAL/32
SeeAlso: INT E0/CL=04h,INT E0/CL=A5h,INT E0/CL=ACh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLB0" name="E0----CLB0"><b>E0----CLB0</b></a> - INT E0 - DR Multiuser DOS - "A_CONFIG" - GET/SET AUX DEVICE PARAMETERS<br />
<pre>
INT E0 - DR Multiuser DOS - "A_CONFIG" - GET/SET AUX DEVICE PARAMETERS
	CL = B0h
	DX:DX -&gt; AUX device parameter block (see #04053)
Return: AX = status
	    0000h successful
		parameter block updated
	    FFFFh failed
		CX = error code
Note:	also supported by REAL/32
SeeAlso: INT E0/CL=A5h,INT E0/CL=B1h

Format of DR Multiuser DOS AUX device parameter block:
Offset	Size	Description	(Table 04053)
 00h	BYTE	function (00h get, 01h set)
 01h	BYTE	baud rate (see #04055) FFh = don't change/unknown
 02h	BYTE	parity (see #04054)
 03h	BYTE	stop bits (00h one, 01h 1.5, 02h two, FFh unknown/don't change)
 04h	BYTE	data bits (05h-08h or FFh unknown/don't change)
 05h	BYTE	handshake (00h none, 01h DTS/DSR, 02h RTS/CTS, 04h XON/XOFF,
		FFh unknown/don't change)
 06h	BYTE	XON character, FFh unknown/don't change
 07h	BYTE	XOFF character, FFh unknown/don't change

(Table 04054)
Values for DR Multiuser DOS AUX parity:
 00h	none
 01h	odd
 02h	none
 03h	even
 04h	stick parity bit
 FFh	don't change/unknown
SeeAlso: #04053,#04055

(Table 04055)
Values for DR Multiuser DOS AUX baud rate:
 00h	50 baud
 01h	62.5 baud
 02h	75 baud
 03h	110 baud
 04h	134.5 baud
 05h	150 baud
 06h	200 baud
 07h	300 baud
 08h	600 baud
 09h	1200 baud
 0Ah	1800 baud
 0Bh	2000 baud
 0Ch	2400 baud
 0Dh	3600 baud
 0Eh	4800 baud
 0Fh	7200 baud
 10h	9600 baud
 11h	19200 baud
 12h	38400 baud
 13h	56000 baud
 14h	76800 baud
 15h	115200 baud
SeeAlso: #04053,#04054

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLB1" name="E0----CLB1"><b>E0----CLB1</b></a> - INT E0 - DR Multiuser DOS - "A_CONTROL" - GET/SET AUX CONTROL PARAMETERS<br />
<pre>
INT E0 - DR Multiuser DOS - "A_CONTROL" - GET/SET AUX CONTROL PARAMETERS
	CL = B1h
	DS:DX -&gt; AUX device control block (see #04056)
Return: AX = status
	    0000h successful
		control block updated
	    FFFFh failed
		CX = error code
Note:	also supported by REAL/32
SeeAlso: INT E0/CL=B0h,INT E0/CL=B2h

Format of DR Multiuser DOS AUX device control block:
Offset	Size	Description	(Table 04056)
 00h	BYTE	function (00h get, 01h set)
 01h	BYTE	DTR state (00h low, 01h high, FFh unknown/don't change)
 02h	BYTE	RTS state (00h low, 01h high, FFh unknown/don't change)
 03h	BYTE	DSR state (00h low, 01h high, FFh unknown/don't change)
 04h	BYTE	CTS state (00h low, 01h high, FFh unknown/don't change)
 05h	BYTE	DCD state (00h low, 01h high, FFh unknown/don't change)
 06h	BYTE	RI state (00h inactive, 01h active, FFh unknown/don't change)

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLB2" name="E0----CLB2"><b>E0----CLB2</b></a> - INT E0 - DR Multiuser DOS - "A_BREAK" - SEND BREAK TO AUX DEVICE<br />
<pre>
INT E0 - DR Multiuser DOS - "A_BREAK" - SEND BREAK TO AUX DEVICE
	CL = B2h
	DX = duration of break in system ticks (0001h-FFFFh)
Return: AX = status
	    0000h successful
		break signal completed
	    FFFFh failed
		CX = error code
Notes:	if the AUX device is currently owned by another process, this call will
	  block until the device becomes available
	also supported by REAL/32
SeeAlso: INT E0/CL=A5h,INT E0/CL=B1h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLB3" name="E0----CLB3"><b>E0----CLB3</b></a> - INT E0 R - REAL/32 - "MP_ALLOC" - ALLOCATE PHYSICAL MEMORY<br />
<pre>
INT E0 R - REAL/32 - "MP_ALLOC" - ALLOCATE PHYSICAL MEMORY
	CL = B3h
	DX = number of 4K pages to allocate
Return: AX = number of first 4K page allocated, or FFFFh on error
Note:	memory allocated with this function is not automatically freed when
	  the process terminates
SeeAlso: INT E0/CL=B4h,INT E0/CL=B5h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLB4" name="E0----CLB4"><b>E0----CLB4</b></a> - INT E0 R - REAL/32 - "MP_FREE" - DEALLOCATE PHYSICAL MEMORY<br />
<pre>
INT E0 R - REAL/32 - "MP_FREE" - DEALLOCATE PHYSICAL MEMORY
	CL = B4h
	DX = number of the physical page to free
Return: AX = status (0000h successful, FFFFh error)
SeeAlso: INT E0/CL=B3h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLB5" name="E0----CLB5"><b>E0----CLB5</b></a> - INT E0 R - REAL/32 - "MP_MAP" - MAP PHYSICAL MEMORY<br />
<pre>
INT E0 R - REAL/32 - "MP_MAP" - MAP PHYSICAL MEMORY
	CL = B5h
	DS:DX -&gt; Memory Physical Parameter Block (see #04057)
Return: AX = status (0000h successful, FFFFh error)
	may destroy SI,DI,DS
SeeAlso: INT E0/CL=B3h

Format of REAL/32 Memory Physical Parameter Block:
Offset	Size	Description	(Table 04057)
 00h	WORD	4K page number in first megabyte to be mapped
 02h	WORD	number of page to map into above page, or 0000h to unmap
 04h	WORD	window number (0000h, as only one window currently supported)
 06h	WORD	reserved
Note:	all users of the system share the window, so applications should not
	  use it for arguments to system calls, attempt to read/write to/from
	  files via the window, etc.

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLB6" name="E0----CLB6"><b>E0----CLB6</b></a> - INT E0 - REAL/32 - "Q_NCREAD" - CONDITIONALLY NONDESTRUCTIVELY READ QUEUE<br />
<pre>
INT E0 - REAL/32 - "Q_NCREAD" - CONDITIONALLY NONDESTRUCTIVELY READ QUEUE
	CL = B6h
	DS:DX -&gt; Queue Parameter Block (QPB) (see #04045,#04044)
Return: AX = status
SeeAlso: INT E0/CL=89h,INT E0/CL=8Ah

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLB7" name="E0----CLB7"><b>E0----CLB7</b></a> - INT E0 - REAL/32 - "DEV_TWAITFLAG" - TIMED WAIT ON SYSTEM FLAG<br />
<pre>
INT E0 - REAL/32 - "DEV_TWAITFLAG" - TIMED WAIT ON SYSTEM FLAG
	CL = B7h
	DS:DX -&gt; Flag Parameter Block (FPB) (see #04058)
Return: AX = status
	may destroy SI,DI,DS
Note:	if the flag was already set, this function returns immediately
SeeAlso: INT E0/CL=84h,INT E0/CL=85h

Format of REAL/32 Flag Parameter Block (FPB):
Offset	Size	Description	(Table 04058)
 00h	WORD	number of system flag on which to wait
 02h	WORD	maximum number of system ticks (see INT E0/CL=9Ah) to wait

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLB8" name="E0----CLB8"><b>E0----CLB8</b></a> - INT E0 - REAL/32 - "DEV_MAP" - GET/SET SERIAL/PARALLEL PORT MAPPINGS<br />
<pre>
INT E0 - REAL/32 - "DEV_MAP" - GET/SET SERIAL/PARALLEL PORT MAPPINGS
	CL = B8h
	DS:DX -&gt; Device Map Parameter Block (DEVPB) (see #04059)
Return: nothing???
	may destroy SI,DI,DS

Format of REAL/32 Device Map Parameter Block (DEVPB):
Offset	Size	Description	(Table 04059)
 00h	WORD	direction (00h = get current mapping, 01h = set new mapping)
 02h  4 BYTEs	physical device IDs which map into LPT1 - LPT4
 06h  4 BYTEs	physical device IDs which map into COM1 - COM4
Note:	LPT4 and COM3/COM4 are reserved on early versions of Multiuser DOS,
	  but are supported from at least CCI Multiuser DOS v7.22 onward

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLB9" name="E0----CLB9"><b>E0----CLB9</b></a> - INT E0 - REAL/32 - "L_TIMEOUT" - SET LIST DEVICE TIMEOUT<br />
<pre>
INT E0 - REAL/32 - "L_TIMEOUT" - SET LIST DEVICE TIMEOUT
	CL = B9h
	DX = timeout value in system ticks (see #04048)
		0000h-FFEFh = new number of system ticks
		FFFDh = get current value without changing
		FFFEh = start timeout count
		FFFFh = never timeout
Return: AX = status, or current timeout value if DX=FFFDh on entry
	may destroy SI,DI
SeeAlso: INT E0/CL=BAh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLBA" name="E0----CLBA"><b>E0----CLBA</b></a> - INT E0 - REAL/32 - "A_TIMEOUT" - SET AUX DEVICE TIMEOUT<br />
<pre>
INT E0 - REAL/32 - "A_TIMEOUT" - SET AUX DEVICE TIMEOUT
	CL = BAh
	DX = timeout value in system ticks (see #04048)
		0000h-FFEFh = new number of system ticks
		FFFDh = get current value without changing
		FFFEh = start timeout count
		FFFFh = never timeout
Return: AX = status, or current timeout value if DX=FFFDh on entry
	may destroy SI,DI
SeeAlso: INT E0/CL=B9h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E0----CLBD" name="E0----CLBD"><b>E0----CLBD</b></a> - INT E0 - DR Multiuser DOS - "P_DELAY" - DELAY EXECUTION<br />
<pre>
INT E0 - DR Multiuser DOS - "P_DELAY" - DELAY EXECUTION
	CL = BDh
	DX = delay in system ticks (typically 16.6 ms/tick)
Return: after the delay elapses
	no results
Notes:	the length of a system tick is installation-dependent (typically
	  1/50 or 1/60 second); the length may be determined by reading the
	  TICKSPERSEC value from the system data segment
	the actual delay before the process is rescheduled to run may be up to
	  one tick longer than requested; the delay between rescheduling and
	  actual execution cannot be predicted if higher-priority processes
	  are awaiting a turn at the CPU
SeeAlso: INT 15/AH=86h,INT 1A/AX=FF01h,INT 2F/AX=1224h,INT 62/AX=0096h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E1_1" name="E1_1"><b>E1</b></a> - INT E1 - MP/M-86, - ALTERNATE CP/M-86 FUNCTION CALLS<br />
<pre>
INT E1 - MP/M-86, - ALTERNATE CP/M-86 FUNCTION CALLS
	CL = function number (see #04019,#04020)
	DS,DX = parameters
Return: as appropriate for function
	CX is often the error code (see #04021)
Desc:	used by some applications which alter CP/M functions while running a
	  child program, to store the original INT E0 vector before
	  intercepting INT E0
Notes:	This is the debugger entry to the operating system.
	This function is also supported by IMS Multiuser DOS and IMS REAL/32.
SeeAlso: #04019 at INT E0"CP/M"

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E6_0" name="E6_0"><b>E6</b></a> - INT E6 C - CP/M-86 v1.1 - XIOS INTERRUPT / UNKNOWN DISK DRIVE<br />
<pre>
INT E6 C - CP/M-86 v1.1 - XIOS INTERRUPT / UNKNOWN DISK DRIVE
	AX = function which accessed drive
	    0000h SELDSK
	    0001h READ
	    0002h WRITE
	    0003h HOME
	DX:BX -&gt; parameter block (see #04063)
Return:	AX = return value
Desc:	called by CP/M-86 kernel when an unknown disk drive is used, which
	  permits an application to provide access services
Note:	This was labelled "XIOS interrupt" in later Digital Research
	  documentation (CCP/M-86) and "for the version 1.0 back door".

Format of CP/M-86 unknown-drive paramter block:
Offset	Size	Description	(Table 04063)
 00h	BYTE	drive number (00h = first unknown drive, etc.)
 01h	BYTE	deblocking flag (00h = normal write, 01h = directory write)
 02h	WORD	track number
 04h	WORD	sector number
 06h	DWORD	data transfer address
 0Ah	BYTE	verify flag (nonzero to verify writes)
Note:	in CP/M-86 v1.1, this is actually a portion of a BIOS disk data
	  table which starts one byte before the address given to the INT E6
	  handler; that extra byte is the current logical drive number

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E600" name="E600"><b>E600</b></a> - INT E6 - Linux DOSEMU - INSTALLATION CHECK<br />
<pre>
INT E6 - Linux DOSEMU - INSTALLATION CHECK
	AH = 00h
Return: AX = AA55h if installed
	    BH = major version number
	    BL = minor version number
	    CX = patchlevel
Notes:	check for the BIOS date string "02/25/93" at F000:FFF5 before
	  calling this function.  In addition, the segment address of this
	  vector should be F000h (for existing versions of DOSemu, the
	  vector is F000h:0E60h)
SeeAlso: AH=FFh

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E601" name="E601"><b>E601</b></a> - INT E6 - Linux DOSEMU - REGISTER DUMP<br />
<pre>
INT E6 - Linux DOSEMU - REGISTER DUMP
	AH = 01h
Return: nothing
SeeAlso: AH=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E602" name="E602"><b>E602</b></a> - INT E6 - Linux DOSEMU - SET I/O PORT PERMISSIONS<br />
<pre>
INT E6 - Linux DOSEMU - SET I/O PORT PERMISSIONS
	AH = 02h
	BX = base I/O port address
	CX = number of consecutive I/O ports
	CF set to allow DOS to use ports
	CF clear if DOS should not be allowed to use ports
Return: nothing
SeeAlso: AH=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E605" name="E605"><b>E605</b></a> - INT E6 - Linux DOSEMU - STARTUP BANNER<br />
<pre>
INT E6 - Linux DOSEMU - STARTUP BANNER
	AH = 05h
Return: nothing
SeeAlso: AH=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E612" name="E612"><b>E612</b></a> - INT E6 - Linux DOSEMU - SET "HOGTHRESHOLD"<br />
<pre>
INT E6 - Linux DOSEMU - SET "HOGTHRESHOLD"
	AH = 12h
	BX = new "hogthreshold" (00h-99h)
Return: nothing
Desc:	specify how much CPU time DOSEMU may use
SeeAlso: AH=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E622" name="E622"><b>E622</b></a> - INT E6 - Linux DOSEMU - GET EMS STATUS<br />
<pre>
INT E6 - Linux DOSEMU - GET EMS STATUS
	AH = 22h
Return: ???
SeeAlso: AH=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E630" name="E630"><b>E630</b></a> - INT E6 - Linux DOSEMU - SET BOOTDISK FLAG<br />
<pre>
INT E6 - Linux DOSEMU - SET BOOTDISK FLAG
	AH = 30h
	BX = new flag state (0 = false, 1 = true)
Return: nothing
SeeAlso: AH=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E650" name="E650"><b>E650</b></a> - INT E6 - Linux DOSEMU - EXECUTE UNIX COMMAND<br />
<pre>
INT E6 - Linux DOSEMU - EXECUTE UNIX COMMAND
	AH = 50h
	ES:DX -&gt; ASCIZ Unix command
SeeAlso: AH=00h,AH=51h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E651" name="E651"><b>E651</b></a> - INT E6 - Linux DOSEMU - EXECUTE DOS COMMAND FROM UNIX<br />
<pre>
INT E6 - Linux DOSEMU - EXECUTE DOS COMMAND FROM UNIX
	AH = 51h
	ES:DX -&gt; ASCIZ DOS command
SeeAlso: AH=00h,AH=50h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E680" name="E680"><b>E680</b></a> - INT E6 - Linux DOSEMU - GET CURRENT UNIX DIRECTORY<br />
<pre>
INT E6 - Linux DOSEMU - GET CURRENT UNIX DIRECTORY
	AH = 80h
Return: ES:DX -&gt; current Unix directory
	AX = length of current directory name
SeeAlso: AH=00h,AH=81h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E681" name="E681"><b>E681</b></a> - INT E6 - Linux DOSEMU - CHANGE CURRENT UNIX DIRECTORY<br />
<pre>
INT E6 - Linux DOSEMU - CHANGE CURRENT UNIX DIRECTORY
	AH = 81h
	ES:DX -&gt; ASCIZ directory name
Return: nothing
SeeAlso: AH=00h,AH=80h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#E6FF" name="E6FF"><b>E6FF</b></a> - INT E6 - Linux DOSEMU - TERMINATE<br />
<pre>
INT E6 - Linux DOSEMU - TERMINATE
	AH = FFh
SeeAlso: AH=00h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#EF----CX00C8" name="EF----CX00C8"><b>EF----CX00C8</b></a> - INT EF - GEM - AES INTERFACE<br />
<pre>
INT EF - GEM - AES INTERFACE
	CX = 00C8h
	DX = 0000h
	ES:BX -&gt; AES parameter block (see #04064)
SeeAlso: INT EF/CX=00C9h,INT EF/CX=0473h

Format of AES parameter block:
Offset	Size	Description	(Table 04064)
 00h	DWORD	-&gt; control array (see #04065)
 04h	DWORD	-&gt; global variables (15 WORDs)
 08h	DWORD	-&gt; integer input parameters
 0Ch	DWORS	-&gt; buffer for integer results
 10h	DWORD	-&gt; address (DWORD) input parameters
 14h	DWORD	-&gt; buffer for address (DWORD) results
SeeAlso: #04066

Format of AES control array:
Offset	Size	Description	(Table 04065)
 00h	WORD	function number (000Ah-0084h)
 02h	WORD	number of words of integer input parameters
 04h	WORD	number of words available for integer results
 06h	WORD	number of words of address input parameters
 08h	WORD	number of words available for address results
SeeAlso: #04064

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#EF----CX00C9" name="EF----CX00C9"><b>EF----CX00C9</b></a> - INT EF - GEM - AES INTERFACE<br />
<pre>
INT EF - GEM - AES INTERFACE
	CX = 00C9h
	DX = 0000h
	ES:BX -&gt; AES parameter block (see #04064)
SeeAlso: INT EF/CX=00C8h,INT EF/CX=0473h

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<a href="#EF----CX0473" name="EF----CX0473"><b>EF----CX0473</b></a> - INT EF - GEM - VDI INTERFACE<br />
<pre>
INT EF - GEM - VDI INTERFACE
	CX = 0473h
	DS:DX -&gt; GEM VDI parameter block (see #04066)
Note:	if installed, one of the following ASCII signatures will appear two
	  bytes after the INT EF entry point:
	    "GEMVDI"	GEM VDI (but not AES) is present
	    "GEMAES"	GEM/ViewMAX VDI and AES are both present
	    "ViewMAX"	ViewMAX VDI (only) is present
	  each of the above is followed by an ASCIZ number indicating the
	  version ("10" for GEM/1 AES and VDI; "20" for GEM/2,GEM/3,ViewMAX
	  AES and GEM/2 VDI; "23" for GEM/3 VDI; and "1" for ViewMAX VDIs)
SeeAlso: INT EF/CX=00C8h,INT EF/CX=00C9h
Index:	installation check;GEM

Format of VDI parameter block:
Offset	Size	Description	(Table 04066)
 00h	DWORD	-&gt; control array (see #04067)
 08h	DWORD	-&gt; integer parameters
 0Ch	DWORD	-&gt; (x,y) pair parameters
 10h	DWORD	-&gt; integer results
 14h	DWORD	-&gt; (x,y) pair results
SeeAlso: #04064

Format of VDI control array:
Offset	Size	Description	(Table 04067)
 00h	WORD	(call) function number (0001h-0084h)
 02h	WORD	(call) number of words of pair parameters
 04h	WORD	(ret) number of words of pair results
 06h	WORD	(call) number of words of integer parameters
 08h	WORD	(ret) number of words of integer results
 0Ah	WORD	subfunction number
 0Ch	WORD	graphics handle
 0Eh	DWORD	(call) -&gt; pointer parameter
 12h	DWORD	(ret) -&gt; pointer result
SeeAlso: #04066

</pre>

<span style="font-size:80%"><a href="#__toc">Top</a></span>

<hr />

<div class="bottom-nav"><b><a href="./index.html">Home</a></b> <b>Interrupt Index</b>: <a href="./INTERRUP.CAT.HTML">by Category</a> <a href="./INTERRUP.NUM.HTML">by ID</a> <b>TOC</b>: <a href="#__toc">by Order</a> <b><a href="#top">Top</a></b></div>

</body>
</html>
